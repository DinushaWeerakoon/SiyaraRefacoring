<html>
    <head></head>
    <body><p><br>/***************************************************************************
<br> *
<br> * Project:  OpenCPN
<br> * Purpose:  OpenCPN Toolbar
<br> * Author:   David Register
<br> *
<br> ***************************************************************************
<br> *   Copyright (C) 2010 by David S. Register                               *
<br> *                                                                         *
<br> *   This program is free software; you can redistribute it and/or modify  *
<br> *   it under the terms of the GNU General Public License as published by  *
<br> *   the Free Software Foundation; either version 2 of the License, or     *
<br> *   (at your option) any later version.                                   *
<br> *                                                                         *
<br> *   This program is distributed in the hope that it will be useful,       *
<br> *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
<br> *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
<br> *   GNU General Public License for more details.                          *
<br> *                                                                         *
<br> *   You should have received a copy of the GNU General Public License     *
<br> *   along with this program; if not, write to the                         *
<br> *   Free Software Foundation, Inc.,                                       *
<br> *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,  USA.         *
<br> **************************************************************************/
<br>
<br>#include "wx/wxprec.h"
<br>
<br>#ifndef  WX_PRECOMP
<br>#include "wx/wx.h"
<br>#endif
<br>
<br>#include <vector>
<br>
<br>#include "ocpn_types.h"
<br>#include "navutil.h"
<br>#include "styles.h"
<br>#include "toolbar.h"
<br>#include "chart1.h"
<br>#include "pluginmanager.h"
<br>#include "FontMgr.h"
<br>
<br>extern ocpnFloatingToolbarDialog* g_FloatingToolbarDialog;
<br>extern bool                       g_bTransparentToolbar;
<br>extern bool                       g_bTransparentToolbarInOpenGLOK;
<br>extern ChartCanvas*               cc1;
<br>extern bool                       g_bopengl;
<br>extern ocpnToolBarSimple*         g_toolbar;
<br>extern ocpnStyle::StyleManager*   g_StyleManager;
<br>extern MyFrame*                   gFrame;
<br>extern PlugInManager*             g_pi_manager;
<br>extern wxMenu*                    g_FloatingToolbarConfigMenu;
<br>extern wxString                   g_toolbarConfig;
<br>extern bool                       g_bPermanentMOBIcon;
<br>extern bool                       g_btouch;
<br>extern bool                       g_bsmoothpanzoom;
<br>
<br>//----------------------------------------------------------------------------
<br>// GrabberWindow Implementation
<br>//----------------------------------------------------------------------------
<br>BEGIN_EVENT_TABLE(GrabberWin, wxPanel) EVT_MOUSE_EVENTS ( GrabberWin::MouseEvent )
<br>EVT_PAINT ( GrabberWin::OnPaint )
<br>END_EVENT_TABLE()
<br>
<br>GrabberWin::GrabberWin( wxWindow *parent, ocpnFloatingToolbarDialog *toolbar, float scale_factor, wxString icon_name, wxPoint position ):
<br>    wxPanel( parent, wxID_ANY, position, wxDefaultSize, wxNO_BORDER )
<br>{
<br>    m_icon_name = icon_name;
<br>    m_style = g_StyleManager->GetCurrentStyle();
<br>    wxBitmap bitmap = m_style->GetIcon( icon_name );
<br>    if(scale_factor > 1.0f){
<br>        int new_width = bitmap.GetWidth() * scale_factor;
<br>        int new_height = bitmap.GetHeight() * scale_factor;
<br><mark>        wxImage scaled_image = bitmap.ConvertToImage();
</mark><br><mark>        m_bitmap = wxBitmap(scaled_image.Scale(new_width, new_height, wxIMAGE_QUALITY_HIGH));
</mark><br>    }
<br>    else
<br>        m_bitmap = bitmap;
<br>
<br>    SetSize( wxSize( m_bitmap.GetWidth(), m_bitmap.GetHeight() ) );
<br>    SetMinSize( wxSize( m_bitmap.GetWidth(), m_bitmap.GetHeight() ) );
<br>
<br>    m_bLeftDown = false;
<br>    m_bRightDown = false;
<br>    m_scale_factor = scale_factor;
<br>    m_ptoolbar = toolbar;
<br>    m_dragging = false;
<br>    Hide();
<br>    
<br>}
<br>
<br>
<br>void GrabberWin::OnPaint( wxPaintEvent& event )
<br>{
<br>    wxPaintDC dc( this );
<br>    
<br>    wxColour back_color = GetGlobalColor( _T("GREY2") );
<br>    SetBackgroundColour( back_color );
<br>    ClearBackground();
<br>    
<br>    dc.DrawBitmap( m_bitmap, 0, 0, true );
<br>}
<br>
<br>void GrabberWin::SetColorScheme( ColorScheme cs )
<br>{
<br>    wxColour back_color = GetGlobalColor( _T("GREY2") );
<br>
<br>    SetBackgroundColour( back_color );
<br>    ClearBackground();
<br>
<br>    wxBitmap bitmap = m_style->GetIcon( m_icon_name) ;
<br>    if(m_scale_factor > 1.0f){
<br>        int new_width = bitmap.GetWidth() * m_scale_factor;
<br>        int new_height = bitmap.GetHeight() * m_scale_factor;
<br><mark>        wxImage scaled_image = bitmap.ConvertToImage();
</mark><br><mark>        m_bitmap = wxBitmap(scaled_image.Scale(new_width, new_height, wxIMAGE_QUALITY_HIGH));
</mark><br>    }
<br>    else
<br>        m_bitmap = bitmap;
<br>}
<br>
<br>void GrabberWin::MouseEvent( wxMouseEvent& event )
<br>{
<br>    static wxPoint s_gspt;
<br>    int x, y;
<br>
<br>    event.GetPosition( &x, &y );
<br>
<br>    wxPoint spt = ClientToScreen( wxPoint( x, y ) );
<br>    if( event.LeftDown() ) {
<br>        s_gspt = spt;
<br>    }
<br>    
<br>    
<br>#ifndef __WXQT__
<br>
<br>    if( event.LeftDown() ) {
<br>        CaptureMouse();
<br>    }
<br>
<br>    if( event.LeftUp() ) {
<br>        if( HasCapture() ) ReleaseMouse();
<br>    }
<br>
<br>#endif
<br>
<br>
<br>    if( event.RightDown() ){
<br>        if(m_ptoolbar){
<br>            m_dragging = true;
<br>            
<br>            if( !m_ptoolbar->m_bnavgrabber ){
<br>                m_ptoolbar->m_bnavgrabber = true;
<br>                m_ptoolbar->SetGrabber(_T("4WayMove") );
<br>            }
<br>            else{
<br>                m_ptoolbar->m_bnavgrabber = false;
<br>                m_ptoolbar->SetGrabber(_T("grabber_hi") );
<br>            }
<br>                
<br>        }
<br>    }
<br>    
<br>
<br>
<br>    if( event.Dragging() ) {
<br>        if(m_ptoolbar && m_ptoolbar->IsShown() /*&& m_ptoolbar->m_bnavgrabber*/){
<br>            wxPoint par_pos_old = m_ptoolbar->GetPosition();
<br>
<br>            wxPoint par_pos = par_pos_old;
<br>            par_pos.x += spt.x - s_gspt.x;
<br>            par_pos.y += spt.y - s_gspt.y;
<br>
<br>            m_ptoolbar->MoveDialogInScreenCoords( par_pos, par_pos_old );
<br>
<br>            s_gspt = spt;
<br>            m_dragging = true;
<br>        }
<br>
<br>    }
<br>
<br>    if( event.LeftUp() ) {
<br>        if(m_ptoolbar){
<br>            if(m_ptoolbar->m_bnavgrabber){
<br>                if(!m_dragging)
<br>                    m_ptoolbar->ToggleOrientation();
<br>            }
<br>            else if(!m_dragging){
<br>                if(m_ptoolbar->m_bsubmerged){
<br>                    m_ptoolbar->SurfaceFromGrabber();
<br>                }
<br>                else{
<br>                    m_ptoolbar->SubmergeToGrabber();
<br>                 }
<br>            }
<br>        }
<br>        m_dragging = false;
<br>    }
<br>    
<br>    
<br>#ifndef __OCPN__ANDROID__
<br>    gFrame->Raise();
<br>#endif
<br>    
<br>}
<br>
<br>class ocpnToolBarTool: public wxToolBarToolBase {
<br>public:
<br>    ocpnToolBarTool( ocpnToolBarSimple *tbar, int id, const wxString& label,
<br>            const wxBitmap& bmpNormal, const wxBitmap& bmpRollover, wxItemKind kind,
<br>            wxObject *clientData, const wxString& shortHelp, const wxString& longHelp ) :
<br>            wxToolBarToolBase( (wxToolBarBase*) tbar, id, label, bmpNormal, bmpRollover, kind,
<br>                    clientData, shortHelp, longHelp )
<br>    {
<br>        m_enabled = true;
<br>        m_toggled = false;
<br>        rollover = false;
<br>        bitmapOK = false;
<br>        m_btooltip_hiviz = false;
<br>
<br>        toolname = g_pi_manager->GetToolOwnerCommonName( id );
<br>        if( toolname == _T("") ) {
<br>            isPluginTool = false;
<br>            toolname = label;
<br>            iconName = label;
<br>        } else {
<br>            isPluginTool = true;
<br>            pluginNormalIcon = &bmpNormal;
<br>            pluginRolloverIcon = &bmpRollover;
<br>        }
<br>    }
<br>
<br>    void SetSize( const wxSize& size )
<br>    {
<br>        m_width = size.x;
<br>        m_height = size.y;
<br>    }
<br>
<br>    wxCoord GetWidth() const
<br>    {
<br>        return m_width;
<br>    }
<br>
<br>    wxCoord GetHeight() const
<br>    {
<br>        return m_height;
<br>    }
<br>
<br>    wxString GetToolname()
<br>    {
<br>        return toolname;
<br>    }
<br>
<br>    void SetIconName(wxString name)
<br>    {
<br>        iconName = name;
<br>    }
<br>    wxString GetIconName()
<br>    {
<br>        return iconName;
<br>    }
<br>
<br>    void SetTooltipHiviz( bool enable){ m_btooltip_hiviz = enable; }
<br>
<br>    wxCoord m_x;
<br>    wxCoord m_y;
<br>    wxCoord m_width;
<br>    wxCoord m_height;
<br>    wxRect trect;
<br>    wxString toolname;
<br>    wxString iconName;
<br>    const wxBitmap* pluginNormalIcon;
<br>    const wxBitmap* pluginRolloverIcon;
<br>    bool firstInLine;
<br>    bool lastInLine;
<br>    bool rollover;
<br>    bool bitmapOK;
<br>    bool isPluginTool;
<br>    bool b_hilite;
<br>    bool m_btooltip_hiviz;
<br>    wxRect last_rect;
<br>};
<br>
<br>//---------------------------------------------------------------------------------------
<br>//          ocpnFloatingToolbarDialog Implementation
<br>//---------------------------------------------------------------------------------------
<br>BEGIN_EVENT_TABLE(ocpnFloatingToolbarDialog, wxDialog)
<br>    EVT_MOUSE_EVENTS ( ocpnFloatingToolbarDialog::MouseEvent )
<br>    EVT_MENU(wxID_ANY, ocpnFloatingToolbarDialog::OnToolLeftClick)
<br>    EVT_TIMER ( FADE_TIMER, ocpnFloatingToolbarDialog::FadeTimerEvent )
<br>    EVT_TIMER ( DESTROY_TIMER, ocpnFloatingToolbarDialog::DestroyTimerEvent )
<br>    EVT_WINDOW_CREATE(ocpnFloatingToolbarDialog::OnWindowCreate)
<br>END_EVENT_TABLE()
<br>
<br>ocpnFloatingToolbarDialog::ocpnFloatingToolbarDialog( wxWindow *parent, wxPoint position,
<br>                                                      long orient, float size_factor )
<br>{
<br>    m_pparent = parent;
<br>    long wstyle = wxNO_BORDER | wxFRAME_NO_TASKBAR;
<br>#ifndef __WXMAC__
<br>    wstyle |= wxFRAME_SHAPED;
<br>#endif
<br>
<br>    m_ptoolbar = NULL;
<br>
<br>#ifdef __WXOSX__
<br>    wstyle |= wxSTAY_ON_TOP;
<br>#endif
<br>    wxDialog::Create( parent, -1, _T("ocpnToolbarDialog"), wxPoint( -1, -1 ), wxSize( -1, -1 ),
<br>            wstyle );
<br>
<br>    m_opacity = 255;
<br>
<br>    m_pGrabberwin = new GrabberWin( this, this, size_factor, _T("grabber_hi") );
<br>    m_pGrabberwin->Show();
<br>    
<br>    m_pRecoverwin = NULL;
<br>    m_position = position;
<br>    m_orient = orient;
<br>    m_sizefactor = size_factor;
<br>    
<br>    m_bAutoHideToolbar = false;
<br>    m_nAutoHideToolbar = 5;
<br>    
<br>
<br>    m_style = g_StyleManager->GetCurrentStyle();
<br>
<br>// A top-level sizer
<br>    m_topSizer = new wxBoxSizer( wxHORIZONTAL );
<br>    SetSizer( m_topSizer );
<br>
<br>    //    Set initial "Dock" parameters
<br>    m_dock_x = 0;
<br>    m_dock_y = 0;
<br>    m_block = false;
<br>
<br>    m_marginsInvisible = m_style->marginsInvisible;
<br>
<br>//    if(m_sizefactor > 1.0 )
<br> //       m_marginsInvisible = true;
<br>
<br>    m_bnavgrabber = false;    
<br>    
<br>    Hide();
<br>
<br>    m_bsubmerged = false;
<br>    
<br>    m_fade_timer.SetOwner( this, FADE_TIMER );
<br>    if( g_bTransparentToolbar )
<br>        m_fade_timer.Start( 5000 );
<br>    
<br>    if( m_bAutoHideToolbar && (m_nAutoHideToolbar > 0))
<br>        m_fade_timer.Start( m_nAutoHideToolbar * 1000 );
<br>    
<br>    m_destroyTimer.SetOwner( this, DESTROY_TIMER );
<br>}
<br>
<br>ocpnFloatingToolbarDialog::~ocpnFloatingToolbarDialog()
<br>{
<br>    DestroyToolBar();
<br>}
<br>
<br>void ocpnFloatingToolbarDialog::OnWindowCreate( wxWindowCreateEvent& event )
<br>{
<br>    Realize();
<br>}
<br>
<br>void ocpnFloatingToolbarDialog::SetGrabber( wxString icon_name )
<br>{
<br>//    m_pGrabberwin->Destroy();
<br>    m_pGrabberwin = new GrabberWin( this, this, m_sizefactor, icon_name );
<br>    m_pGrabberwin->Show();
<br>    
<br>    Realize();
<br>    
<br>#ifdef __WXOSX__    
<br>    m_pGrabberwin->Refresh();
<br>#endif    
<br>    
<br>}
<br>
<br>
<br>    
<br>void ocpnFloatingToolbarDialog::SetColorScheme( ColorScheme cs )
<br>{
<br>    m_cs = cs;
<br>
<br>    wxColour back_color = GetGlobalColor( _T("GREY2") );
<br>
<br>    //  Set background
<br>    SetBackgroundColour( back_color );
<br>    ClearBackground();
<br>
<br>    if( m_ptoolbar ) {
<br>        wxColour back_color = GetGlobalColor( _T("GREY2") );
<br>
<br>        //  Set background
<br>        m_ptoolbar->SetBackgroundColour( back_color );
<br>        m_ptoolbar->ClearBackground();
<br>
<br>        m_ptoolbar->SetToggledBackgroundColour( GetGlobalColor( _T("GREY1") ) );
<br>
<br>        m_ptoolbar->SetColorScheme( cs );
<br>        m_ptoolbar->Refresh( true );
<br>    }
<br>
<br>    if( m_pGrabberwin ) m_pGrabberwin->SetColorScheme( cs );
<br>
<br>}
<br>
<br>void ocpnFloatingToolbarDialog::SetGeometry(bool bAvoid, wxRect rectAvoid)
<br>{
<br>
<br>    if( m_ptoolbar ) {
<br>        wxSize style_tool_size = m_style->GetToolSize();
<br>
<br>        style_tool_size.x *= m_sizefactor;
<br>        style_tool_size.y *= m_sizefactor;
<br>
<br>        m_ptoolbar->SetToolBitmapSize( style_tool_size );
<br>
<br>        wxSize tool_size = m_ptoolbar->GetToolBitmapSize();
<br>        int grabber_width =  m_style->GetIcon( _T("grabber") ).GetWidth();
<br>        
<br>        int max_rows = 10;
<br>        int max_cols = 100;
<br>        if(cc1){
<br>
<br>            int avoid_start = cc1->GetClientSize().x - (tool_size.x + m_style->GetToolSeparation()) * 2;  // default
<br>            if(bAvoid && !rectAvoid.IsEmpty()){
<br>                avoid_start = cc1->GetClientSize().x - rectAvoid.width - 10;  // this is compass window, if shown
<br>            }
<br>            
<br>            
<br>            max_rows = (cc1->GetClientSize().y / ( tool_size.y + m_style->GetToolSeparation())) - 1;
<br>            
<br>            max_cols = (avoid_start - grabber_width) / ( tool_size.x + m_style->GetToolSeparation());
<br>            max_cols -= 1;
<br>            
<br>            if(m_orient == wxTB_VERTICAL)
<br>                max_rows = wxMax( max_rows, 2);             // at least two rows
<br>            else
<br>                max_cols = wxMax( max_cols, 2);             // at least two columns
<br>        }
<br>
<br>        if( m_orient == wxTB_VERTICAL )
<br>            m_ptoolbar->SetMaxRowsCols(max_rows, 100);
<br>        else
<br>            m_ptoolbar->SetMaxRowsCols( 100, max_cols);
<br>        m_ptoolbar->SetSizeFactor(m_sizefactor);
<br>        
<br>    }
<br> }
<br>
<br>void ocpnFloatingToolbarDialog::RePosition()
<br>{
<br>    if(m_block) return;
<br>
<br>    if( m_pparent && m_ptoolbar ) {
<br>        wxSize cs = m_pparent->GetClientSize();
<br>        if( -1 == m_dock_x ) m_position.x = 0;
<br>        else
<br>            if( 1 == m_dock_x ) m_position.x = cs.x - GetSize().x;
<br>
<br>        if( -1 == m_dock_y ) m_position.y = 0;
<br>        else
<br>            if( 1 == m_dock_y ) m_position.y = cs.y - GetSize().y;
<br>
<br>        m_position.x = wxMin(cs.x - GetSize().x, m_position.x);
<br>        m_position.y = wxMin(cs.y - GetSize().y, m_position.y);
<br>
<br>        m_position.x = wxMax(0, m_position.x);
<br>        m_position.y = wxMax(0, m_position.y);
<br>
<br>        wxPoint screen_pos = m_pparent->ClientToScreen( m_position );
<br>
<br>        Move( screen_pos );
<br>
<br>#ifdef __WXQT__
<br>        Raise();
<br>#endif
<br>
<br>    }
<br>}
<br>
<br>void ocpnFloatingToolbarDialog::Submerge()
<br>{
<br>    m_bsubmerged = true;
<br>    Hide();
<br>    if( m_ptoolbar ) m_ptoolbar->KillTooltip();
<br>}
<br>
<br>void ocpnFloatingToolbarDialog::SubmergeToGrabber()
<br>{
<br>//Submerge();
<br>    m_bsubmerged = true;
<br>    Hide();
<br>    if( m_ptoolbar ) m_ptoolbar->KillTooltip();
<br>
<br>    m_pRecoverwin = new GrabberWin( m_pparent, this, m_sizefactor, _T("grabber_ext" ), wxPoint(10,10) );
<br>   
<br>    m_pRecoverwin->Show();
<br>    m_pRecoverwin->Raise();
<br>#ifdef __WXQT__
<br>    wxSize s = gFrame->GetSize();
<br>    m_recoversize = s;
<br>    s.y--;
<br>    gFrame->TriggerResize(s);
<br>    Raise();
<br>#endif    
<br>
<br>    gFrame->Refresh();          // Needed for MSW OpenGL
<br>}
<br>
<br>void ocpnFloatingToolbarDialog::Surface()
<br>{
<br>    
<br>    if(m_pRecoverwin){
<br>        m_pRecoverwin->Show();
<br>        m_pRecoverwin->Raise();
<br>    }
<br>    else {
<br>        m_bsubmerged = false;
<br>        #ifndef __WXOSX__
<br>        Hide();
<br>        Move( 0, 0 );
<br>        #endif
<br>
<br>        RePosition();
<br>        Show();
<br>        if( m_ptoolbar )
<br>            m_ptoolbar->EnableTooltips();
<br>
<br>        #ifdef __WXQT__
<br>        Raise();
<br>        #endif
<br>    }
<br>    
<br>    if( m_bAutoHideToolbar && (m_nAutoHideToolbar > 0) ){
<br>        m_fade_timer.Start( m_nAutoHideToolbar * 1000 );
<br>    }
<br>}
<br>
<br>bool ocpnFloatingToolbarDialog::CheckSurfaceRequest( wxMouseEvent &event )
<br>{
<br>    if( m_bsubmerged ){
<br>        if( event.LeftUp() ){
<br>            int x,y;
<br>            event.GetPosition( &x, &y );
<br>            if( m_pRecoverwin ){
<br>                wxRect winRect = m_pRecoverwin->GetRect();
<br>                if( winRect.Contains( x, y ) ){
<br>                    SurfaceFromGrabber();
<br>                    return true;
<br>                }
<br>            }
<br>        }
<br>    }
<br>    
<br>    return false;
<br>}
<br>        
<br>void ocpnFloatingToolbarDialog::SurfaceFromGrabber()
<br>{
<br>    m_bsubmerged = false;
<br>    
<br>#ifndef __WXOSX__
<br>    Hide();
<br>    Move( 0, 0 );
<br>#endif
<br>
<br>    if( m_ptoolbar )
<br>        m_ptoolbar->InvalidateBitmaps();
<br>    
<br>    RePosition();
<br>    Show();
<br>    if( m_ptoolbar )
<br>        m_ptoolbar->EnableTooltips();
<br>    
<br>    if( m_bAutoHideToolbar && (m_nAutoHideToolbar > 0) ){
<br>        m_fade_timer.Start( m_nAutoHideToolbar * 1000 );
<br>    }
<br>    
<br>#ifdef __WXQT__
<br>    wxSize s = gFrame->GetSize();               // check for rotation
<br>    if(m_recoversize.x == s.x)
<br>        gFrame->TriggerResize(m_recoversize);
<br>    Raise();
<br>#endif
<br>    
<br>    m_destroyGrabber = m_pRecoverwin;
<br>    m_destroyTimer.Start( 5, wxTIMER_ONE_SHOT );           //  Destor the unneeded recovery grabber
<br>    
<br>}
<br>
<br>void ocpnFloatingToolbarDialog::DestroyTimerEvent( wxTimerEvent& event )
<br>{
<br>    delete m_destroyGrabber;
<br>    m_destroyGrabber = NULL;
<br>    m_pRecoverwin = NULL;
<br>}
<br>
<br>void ocpnFloatingToolbarDialog::HideTooltip()
<br>{
<br>    if( m_ptoolbar ) m_ptoolbar->HideTooltip();
<br>}
<br>
<br>void ocpnFloatingToolbarDialog::ShowTooltips()
<br>{
<br>    if( m_ptoolbar ) m_ptoolbar->EnableTooltips();
<br>}
<br>
<br>void ocpnFloatingToolbarDialog::ToggleOrientation()
<br>{
<br>    if( m_orient == wxTB_HORIZONTAL )
<br>        m_orient = wxTB_VERTICAL;
<br>    else
<br>        m_orient = wxTB_HORIZONTAL;
<br>
<br>    m_style->SetOrientation( m_orient );
<br>
<br>    wxPoint old_screen_pos = m_pparent->ClientToScreen( m_position );
<br>    wxPoint grabber_point_abs = ClientToScreen( m_pGrabberwin->GetPosition() );
<br>
<br>    gFrame->RequestNewToolbar();
<br>    wxPoint pos_abs = grabber_point_abs;
<br>    pos_abs.x -= m_pGrabberwin->GetPosition().x;
<br>    MoveDialogInScreenCoords( pos_abs, old_screen_pos );
<br>
<br>
<br>    Show();   // this seems to be necessary on GTK to kick the sizer into gear...(FS#553)
<br>    Refresh(true);
<br>    Raise();
<br>}
<br>
<br>void ocpnFloatingToolbarDialog::MouseEvent( wxMouseEvent& event )
<br>{
<br>    if( g_bTransparentToolbar ) {
<br>        if( event.Entering() && ( m_opacity < 255 ) ) {
<br>            SetTransparent( 255 );
<br>            m_opacity = 255;
<br>        }
<br>
<br>        m_fade_timer.Start( 5000 );           // retrigger the continuous timer
<br>    }
<br>    
<br>    if(m_bAutoHideToolbar && (m_nAutoHideToolbar > 0) ){
<br>        m_fade_timer.Start( m_nAutoHideToolbar * 1000 );
<br>    }
<br>}
<br>
<br>void ocpnFloatingToolbarDialog::FadeTimerEvent( wxTimerEvent& event )
<br>{
<br>    if(m_bnavgrabber){
<br>        m_fade_timer.Start( 5000 );           // do nothing if nav grabber is shown
<br>    }
<br>    else{
<br>        if( g_bTransparentToolbar && (!g_bopengl || g_bTransparentToolbarInOpenGLOK) ){
<br>            DoFade( 128 );
<br>            m_fade_timer.Start( 5000 );           // retrigger the continuous timer
<br>        }
<br>        
<br>        if(m_bAutoHideToolbar && (m_nAutoHideToolbar > 0) && !m_bsubmerged){
<br>            SubmergeToGrabber();
<br>//            m_fade_timer.Stop();
<br>        }
<br>    }
<br>}
<br>
<br>void ocpnFloatingToolbarDialog::SetAutoHideTimer(int time)
<br>{
<br>    m_nAutoHideToolbar = time;
<br>    if(m_bAutoHideToolbar){
<br>        m_fade_timer.Stop();
<br>        m_fade_timer.Start( m_nAutoHideToolbar * 1000 );
<br>    }
<br>}
<br>        
<br>void ocpnFloatingToolbarDialog::DoFade( int value )
<br>{
<br>    if( value != m_opacity ) SetTransparent( value );
<br>    m_opacity = value;
<br>}
<br>
<br>void ocpnFloatingToolbarDialog::RefreshFadeTimer()
<br>{
<br>    SetTransparent( 255 );
<br>    m_opacity = 255;
<br>    m_fade_timer.Start( 500 );           // retrigger the continuous timer
<br>    
<br>    if(m_bAutoHideToolbar && (m_nAutoHideToolbar > 0) ){
<br>        m_fade_timer.Start( m_nAutoHideToolbar * 1000 );
<br>    }
<br>    
<br>}
<br>
<br>void ocpnFloatingToolbarDialog::MoveDialogInScreenCoords( wxPoint posn, wxPoint posn_old )
<br>{
<br>    wxPoint pos_in_parent = m_pparent->ScreenToClient( posn );
<br>    wxPoint pos_in_parent_old = m_pparent->ScreenToClient( posn_old );
<br>
<br>    //    "Docking" support
<br>#define DOCK_MARGIN 40
<br>
<br>    // X
<br>    m_dock_x = 0;
<br>    if( pos_in_parent.x < pos_in_parent_old.x )            // moving left
<br>            {
<br>        if( pos_in_parent.x < DOCK_MARGIN ) {
<br>            pos_in_parent.x = 0;
<br>            m_dock_x = -1;
<br>        }
<br>    } else
<br>        if( pos_in_parent.x > pos_in_parent_old.x )            // moving right
<br>                {
<br>            int max_right = m_pparent->GetClientSize().x - GetSize().x;
<br>            if( pos_in_parent.x > ( max_right - DOCK_MARGIN ) ) {
<br>                pos_in_parent.x = max_right;
<br>                m_dock_x = 1;
<br>            }
<br>        }
<br>
<br>    // Y
<br>    m_dock_y = 0;
<br>    if( pos_in_parent.y < pos_in_parent_old.y )            // moving up
<br>            {
<br>        if( pos_in_parent.y < DOCK_MARGIN ) {
<br>            pos_in_parent.y = 0;
<br>            m_dock_y = -1;
<br>        }
<br>    } else
<br>        if( pos_in_parent.y > pos_in_parent_old.y )            // moving down
<br>                {
<br>            int max_down = m_pparent->GetClientSize().y - GetSize().y;
<br>            if( pos_in_parent.y > ( max_down - DOCK_MARGIN ) ) {
<br>                pos_in_parent.y = max_down;
<br>                m_dock_y = 1;
<br>            }
<br>        }
<br>
<br>    m_position = pos_in_parent;
<br>
<br>    wxPoint final_pos = m_pparent->ClientToScreen( pos_in_parent );
<br>
<br>    Move( final_pos );
<br>}
<br>
<br>void ocpnFloatingToolbarDialog::Realize()
<br>{
<br>    if( m_ptoolbar ) {
<br>        m_ptoolbar->Realize();
<br>
<br>        m_topSizer->Clear();
<br>        m_topSizer->Add( m_ptoolbar );
<br>        m_topSizer->Add( m_pGrabberwin, 0, wxTOP, m_style->GetTopMargin() );
<br>
<br>        m_topSizer->Layout();
<br>        Fit();
<br>
<br>        //    Update "Dock" parameters
<br>        if( m_position.x == 0 ) m_dock_x = -1;
<br>        else
<br>            if( m_position.x == m_pparent->GetClientSize().x - GetSize().x ) m_dock_x = 1;
<br>
<br>        if( m_position.y == 0 ) m_dock_y = -1;
<br>        else
<br>            if( m_position.y == m_pparent->GetClientSize().y - GetSize().y ) m_dock_y = 1;
<br>
<br>        // Now create a bitmap mask forthe frame shape.
<br>
<br>        if( m_marginsInvisible ) {
<br>
<br>            wxSize tool_size = m_ptoolbar->GetToolBitmapSize();
<br>
<br>            //  Determine whether the tool icons are meant (by style) to join without speces between
<br>            //  This will determine what type of region to draw.
<br>            bool b_overlap = false;
<br>
<br>            wxToolBarToolsList::compatibility_iterator node1 = m_ptoolbar->m_tools.GetFirst();
<br>            wxToolBarToolsList::compatibility_iterator node2 = node1->GetNext() ;
<br>
<br>            wxToolBarToolBase *tool1 = node1->GetData();
<br>            ocpnToolBarTool *tools1 = (ocpnToolBarTool *) tool1;
<br>
<br>            wxToolBarToolBase *tool2 = node2->GetData();
<br>            ocpnToolBarTool *tools2 = (ocpnToolBarTool *) tool2;
<br>
<br>            if( (tools1->m_x + tools1->m_width) >= tools2->m_x)
<br>                b_overlap = true;
<br>
<br>
<br>
<br>
<br>            int toolCount = m_ptoolbar->GetVisibleToolCount();
<br>
<br>            wxPoint upperLeft( m_style->GetLeftMargin(), m_style->GetTopMargin() );
<br>            wxSize visibleSize;
<br>            if( m_ptoolbar->IsVertical() ) {
<br>                int noTools = m_ptoolbar->GetMaxRows();
<br>                if( noTools > toolCount )
<br>                    noTools = toolCount;
<br>                visibleSize.x = m_ptoolbar->GetLineCount() * ( tool_size.x + m_style->GetTopMargin() );
<br>                visibleSize.y = noTools * ( tool_size.y + m_style->GetToolSeparation() );
<br>                visibleSize.x -= m_style->GetTopMargin();
<br>                visibleSize.y -= m_style->GetToolSeparation();
<br>            } else {
<br>                    int noTools = m_ptoolbar->GetMaxCols();
<br>                    if( noTools > toolCount )
<br>                        noTools = toolCount;
<br>                visibleSize.x = noTools * ( tool_size.x + m_style->GetToolSeparation() );
<br>                visibleSize.y = m_ptoolbar->GetLineCount() * ( tool_size.y + m_style->GetTopMargin() );
<br>                visibleSize.x -= m_style->GetToolSeparation();
<br>                visibleSize.y -= m_style->GetTopMargin();
<br>            }
<br>
<br>            wxBitmap shape( visibleSize.x + tool_size.x, visibleSize.y + tool_size.y);          // + fluff
<br>            wxMemoryDC sdc( shape );
<br>            sdc.SetBackground( *wxWHITE_BRUSH );
<br>            sdc.SetBrush( *wxBLACK_BRUSH );
<br>            sdc.SetPen( *wxBLACK_PEN );
<br>            sdc.Clear();
<br>
<br>            if(b_overlap) {
<br>                int lines = m_ptoolbar->GetLineCount();
<br>                for( int i = 1; i <= lines; i++ ) {
<br>                    if( m_ptoolbar->IsVertical() ) {
<br>                        wxSize barsize( tool_size.x, visibleSize.y );
<br>                        if( i == lines && i > 1 ) {
<br>                            int toolsInLastLine = toolCount % m_ptoolbar->GetMaxRows();
<br>                            if( toolsInLastLine == 0 ) toolsInLastLine = m_ptoolbar->GetMaxRows();
<br>                            int emptySpace = ( m_ptoolbar->GetMaxRows() - toolsInLastLine );
<br>                            barsize.y -= emptySpace
<br>                            * ( tool_size.y + m_style->GetToolSeparation() );
<br>                        }
<br>                        if( i == lines ) {
<br>                            // Also do grabber here, since it is to the right of the last line.
<br>                            wxRect grabMask( upperLeft, barsize );
<br>                            grabMask.width += m_style->GetIcon( _T("grabber") ).GetWidth();
<br>                            grabMask.height = m_style->GetIcon( _T("grabber") ).GetHeight();
<br>                            sdc.DrawRoundedRectangle( grabMask, m_style->GetToolbarCornerRadius() );
<br>                        }
<br>                        sdc.DrawRoundedRectangle( upperLeft, barsize,
<br>                                m_style->GetToolbarCornerRadius() );
<br>                        upperLeft.x += m_style->GetTopMargin() + tool_size.x;
<br>                    } else {
<br>                        wxSize barsize( visibleSize.x, tool_size.y );
<br>
<br>                        if( i == 1 ) {
<br>                            barsize.x += m_style->GetIcon( _T("grabber") ).GetWidth();
<br>                        }
<br>                        if( i == lines && i > 1 ) {
<br>                            int toolsInLastLine = toolCount % m_ptoolbar->GetMaxCols();
<br>                            if( toolsInLastLine == 0 ) toolsInLastLine = m_ptoolbar->GetMaxCols();
<br>                            int emptySpace = ( m_ptoolbar->GetMaxCols() - toolsInLastLine );
<br>                            barsize.x -= emptySpace * ( tool_size.x + m_style->GetToolSeparation() );
<br>                        }
<br>
<br>                        sdc.DrawRoundedRectangle( upperLeft, barsize,
<br>                                m_style->GetToolbarCornerRadius() );
<br>                        upperLeft.y += m_style->GetTopMargin() + tool_size.y;
<br>                    }
<br>                }
<br>            } //b_overlap
<br>            else {
<br>                for( wxToolBarToolsList::compatibility_iterator node = m_ptoolbar->m_tools.GetFirst(); node; node = node->GetNext() ) {
<br>                    wxToolBarToolBase *tool = node->GetData();
<br>                    ocpnToolBarTool *tools = (ocpnToolBarTool *) tool;
<br>                    wxRect toolRect = tools->trect;
<br>
<br>                    sdc.DrawRoundedRectangle( tools->m_x, tools->m_y, tool_size.x, tool_size.y,
<br>                                              m_style->GetToolbarCornerRadius() );
<br>                }
<br>            }
<br>
<br>#ifndef __OCPN__ANDROID__
<br>            if(shape.GetWidth() && shape.GetHeight())
<br>                SetShape( wxRegion( shape, *wxWHITE, 10 ) );
<br>#endif
<br>        }
<br>    }
<br>}
<br>
<br>void ocpnFloatingToolbarDialog::OnToolLeftClick( wxCommandEvent& event )
<br>{
<br>    // First see if it was actually the context menu that was clicked.
<br>
<br>    if( event.GetId() >= ID_PLUGIN_BASE + 100 ) {
<br>
<br>        int itemId = event.GetId() - ID_PLUGIN_BASE - 100;
<br>        wxMenuItem *item = g_FloatingToolbarConfigMenu->FindItem( event.GetId() );
<br>
<br>        if(item){
<br>            bool toolIsChecked = item->IsChecked();
<br>
<br>            if( toolIsChecked ) {
<br>                g_toolbarConfig.SetChar( itemId, _T('X') );
<br>            } else {
<br>
<br>                if( itemId + ID_ZOOMIN == ID_MOB ) {
<br>                    ToolbarMOBDialog mdlg( this );
<br>                    int dialog_ret = mdlg.ShowModal();
<br>                    int answer = mdlg.GetSelection();
<br>
<br>                    if( answer == 0 || answer == 1 || dialog_ret == wxID_CANCEL ) {
<br>                        g_FloatingToolbarConfigMenu->FindItem( event.GetId() )->Check( true );
<br>                        if( answer == 1 && dialog_ret == wxID_OK ) {
<br>                            g_bPermanentMOBIcon = true;
<br>                            delete g_FloatingToolbarConfigMenu;
<br>                            g_FloatingToolbarConfigMenu = new wxMenu();
<br>                            toolbarConfigChanged = true;
<br>                        }
<br>                        return;
<br>                    }
<br>                }
<br>
<br>                if( m_ptoolbar->GetVisibleToolCount() == 1 ) {
<br>                    OCPNMessageBox( this,
<br>                            _("You can't hide the last tool from the toolbar\nas this would make it inaccessible."),
<br>                            _("OpenCPN Alert"), wxOK );
<br>                    g_FloatingToolbarConfigMenu->FindItem( event.GetId() )->Check( true );
<br>                    return;
<br>                }
<br>
<br>                g_toolbarConfig.SetChar( itemId, _T('.') );
<br>            }
<br>        }
<br>
<br>        toolbarConfigChanged = true;
<br>        return;
<br>    }
<br>
<br>    // No it was a button that was clicked.
<br>    // Since Dialog events don't propagate automatically, we send it explicitly
<br>    // (instead of relying on event.Skip()). Send events up the window hierarchy
<br>
<br>    m_pparent->GetEventHandler()->AddPendingEvent( event );
<br>#ifndef __WXQT__
<br>    gFrame->Raise();
<br>#endif    
<br>}
<br>
<br>ocpnToolBarSimple *ocpnFloatingToolbarDialog::GetToolbar()
<br>{
<br>    if( !m_ptoolbar ) {
<br>        long winstyle = wxNO_BORDER | wxTB_FLAT;
<br>        winstyle |= m_orient;
<br>
<br>        m_ptoolbar = new ocpnToolBarSimple( this, -1, wxPoint( -1, -1 ), wxSize( -1, -1 ),
<br>                winstyle );
<br>
<br>        m_ptoolbar->SetBackgroundColour( GetGlobalColor( _T("GREY2") ) );
<br>        m_ptoolbar->ClearBackground();
<br>        m_ptoolbar->SetToggledBackgroundColour( GetGlobalColor( _T("GREY1") ) );
<br>        m_ptoolbar->SetColorScheme( m_cs );
<br>
<br>        SetGeometry(false, wxRect());
<br>    }
<br>
<br>    return m_ptoolbar;
<br>}
<br>
<br>void ocpnFloatingToolbarDialog::DestroyToolBar()
<br>{
<br>    if( m_ptoolbar ) {
<br>        m_ptoolbar->ClearTools();
<br>        delete m_ptoolbar;                  //->Destroy();
<br>        m_ptoolbar = NULL;
<br>    }
<br> 
<br>    m_destroyGrabber = m_pRecoverwin;
<br>    m_destroyTimer.Start( 5, wxTIMER_ONE_SHOT );           //  Destor the unneeded recovery grabber
<br>    
<br>}
<br>
<br>//----------------------------------------------------------------------------
<br>// Toolbar Tooltip Popup Window Definition
<br>//----------------------------------------------------------------------------
<br>class ToolTipWin: public wxDialog {
<br>public:
<br>    ToolTipWin( wxWindow *parent );
<br>    ~ToolTipWin();
<br>
<br>    void OnPaint( wxPaintEvent& event );
<br>
<br>    void SetColorScheme( ColorScheme cs );
<br>    void SetString( wxString &s )
<br>    {
<br>        m_string = s;
<br>    }
<br>    void SetPosition( wxPoint pt )
<br>    {
<br>        m_position = pt;
<br>    }
<br>    void SetBitmap( void );
<br>
<br>    void SetHiviz( bool hiviz){ m_hiviz = hiviz; }
<br>    
<br>    wxSize GetRenderedSize( void );
<br>    
<br>private:
<br>
<br>    wxString m_string;
<br>    wxSize m_size;
<br>    wxPoint m_position;
<br>    wxBitmap *m_pbm;
<br>    wxColour m_back_color;
<br>    wxColour m_text_color;
<br>    ColorScheme m_cs ;
<br>    bool m_hiviz;
<br>
<br>DECLARE_EVENT_TABLE()
<br>};
<br>//-----------------------------------------------------------------------
<br>//
<br>//    Toolbar Tooltip window implementation
<br>//
<br>//-----------------------------------------------------------------------
<br>BEGIN_EVENT_TABLE(ToolTipWin, wxDialog) EVT_PAINT(ToolTipWin::OnPaint)
<br>
<br>END_EVENT_TABLE()
<br>
<br>// Define a constructor
<br>ToolTipWin::ToolTipWin( wxWindow *parent ) :
<br>        wxDialog( parent, wxID_ANY, _T(""), wxPoint( 0, 0 ), wxSize( 1, 1 ),
<br>                wxNO_BORDER | wxSTAY_ON_TOP )
<br>{
<br>    m_pbm = NULL;
<br>
<br>    m_back_color = GetGlobalColor( _T ( "UIBCK" ) );
<br>    m_text_color = GetGlobalColor( _T ( "UITX1" ) );
<br>
<br>    SetBackgroundStyle( wxBG_STYLE_CUSTOM );
<br>    SetBackgroundColour( m_back_color );
<br>    m_cs = GLOBAL_COLOR_SCHEME_RGB;
<br>
<br>    Hide();
<br>}
<br>
<br>ToolTipWin::~ToolTipWin()
<br>{
<br>    delete m_pbm;
<br>}
<br>
<br>void ToolTipWin::SetColorScheme( ColorScheme cs )
<br>{
<br>    m_back_color = GetGlobalColor( _T ( "UIBCK" ) );
<br>    m_text_color = FontMgr::Get().GetFontColor( _("ToolTips") );
<br>
<br>    m_cs = cs;
<br>}
<br>
<br>wxSize ToolTipWin::GetRenderedSize( void )
<br>{
<br>    int h, w;
<br>    wxSize sz;
<br>
<br>    wxClientDC cdc( GetParent() );
<br>
<br>    wxFont *plabelFont = FontMgr::Get().GetFont( _("ToolTips") );
<br>    cdc.GetTextExtent( m_string, &w, &h, NULL, NULL, plabelFont );
<br>
<br>    sz.x = w + 8;
<br>    sz.y = h + 4;
<br>    
<br>    return sz;
<br>
<br>}
<br>
<br>void ToolTipWin::SetBitmap()
<br>{
<br>    int h, w;
<br>
<br>    wxClientDC cdc( GetParent() );
<br>
<br>    wxFont *plabelFont = FontMgr::Get().GetFont( _("ToolTips") );
<br>    cdc.GetTextExtent( m_string, &w, &h, NULL, NULL, plabelFont );
<br>
<br>    m_size.x = w + 8;
<br>    m_size.y = h + 4;
<br>
<br>    wxMemoryDC mdc;
<br>
<br>    delete m_pbm;
<br>    m_pbm = new wxBitmap( m_size.x, m_size.y, -1 );
<br>    mdc.SelectObject( *m_pbm );
<br>
<br>    wxPen pborder( m_text_color );
<br>    wxBrush bback( m_back_color );
<br>    mdc.SetPen( pborder );
<br>    mdc.SetBrush( bback );
<br>
<br>    if(m_hiviz){
<br>        if((m_cs == GLOBAL_COLOR_SCHEME_DUSK) || (m_cs == GLOBAL_COLOR_SCHEME_NIGHT)){
<br>            wxBrush hv_back( wxColour(200,200,200));
<br>            mdc.SetBrush( hv_back );
<br>        }
<br>    }
<br>    mdc.DrawRectangle( 0, 0, m_size.x, m_size.y );
<br>
<br>    //    Draw the text
<br>    mdc.SetFont( *plabelFont );
<br>    mdc.SetTextForeground( m_text_color );
<br>    mdc.SetTextBackground( m_back_color );
<br>
<br>    mdc.DrawText( m_string, 4, 2 );
<br>
<br>    SetSize( m_position.x, m_position.y, m_size.x, m_size.y );
<br>
<br>}
<br>
<br>void ToolTipWin::OnPaint( wxPaintEvent& event )
<br>{
<br>    int width, height;
<br>    GetClientSize( &width, &height );
<br>    wxPaintDC dc( this );
<br>
<br>    if( m_string.Len() ) {
<br>        wxMemoryDC mdc;
<br>        mdc.SelectObject( *m_pbm );
<br>        dc.Blit( 0, 0, width, height, &mdc, 0, 0 );
<br>    }
<br>}
<br>
<br>
<br>// ----------------------------------------------------------------------------
<br>BEGIN_EVENT_TABLE(ocpnToolBarSimple, wxControl) EVT_SIZE(ocpnToolBarSimple::OnSize)
<br>EVT_PAINT(ocpnToolBarSimple::OnPaint)
<br>EVT_KILL_FOCUS(ocpnToolBarSimple::OnKillFocus)
<br>EVT_MOUSE_EVENTS(ocpnToolBarSimple::OnMouseEvent)
<br>EVT_TIMER(TOOLTIPON_TIMER, ocpnToolBarSimple::OnToolTipTimerEvent)
<br>EVT_TIMER(TOOLTIPOFF_TIMER, ocpnToolBarSimple::OnToolTipOffTimerEvent)
<br>
<br>END_EVENT_TABLE()
<br>
<br>// ============================================================================
<br>// implementation
<br>// ============================================================================
<br>
<br>// ----------------------------------------------------------------------------
<br>// tool bar tools creation
<br>// ----------------------------------------------------------------------------
<br>
<br>wxToolBarToolBase *ocpnToolBarSimple::CreateTool( int id, const wxString& label,
<br>        const wxBitmap& bmpNormal, const wxBitmap& bmpDisabled, wxItemKind kind,
<br>        wxObject *clientData, const wxString& shortHelp, const wxString& longHelp )
<br>{
<br>    return new ocpnToolBarTool( this, id, label, bmpNormal, bmpDisabled, kind, clientData,
<br>            shortHelp, longHelp );
<br>}
<br>
<br>// ----------------------------------------------------------------------------
<br>// ocpnToolBarSimple creation
<br>// ----------------------------------------------------------------------------
<br>
<br>void ocpnToolBarSimple::Init()
<br>{
<br>    m_currentRowsOrColumns = 0;
<br>
<br>    m_lastX = m_lastY = 0;
<br>
<br>    m_maxWidth = m_maxHeight = 0;
<br>
<br>    m_pressedTool = m_currentTool = -1;
<br>
<br>    m_xPos = m_yPos = wxDefaultCoord;
<br>
<br>    m_style = g_StyleManager->GetCurrentStyle();
<br>
<br>    m_defaultWidth = 16;
<br>    m_defaultHeight = 15;
<br>
<br>    m_toggle_bg_color = wxSystemSettings::GetColour( wxSYS_COLOUR_3DFACE );
<br>    m_toolOutlineColour.Set( _T("BLACK") );
<br>    m_pToolTipWin = NULL;
<br>    m_last_ro_tool = NULL;
<br>
<br>    m_btoolbar_is_zooming = false;
<br>    m_sizefactor = 1.0f;
<br>
<br>    m_last_plugin_down_id = -1;
<br>    
<br>    EnableTooltips();
<br>}
<br>
<br>wxToolBarToolBase *ocpnToolBarSimple::DoAddTool( int id, const wxString& label,
<br>        const wxBitmap& bitmap, const wxBitmap& bmpDisabled, wxItemKind kind,
<br>        const wxString& shortHelp, const wxString& longHelp, wxObject *clientData, wxCoord xPos,
<br>        wxCoord yPos )
<br>{
<br>    // rememeber the position for DoInsertTool()
<br>    m_xPos = xPos;
<br>    m_yPos = yPos;
<br>
<br>    InvalidateBestSize();
<br>    return InsertTool( GetToolsCount(), id, label, bitmap, bmpDisabled, kind, shortHelp, longHelp,
<br>            clientData );
<br>
<br>}
<br>
<br>///
<br>
<br>wxToolBarToolBase *ocpnToolBarSimple::AddTool( int toolid, const wxString& label,
<br>        const wxBitmap& bitmap, const wxBitmap& bmpDisabled, wxItemKind kind,
<br>        const wxString& shortHelp, const wxString& longHelp, wxObject *data )
<br>{
<br>    InvalidateBestSize();
<br>    ocpnToolBarTool* tool = (ocpnToolBarTool*)InsertTool( GetToolsCount(), toolid, label, bitmap, bmpDisabled, kind,
<br>            shortHelp, longHelp, data );
<br>    return tool;
<br>}
<br>
<br>wxToolBarToolBase *ocpnToolBarSimple::InsertTool( size_t pos, int id, const wxString& label,
<br>        const wxBitmap& bitmap, const wxBitmap& bmpDisabled, wxItemKind kind,
<br>        const wxString& shortHelp, const wxString& longHelp, wxObject *clientData )
<br>{
<br>    wxCHECK_MSG( pos <= GetToolsCount(), (wxToolBarToolBase *)NULL,
<br>            _T("invalid position in wxToolBar::InsertTool()") );
<br>
<br>    wxToolBarToolBase *tool = CreateTool( id, label, bitmap, bmpDisabled, kind, clientData,
<br>            shortHelp, longHelp );
<br>
<br>    if( !InsertTool( pos, tool ) ) {
<br>        delete tool;
<br>
<br>        return NULL;
<br>    }
<br>
<br>    return tool;
<br>}
<br>
<br>wxToolBarToolBase *ocpnToolBarSimple::InsertTool( size_t pos, wxToolBarToolBase *tool )
<br>{
<br>    wxCHECK_MSG( pos <= GetToolsCount(), (wxToolBarToolBase *)NULL,
<br>            _T("invalid position in wxToolBar::InsertTool()") );
<br>
<br>    if( !tool || !DoInsertTool( pos, tool ) ) {
<br>        return NULL;
<br>    }
<br>
<br>    m_tools.Insert( pos, tool );
<br>
<br>    return tool;
<br>}
<br>
<br>bool ocpnToolBarSimple::DoInsertTool( size_t WXUNUSED(pos), wxToolBarToolBase *toolBase )
<br>{
<br>    ocpnToolBarTool *tool = (ocpnToolBarTool *) toolBase;
<br>
<br>    // Check if the plugin is inserting same-named tools. Make sure they have different names,
<br>    // otherwise the style manager cannot differentiate between them.
<br>    if( tool->isPluginTool ) {
<br>        for( unsigned int i=0; i<GetToolsCount(); i++ ) {
<br>            if( tool->GetToolname() == ((ocpnToolBarTool *)m_tools.Item(i)->GetData())->GetToolname()) {
<br>                tool->toolname << _T("1");
<br>            }
<br>        }
<br>    }
<br>
<br>    tool->m_x = m_xPos;
<br>    if( tool->m_x == wxDefaultCoord ) tool->m_x = m_style->GetLeftMargin();
<br>
<br>    tool->m_y = m_yPos;
<br>    if( tool->m_y == wxDefaultCoord ) tool->m_y = m_style->GetTopMargin();
<br>
<br>    if( tool->IsButton() ) {
<br>        tool->SetSize( GetToolSize() );
<br>
<br>        // Calculate reasonable max size in case Layout() not called
<br>        if( ( tool->m_x + tool->GetNormalBitmap().GetWidth() + m_style->GetLeftMargin() )
<br>                > m_maxWidth ) m_maxWidth = (wxCoord) ( ( tool->m_x + tool->GetWidth()
<br>                + m_style->GetLeftMargin() ) );
<br>
<br>        if( ( tool->m_y + tool->GetNormalBitmap().GetHeight() + m_style->GetTopMargin() )
<br>                > m_maxHeight ) m_maxHeight = (wxCoord) ( ( tool->m_y + tool->GetHeight()
<br>                + m_style->GetTopMargin() ) );
<br>    }
<br>
<br>    else
<br>        if( tool->IsControl() ) {
<br>            tool->SetSize( tool->GetControl()->GetSize() );
<br>        }
<br>
<br>    tool->b_hilite = false;
<br>
<br>    return true;
<br>}
<br>
<br>bool ocpnToolBarSimple::DoDeleteTool( size_t WXUNUSED(pos), wxToolBarToolBase *tool )
<br>{
<br>    // VZ: didn't test whether it works, but why not...
<br>    tool->Detach();
<br>
<br>    if( m_last_ro_tool == tool ) m_last_ro_tool = NULL;
<br>
<br>    Refresh( false );
<br>
<br>    return true;
<br>}
<br>
<br>bool ocpnToolBarSimple::Create( wxWindow *parent, wxWindowID id, const wxPoint& pos,
<br>        const wxSize& size, long style, const wxString& name )
<br>{
<br>    if( !wxWindow::Create( parent, id, pos, size, style, name ) ) return false;
<br>
<br>    // Set it to grey (or other 3D face colour)
<br>    SetBackgroundColour( wxSystemSettings::GetColour( wxSYS_COLOUR_3DFACE ) );
<br>
<br>    if( GetWindowStyleFlag() & wxTB_VERTICAL ) {
<br>        m_lastX = 7;
<br>        m_lastY = 3;
<br>
<br>        m_maxRows = 32000;      // a lot
<br>        m_maxCols = 1;
<br>    } else {
<br>        m_lastX = 3;
<br>        m_lastY = 7;
<br>
<br>        m_maxRows = 1;
<br>        m_maxCols = 32000;      // a lot
<br>    }
<br>
<br>    SetCursor( *wxSTANDARD_CURSOR );
<br>
<br>    m_tooltip_timer.SetOwner( this, TOOLTIPON_TIMER );
<br>    m_tooltipoff_timer.SetOwner( this, TOOLTIPOFF_TIMER );
<br>    m_tooltip_off = 3000;
<br>
<br>    return true;
<br>}
<br>
<br>ocpnToolBarSimple::~ocpnToolBarSimple()
<br>{
<br>    if( m_pToolTipWin ) {
<br>        m_pToolTipWin->Destroy();
<br>        m_pToolTipWin = NULL;
<br>    }
<br>
<br>}
<br>
<br>void ocpnToolBarSimple::KillTooltip()
<br>{
<br>    m_btooltip_show = false;
<br>
<br>    if( m_pToolTipWin ) {
<br>        m_pToolTipWin->Hide();
<br>        m_pToolTipWin->Destroy();
<br>        m_pToolTipWin = NULL;
<br>    }
<br>    m_tooltip_timer.Stop();
<br>
<br>    if( m_last_ro_tool ) {
<br>        if( m_last_ro_tool->IsEnabled() ) {
<br>            if( m_last_ro_tool->IsToggled() ) {
<br>                m_last_ro_tool->SetNormalBitmap( m_style->GetToolIcon( m_last_ro_tool->GetToolname(), TOOLICON_TOGGLED ) );
<br>            }
<br>            else {
<br>                m_last_ro_tool->SetNormalBitmap( m_style->GetToolIcon( m_last_ro_tool->GetToolname(), TOOLICON_NORMAL ) );
<br>            }
<br>        }
<br>    }
<br>}
<br>
<br>void ocpnToolBarSimple::HideTooltip()
<br>{
<br>    if( m_pToolTipWin ) {
<br>        m_pToolTipWin->Hide();
<br>    }
<br>}
<br>
<br>void ocpnToolBarSimple::SetColorScheme( ColorScheme cs )
<br>{
<br>    if( m_pToolTipWin ) {
<br>        m_pToolTipWin->Destroy();
<br>        m_pToolTipWin = NULL;
<br>    }
<br>
<br>    m_toolOutlineColour = GetGlobalColor( _T("UIBDR") );
<br>
<br>    m_currentColorScheme = cs;
<br>}
<br>
<br>bool ocpnToolBarSimple::Realize()
<br>{
<br>    m_currentRowsOrColumns = 0;
<br>    m_LineCount = 1;
<br>    m_lastX = m_style->GetLeftMargin();
<br>    m_lastY = m_style->GetTopMargin();
<br>    m_maxWidth = 0;
<br>    m_maxHeight = 0;
<br>
<br>    if( IsVertical() ) m_style->SetOrientation( wxTB_VERTICAL );
<br>    else
<br>        m_style->SetOrientation( wxTB_HORIZONTAL );
<br>
<br>    wxSize toolSize = wxSize(-1, -1);
<br>    int separatorSize = m_style->GetToolSeparation();
<br>
<br>    ocpnToolBarTool *lastTool = NULL;
<br>    bool firstNode = true;
<br>    wxToolBarToolsList::compatibility_iterator node = m_tools.GetFirst();
<br>
<br>    while( node ) {
<br>        ocpnToolBarTool *tool = (ocpnToolBarTool *) node->GetData();
<br>
<br>        // Set the tool size to be the size of the first non-separator tool, usually the first one
<br>        if(toolSize.x == -1){
<br>            if( !tool->IsSeparator() ){
<br>                toolSize.x = tool->m_width;
<br>                toolSize.y = tool->m_height;
<br>            }
<br>        }
<br>
<br>        tool->firstInLine = firstNode;
<br>        tool->lastInLine = false;
<br>        firstNode = false;
<br>
<br>        tool->last_rect.width = 0;              // mark it invalid
<br>        
<br>        if( tool->IsSeparator() ) {
<br>            if( GetWindowStyleFlag() & wxTB_HORIZONTAL ) {
<br>                if( m_currentRowsOrColumns >= m_maxCols ) m_lastY += separatorSize;
<br>                else
<br>                    m_lastX += separatorSize;
<br>            } else {
<br>                if( m_currentRowsOrColumns >= m_maxRows ) m_lastX += separatorSize;
<br>                else
<br>                    m_lastY += separatorSize;
<br>            }
<br>        } else
<br>            if( tool->IsButton() ) {
<br>                if( !IsVertical() ) {
<br>                    if( m_currentRowsOrColumns >= m_maxCols ) {
<br>                        tool->firstInLine = true;
<br>                        if( lastTool && m_LineCount > 1 ) lastTool->lastInLine = true;
<br>                        m_LineCount++;
<br>                        m_currentRowsOrColumns = 0;
<br>                        m_lastX = m_style->GetLeftMargin();
<br>                        m_lastY += toolSize.y + m_style->GetTopMargin();
<br>                    }
<br>                    tool->m_x = (wxCoord) m_lastX;
<br>                    tool->m_y = (wxCoord) m_lastY;
<br>
<br>                    tool->trect = wxRect( tool->m_x, tool->m_y, toolSize.x, toolSize.y );
<br>                    tool->trect.Inflate( m_style->GetToolSeparation() / 2,
<br>                            m_style->GetTopMargin() );
<br>
<br>                    m_lastX += toolSize.x + m_style->GetToolSeparation();
<br>                } else {
<br>                    if( m_currentRowsOrColumns >= m_maxRows ) {
<br>                        tool->firstInLine = true;
<br>                        if( lastTool ) lastTool->lastInLine = true;
<br>                        m_LineCount++;
<br>                        m_currentRowsOrColumns = 0;
<br>                        m_lastX += toolSize.x + m_style->GetTopMargin();
<br>                        m_lastY = m_style->GetTopMargin();
<br>                    }
<br>                    tool->m_x = (wxCoord) m_lastX;
<br>                    tool->m_y = (wxCoord) m_lastY;
<br>
<br>                    tool->trect = wxRect( tool->m_x, tool->m_y, toolSize.x, toolSize.y );
<br>                    tool->trect.Inflate( m_style->GetToolSeparation() / 2,
<br>                            m_style->GetTopMargin() );
<br>
<br>                    m_lastY += toolSize.y + m_style->GetToolSeparation();
<br>                }
<br>                m_currentRowsOrColumns++;
<br>            } else
<br>                if( tool->IsControl() ) {
<br>                    tool->m_x = (wxCoord) ( m_lastX );
<br>                    tool->m_y = (wxCoord) ( m_lastY - ( m_style->GetTopMargin() / 2 ) );
<br>
<br>                    tool->trect = wxRect( tool->m_x, tool->m_y, tool->GetWidth(),
<br>                            tool->GetHeight() );
<br>                    tool->trect.Inflate( m_style->GetToolSeparation() / 2,
<br>                            m_style->GetTopMargin() );
<br>                    ;
<br>
<br>                    wxSize s = tool->GetControl()->GetSize();
<br>                    m_lastX += s.x + m_style->GetToolSeparation();
<br>
<br>                }
<br>
<br>        if( m_lastX > m_maxWidth ) m_maxWidth = m_lastX;
<br>        if( m_lastY > m_maxHeight ) m_maxHeight = m_lastY;
<br>
<br>        lastTool = tool;
<br>        node = node->GetNext();
<br>    }
<br>    if( lastTool && (m_LineCount > 1 || IsVertical()) )
<br>        lastTool->lastInLine = true;
<br>
<br>    if( GetWindowStyleFlag() & wxTB_HORIZONTAL ) m_maxHeight += toolSize.y;
<br>    else
<br>        m_maxWidth += toolSize.x;
<br>
<br>    m_maxWidth += m_style->GetRightMargin();
<br>    m_maxHeight += m_style->GetBottomMargin();
<br>
<br>    SetSize( m_maxWidth, m_maxHeight );
<br>    SetMinSize( wxSize( m_maxWidth, m_maxHeight ) );
<br>
<br>    return true;
<br>}
<br>
<br>// ----------------------------------------------------------------------------
<br>// event handlers
<br>// ----------------------------------------------------------------------------
<br>
<br>void ocpnToolBarSimple::OnPaint( wxPaintEvent& WXUNUSED(event) )
<br>{
<br>    wxPaintDC dc( this );
<br>    PrepareDC( dc );
<br>
<br>    wxRegion ru = GetUpdateRegion();
<br>    wxRect upRect = ru.GetBox();
<br>
<br>    static int count = 0;
<br>    // Prevent reentry of OnPaint which would cause wxMemoryDC errors.
<br>    if( count > 0 ) return;
<br>    count++;
<br>
<br>    for( wxToolBarToolsList::compatibility_iterator node = m_tools.GetFirst(); node;
<br>            node = node->GetNext() ) {
<br>        wxToolBarToolBase *tool = node->GetData();
<br>        ocpnToolBarTool *tools = (ocpnToolBarTool *) tool;
<br>        wxRect toolRect = tools->trect;
<br>
<br>        if( toolRect.Intersects( upRect ) ) {
<br>
<br>            if( tool->IsButton() ) {
<br>                DrawTool( dc, tool );
<br>            } else
<br>                if( tool->IsControl() ) {
<br>                    if( tool->GetControl()->IsKindOf( CLASSINFO(wxStaticBitmap) ) ) {
<br>                        wxStaticBitmap *psbm = (wxStaticBitmap *) tool->GetControl();
<br>                        ocpnToolBarTool *toolsimp = (ocpnToolBarTool *) tool;
<br>                        dc.DrawBitmap( psbm->GetBitmap(), toolsimp->m_x, toolsimp->m_y, false );
<br>                    }
<br>                }
<br>        }
<br>    }
<br>
<br>    count--;
<br>}
<br>
<br>void ocpnToolBarSimple::OnSize( wxSizeEvent& WXUNUSED(event) )
<br>{
<br>    if( GetAutoLayout() ) Layout();
<br>}
<br>
<br>void ocpnToolBarSimple::OnKillFocus( wxFocusEvent& WXUNUSED(event) )
<br>{
<br>    OnMouseEnter( m_pressedTool = m_currentTool = -1 );
<br>}
<br>
<br>void ocpnToolBarSimple::OnToolTipTimerEvent( wxTimerEvent& event )
<br>{
<br>    if( !gFrame->IsActive() ) return;
<br>
<br>    if( m_btooltip_show && IsShown() && m_pToolTipWin && ( !m_pToolTipWin->IsShown() ) ) {
<br>        if( m_last_ro_tool ) {
<br>            wxString s = m_last_ro_tool->GetShortHelp();
<br>
<br>            if( s.Len() ) {
<br>                m_pToolTipWin->SetString( s );
<br>                m_pToolTipWin->SetHiviz(m_last_ro_tool->m_btooltip_hiviz);
<br>
<br>                wxPoint pos_in_toolbar( m_last_ro_tool->m_x, m_last_ro_tool->m_y );
<br>                pos_in_toolbar.x += m_last_ro_tool->m_width + 2;
<br>
<br>                m_pToolTipWin->Move(0,0);       // workaround for gtk autocentre dialog behavior
<br>
<br>                wxPoint screenPosition = ClientToScreen( pos_in_toolbar );
<br>                wxPoint framePosition = gFrame->ScreenToClient(screenPosition);
<br>                wxSize tipSize = m_pToolTipWin->GetRenderedSize();
<br>                
<br>                if( (framePosition.x + tipSize.x) > gFrame->GetSize().x)
<br>                    screenPosition.x -= (tipSize.x + m_last_ro_tool->m_width + 4);
<br>                
<br>                m_pToolTipWin->SetPosition( screenPosition );
<br>                m_pToolTipWin->SetBitmap();
<br>                m_pToolTipWin->Show();
<br>                gFrame->Raise();
<br>                if( g_btouch )
<br>                    m_tooltipoff_timer.Start(m_tooltip_off, wxTIMER_ONE_SHOT);
<br>            }
<br>        }
<br>    }
<br>}
<br>
<br>void ocpnToolBarSimple::OnToolTipOffTimerEvent( wxTimerEvent& event )
<br>{
<br>    HideTooltip();
<br>}
<br>
<br>
<br>int s_dragx, s_dragy;
<br>
<br>void ocpnToolBarSimple::OnMouseEvent( wxMouseEvent & event )
<br>{
<br>#ifdef __OCPN__ANDROID__
<br>    if(!event.IsButton())
<br>        return;
<br>#endif
<br>
<br>    wxCoord x, y;
<br>    event.GetPosition( &x, &y );
<br>    ocpnToolBarTool *tool = (ocpnToolBarTool *) FindToolForPosition( x, y );
<br>
<br>#ifndef __OCPN__ANDROID__
<br>    if( event.LeftDown() ) {
<br>        CaptureMouse();
<br>        s_dragx = x;
<br>        s_dragy = y;
<br>    }
<br>    if( event.LeftUp() ) {
<br>        if( HasCapture() ) ReleaseMouse();
<br>    }
<br>#endif
<br>
<br>    if( tool && tool->IsButton() && IsShown() ) {
<br>
<br>        //    ToolTips
<br>        if( NULL == m_pToolTipWin ) {
<br>            m_pToolTipWin = new ToolTipWin( GetParent() );
<br>            m_pToolTipWin->SetColorScheme( m_currentColorScheme );
<br>            m_pToolTipWin->Hide();
<br>        }
<br>
<br>        if( tool != m_last_ro_tool ) m_pToolTipWin->Hide();
<br>
<br>#ifndef __OCPN__ANDROID__
<br>        if( !m_pToolTipWin->IsShown() ) {
<br>            m_tooltip_timer.Start( m_one_shot, wxTIMER_ONE_SHOT );
<br>        }
<br>#endif
<br>
<br>        //    Tool Rollover highlighting
<br>        if(!g_btouch){
<br>            if( tool != m_last_ro_tool ) {
<br>                if( tool->IsEnabled() ) {
<br>                    tool->rollover = true;
<br>                    tool->bitmapOK = false;
<br>                }
<br>                if( m_last_ro_tool ) {
<br>                    if( m_last_ro_tool->IsEnabled() ) {
<br>                        m_last_ro_tool->rollover = false;
<br>                        m_last_ro_tool->bitmapOK = false;
<br>                    }
<br>                }
<br>                m_last_ro_tool = tool;
<br>                if(g_toolbar)
<br>                    g_toolbar->Refresh( false );
<br>            }
<br>        }
<br>    } else {
<br>        //    Tooltips
<br>        if( m_pToolTipWin && m_pToolTipWin->IsShown() ) m_pToolTipWin->Hide();
<br>
<br>        //    Remove Highlighting
<br>        if( m_last_ro_tool ) {
<br>            if( m_last_ro_tool->IsEnabled() ) {
<br>                m_last_ro_tool->rollover = false;
<br>                m_last_ro_tool->bitmapOK = false;
<br>            }
<br>            g_toolbar->Refresh( false );
<br>        }
<br>    }
<br>
<br>    m_last_ro_tool = tool;
<br>
<br>    // allow smooth zooming while toolbutton is held down
<br>    if(g_bsmoothpanzoom && !g_btouch) {
<br>        if(event.LeftUp() && m_btoolbar_is_zooming) {
<br>            cc1->StopMovement();
<br>            m_btoolbar_is_zooming = false;
<br>            return;
<br>        }
<br>
<br>        if( event.LeftDown() && tool &&
<br>            (tool->GetId() == ID_ZOOMIN || tool->GetId() == ID_ZOOMOUT) ) {
<br>            cc1->ZoomCanvas( tool->GetId() == ID_ZOOMIN ? 2.0 : .5, false, false );
<br>            m_btoolbar_is_zooming = true;
<br>            return;
<br>        }
<br>    }
<br>
<br>    if( !tool ) {
<br>        if( m_currentTool > -1 ) {
<br>            if( event.LeftIsDown() ) SpringUpButton( m_currentTool );
<br>            m_currentTool = -1;
<br>            OnMouseEnter( -1 );
<br>        }
<br>
<br>        wxMouseEvent *pev = (wxMouseEvent *) event.Clone();
<br>        GetParent()->GetEventHandler()->AddPendingEvent( *pev );
<br>        wxDELETE( pev );
<br>
<br>        return;
<br>    }
<br>
<br>    if( !event.IsButton() ) {
<br>        if( tool->GetId() != m_currentTool ) {
<br>            // If the left button is kept down and moved over buttons,
<br>            // press those buttons.
<br>            if( event.LeftIsDown() && tool->IsEnabled() ) {
<br>                SpringUpButton( m_currentTool );
<br>
<br>                if( tool->CanBeToggled() ) {
<br>                    tool->Toggle();
<br>                }
<br>
<br>                DrawTool( tool );
<br>            }
<br>
<br>            m_currentTool = tool->GetId();
<br>            OnMouseEnter( m_currentTool );
<br>        }
<br>
<br>        wxMouseEvent *pev = (wxMouseEvent *) event.Clone();
<br>        GetParent()->GetEventHandler()->AddPendingEvent( *pev );
<br>        wxDELETE( pev );
<br>
<br>        return;
<br>    }
<br>
<br>    // Left button pressed.
<br>    if( event.LeftDown() && tool->IsEnabled() ) {
<br>        if( tool->CanBeToggled() ) {
<br>            tool->Toggle();
<br>            tool->bitmapOK = false;
<br>            
<br>        }
<br>
<br>        DrawTool( tool );
<br>
<br>        //        Look for PlugIn tools
<br>        //        If found, make the callback.
<br>        if( g_pi_manager ) {
<br>            ArrayOfPlugInToolbarTools tool_array = g_pi_manager->GetPluginToolbarToolArray();
<br>            for( unsigned int i = 0; i < tool_array.GetCount(); i++ ) {
<br>                PlugInToolbarToolContainer *pttc = tool_array.Item( i );
<br>                if( tool->GetId() == pttc->id ) {
<br>                    opencpn_plugin_113 *ppi = dynamic_cast<opencpn_plugin_113 *>(pttc->m_pplugin);
<br>                    if( ppi ) {
<br>                        ppi->OnToolbarToolDownCallback( pttc->id );
<br>                        m_last_plugin_down_id = pttc->id;
<br>                    }
<br>                }
<br>            }
<br>        }
<br>    } else
<br>        if( event.RightDown() ) {
<br>            OnRightClick( tool->GetId(), x, y );
<br>        }
<br>
<br>    // Left Button Released.  Only this action confirms selection.
<br>    // If the button is enabled and it is not a toggle tool and it is
<br>    // in the pressed state, then raise the button and call OnLeftClick.
<br>    //
<br>    if( event.LeftUp() && tool->IsEnabled() ) {
<br>        // Pass the OnLeftClick event to tool
<br>        if( !OnLeftClick( tool->GetId(), tool->IsToggled() ) && tool->CanBeToggled() ) {
<br>            // If it was a toggle, and OnLeftClick says No Toggle allowed,
<br>            // then change it back
<br>            tool->Toggle();
<br>            tool->bitmapOK = false;
<br>        }
<br>
<br>        DoPluginToolUp();
<br>    }
<br>
<br>    wxMouseEvent *pev = (wxMouseEvent *) event.Clone();
<br>    GetParent()->GetEventHandler()->AddPendingEvent( *pev );
<br>    wxDELETE( pev );
<br>    event.Skip();
<br>}
<br>
<br>// ----------------------------------------------------------------------------
<br>// drawing
<br>// ----------------------------------------------------------------------------
<br>
<br>void ocpnToolBarSimple::DrawTool( wxToolBarToolBase *tool )
<br>{
<br>    wxClientDC dc( this );
<br>    DrawTool( dc, tool );
<br>}
<br>
<br>// NB! The current DrawTool code assumes that plugin tools are never disabled
<br>// when they are present on the toolbar, since disabled plugins are removed.
<br>
<br>void ocpnToolBarSimple::DrawTool( wxDC& dc, wxToolBarToolBase *toolBase )
<br>{
<br>    ocpnToolBarTool *tool = (ocpnToolBarTool *) toolBase;
<br>    PrepareDC( dc );
<br>
<br>    wxPoint drawAt( tool->m_x, tool->m_y );
<br>    wxBitmap bmp;
<br>
<br>    if( tool->bitmapOK ) {
<br>        if( tool->IsEnabled() ) {
<br>            bmp = tool->GetNormalBitmap();
<br>            if( !bmp.IsOk() ){
<br>                bmp = m_style->GetToolIcon( tool->GetToolname(), TOOLICON_NORMAL, tool->rollover );
<br>                if(m_sizefactor > 1.0 ){
<br><mark>                    wxImage scaled_image = bmp.ConvertToImage();
</mark><br><mark>                    bmp = wxBitmap(scaled_image.Scale(tool->m_width, tool->m_height, wxIMAGE_QUALITY_HIGH));
</mark><br>                }
<br>                tool->SetNormalBitmap( bmp );
<br>                tool->bitmapOK = true;
<br>            }
<br>        } else {
<br>            bmp = tool->GetDisabledBitmap();
<br>            if( !bmp.IsOk() ){
<br>                bmp = m_style->GetToolIcon( tool->GetToolname(), TOOLICON_DISABLED );
<br>                if(m_sizefactor > 1.0 ){
<br><mark>                    wxImage scaled_image = bmp.ConvertToImage();
</mark><br><mark>                    bmp = wxBitmap(scaled_image.Scale(tool->m_width, tool->m_height, wxIMAGE_QUALITY_HIGH));
</mark><br>                }
<br>                tool->SetDisabledBitmap( bmp );
<br>                tool->bitmapOK = true;
<br>            }
<br>        }
<br>    } else {
<br>        if ( tool->isPluginTool ) {
<br>
<br>            // First try getting the icon from the Style.
<br>            // If it is not in the style we build a new icon from the style BG and the plugin icon.
<br>
<br>            if( tool->IsToggled() ) {
<br>                bmp = m_style->GetToolIcon( tool->GetToolname(), TOOLICON_TOGGLED, tool->rollover );
<br>                if( bmp.GetDepth() == 1 ) {
<br>                    if( tool->rollover ) {
<br>                        bmp = m_style->BuildPluginIcon( tool->pluginRolloverIcon, TOOLICON_TOGGLED );
<br>                        if( ! bmp.IsOk() )
<br>                            bmp = m_style->BuildPluginIcon( tool->pluginNormalIcon, TOOLICON_TOGGLED );
<br>                    }
<br>                    else
<br>                        bmp = m_style->BuildPluginIcon( tool->pluginNormalIcon, TOOLICON_TOGGLED );
<br>                }
<br>            } else {
<br>                bmp = m_style->GetToolIcon( tool->GetToolname(), TOOLICON_NORMAL, tool->rollover );
<br>                if( bmp.GetDepth() == 1 ) {
<br>                    if( tool->rollover ) {
<br>                        bmp = m_style->BuildPluginIcon( tool->pluginRolloverIcon, TOOLICON_NORMAL );
<br>                        if( ! bmp.IsOk() )
<br>                            bmp = m_style->BuildPluginIcon( tool->pluginNormalIcon, TOOLICON_NORMAL );
<br>                    }
<br>                    else
<br>                        bmp = m_style->BuildPluginIcon( tool->pluginNormalIcon, TOOLICON_NORMAL );
<br>                }
<br>            }
<br>            if(m_sizefactor > 1.0 ){
<br><mark>                wxImage scaled_image = bmp.ConvertToImage();
</mark><br><mark>                bmp = wxBitmap(scaled_image.Scale(tool->m_width, tool->m_height, wxIMAGE_QUALITY_HIGH));
</mark><br>            }
<br>            tool->SetNormalBitmap( bmp );
<br>            tool->bitmapOK = true;
<br>        } else {
<br>            if( tool->IsEnabled() ) {
<br>                if( tool->IsToggled() )
<br>                    bmp = m_style->GetToolIcon( tool->GetToolname(), TOOLICON_TOGGLED, tool->rollover );
<br>                else
<br>                    bmp = m_style->GetToolIcon( tool->GetIconName(), TOOLICON_NORMAL, tool->rollover );
<br>
<br>                if(m_sizefactor > 1.0 ){
<br><mark>                    wxImage scaled_image = bmp.ConvertToImage();
</mark><br><mark>                    bmp = wxBitmap(scaled_image.Scale(tool->m_width, tool->m_height, wxIMAGE_QUALITY_HIGH));
</mark><br>                }
<br>                tool->SetNormalBitmap( bmp );
<br>                tool->bitmapOK = true;
<br>            } else {
<br>                bmp = m_style->GetToolIcon( tool->GetToolname(), TOOLICON_DISABLED );
<br>                if(m_sizefactor > 1.0 ){
<br><mark>                    wxImage scaled_image = bmp.ConvertToImage();
</mark><br><mark>                    bmp = wxBitmap(scaled_image.Scale(tool->m_width, tool->m_height, wxIMAGE_QUALITY_HIGH));
</mark><br>                }
<br>                tool->SetDisabledBitmap( bmp );
<br>                tool->bitmapOK = true;
<br>            }
<br>        }
<br>    }
<br>
<br>    if( tool->firstInLine ) {
<br>        m_style->DrawToolbarLineStart( bmp );
<br>    }
<br>    if( tool->lastInLine ) {
<br>        m_style->DrawToolbarLineEnd( bmp );
<br>    }
<br>
<br>    if( bmp.GetWidth() != m_style->GetToolSize().x
<br>            || bmp.GetHeight() != m_style->GetToolSize().y ) {
<br>//        drawAt.x -= ( bmp.GetWidth() - m_style->GetToolSize().x ) / 2;
<br>//        drawAt.y -= ( bmp.GetHeight() - m_style->GetToolSize().y ) / 2;
<br>    }
<br>
<br>    //      Clear the last drawn tool if necessary
<br>    if( tool->last_rect.width && ((tool->last_rect.x != drawAt.x) || (tool->last_rect.y != drawAt.y)) ){
<br>        wxBrush bb(GetGlobalColor( _T("GREY2") ));
<br>        dc.SetBrush(bb);
<br>        dc.SetPen( *wxTRANSPARENT_PEN );
<br>        dc.DrawRectangle(tool->last_rect.x, tool->last_rect.y, tool->last_rect.width, tool->last_rect.height);
<br>    }
<br>
<br>    //  could cache this in the tool...
<br>    //  A bit of a hack here.  We only scale tools if they are to be magnified globally
<br>    if(0/*m_sizefactor > 1.0*/ )
<br>    {
<br><mark>        wxImage scaled_image = bmp.ConvertToImage();
</mark><br><mark>        wxBitmap sbmp = wxBitmap(scaled_image.Scale(tool->m_width, tool->m_height, wxIMAGE_QUALITY_HIGH));
</mark><br>        dc.DrawBitmap( sbmp, drawAt );
<br>        tool->last_rect = wxRect(drawAt.x, drawAt.y, sbmp.GetWidth(), sbmp.GetHeight());
<br>
<br>    }
<br>    else
<br>    {
<br>        dc.DrawBitmap( bmp, drawAt );
<br>        tool->last_rect = wxRect(drawAt.x, drawAt.y, bmp.GetWidth(), bmp.GetHeight());
<br>    }
<br>
<br>}
<br>
<br>// ----------------------------------------------------------------------------
<br>// toolbar geometry
<br>// ----------------------------------------------------------------------------
<br>
<br>wxToolBarToolBase *ocpnToolBarSimple::FindToolForPosition( wxCoord x, wxCoord y )
<br>{
<br>    wxToolBarToolsList::compatibility_iterator node = m_tools.GetFirst();
<br>    while( node ) {
<br>        ocpnToolBarTool *tool = (ocpnToolBarTool *) node->GetData();
<br>        if( ( x >= tool->m_x ) && ( y >= tool->m_y ) && ( x < ( tool->m_x + tool->GetWidth() ) )
<br>                && ( y < ( tool->m_y + tool->GetHeight() ) ) ) {
<br>            return tool;
<br>        }
<br>
<br>        node = node->GetNext();
<br>    }
<br>
<br>    return (wxToolBarToolBase *) NULL;
<br>}
<br>
<br>void ocpnToolBarSimple::InvalidateBitmaps()
<br>{
<br>    wxToolBarToolsList::compatibility_iterator node = m_tools.GetFirst();
<br>    while( node ) {
<br>        ocpnToolBarTool *tool = (ocpnToolBarTool *) node->GetData();
<br>        tool->bitmapOK = false;
<br>        node = node->GetNext();
<br>    }
<br>}
<br>
<br>wxRect ocpnToolBarSimple::GetToolRect( int tool_id )
<br>{
<br>    wxRect rect;
<br>    wxToolBarToolBase *tool = FindById( tool_id );
<br>    if( tool ) {
<br>        ocpnToolBarTool *otool = (ocpnToolBarTool *) tool;
<br>        if( otool ) rect = otool->trect;
<br>    }
<br>
<br>    return rect;
<br>}
<br>
<br>// ----------------------------------------------------------------------------
<br>// tool state change handlers
<br>// ----------------------------------------------------------------------------
<br>
<br>void ocpnToolBarSimple::DoEnableTool( wxToolBarToolBase *tool, bool WXUNUSED(enable) )
<br>{
<br>    DrawTool( tool );
<br>}
<br>
<br>void ocpnToolBarSimple::DoToggleTool( wxToolBarToolBase *tool, bool WXUNUSED(toggle) )
<br>{
<br>    ocpnToolBarTool *t = (ocpnToolBarTool *) tool;
<br>    t->bitmapOK = false;
<br>    DrawTool( tool );
<br>}
<br>
<br>// Okay, so we've left the tool we're in ... we must check if the tool we're
<br>// leaving was a 'sprung push button' and if so, spring it back to the up
<br>// state.
<br>void ocpnToolBarSimple::SpringUpButton( int id )
<br>{
<br>    wxToolBarToolBase *tool = FindById( id );
<br>
<br>    if( tool && tool->CanBeToggled() ) {
<br>        if( tool->IsToggled() ) tool->Toggle();
<br>
<br>        DrawTool( tool );
<br>    }
<br>}
<br>
<br>// ----------------------------------------------------------------------------
<br>// scrolling implementation
<br>// ----------------------------------------------------------------------------
<br>
<br>wxString ocpnToolBarSimple::GetToolShortHelp( int id ) const
<br>{
<br>    wxToolBarToolBase *tool = FindById( id );
<br>    wxCHECK_MSG( tool, wxEmptyString, _T("no such tool") );
<br>
<br>    return tool->GetShortHelp();
<br>}
<br>
<br>wxString ocpnToolBarSimple::GetToolLongHelp( int id ) const
<br>{
<br>    wxToolBarToolBase *tool = FindById( id );
<br>    wxCHECK_MSG( tool, wxEmptyString, _T("no such tool") );
<br>
<br>    return tool->GetLongHelp();
<br>}
<br>
<br>void ocpnToolBarSimple::SetToolShortHelp( int id, const wxString& help )
<br>{
<br>    wxToolBarToolBase *tool = FindById( id );
<br>    if( tool ) {
<br>        (void) tool->SetShortHelp( help );
<br>    }
<br>}
<br>
<br>void ocpnToolBarSimple::SetToolLongHelp( int id, const wxString& help )
<br>{
<br>    wxToolBarToolBase *tool = FindById( id );
<br>    if( tool ) {
<br>        (void) tool->SetLongHelp( help );
<br>    }
<br>}
<br>
<br>int ocpnToolBarSimple::GetToolPos( int id ) const
<br>{
<br>    size_t pos = 0;
<br>    wxToolBarToolsList::compatibility_iterator node;
<br>
<br>    for( node = m_tools.GetFirst(); node; node = node->GetNext() ) {
<br>        if( node->GetData()->GetId() == id ) return pos;
<br>
<br>        pos++;
<br>    }
<br>
<br>    return wxNOT_FOUND;
<br>}
<br>bool ocpnToolBarSimple::GetToolState( int id ) const
<br>{
<br>    wxToolBarToolBase *tool = FindById( id );
<br>    wxCHECK_MSG( tool, false, _T("no such tool") );
<br>
<br>    return tool->IsToggled();
<br>}
<br>
<br>bool ocpnToolBarSimple::GetToolEnabled( int id ) const
<br>{
<br>    wxToolBarToolBase *tool = FindById( id );
<br>    wxCHECK_MSG( tool, false, _T("no such tool") );
<br>
<br>    return tool->IsEnabled();
<br>}
<br>
<br>void ocpnToolBarSimple::ToggleTool( int id, bool toggle )
<br>{
<br>    wxToolBarToolBase *tool = FindById( id );
<br>        
<br>    if( tool && tool->CanBeToggled() && tool->Toggle( toggle ) ) {
<br>        DoToggleTool( tool, toggle );
<br>        if( g_toolbar ) g_toolbar->Refresh();
<br>    }
<br>}
<br>
<br>wxObject *ocpnToolBarSimple::GetToolClientData( int id ) const
<br>{
<br>    wxToolBarToolBase *tool = FindById( id );
<br>    return tool ? tool->GetClientData() : (wxObject *) NULL;
<br>}
<br>
<br>void ocpnToolBarSimple::SetToolClientData( int id, wxObject *clientData )
<br>{
<br>    wxToolBarToolBase *tool = FindById( id );
<br>
<br>    wxCHECK_RET( tool, _T("no such tool in wxToolBar::SetToolClientData") );
<br>
<br>    tool->SetClientData( clientData );
<br>}
<br>
<br>void ocpnToolBarSimple::EnableTool( int id, bool enable )
<br>{
<br>    wxToolBarToolBase *tool = FindById( id );
<br>    if( tool ) {
<br>        if( tool->Enable( enable ) ) {
<br>            DoEnableTool( tool, enable );
<br>        }
<br>    }
<br>    wxMenuItem* configItem = g_FloatingToolbarConfigMenu->FindItem( id );
<br>    configItem->Check( true );
<br>}
<br>
<br>void ocpnToolBarSimple::SetToolBitmaps( int id, wxBitmap *bmp, wxBitmap *bmpRollover )
<br>{
<br>    ocpnToolBarTool *tool = (ocpnToolBarTool*)FindById( id );
<br>    if( tool ) {
<br>        tool->pluginNormalIcon = bmp;
<br>        tool->pluginRolloverIcon = bmpRollover;
<br>        tool->bitmapOK = false;
<br>    }
<br>}
<br>
<br>void ocpnToolBarSimple::SetToolTooltipHiViz( int id, bool b_hiviz )
<br>{
<br>    ocpnToolBarTool *tool = (ocpnToolBarTool*)FindById( id );
<br>    if( tool ) {
<br>        tool->SetTooltipHiviz( b_hiviz );
<br>    }
<br>}
<br>
<br>
<br>void ocpnToolBarSimple::ClearTools()
<br>{
<br>    while( GetToolsCount() ) {
<br>        DeleteToolByPos( 0 );
<br>    }
<br>}
<br>
<br>int ocpnToolBarSimple::GetVisibleToolCount()
<br>{
<br>    int counter = 0;
<br>    wxToolBarToolsList::compatibility_iterator node = m_tools.GetFirst();
<br>    while( node ) {
<br>        ocpnToolBarTool *tool = (ocpnToolBarTool *) node->GetData();
<br>        counter++;
<br>        node = node->GetNext();
<br>    }
<br>    return counter;
<br>}
<br>
<br>bool ocpnToolBarSimple::DeleteToolByPos( size_t pos )
<br>{
<br>    wxCHECK_MSG( pos < GetToolsCount(), false,
<br>            _T("invalid position in wxToolBar::DeleteToolByPos()") );
<br>
<br>    wxToolBarToolsList::compatibility_iterator node = m_tools.Item( pos );
<br>
<br>    if( !DoDeleteTool( pos, node->GetData() ) ) {
<br>        return false;
<br>    }
<br>
<br>    delete node->GetData();
<br>    m_tools.Erase( node );
<br>
<br>    return true;
<br>}
<br>
<br>bool ocpnToolBarSimple::DeleteTool( int id )
<br>{
<br>    size_t pos = 0;
<br>    wxToolBarToolsList::compatibility_iterator node;
<br>    for( node = m_tools.GetFirst(); node; node = node->GetNext() ) {
<br>        if( node->GetData()->GetId() == id ) break;
<br>
<br>        pos++;
<br>    }
<br>
<br>    if( !node || !DoDeleteTool( pos, node->GetData() ) ) {
<br>        return false;
<br>    }
<br>
<br>    delete node->GetData();
<br>    m_tools.Erase( node );
<br>
<br>    return true;
<br>}
<br>
<br>wxToolBarToolBase *ocpnToolBarSimple::AddSeparator()
<br>{
<br>    return InsertSeparator( GetToolsCount() );
<br>}
<br>
<br>wxToolBarToolBase *ocpnToolBarSimple::InsertSeparator( size_t pos )
<br>{
<br>    wxCHECK_MSG( pos <= GetToolsCount(), (wxToolBarToolBase *)NULL,
<br>            _T("invalid position in wxToolBar::InsertSeparator()") );
<br>
<br>    wxToolBarToolBase *tool = CreateTool( wxID_SEPARATOR, wxEmptyString, wxNullBitmap, wxNullBitmap,
<br>            wxITEM_SEPARATOR, (wxObject *) NULL, wxEmptyString, wxEmptyString );
<br>
<br>    if( !tool || !DoInsertTool( pos, tool ) ) {
<br>        delete tool;
<br>
<br>        return NULL;
<br>    }
<br>
<br>    m_tools.Insert( pos, tool );
<br>
<br>    return tool;
<br>}
<br>
<br>wxToolBarToolBase *ocpnToolBarSimple::RemoveTool( int id )
<br>{
<br>    size_t pos = 0;
<br>    wxToolBarToolsList::compatibility_iterator node;
<br>    for( node = m_tools.GetFirst(); node; node = node->GetNext() ) {
<br>        if( node->GetData()->GetId() == id ) break;
<br>
<br>        pos++;
<br>    }
<br>
<br>    if( !node ) {
<br>        // don't give any error messages - sometimes we might call RemoveTool()
<br>        // without knowing whether the tool is or not in the toolbar
<br>        return (wxToolBarToolBase *) NULL;
<br>    }
<br>
<br>    wxToolBarToolBase *tool = node->GetData();
<br>    if( !DoDeleteTool( pos, tool ) ) {
<br>        return (wxToolBarToolBase *) NULL;
<br>    }
<br>
<br>    m_tools.Erase( node );
<br>
<br>    return tool;
<br>}
<br>
<br>
<br>wxControl *ocpnToolBarSimple::FindControl( int id )
<br>{
<br>    for( wxToolBarToolsList::compatibility_iterator node = m_tools.GetFirst(); node;
<br>            node = node->GetNext() ) {
<br>        const wxToolBarToolBase * const tool = node->GetData();
<br>        if( tool->IsControl() ) {
<br>            wxControl * const control = tool->GetControl();
<br>
<br>            if( !control ) {
<br>                wxFAIL_MSG( _T("NULL control in toolbar?") );
<br>            } else
<br>                if( control->GetId() == id ) {
<br>                    // found
<br>                    return control;
<br>                }
<br>        }
<br>    }
<br>
<br>    return NULL;
<br>}
<br>
<br>wxToolBarToolBase *ocpnToolBarSimple::FindById( int id ) const
<br>{
<br>    wxToolBarToolBase *tool = (wxToolBarToolBase *) NULL;
<br>
<br>    for( wxToolBarToolsList::compatibility_iterator node = m_tools.GetFirst(); node;
<br>            node = node->GetNext() ) {
<br>        tool = node->GetData();
<br>        if( tool->GetId() == id ) {
<br>            // found
<br>            break;
<br>        }
<br>
<br>        tool = NULL;
<br>    }
<br>
<br>    return tool;
<br>}
<br>
<br>// ----------------------------------------------------------------------------
<br>// event processing
<br>// ----------------------------------------------------------------------------
<br>
<br>// Only allow toggle if returns true
<br>bool ocpnToolBarSimple::OnLeftClick( int id, bool toggleDown )
<br>{
<br>    wxCommandEvent event( wxEVT_COMMAND_TOOL_CLICKED, id );
<br>    event.SetEventObject( this );
<br>
<br>    // we use SetInt() to make wxCommandEvent::IsChecked() return toggleDown
<br>    event.SetInt( (int) toggleDown );
<br>
<br>    // and SetExtraLong() for backwards compatibility
<br>    event.SetExtraLong( (long) toggleDown );
<br>
<br>    // Send events to this toolbar instead (and thence up the window hierarchy)
<br>    GetEventHandler()->ProcessEvent( event );
<br>
<br>    return true;
<br>}
<br>
<br>// Call when right button down.
<br>void ocpnToolBarSimple::OnRightClick( int id, long WXUNUSED(x), long WXUNUSED(y) )
<br>{
<br>    wxCommandEvent event( wxEVT_COMMAND_TOOL_RCLICKED, id );
<br>    event.SetEventObject( this );
<br>    event.SetInt( id );
<br>
<br>    HideTooltip();
<br>    ((ocpnFloatingToolbarDialog*)GetParent())->toolbarConfigChanged = false;
<br>    wxMenu* contextMenu = new wxMenu();
<br>    wxMenuItem* submenu = contextMenu->AppendSubMenu( g_FloatingToolbarConfigMenu, _("Visible buttons") );
<br>
<br>    PopupMenu( contextMenu );
<br>
<br>    contextMenu->Remove( submenu );
<br>    delete contextMenu;
<br>
<br>    if( ((ocpnFloatingToolbarDialog*)GetParent())->toolbarConfigChanged )
<br>        gFrame->GetEventHandler()->AddPendingEvent( event );
<br>}
<br>
<br>// Called when the mouse cursor enters a tool bitmap (no button pressed).
<br>// Argument is wxID_ANY if mouse is exiting the toolbar.
<br>// Note that for this event, the id of the window is used,
<br>// and the integer parameter of wxCommandEvent is used to retrieve
<br>// the tool id.
<br>void ocpnToolBarSimple::OnMouseEnter( int id )
<br>{
<br>    wxCommandEvent event( wxEVT_COMMAND_TOOL_ENTER, GetId() );
<br>    event.SetEventObject( this );
<br>    event.SetInt( id );
<br>
<br>    wxFrame *frame = wxDynamicCast(GetParent(), wxFrame);
<br>    if( frame ) {
<br>        wxString help;
<br>        wxToolBarToolBase* tool = id == wxID_ANY ? (wxToolBarToolBase*) NULL : FindById( id );
<br>        if( tool ) help = tool->GetLongHelp();
<br>        frame->DoGiveHelp( help, id != wxID_ANY );
<br>    }
<br>
<br>    (void) GetEventHandler()->ProcessEvent( event );
<br>
<br>    DoPluginToolUp();
<br>}
<br>
<br>void ocpnToolBarSimple::DoPluginToolUp()
<br>{
<br>    //        Look for PlugIn tools
<br>    //        If found, make the callback.
<br>    if( !g_pi_manager)
<br>        return;
<br>
<br>    ArrayOfPlugInToolbarTools tool_array = g_pi_manager->GetPluginToolbarToolArray();
<br>    for( unsigned int i = 0; i < tool_array.GetCount(); i++ ) {
<br>        PlugInToolbarToolContainer *pttc = tool_array.Item( i );
<br>        if( m_last_plugin_down_id == pttc->id ) {
<br>            opencpn_plugin_113 *ppi = dynamic_cast<opencpn_plugin_113 *>(pttc->m_pplugin);
<br>            if( ppi )
<br>                ppi->OnToolbarToolUpCallback( pttc->id );
<br>        }
<br>    }
<br>
<br>    m_last_plugin_down_id = -1;
<br>}
<br>
<br>void ocpnToolBarSimple::SetToolNormalBitmapEx( wxToolBarToolBase *tool, const wxString &iconName)
<br>{
<br>    if( tool ) {
<br>        ocpnToolBarTool *otool = (ocpnToolBarTool *) tool;
<br>        if(otool){
<br>            ocpnStyle::Style *style = g_StyleManager->GetCurrentStyle();
<br>
<br>            wxBitmap bmp = style->GetToolIcon( iconName, TOOLICON_NORMAL );
<br>            if(m_sizefactor > 1.0 ){
<br><mark>                wxImage scaled_image = bmp.ConvertToImage();
</mark><br><mark>                bmp = wxBitmap(scaled_image.Scale(otool->m_width, otool->m_height, wxIMAGE_QUALITY_HIGH));
</mark><br>            }
<br>        
<br>            tool->SetNormalBitmap( bmp );
<br>            otool->SetIconName( iconName );
<br>        }
<br>    }
<br>}
<br>
<br>
<br>//-------------------------------------------------------------------------------------
<br>
<br>ToolbarMOBDialog::ToolbarMOBDialog( wxWindow* parent )
<br>       : wxDialog( parent, wxID_ANY, _("OpenCPN Alert"), wxDefaultPosition, wxSize(250, 230) )
<br>{
<br>    wxBoxSizer* topSizer = new wxBoxSizer( wxVERTICAL );
<br>
<br>    wxBoxSizer* sizer = new wxBoxSizer( wxVERTICAL );
<br>    topSizer->Add( sizer, 0, wxALIGN_CENTER_HORIZONTAL | wxALL, 5 );
<br>
<br>    choices.push_back( new wxRadioButton( this, 0,  _("No, I don't want to hide it."),
<br>            wxDefaultPosition, wxDefaultSize, wxRB_GROUP ) );
<br>
<br>    choices.push_back( new wxRadioButton( this, 1, _("No, and permanently remove the option to hide it."),
<br>            wxDefaultPosition) );
<br>
<br>    choices.push_back( new wxRadioButton( this, 2, _("Yes, hide it."),
<br>            wxDefaultPosition) );
<br>
<br>    wxStdDialogButtonSizer* buttonSizer = CreateStdDialogButtonSizer( wxOK | wxCANCEL );
<br>
<br>
<br>    wxStaticText* textCtrl = new wxStaticText( this, wxID_ANY, _("The Man Over Board button could be an important safety feature.\nAre you sure you want to hide it?") );
<br>
<br>    sizer->Add( textCtrl, 0, wxEXPAND | wxALL, 5 );
<br>    sizer->Add( choices[0], 0, wxEXPAND | wxALL, 5 );
<br>    sizer->Add( choices[1], 0, wxEXPAND | wxALL, 5 );
<br>    sizer->Add( choices[2], 0, wxEXPAND | wxALL, 5 );
<br>    sizer->Add( buttonSizer, 0, wxEXPAND | wxTOP, 5 );
<br>
<br>    topSizer->SetSizeHints(this);
<br>    SetSizer( topSizer );
<br>}
<br>
<br>int ToolbarMOBDialog::GetSelection() {
<br>    for( unsigned int i=0; i<choices.size(); i++ ) {
<br>        if( choices[i]->GetValue() ) return choices[i]->GetId();
<br>    }
<br>    return 0;
<br>}
</p></body>
    </html><html>
    <head></head>
    <body><p><br>/***************************************************************************
<br> *
<br> * Project:  OpenCPN
<br> * Purpose:  OpenCPN Toolbar
<br> * Author:   David Register
<br> *
<br> ***************************************************************************
<br> *   Copyright (C) 2010 by David S. Register                               *
<br> *                                                                         *
<br> *   This program is free software; you can redistribute it and/or modify  *
<br> *   it under the terms of the GNU General Public License as published by  *
<br> *   the Free Software Foundation; either version 2 of the License, or     *
<br> *   (at your option) any later version.                                   *
<br> *                                                                         *
<br> *   This program is distributed in the hope that it will be useful,       *
<br> *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
<br> *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
<br> *   GNU General Public License for more details.                          *
<br> *                                                                         *
<br> *   You should have received a copy of the GNU General Public License     *
<br> *   along with this program; if not, write to the                         *
<br> *   Free Software Foundation, Inc.,                                       *
<br> *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,  USA.         *
<br> **************************************************************************/
<br>
<br>#include "wx/wxprec.h"
<br>
<br>#ifndef  WX_PRECOMP
<br>#include "wx/wx.h"
<br>#endif
<br>
<br>#include <vector>
<br>
<br>#include "ocpn_types.h"
<br>#include "navutil.h"
<br>#include "styles.h"
<br>#include "toolbar.h"
<br>#include "chart1.h"
<br>#include "pluginmanager.h"
<br>#include "FontMgr.h"
<br>
<br>extern ocpnFloatingToolbarDialog* g_FloatingToolbarDialog;
<br>extern bool                       g_bTransparentToolbar;
<br>extern bool                       g_bTransparentToolbarInOpenGLOK;
<br>extern ChartCanvas*               cc1;
<br>extern bool                       g_bopengl;
<br>extern ocpnToolBarSimple*         g_toolbar;
<br>extern ocpnStyle::StyleManager*   g_StyleManager;
<br>extern MyFrame*                   gFrame;
<br>extern PlugInManager*             g_pi_manager;
<br>extern wxMenu*                    g_FloatingToolbarConfigMenu;
<br>extern wxString                   g_toolbarConfig;
<br>extern bool                       g_bPermanentMOBIcon;
<br>extern bool                       g_btouch;
<br>extern bool                       g_bsmoothpanzoom;
<br>
<br>//----------------------------------------------------------------------------
<br>// GrabberWindow Implementation
<br>//----------------------------------------------------------------------------
<br>BEGIN_EVENT_TABLE(GrabberWin, wxPanel) EVT_MOUSE_EVENTS ( GrabberWin::MouseEvent )
<br>EVT_PAINT ( GrabberWin::OnPaint )
<br>END_EVENT_TABLE()
<br>
<br>GrabberWin::GrabberWin( wxWindow *parent, ocpnFloatingToolbarDialog *toolbar, float scale_factor, wxString icon_name, wxPoint position ):
<br>    wxPanel( parent, wxID_ANY, position, wxDefaultSize, wxNO_BORDER )
<br>{
<br>    m_icon_name = icon_name;
<br>    m_style = g_StyleManager->GetCurrentStyle();
<br>    wxBitmap bitmap = m_style->GetIcon( icon_name );
<br>    if(scale_factor > 1.0f){
<br>        int new_width = bitmap.GetWidth() * scale_factor;
<br>        int new_height = bitmap.GetHeight() * scale_factor;
<br><mark>        wxImage scaled_image = bitmap.ConvertToImage();
</mark><br><mark>        m_bitmap = wxBitmap(scaled_image.Scale(new_width, new_height, wxIMAGE_QUALITY_HIGH));
</mark><br>    }
<br>    else
<br>        m_bitmap = bitmap;
<br>
<br>    SetSize( wxSize( m_bitmap.GetWidth(), m_bitmap.GetHeight() ) );
<br>    SetMinSize( wxSize( m_bitmap.GetWidth(), m_bitmap.GetHeight() ) );
<br>
<br>    m_bLeftDown = false;
<br>    m_bRightDown = false;
<br>    m_scale_factor = scale_factor;
<br>    m_ptoolbar = toolbar;
<br>    m_dragging = false;
<br>    Hide();
<br>    
<br>}
<br>
<br>
<br>void GrabberWin::OnPaint( wxPaintEvent& event )
<br>{
<br>    wxPaintDC dc( this );
<br>    
<br>    wxColour back_color = GetGlobalColor( _T("GREY2") );
<br>    SetBackgroundColour( back_color );
<br>    ClearBackground();
<br>    
<br>    dc.DrawBitmap( m_bitmap, 0, 0, true );
<br>}
<br>
<br>void GrabberWin::SetColorScheme( ColorScheme cs )
<br>{
<br>    wxColour back_color = GetGlobalColor( _T("GREY2") );
<br>
<br>    SetBackgroundColour( back_color );
<br>    ClearBackground();
<br>
<br>    wxBitmap bitmap = m_style->GetIcon( m_icon_name) ;
<br>    if(m_scale_factor > 1.0f){
<br>        int new_width = bitmap.GetWidth() * m_scale_factor;
<br>        int new_height = bitmap.GetHeight() * m_scale_factor;
<br><mark>        wxImage scaled_image = bitmap.ConvertToImage();
</mark><br><mark>        m_bitmap = wxBitmap(scaled_image.Scale(new_width, new_height, wxIMAGE_QUALITY_HIGH));
</mark><br>    }
<br>    else
<br>        m_bitmap = bitmap;
<br>}
<br>
<br>void GrabberWin::MouseEvent( wxMouseEvent& event )
<br>{
<br>    static wxPoint s_gspt;
<br>    int x, y;
<br>
<br>    event.GetPosition( &x, &y );
<br>
<br>    wxPoint spt = ClientToScreen( wxPoint( x, y ) );
<br>    if( event.LeftDown() ) {
<br>        s_gspt = spt;
<br>    }
<br>    
<br>    
<br>#ifndef __WXQT__
<br>
<br>    if( event.LeftDown() ) {
<br>        CaptureMouse();
<br>    }
<br>
<br>    if( event.LeftUp() ) {
<br>        if( HasCapture() ) ReleaseMouse();
<br>    }
<br>
<br>#endif
<br>
<br>
<br>    if( event.RightDown() ){
<br>        if(m_ptoolbar){
<br>            m_dragging = true;
<br>            
<br>            if( !m_ptoolbar->m_bnavgrabber ){
<br>                m_ptoolbar->m_bnavgrabber = true;
<br>                m_ptoolbar->SetGrabber(_T("4WayMove") );
<br>            }
<br>            else{
<br>                m_ptoolbar->m_bnavgrabber = false;
<br>                m_ptoolbar->SetGrabber(_T("grabber_hi") );
<br>            }
<br>                
<br>        }
<br>    }
<br>    
<br>
<br>
<br>    if( event.Dragging() ) {
<br>        if(m_ptoolbar && m_ptoolbar->IsShown() /*&& m_ptoolbar->m_bnavgrabber*/){
<br>            wxPoint par_pos_old = m_ptoolbar->GetPosition();
<br>
<br>            wxPoint par_pos = par_pos_old;
<br>            par_pos.x += spt.x - s_gspt.x;
<br>            par_pos.y += spt.y - s_gspt.y;
<br>
<br>            m_ptoolbar->MoveDialogInScreenCoords( par_pos, par_pos_old );
<br>
<br>            s_gspt = spt;
<br>            m_dragging = true;
<br>        }
<br>
<br>    }
<br>
<br>    if( event.LeftUp() ) {
<br>        if(m_ptoolbar){
<br>            if(m_ptoolbar->m_bnavgrabber){
<br>                if(!m_dragging)
<br>                    m_ptoolbar->ToggleOrientation();
<br>            }
<br>            else if(!m_dragging){
<br>                if(m_ptoolbar->m_bsubmerged){
<br>                    m_ptoolbar->SurfaceFromGrabber();
<br>                }
<br>                else{
<br>                    m_ptoolbar->SubmergeToGrabber();
<br>                 }
<br>            }
<br>        }
<br>        m_dragging = false;
<br>    }
<br>    
<br>    
<br>#ifndef __OCPN__ANDROID__
<br>    gFrame->Raise();
<br>#endif
<br>    
<br>}
<br>
<br>class ocpnToolBarTool: public wxToolBarToolBase {
<br>public:
<br>    ocpnToolBarTool( ocpnToolBarSimple *tbar, int id, const wxString& label,
<br>            const wxBitmap& bmpNormal, const wxBitmap& bmpRollover, wxItemKind kind,
<br>            wxObject *clientData, const wxString& shortHelp, const wxString& longHelp ) :
<br>            wxToolBarToolBase( (wxToolBarBase*) tbar, id, label, bmpNormal, bmpRollover, kind,
<br>                    clientData, shortHelp, longHelp )
<br>    {
<br>        m_enabled = true;
<br>        m_toggled = false;
<br>        rollover = false;
<br>        bitmapOK = false;
<br>        m_btooltip_hiviz = false;
<br>
<br>        toolname = g_pi_manager->GetToolOwnerCommonName( id );
<br>        if( toolname == _T("") ) {
<br>            isPluginTool = false;
<br>            toolname = label;
<br>            iconName = label;
<br>        } else {
<br>            isPluginTool = true;
<br>            pluginNormalIcon = &bmpNormal;
<br>            pluginRolloverIcon = &bmpRollover;
<br>        }
<br>    }
<br>
<br>    void SetSize( const wxSize& size )
<br>    {
<br>        m_width = size.x;
<br>        m_height = size.y;
<br>    }
<br>
<br>    wxCoord GetWidth() const
<br>    {
<br>        return m_width;
<br>    }
<br>
<br>    wxCoord GetHeight() const
<br>    {
<br>        return m_height;
<br>    }
<br>
<br>    wxString GetToolname()
<br>    {
<br>        return toolname;
<br>    }
<br>
<br>    void SetIconName(wxString name)
<br>    {
<br>        iconName = name;
<br>    }
<br>    wxString GetIconName()
<br>    {
<br>        return iconName;
<br>    }
<br>
<br>    void SetTooltipHiviz( bool enable){ m_btooltip_hiviz = enable; }
<br>
<br>    wxCoord m_x;
<br>    wxCoord m_y;
<br>    wxCoord m_width;
<br>    wxCoord m_height;
<br>    wxRect trect;
<br>    wxString toolname;
<br>    wxString iconName;
<br>    const wxBitmap* pluginNormalIcon;
<br>    const wxBitmap* pluginRolloverIcon;
<br>    bool firstInLine;
<br>    bool lastInLine;
<br>    bool rollover;
<br>    bool bitmapOK;
<br>    bool isPluginTool;
<br>    bool b_hilite;
<br>    bool m_btooltip_hiviz;
<br>    wxRect last_rect;
<br>};
<br>
<br>//---------------------------------------------------------------------------------------
<br>//          ocpnFloatingToolbarDialog Implementation
<br>//---------------------------------------------------------------------------------------
<br>BEGIN_EVENT_TABLE(ocpnFloatingToolbarDialog, wxDialog)
<br>    EVT_MOUSE_EVENTS ( ocpnFloatingToolbarDialog::MouseEvent )
<br>    EVT_MENU(wxID_ANY, ocpnFloatingToolbarDialog::OnToolLeftClick)
<br>    EVT_TIMER ( FADE_TIMER, ocpnFloatingToolbarDialog::FadeTimerEvent )
<br>    EVT_TIMER ( DESTROY_TIMER, ocpnFloatingToolbarDialog::DestroyTimerEvent )
<br>    EVT_WINDOW_CREATE(ocpnFloatingToolbarDialog::OnWindowCreate)
<br>END_EVENT_TABLE()
<br>
<br>ocpnFloatingToolbarDialog::ocpnFloatingToolbarDialog( wxWindow *parent, wxPoint position,
<br>                                                      long orient, float size_factor )
<br>{
<br>    m_pparent = parent;
<br>    long wstyle = wxNO_BORDER | wxFRAME_NO_TASKBAR;
<br>#ifndef __WXMAC__
<br>    wstyle |= wxFRAME_SHAPED;
<br>#endif
<br>
<br>    m_ptoolbar = NULL;
<br>
<br>#ifdef __WXOSX__
<br>    wstyle |= wxSTAY_ON_TOP;
<br>#endif
<br>    wxDialog::Create( parent, -1, _T("ocpnToolbarDialog"), wxPoint( -1, -1 ), wxSize( -1, -1 ),
<br>            wstyle );
<br>
<br>    m_opacity = 255;
<br>
<br>    m_pGrabberwin = new GrabberWin( this, this, size_factor, _T("grabber_hi") );
<br>    m_pGrabberwin->Show();
<br>    
<br>    m_pRecoverwin = NULL;
<br>    m_position = position;
<br>    m_orient = orient;
<br>    m_sizefactor = size_factor;
<br>    
<br>    m_bAutoHideToolbar = false;
<br>    m_nAutoHideToolbar = 5;
<br>    
<br>
<br>    m_style = g_StyleManager->GetCurrentStyle();
<br>
<br>// A top-level sizer
<br>    m_topSizer = new wxBoxSizer( wxHORIZONTAL );
<br>    SetSizer( m_topSizer );
<br>
<br>    //    Set initial "Dock" parameters
<br>    m_dock_x = 0;
<br>    m_dock_y = 0;
<br>    m_block = false;
<br>
<br>    m_marginsInvisible = m_style->marginsInvisible;
<br>
<br>//    if(m_sizefactor > 1.0 )
<br> //       m_marginsInvisible = true;
<br>
<br>    m_bnavgrabber = false;    
<br>    
<br>    Hide();
<br>
<br>    m_bsubmerged = false;
<br>    
<br>    m_fade_timer.SetOwner( this, FADE_TIMER );
<br>    if( g_bTransparentToolbar )
<br>        m_fade_timer.Start( 5000 );
<br>    
<br>    if( m_bAutoHideToolbar && (m_nAutoHideToolbar > 0))
<br>        m_fade_timer.Start( m_nAutoHideToolbar * 1000 );
<br>    
<br>    m_destroyTimer.SetOwner( this, DESTROY_TIMER );
<br>}
<br>
<br>ocpnFloatingToolbarDialog::~ocpnFloatingToolbarDialog()
<br>{
<br>    DestroyToolBar();
<br>}
<br>
<br>void ocpnFloatingToolbarDialog::OnWindowCreate( wxWindowCreateEvent& event )
<br>{
<br>    Realize();
<br>}
<br>
<br>void ocpnFloatingToolbarDialog::SetGrabber( wxString icon_name )
<br>{
<br>//    m_pGrabberwin->Destroy();
<br>    m_pGrabberwin = new GrabberWin( this, this, m_sizefactor, icon_name );
<br>    m_pGrabberwin->Show();
<br>    
<br>    Realize();
<br>    
<br>#ifdef __WXOSX__    
<br>    m_pGrabberwin->Refresh();
<br>#endif    
<br>    
<br>}
<br>
<br>
<br>    
<br>void ocpnFloatingToolbarDialog::SetColorScheme( ColorScheme cs )
<br>{
<br>    m_cs = cs;
<br>
<br>    wxColour back_color = GetGlobalColor( _T("GREY2") );
<br>
<br>    //  Set background
<br>    SetBackgroundColour( back_color );
<br>    ClearBackground();
<br>
<br>    if( m_ptoolbar ) {
<br>        wxColour back_color = GetGlobalColor( _T("GREY2") );
<br>
<br>        //  Set background
<br>        m_ptoolbar->SetBackgroundColour( back_color );
<br>        m_ptoolbar->ClearBackground();
<br>
<br>        m_ptoolbar->SetToggledBackgroundColour( GetGlobalColor( _T("GREY1") ) );
<br>
<br>        m_ptoolbar->SetColorScheme( cs );
<br>        m_ptoolbar->Refresh( true );
<br>    }
<br>
<br>    if( m_pGrabberwin ) m_pGrabberwin->SetColorScheme( cs );
<br>
<br>}
<br>
<br>void ocpnFloatingToolbarDialog::SetGeometry(bool bAvoid, wxRect rectAvoid)
<br>{
<br>
<br>    if( m_ptoolbar ) {
<br>        wxSize style_tool_size = m_style->GetToolSize();
<br>
<br>        style_tool_size.x *= m_sizefactor;
<br>        style_tool_size.y *= m_sizefactor;
<br>
<br>        m_ptoolbar->SetToolBitmapSize( style_tool_size );
<br>
<br>        wxSize tool_size = m_ptoolbar->GetToolBitmapSize();
<br>        int grabber_width =  m_style->GetIcon( _T("grabber") ).GetWidth();
<br>        
<br>        int max_rows = 10;
<br>        int max_cols = 100;
<br>        if(cc1){
<br>
<br>            int avoid_start = cc1->GetClientSize().x - (tool_size.x + m_style->GetToolSeparation()) * 2;  // default
<br>            if(bAvoid && !rectAvoid.IsEmpty()){
<br>                avoid_start = cc1->GetClientSize().x - rectAvoid.width - 10;  // this is compass window, if shown
<br>            }
<br>            
<br>            
<br>            max_rows = (cc1->GetClientSize().y / ( tool_size.y + m_style->GetToolSeparation())) - 1;
<br>            
<br>            max_cols = (avoid_start - grabber_width) / ( tool_size.x + m_style->GetToolSeparation());
<br>            max_cols -= 1;
<br>            
<br>            if(m_orient == wxTB_VERTICAL)
<br>                max_rows = wxMax( max_rows, 2);             // at least two rows
<br>            else
<br>                max_cols = wxMax( max_cols, 2);             // at least two columns
<br>        }
<br>
<br>        if( m_orient == wxTB_VERTICAL )
<br>            m_ptoolbar->SetMaxRowsCols(max_rows, 100);
<br>        else
<br>            m_ptoolbar->SetMaxRowsCols( 100, max_cols);
<br>        m_ptoolbar->SetSizeFactor(m_sizefactor);
<br>        
<br>    }
<br> }
<br>
<br>void ocpnFloatingToolbarDialog::RePosition()
<br>{
<br>    if(m_block) return;
<br>
<br>    if( m_pparent && m_ptoolbar ) {
<br>        wxSize cs = m_pparent->GetClientSize();
<br>        if( -1 == m_dock_x ) m_position.x = 0;
<br>        else
<br>            if( 1 == m_dock_x ) m_position.x = cs.x - GetSize().x;
<br>
<br>        if( -1 == m_dock_y ) m_position.y = 0;
<br>        else
<br>            if( 1 == m_dock_y ) m_position.y = cs.y - GetSize().y;
<br>
<br>        m_position.x = wxMin(cs.x - GetSize().x, m_position.x);
<br>        m_position.y = wxMin(cs.y - GetSize().y, m_position.y);
<br>
<br>        m_position.x = wxMax(0, m_position.x);
<br>        m_position.y = wxMax(0, m_position.y);
<br>
<br>        wxPoint screen_pos = m_pparent->ClientToScreen( m_position );
<br>
<br>        Move( screen_pos );
<br>
<br>#ifdef __WXQT__
<br>        Raise();
<br>#endif
<br>
<br>    }
<br>}
<br>
<br>void ocpnFloatingToolbarDialog::Submerge()
<br>{
<br>    m_bsubmerged = true;
<br>    Hide();
<br>    if( m_ptoolbar ) m_ptoolbar->KillTooltip();
<br>}
<br>
<br>void ocpnFloatingToolbarDialog::SubmergeToGrabber()
<br>{
<br>//Submerge();
<br>    m_bsubmerged = true;
<br>    Hide();
<br>    if( m_ptoolbar ) m_ptoolbar->KillTooltip();
<br>
<br>    m_pRecoverwin = new GrabberWin( m_pparent, this, m_sizefactor, _T("grabber_ext" ), wxPoint(10,10) );
<br>   
<br>    m_pRecoverwin->Show();
<br>    m_pRecoverwin->Raise();
<br>#ifdef __WXQT__
<br>    wxSize s = gFrame->GetSize();
<br>    m_recoversize = s;
<br>    s.y--;
<br>    gFrame->TriggerResize(s);
<br>    Raise();
<br>#endif    
<br>
<br>    gFrame->Refresh();          // Needed for MSW OpenGL
<br>}
<br>
<br>void ocpnFloatingToolbarDialog::Surface()
<br>{
<br>    
<br>    if(m_pRecoverwin){
<br>        m_pRecoverwin->Show();
<br>        m_pRecoverwin->Raise();
<br>    }
<br>    else {
<br>        m_bsubmerged = false;
<br>        #ifndef __WXOSX__
<br>        Hide();
<br>        Move( 0, 0 );
<br>        #endif
<br>
<br>        RePosition();
<br>        Show();
<br>        if( m_ptoolbar )
<br>            m_ptoolbar->EnableTooltips();
<br>
<br>        #ifdef __WXQT__
<br>        Raise();
<br>        #endif
<br>    }
<br>    
<br>    if( m_bAutoHideToolbar && (m_nAutoHideToolbar > 0) ){
<br>        m_fade_timer.Start( m_nAutoHideToolbar * 1000 );
<br>    }
<br>}
<br>
<br>bool ocpnFloatingToolbarDialog::CheckSurfaceRequest( wxMouseEvent &event )
<br>{
<br>    if( m_bsubmerged ){
<br>        if( event.LeftUp() ){
<br>            int x,y;
<br>            event.GetPosition( &x, &y );
<br>            if( m_pRecoverwin ){
<br>                wxRect winRect = m_pRecoverwin->GetRect();
<br>                if( winRect.Contains( x, y ) ){
<br>                    SurfaceFromGrabber();
<br>                    return true;
<br>                }
<br>            }
<br>        }
<br>    }
<br>    
<br>    return false;
<br>}
<br>        
<br>void ocpnFloatingToolbarDialog::SurfaceFromGrabber()
<br>{
<br>    m_bsubmerged = false;
<br>    
<br>#ifndef __WXOSX__
<br>    Hide();
<br>    Move( 0, 0 );
<br>#endif
<br>
<br>    if( m_ptoolbar )
<br>        m_ptoolbar->InvalidateBitmaps();
<br>    
<br>    RePosition();
<br>    Show();
<br>    if( m_ptoolbar )
<br>        m_ptoolbar->EnableTooltips();
<br>    
<br>    if( m_bAutoHideToolbar && (m_nAutoHideToolbar > 0) ){
<br>        m_fade_timer.Start( m_nAutoHideToolbar * 1000 );
<br>    }
<br>    
<br>#ifdef __WXQT__
<br>    wxSize s = gFrame->GetSize();               // check for rotation
<br>    if(m_recoversize.x == s.x)
<br>        gFrame->TriggerResize(m_recoversize);
<br>    Raise();
<br>#endif
<br>    
<br>    m_destroyGrabber = m_pRecoverwin;
<br>    m_destroyTimer.Start( 5, wxTIMER_ONE_SHOT );           //  Destor the unneeded recovery grabber
<br>    
<br>}
<br>
<br>void ocpnFloatingToolbarDialog::DestroyTimerEvent( wxTimerEvent& event )
<br>{
<br>    delete m_destroyGrabber;
<br>    m_destroyGrabber = NULL;
<br>    m_pRecoverwin = NULL;
<br>}
<br>
<br>void ocpnFloatingToolbarDialog::HideTooltip()
<br>{
<br>    if( m_ptoolbar ) m_ptoolbar->HideTooltip();
<br>}
<br>
<br>void ocpnFloatingToolbarDialog::ShowTooltips()
<br>{
<br>    if( m_ptoolbar ) m_ptoolbar->EnableTooltips();
<br>}
<br>
<br>void ocpnFloatingToolbarDialog::ToggleOrientation()
<br>{
<br>    if( m_orient == wxTB_HORIZONTAL )
<br>        m_orient = wxTB_VERTICAL;
<br>    else
<br>        m_orient = wxTB_HORIZONTAL;
<br>
<br>    m_style->SetOrientation( m_orient );
<br>
<br>    wxPoint old_screen_pos = m_pparent->ClientToScreen( m_position );
<br>    wxPoint grabber_point_abs = ClientToScreen( m_pGrabberwin->GetPosition() );
<br>
<br>    gFrame->RequestNewToolbar();
<br>    wxPoint pos_abs = grabber_point_abs;
<br>    pos_abs.x -= m_pGrabberwin->GetPosition().x;
<br>    MoveDialogInScreenCoords( pos_abs, old_screen_pos );
<br>
<br>
<br>    Show();   // this seems to be necessary on GTK to kick the sizer into gear...(FS#553)
<br>    Refresh(true);
<br>    Raise();
<br>}
<br>
<br>void ocpnFloatingToolbarDialog::MouseEvent( wxMouseEvent& event )
<br>{
<br>    if( g_bTransparentToolbar ) {
<br>        if( event.Entering() && ( m_opacity < 255 ) ) {
<br>            SetTransparent( 255 );
<br>            m_opacity = 255;
<br>        }
<br>
<br>        m_fade_timer.Start( 5000 );           // retrigger the continuous timer
<br>    }
<br>    
<br>    if(m_bAutoHideToolbar && (m_nAutoHideToolbar > 0) ){
<br>        m_fade_timer.Start( m_nAutoHideToolbar * 1000 );
<br>    }
<br>}
<br>
<br>void ocpnFloatingToolbarDialog::FadeTimerEvent( wxTimerEvent& event )
<br>{
<br>    if(m_bnavgrabber){
<br>        m_fade_timer.Start( 5000 );           // do nothing if nav grabber is shown
<br>    }
<br>    else{
<br>        if( g_bTransparentToolbar && (!g_bopengl || g_bTransparentToolbarInOpenGLOK) ){
<br>            DoFade( 128 );
<br>            m_fade_timer.Start( 5000 );           // retrigger the continuous timer
<br>        }
<br>        
<br>        if(m_bAutoHideToolbar && (m_nAutoHideToolbar > 0) && !m_bsubmerged){
<br>            SubmergeToGrabber();
<br>//            m_fade_timer.Stop();
<br>        }
<br>    }
<br>}
<br>
<br>void ocpnFloatingToolbarDialog::SetAutoHideTimer(int time)
<br>{
<br>    m_nAutoHideToolbar = time;
<br>    if(m_bAutoHideToolbar){
<br>        m_fade_timer.Stop();
<br>        m_fade_timer.Start( m_nAutoHideToolbar * 1000 );
<br>    }
<br>}
<br>        
<br>void ocpnFloatingToolbarDialog::DoFade( int value )
<br>{
<br>    if( value != m_opacity ) SetTransparent( value );
<br>    m_opacity = value;
<br>}
<br>
<br>void ocpnFloatingToolbarDialog::RefreshFadeTimer()
<br>{
<br>    SetTransparent( 255 );
<br>    m_opacity = 255;
<br>    m_fade_timer.Start( 500 );           // retrigger the continuous timer
<br>    
<br>    if(m_bAutoHideToolbar && (m_nAutoHideToolbar > 0) ){
<br>        m_fade_timer.Start( m_nAutoHideToolbar * 1000 );
<br>    }
<br>    
<br>}
<br>
<br>void ocpnFloatingToolbarDialog::MoveDialogInScreenCoords( wxPoint posn, wxPoint posn_old )
<br>{
<br>    wxPoint pos_in_parent = m_pparent->ScreenToClient( posn );
<br>    wxPoint pos_in_parent_old = m_pparent->ScreenToClient( posn_old );
<br>
<br>    //    "Docking" support
<br>#define DOCK_MARGIN 40
<br>
<br>    // X
<br>    m_dock_x = 0;
<br>    if( pos_in_parent.x < pos_in_parent_old.x )            // moving left
<br>            {
<br>        if( pos_in_parent.x < DOCK_MARGIN ) {
<br>            pos_in_parent.x = 0;
<br>            m_dock_x = -1;
<br>        }
<br>    } else
<br>        if( pos_in_parent.x > pos_in_parent_old.x )            // moving right
<br>                {
<br>            int max_right = m_pparent->GetClientSize().x - GetSize().x;
<br>            if( pos_in_parent.x > ( max_right - DOCK_MARGIN ) ) {
<br>                pos_in_parent.x = max_right;
<br>                m_dock_x = 1;
<br>            }
<br>        }
<br>
<br>    // Y
<br>    m_dock_y = 0;
<br>    if( pos_in_parent.y < pos_in_parent_old.y )            // moving up
<br>            {
<br>        if( pos_in_parent.y < DOCK_MARGIN ) {
<br>            pos_in_parent.y = 0;
<br>            m_dock_y = -1;
<br>        }
<br>    } else
<br>        if( pos_in_parent.y > pos_in_parent_old.y )            // moving down
<br>                {
<br>            int max_down = m_pparent->GetClientSize().y - GetSize().y;
<br>            if( pos_in_parent.y > ( max_down - DOCK_MARGIN ) ) {
<br>                pos_in_parent.y = max_down;
<br>                m_dock_y = 1;
<br>            }
<br>        }
<br>
<br>    m_position = pos_in_parent;
<br>
<br>    wxPoint final_pos = m_pparent->ClientToScreen( pos_in_parent );
<br>
<br>    Move( final_pos );
<br>}
<br>
<br>void ocpnFloatingToolbarDialog::Realize()
<br>{
<br>    if( m_ptoolbar ) {
<br>        m_ptoolbar->Realize();
<br>
<br>        m_topSizer->Clear();
<br>        m_topSizer->Add( m_ptoolbar );
<br>        m_topSizer->Add( m_pGrabberwin, 0, wxTOP, m_style->GetTopMargin() );
<br>
<br>        m_topSizer->Layout();
<br>        Fit();
<br>
<br>        //    Update "Dock" parameters
<br>        if( m_position.x == 0 ) m_dock_x = -1;
<br>        else
<br>            if( m_position.x == m_pparent->GetClientSize().x - GetSize().x ) m_dock_x = 1;
<br>
<br>        if( m_position.y == 0 ) m_dock_y = -1;
<br>        else
<br>            if( m_position.y == m_pparent->GetClientSize().y - GetSize().y ) m_dock_y = 1;
<br>
<br>        // Now create a bitmap mask forthe frame shape.
<br>
<br>        if( m_marginsInvisible ) {
<br>
<br>            wxSize tool_size = m_ptoolbar->GetToolBitmapSize();
<br>
<br>            //  Determine whether the tool icons are meant (by style) to join without speces between
<br>            //  This will determine what type of region to draw.
<br>            bool b_overlap = false;
<br>
<br>            wxToolBarToolsList::compatibility_iterator node1 = m_ptoolbar->m_tools.GetFirst();
<br>            wxToolBarToolsList::compatibility_iterator node2 = node1->GetNext() ;
<br>
<br>            wxToolBarToolBase *tool1 = node1->GetData();
<br>            ocpnToolBarTool *tools1 = (ocpnToolBarTool *) tool1;
<br>
<br>            wxToolBarToolBase *tool2 = node2->GetData();
<br>            ocpnToolBarTool *tools2 = (ocpnToolBarTool *) tool2;
<br>
<br>            if( (tools1->m_x + tools1->m_width) >= tools2->m_x)
<br>                b_overlap = true;
<br>
<br>
<br>
<br>
<br>            int toolCount = m_ptoolbar->GetVisibleToolCount();
<br>
<br>            wxPoint upperLeft( m_style->GetLeftMargin(), m_style->GetTopMargin() );
<br>            wxSize visibleSize;
<br>            if( m_ptoolbar->IsVertical() ) {
<br>                int noTools = m_ptoolbar->GetMaxRows();
<br>                if( noTools > toolCount )
<br>                    noTools = toolCount;
<br>                visibleSize.x = m_ptoolbar->GetLineCount() * ( tool_size.x + m_style->GetTopMargin() );
<br>                visibleSize.y = noTools * ( tool_size.y + m_style->GetToolSeparation() );
<br>                visibleSize.x -= m_style->GetTopMargin();
<br>                visibleSize.y -= m_style->GetToolSeparation();
<br>            } else {
<br>                    int noTools = m_ptoolbar->GetMaxCols();
<br>                    if( noTools > toolCount )
<br>                        noTools = toolCount;
<br>                visibleSize.x = noTools * ( tool_size.x + m_style->GetToolSeparation() );
<br>                visibleSize.y = m_ptoolbar->GetLineCount() * ( tool_size.y + m_style->GetTopMargin() );
<br>                visibleSize.x -= m_style->GetToolSeparation();
<br>                visibleSize.y -= m_style->GetTopMargin();
<br>            }
<br>
<br>            wxBitmap shape( visibleSize.x + tool_size.x, visibleSize.y + tool_size.y);          // + fluff
<br>            wxMemoryDC sdc( shape );
<br>            sdc.SetBackground( *wxWHITE_BRUSH );
<br>            sdc.SetBrush( *wxBLACK_BRUSH );
<br>            sdc.SetPen( *wxBLACK_PEN );
<br>            sdc.Clear();
<br>
<br>            if(b_overlap) {
<br>                int lines = m_ptoolbar->GetLineCount();
<br>                for( int i = 1; i <= lines; i++ ) {
<br>                    if( m_ptoolbar->IsVertical() ) {
<br>                        wxSize barsize( tool_size.x, visibleSize.y );
<br>                        if( i == lines && i > 1 ) {
<br>                            int toolsInLastLine = toolCount % m_ptoolbar->GetMaxRows();
<br>                            if( toolsInLastLine == 0 ) toolsInLastLine = m_ptoolbar->GetMaxRows();
<br>                            int emptySpace = ( m_ptoolbar->GetMaxRows() - toolsInLastLine );
<br>                            barsize.y -= emptySpace
<br>                            * ( tool_size.y + m_style->GetToolSeparation() );
<br>                        }
<br>                        if( i == lines ) {
<br>                            // Also do grabber here, since it is to the right of the last line.
<br>                            wxRect grabMask( upperLeft, barsize );
<br>                            grabMask.width += m_style->GetIcon( _T("grabber") ).GetWidth();
<br>                            grabMask.height = m_style->GetIcon( _T("grabber") ).GetHeight();
<br>                            sdc.DrawRoundedRectangle( grabMask, m_style->GetToolbarCornerRadius() );
<br>                        }
<br>                        sdc.DrawRoundedRectangle( upperLeft, barsize,
<br>                                m_style->GetToolbarCornerRadius() );
<br>                        upperLeft.x += m_style->GetTopMargin() + tool_size.x;
<br>                    } else {
<br>                        wxSize barsize( visibleSize.x, tool_size.y );
<br>
<br>                        if( i == 1 ) {
<br>                            barsize.x += m_style->GetIcon( _T("grabber") ).GetWidth();
<br>                        }
<br>                        if( i == lines && i > 1 ) {
<br>                            int toolsInLastLine = toolCount % m_ptoolbar->GetMaxCols();
<br>                            if( toolsInLastLine == 0 ) toolsInLastLine = m_ptoolbar->GetMaxCols();
<br>                            int emptySpace = ( m_ptoolbar->GetMaxCols() - toolsInLastLine );
<br>                            barsize.x -= emptySpace * ( tool_size.x + m_style->GetToolSeparation() );
<br>                        }
<br>
<br>                        sdc.DrawRoundedRectangle( upperLeft, barsize,
<br>                                m_style->GetToolbarCornerRadius() );
<br>                        upperLeft.y += m_style->GetTopMargin() + tool_size.y;
<br>                    }
<br>                }
<br>            } //b_overlap
<br>            else {
<br>                for( wxToolBarToolsList::compatibility_iterator node = m_ptoolbar->m_tools.GetFirst(); node; node = node->GetNext() ) {
<br>                    wxToolBarToolBase *tool = node->GetData();
<br>                    ocpnToolBarTool *tools = (ocpnToolBarTool *) tool;
<br>                    wxRect toolRect = tools->trect;
<br>
<br>                    sdc.DrawRoundedRectangle( tools->m_x, tools->m_y, tool_size.x, tool_size.y,
<br>                                              m_style->GetToolbarCornerRadius() );
<br>                }
<br>            }
<br>
<br>#ifndef __OCPN__ANDROID__
<br>            if(shape.GetWidth() && shape.GetHeight())
<br>                SetShape( wxRegion( shape, *wxWHITE, 10 ) );
<br>#endif
<br>        }
<br>    }
<br>}
<br>
<br>void ocpnFloatingToolbarDialog::OnToolLeftClick( wxCommandEvent& event )
<br>{
<br>    // First see if it was actually the context menu that was clicked.
<br>
<br>    if( event.GetId() >= ID_PLUGIN_BASE + 100 ) {
<br>
<br>        int itemId = event.GetId() - ID_PLUGIN_BASE - 100;
<br>        wxMenuItem *item = g_FloatingToolbarConfigMenu->FindItem( event.GetId() );
<br>
<br>        if(item){
<br>            bool toolIsChecked = item->IsChecked();
<br>
<br>            if( toolIsChecked ) {
<br>                g_toolbarConfig.SetChar( itemId, _T('X') );
<br>            } else {
<br>
<br>                if( itemId + ID_ZOOMIN == ID_MOB ) {
<br>                    ToolbarMOBDialog mdlg( this );
<br>                    int dialog_ret = mdlg.ShowModal();
<br>                    int answer = mdlg.GetSelection();
<br>
<br>                    if( answer == 0 || answer == 1 || dialog_ret == wxID_CANCEL ) {
<br>                        g_FloatingToolbarConfigMenu->FindItem( event.GetId() )->Check( true );
<br>                        if( answer == 1 && dialog_ret == wxID_OK ) {
<br>                            g_bPermanentMOBIcon = true;
<br>                            delete g_FloatingToolbarConfigMenu;
<br>                            g_FloatingToolbarConfigMenu = new wxMenu();
<br>                            toolbarConfigChanged = true;
<br>                        }
<br>                        return;
<br>                    }
<br>                }
<br>
<br>                if( m_ptoolbar->GetVisibleToolCount() == 1 ) {
<br>                    OCPNMessageBox( this,
<br>                            _("You can't hide the last tool from the toolbar\nas this would make it inaccessible."),
<br>                            _("OpenCPN Alert"), wxOK );
<br>                    g_FloatingToolbarConfigMenu->FindItem( event.GetId() )->Check( true );
<br>                    return;
<br>                }
<br>
<br>                g_toolbarConfig.SetChar( itemId, _T('.') );
<br>            }
<br>        }
<br>
<br>        toolbarConfigChanged = true;
<br>        return;
<br>    }
<br>
<br>    // No it was a button that was clicked.
<br>    // Since Dialog events don't propagate automatically, we send it explicitly
<br>    // (instead of relying on event.Skip()). Send events up the window hierarchy
<br>
<br>    m_pparent->GetEventHandler()->AddPendingEvent( event );
<br>#ifndef __WXQT__
<br>    gFrame->Raise();
<br>#endif    
<br>}
<br>
<br>ocpnToolBarSimple *ocpnFloatingToolbarDialog::GetToolbar()
<br>{
<br>    if( !m_ptoolbar ) {
<br>        long winstyle = wxNO_BORDER | wxTB_FLAT;
<br>        winstyle |= m_orient;
<br>
<br>        m_ptoolbar = new ocpnToolBarSimple( this, -1, wxPoint( -1, -1 ), wxSize( -1, -1 ),
<br>                winstyle );
<br>
<br>        m_ptoolbar->SetBackgroundColour( GetGlobalColor( _T("GREY2") ) );
<br>        m_ptoolbar->ClearBackground();
<br>        m_ptoolbar->SetToggledBackgroundColour( GetGlobalColor( _T("GREY1") ) );
<br>        m_ptoolbar->SetColorScheme( m_cs );
<br>
<br>        SetGeometry(false, wxRect());
<br>    }
<br>
<br>    return m_ptoolbar;
<br>}
<br>
<br>void ocpnFloatingToolbarDialog::DestroyToolBar()
<br>{
<br>    if( m_ptoolbar ) {
<br>        m_ptoolbar->ClearTools();
<br>        delete m_ptoolbar;                  //->Destroy();
<br>        m_ptoolbar = NULL;
<br>    }
<br> 
<br>    m_destroyGrabber = m_pRecoverwin;
<br>    m_destroyTimer.Start( 5, wxTIMER_ONE_SHOT );           //  Destor the unneeded recovery grabber
<br>    
<br>}
<br>
<br>//----------------------------------------------------------------------------
<br>// Toolbar Tooltip Popup Window Definition
<br>//----------------------------------------------------------------------------
<br>class ToolTipWin: public wxDialog {
<br>public:
<br>    ToolTipWin( wxWindow *parent );
<br>    ~ToolTipWin();
<br>
<br>    void OnPaint( wxPaintEvent& event );
<br>
<br>    void SetColorScheme( ColorScheme cs );
<br>    void SetString( wxString &s )
<br>    {
<br>        m_string = s;
<br>    }
<br>    void SetPosition( wxPoint pt )
<br>    {
<br>        m_position = pt;
<br>    }
<br>    void SetBitmap( void );
<br>
<br>    void SetHiviz( bool hiviz){ m_hiviz = hiviz; }
<br>    
<br>    wxSize GetRenderedSize( void );
<br>    
<br>private:
<br>
<br>    wxString m_string;
<br>    wxSize m_size;
<br>    wxPoint m_position;
<br>    wxBitmap *m_pbm;
<br>    wxColour m_back_color;
<br>    wxColour m_text_color;
<br>    ColorScheme m_cs ;
<br>    bool m_hiviz;
<br>
<br>DECLARE_EVENT_TABLE()
<br>};
<br>//-----------------------------------------------------------------------
<br>//
<br>//    Toolbar Tooltip window implementation
<br>//
<br>//-----------------------------------------------------------------------
<br>BEGIN_EVENT_TABLE(ToolTipWin, wxDialog) EVT_PAINT(ToolTipWin::OnPaint)
<br>
<br>END_EVENT_TABLE()
<br>
<br>// Define a constructor
<br>ToolTipWin::ToolTipWin( wxWindow *parent ) :
<br>        wxDialog( parent, wxID_ANY, _T(""), wxPoint( 0, 0 ), wxSize( 1, 1 ),
<br>                wxNO_BORDER | wxSTAY_ON_TOP )
<br>{
<br>    m_pbm = NULL;
<br>
<br>    m_back_color = GetGlobalColor( _T ( "UIBCK" ) );
<br>    m_text_color = GetGlobalColor( _T ( "UITX1" ) );
<br>
<br>    SetBackgroundStyle( wxBG_STYLE_CUSTOM );
<br>    SetBackgroundColour( m_back_color );
<br>    m_cs = GLOBAL_COLOR_SCHEME_RGB;
<br>
<br>    Hide();
<br>}
<br>
<br>ToolTipWin::~ToolTipWin()
<br>{
<br>    delete m_pbm;
<br>}
<br>
<br>void ToolTipWin::SetColorScheme( ColorScheme cs )
<br>{
<br>    m_back_color = GetGlobalColor( _T ( "UIBCK" ) );
<br>    m_text_color = FontMgr::Get().GetFontColor( _("ToolTips") );
<br>
<br>    m_cs = cs;
<br>}
<br>
<br>wxSize ToolTipWin::GetRenderedSize( void )
<br>{
<br>    int h, w;
<br>    wxSize sz;
<br>
<br>    wxClientDC cdc( GetParent() );
<br>
<br>    wxFont *plabelFont = FontMgr::Get().GetFont( _("ToolTips") );
<br>    cdc.GetTextExtent( m_string, &w, &h, NULL, NULL, plabelFont );
<br>
<br>    sz.x = w + 8;
<br>    sz.y = h + 4;
<br>    
<br>    return sz;
<br>
<br>}
<br>
<br>void ToolTipWin::SetBitmap()
<br>{
<br>    int h, w;
<br>
<br>    wxClientDC cdc( GetParent() );
<br>
<br>    wxFont *plabelFont = FontMgr::Get().GetFont( _("ToolTips") );
<br>    cdc.GetTextExtent( m_string, &w, &h, NULL, NULL, plabelFont );
<br>
<br>    m_size.x = w + 8;
<br>    m_size.y = h + 4;
<br>
<br>    wxMemoryDC mdc;
<br>
<br>    delete m_pbm;
<br>    m_pbm = new wxBitmap( m_size.x, m_size.y, -1 );
<br>    mdc.SelectObject( *m_pbm );
<br>
<br>    wxPen pborder( m_text_color );
<br>    wxBrush bback( m_back_color );
<br>    mdc.SetPen( pborder );
<br>    mdc.SetBrush( bback );
<br>
<br>    if(m_hiviz){
<br>        if((m_cs == GLOBAL_COLOR_SCHEME_DUSK) || (m_cs == GLOBAL_COLOR_SCHEME_NIGHT)){
<br>            wxBrush hv_back( wxColour(200,200,200));
<br>            mdc.SetBrush( hv_back );
<br>        }
<br>    }
<br>    mdc.DrawRectangle( 0, 0, m_size.x, m_size.y );
<br>
<br>    //    Draw the text
<br>    mdc.SetFont( *plabelFont );
<br>    mdc.SetTextForeground( m_text_color );
<br>    mdc.SetTextBackground( m_back_color );
<br>
<br>    mdc.DrawText( m_string, 4, 2 );
<br>
<br>    SetSize( m_position.x, m_position.y, m_size.x, m_size.y );
<br>
<br>}
<br>
<br>void ToolTipWin::OnPaint( wxPaintEvent& event )
<br>{
<br>    int width, height;
<br>    GetClientSize( &width, &height );
<br>    wxPaintDC dc( this );
<br>
<br>    if( m_string.Len() ) {
<br>        wxMemoryDC mdc;
<br>        mdc.SelectObject( *m_pbm );
<br>        dc.Blit( 0, 0, width, height, &mdc, 0, 0 );
<br>    }
<br>}
<br>
<br>
<br>// ----------------------------------------------------------------------------
<br>BEGIN_EVENT_TABLE(ocpnToolBarSimple, wxControl) EVT_SIZE(ocpnToolBarSimple::OnSize)
<br>EVT_PAINT(ocpnToolBarSimple::OnPaint)
<br>EVT_KILL_FOCUS(ocpnToolBarSimple::OnKillFocus)
<br>EVT_MOUSE_EVENTS(ocpnToolBarSimple::OnMouseEvent)
<br>EVT_TIMER(TOOLTIPON_TIMER, ocpnToolBarSimple::OnToolTipTimerEvent)
<br>EVT_TIMER(TOOLTIPOFF_TIMER, ocpnToolBarSimple::OnToolTipOffTimerEvent)
<br>
<br>END_EVENT_TABLE()
<br>
<br>// ============================================================================
<br>// implementation
<br>// ============================================================================
<br>
<br>// ----------------------------------------------------------------------------
<br>// tool bar tools creation
<br>// ----------------------------------------------------------------------------
<br>
<br>wxToolBarToolBase *ocpnToolBarSimple::CreateTool( int id, const wxString& label,
<br>        const wxBitmap& bmpNormal, const wxBitmap& bmpDisabled, wxItemKind kind,
<br>        wxObject *clientData, const wxString& shortHelp, const wxString& longHelp )
<br>{
<br>    return new ocpnToolBarTool( this, id, label, bmpNormal, bmpDisabled, kind, clientData,
<br>            shortHelp, longHelp );
<br>}
<br>
<br>// ----------------------------------------------------------------------------
<br>// ocpnToolBarSimple creation
<br>// ----------------------------------------------------------------------------
<br>
<br>void ocpnToolBarSimple::Init()
<br>{
<br>    m_currentRowsOrColumns = 0;
<br>
<br>    m_lastX = m_lastY = 0;
<br>
<br>    m_maxWidth = m_maxHeight = 0;
<br>
<br>    m_pressedTool = m_currentTool = -1;
<br>
<br>    m_xPos = m_yPos = wxDefaultCoord;
<br>
<br>    m_style = g_StyleManager->GetCurrentStyle();
<br>
<br>    m_defaultWidth = 16;
<br>    m_defaultHeight = 15;
<br>
<br>    m_toggle_bg_color = wxSystemSettings::GetColour( wxSYS_COLOUR_3DFACE );
<br>    m_toolOutlineColour.Set( _T("BLACK") );
<br>    m_pToolTipWin = NULL;
<br>    m_last_ro_tool = NULL;
<br>
<br>    m_btoolbar_is_zooming = false;
<br>    m_sizefactor = 1.0f;
<br>
<br>    m_last_plugin_down_id = -1;
<br>    
<br>    EnableTooltips();
<br>}
<br>
<br>wxToolBarToolBase *ocpnToolBarSimple::DoAddTool( int id, const wxString& label,
<br>        const wxBitmap& bitmap, const wxBitmap& bmpDisabled, wxItemKind kind,
<br>        const wxString& shortHelp, const wxString& longHelp, wxObject *clientData, wxCoord xPos,
<br>        wxCoord yPos )
<br>{
<br>    // rememeber the position for DoInsertTool()
<br>    m_xPos = xPos;
<br>    m_yPos = yPos;
<br>
<br>    InvalidateBestSize();
<br>    return InsertTool( GetToolsCount(), id, label, bitmap, bmpDisabled, kind, shortHelp, longHelp,
<br>            clientData );
<br>
<br>}
<br>
<br>///
<br>
<br>wxToolBarToolBase *ocpnToolBarSimple::AddTool( int toolid, const wxString& label,
<br>        const wxBitmap& bitmap, const wxBitmap& bmpDisabled, wxItemKind kind,
<br>        const wxString& shortHelp, const wxString& longHelp, wxObject *data )
<br>{
<br>    InvalidateBestSize();
<br>    ocpnToolBarTool* tool = (ocpnToolBarTool*)InsertTool( GetToolsCount(), toolid, label, bitmap, bmpDisabled, kind,
<br>            shortHelp, longHelp, data );
<br>    return tool;
<br>}
<br>
<br>wxToolBarToolBase *ocpnToolBarSimple::InsertTool( size_t pos, int id, const wxString& label,
<br>        const wxBitmap& bitmap, const wxBitmap& bmpDisabled, wxItemKind kind,
<br>        const wxString& shortHelp, const wxString& longHelp, wxObject *clientData )
<br>{
<br>    wxCHECK_MSG( pos <= GetToolsCount(), (wxToolBarToolBase *)NULL,
<br>            _T("invalid position in wxToolBar::InsertTool()") );
<br>
<br>    wxToolBarToolBase *tool = CreateTool( id, label, bitmap, bmpDisabled, kind, clientData,
<br>            shortHelp, longHelp );
<br>
<br>    if( !InsertTool( pos, tool ) ) {
<br>        delete tool;
<br>
<br>        return NULL;
<br>    }
<br>
<br>    return tool;
<br>}
<br>
<br>wxToolBarToolBase *ocpnToolBarSimple::InsertTool( size_t pos, wxToolBarToolBase *tool )
<br>{
<br>    wxCHECK_MSG( pos <= GetToolsCount(), (wxToolBarToolBase *)NULL,
<br>            _T("invalid position in wxToolBar::InsertTool()") );
<br>
<br>    if( !tool || !DoInsertTool( pos, tool ) ) {
<br>        return NULL;
<br>    }
<br>
<br>    m_tools.Insert( pos, tool );
<br>
<br>    return tool;
<br>}
<br>
<br>bool ocpnToolBarSimple::DoInsertTool( size_t WXUNUSED(pos), wxToolBarToolBase *toolBase )
<br>{
<br>    ocpnToolBarTool *tool = (ocpnToolBarTool *) toolBase;
<br>
<br>    // Check if the plugin is inserting same-named tools. Make sure they have different names,
<br>    // otherwise the style manager cannot differentiate between them.
<br>    if( tool->isPluginTool ) {
<br>        for( unsigned int i=0; i<GetToolsCount(); i++ ) {
<br>            if( tool->GetToolname() == ((ocpnToolBarTool *)m_tools.Item(i)->GetData())->GetToolname()) {
<br>                tool->toolname << _T("1");
<br>            }
<br>        }
<br>    }
<br>
<br>    tool->m_x = m_xPos;
<br>    if( tool->m_x == wxDefaultCoord ) tool->m_x = m_style->GetLeftMargin();
<br>
<br>    tool->m_y = m_yPos;
<br>    if( tool->m_y == wxDefaultCoord ) tool->m_y = m_style->GetTopMargin();
<br>
<br>    if( tool->IsButton() ) {
<br>        tool->SetSize( GetToolSize() );
<br>
<br>        // Calculate reasonable max size in case Layout() not called
<br>        if( ( tool->m_x + tool->GetNormalBitmap().GetWidth() + m_style->GetLeftMargin() )
<br>                > m_maxWidth ) m_maxWidth = (wxCoord) ( ( tool->m_x + tool->GetWidth()
<br>                + m_style->GetLeftMargin() ) );
<br>
<br>        if( ( tool->m_y + tool->GetNormalBitmap().GetHeight() + m_style->GetTopMargin() )
<br>                > m_maxHeight ) m_maxHeight = (wxCoord) ( ( tool->m_y + tool->GetHeight()
<br>                + m_style->GetTopMargin() ) );
<br>    }
<br>
<br>    else
<br>        if( tool->IsControl() ) {
<br>            tool->SetSize( tool->GetControl()->GetSize() );
<br>        }
<br>
<br>    tool->b_hilite = false;
<br>
<br>    return true;
<br>}
<br>
<br>bool ocpnToolBarSimple::DoDeleteTool( size_t WXUNUSED(pos), wxToolBarToolBase *tool )
<br>{
<br>    // VZ: didn't test whether it works, but why not...
<br>    tool->Detach();
<br>
<br>    if( m_last_ro_tool == tool ) m_last_ro_tool = NULL;
<br>
<br>    Refresh( false );
<br>
<br>    return true;
<br>}
<br>
<br>bool ocpnToolBarSimple::Create( wxWindow *parent, wxWindowID id, const wxPoint& pos,
<br>        const wxSize& size, long style, const wxString& name )
<br>{
<br>    if( !wxWindow::Create( parent, id, pos, size, style, name ) ) return false;
<br>
<br>    // Set it to grey (or other 3D face colour)
<br>    SetBackgroundColour( wxSystemSettings::GetColour( wxSYS_COLOUR_3DFACE ) );
<br>
<br>    if( GetWindowStyleFlag() & wxTB_VERTICAL ) {
<br>        m_lastX = 7;
<br>        m_lastY = 3;
<br>
<br>        m_maxRows = 32000;      // a lot
<br>        m_maxCols = 1;
<br>    } else {
<br>        m_lastX = 3;
<br>        m_lastY = 7;
<br>
<br>        m_maxRows = 1;
<br>        m_maxCols = 32000;      // a lot
<br>    }
<br>
<br>    SetCursor( *wxSTANDARD_CURSOR );
<br>
<br>    m_tooltip_timer.SetOwner( this, TOOLTIPON_TIMER );
<br>    m_tooltipoff_timer.SetOwner( this, TOOLTIPOFF_TIMER );
<br>    m_tooltip_off = 3000;
<br>
<br>    return true;
<br>}
<br>
<br>ocpnToolBarSimple::~ocpnToolBarSimple()
<br>{
<br>    if( m_pToolTipWin ) {
<br>        m_pToolTipWin->Destroy();
<br>        m_pToolTipWin = NULL;
<br>    }
<br>
<br>}
<br>
<br>void ocpnToolBarSimple::KillTooltip()
<br>{
<br>    m_btooltip_show = false;
<br>
<br>    if( m_pToolTipWin ) {
<br>        m_pToolTipWin->Hide();
<br>        m_pToolTipWin->Destroy();
<br>        m_pToolTipWin = NULL;
<br>    }
<br>    m_tooltip_timer.Stop();
<br>
<br>    if( m_last_ro_tool ) {
<br>        if( m_last_ro_tool->IsEnabled() ) {
<br>            if( m_last_ro_tool->IsToggled() ) {
<br>                m_last_ro_tool->SetNormalBitmap( m_style->GetToolIcon( m_last_ro_tool->GetToolname(), TOOLICON_TOGGLED ) );
<br>            }
<br>            else {
<br>                m_last_ro_tool->SetNormalBitmap( m_style->GetToolIcon( m_last_ro_tool->GetToolname(), TOOLICON_NORMAL ) );
<br>            }
<br>        }
<br>    }
<br>}
<br>
<br>void ocpnToolBarSimple::HideTooltip()
<br>{
<br>    if( m_pToolTipWin ) {
<br>        m_pToolTipWin->Hide();
<br>    }
<br>}
<br>
<br>void ocpnToolBarSimple::SetColorScheme( ColorScheme cs )
<br>{
<br>    if( m_pToolTipWin ) {
<br>        m_pToolTipWin->Destroy();
<br>        m_pToolTipWin = NULL;
<br>    }
<br>
<br>    m_toolOutlineColour = GetGlobalColor( _T("UIBDR") );
<br>
<br>    m_currentColorScheme = cs;
<br>}
<br>
<br>bool ocpnToolBarSimple::Realize()
<br>{
<br>    m_currentRowsOrColumns = 0;
<br>    m_LineCount = 1;
<br>    m_lastX = m_style->GetLeftMargin();
<br>    m_lastY = m_style->GetTopMargin();
<br>    m_maxWidth = 0;
<br>    m_maxHeight = 0;
<br>
<br>    if( IsVertical() ) m_style->SetOrientation( wxTB_VERTICAL );
<br>    else
<br>        m_style->SetOrientation( wxTB_HORIZONTAL );
<br>
<br>    wxSize toolSize = wxSize(-1, -1);
<br>    int separatorSize = m_style->GetToolSeparation();
<br>
<br>    ocpnToolBarTool *lastTool = NULL;
<br>    bool firstNode = true;
<br>    wxToolBarToolsList::compatibility_iterator node = m_tools.GetFirst();
<br>
<br>    while( node ) {
<br>        ocpnToolBarTool *tool = (ocpnToolBarTool *) node->GetData();
<br>
<br>        // Set the tool size to be the size of the first non-separator tool, usually the first one
<br>        if(toolSize.x == -1){
<br>            if( !tool->IsSeparator() ){
<br>                toolSize.x = tool->m_width;
<br>                toolSize.y = tool->m_height;
<br>            }
<br>        }
<br>
<br>        tool->firstInLine = firstNode;
<br>        tool->lastInLine = false;
<br>        firstNode = false;
<br>
<br>        tool->last_rect.width = 0;              // mark it invalid
<br>        
<br>        if( tool->IsSeparator() ) {
<br>            if( GetWindowStyleFlag() & wxTB_HORIZONTAL ) {
<br>                if( m_currentRowsOrColumns >= m_maxCols ) m_lastY += separatorSize;
<br>                else
<br>                    m_lastX += separatorSize;
<br>            } else {
<br>                if( m_currentRowsOrColumns >= m_maxRows ) m_lastX += separatorSize;
<br>                else
<br>                    m_lastY += separatorSize;
<br>            }
<br>        } else
<br>            if( tool->IsButton() ) {
<br>                if( !IsVertical() ) {
<br>                    if( m_currentRowsOrColumns >= m_maxCols ) {
<br>                        tool->firstInLine = true;
<br>                        if( lastTool && m_LineCount > 1 ) lastTool->lastInLine = true;
<br>                        m_LineCount++;
<br>                        m_currentRowsOrColumns = 0;
<br>                        m_lastX = m_style->GetLeftMargin();
<br>                        m_lastY += toolSize.y + m_style->GetTopMargin();
<br>                    }
<br>                    tool->m_x = (wxCoord) m_lastX;
<br>                    tool->m_y = (wxCoord) m_lastY;
<br>
<br>                    tool->trect = wxRect( tool->m_x, tool->m_y, toolSize.x, toolSize.y );
<br>                    tool->trect.Inflate( m_style->GetToolSeparation() / 2,
<br>                            m_style->GetTopMargin() );
<br>
<br>                    m_lastX += toolSize.x + m_style->GetToolSeparation();
<br>                } else {
<br>                    if( m_currentRowsOrColumns >= m_maxRows ) {
<br>                        tool->firstInLine = true;
<br>                        if( lastTool ) lastTool->lastInLine = true;
<br>                        m_LineCount++;
<br>                        m_currentRowsOrColumns = 0;
<br>                        m_lastX += toolSize.x + m_style->GetTopMargin();
<br>                        m_lastY = m_style->GetTopMargin();
<br>                    }
<br>                    tool->m_x = (wxCoord) m_lastX;
<br>                    tool->m_y = (wxCoord) m_lastY;
<br>
<br>                    tool->trect = wxRect( tool->m_x, tool->m_y, toolSize.x, toolSize.y );
<br>                    tool->trect.Inflate( m_style->GetToolSeparation() / 2,
<br>                            m_style->GetTopMargin() );
<br>
<br>                    m_lastY += toolSize.y + m_style->GetToolSeparation();
<br>                }
<br>                m_currentRowsOrColumns++;
<br>            } else
<br>                if( tool->IsControl() ) {
<br>                    tool->m_x = (wxCoord) ( m_lastX );
<br>                    tool->m_y = (wxCoord) ( m_lastY - ( m_style->GetTopMargin() / 2 ) );
<br>
<br>                    tool->trect = wxRect( tool->m_x, tool->m_y, tool->GetWidth(),
<br>                            tool->GetHeight() );
<br>                    tool->trect.Inflate( m_style->GetToolSeparation() / 2,
<br>                            m_style->GetTopMargin() );
<br>                    ;
<br>
<br>                    wxSize s = tool->GetControl()->GetSize();
<br>                    m_lastX += s.x + m_style->GetToolSeparation();
<br>
<br>                }
<br>
<br>        if( m_lastX > m_maxWidth ) m_maxWidth = m_lastX;
<br>        if( m_lastY > m_maxHeight ) m_maxHeight = m_lastY;
<br>
<br>        lastTool = tool;
<br>        node = node->GetNext();
<br>    }
<br>    if( lastTool && (m_LineCount > 1 || IsVertical()) )
<br>        lastTool->lastInLine = true;
<br>
<br>    if( GetWindowStyleFlag() & wxTB_HORIZONTAL ) m_maxHeight += toolSize.y;
<br>    else
<br>        m_maxWidth += toolSize.x;
<br>
<br>    m_maxWidth += m_style->GetRightMargin();
<br>    m_maxHeight += m_style->GetBottomMargin();
<br>
<br>    SetSize( m_maxWidth, m_maxHeight );
<br>    SetMinSize( wxSize( m_maxWidth, m_maxHeight ) );
<br>
<br>    return true;
<br>}
<br>
<br>// ----------------------------------------------------------------------------
<br>// event handlers
<br>// ----------------------------------------------------------------------------
<br>
<br>void ocpnToolBarSimple::OnPaint( wxPaintEvent& WXUNUSED(event) )
<br>{
<br>    wxPaintDC dc( this );
<br>    PrepareDC( dc );
<br>
<br>    wxRegion ru = GetUpdateRegion();
<br>    wxRect upRect = ru.GetBox();
<br>
<br>    static int count = 0;
<br>    // Prevent reentry of OnPaint which would cause wxMemoryDC errors.
<br>    if( count > 0 ) return;
<br>    count++;
<br>
<br>    for( wxToolBarToolsList::compatibility_iterator node = m_tools.GetFirst(); node;
<br>            node = node->GetNext() ) {
<br>        wxToolBarToolBase *tool = node->GetData();
<br>        ocpnToolBarTool *tools = (ocpnToolBarTool *) tool;
<br>        wxRect toolRect = tools->trect;
<br>
<br>        if( toolRect.Intersects( upRect ) ) {
<br>
<br>            if( tool->IsButton() ) {
<br>                DrawTool( dc, tool );
<br>            } else
<br>                if( tool->IsControl() ) {
<br>                    if( tool->GetControl()->IsKindOf( CLASSINFO(wxStaticBitmap) ) ) {
<br>                        wxStaticBitmap *psbm = (wxStaticBitmap *) tool->GetControl();
<br>                        ocpnToolBarTool *toolsimp = (ocpnToolBarTool *) tool;
<br>                        dc.DrawBitmap( psbm->GetBitmap(), toolsimp->m_x, toolsimp->m_y, false );
<br>                    }
<br>                }
<br>        }
<br>    }
<br>
<br>    count--;
<br>}
<br>
<br>void ocpnToolBarSimple::OnSize( wxSizeEvent& WXUNUSED(event) )
<br>{
<br>    if( GetAutoLayout() ) Layout();
<br>}
<br>
<br>void ocpnToolBarSimple::OnKillFocus( wxFocusEvent& WXUNUSED(event) )
<br>{
<br>    OnMouseEnter( m_pressedTool = m_currentTool = -1 );
<br>}
<br>
<br>void ocpnToolBarSimple::OnToolTipTimerEvent( wxTimerEvent& event )
<br>{
<br>    if( !gFrame->IsActive() ) return;
<br>
<br>    if( m_btooltip_show && IsShown() && m_pToolTipWin && ( !m_pToolTipWin->IsShown() ) ) {
<br>        if( m_last_ro_tool ) {
<br>            wxString s = m_last_ro_tool->GetShortHelp();
<br>
<br>            if( s.Len() ) {
<br>                m_pToolTipWin->SetString( s );
<br>                m_pToolTipWin->SetHiviz(m_last_ro_tool->m_btooltip_hiviz);
<br>
<br>                wxPoint pos_in_toolbar( m_last_ro_tool->m_x, m_last_ro_tool->m_y );
<br>                pos_in_toolbar.x += m_last_ro_tool->m_width + 2;
<br>
<br>                m_pToolTipWin->Move(0,0);       // workaround for gtk autocentre dialog behavior
<br>
<br>                wxPoint screenPosition = ClientToScreen( pos_in_toolbar );
<br>                wxPoint framePosition = gFrame->ScreenToClient(screenPosition);
<br>                wxSize tipSize = m_pToolTipWin->GetRenderedSize();
<br>                
<br>                if( (framePosition.x + tipSize.x) > gFrame->GetSize().x)
<br>                    screenPosition.x -= (tipSize.x + m_last_ro_tool->m_width + 4);
<br>                
<br>                m_pToolTipWin->SetPosition( screenPosition );
<br>                m_pToolTipWin->SetBitmap();
<br>                m_pToolTipWin->Show();
<br>                gFrame->Raise();
<br>                if( g_btouch )
<br>                    m_tooltipoff_timer.Start(m_tooltip_off, wxTIMER_ONE_SHOT);
<br>            }
<br>        }
<br>    }
<br>}
<br>
<br>void ocpnToolBarSimple::OnToolTipOffTimerEvent( wxTimerEvent& event )
<br>{
<br>    HideTooltip();
<br>}
<br>
<br>
<br>int s_dragx, s_dragy;
<br>
<br>void ocpnToolBarSimple::OnMouseEvent( wxMouseEvent & event )
<br>{
<br>#ifdef __OCPN__ANDROID__
<br>    if(!event.IsButton())
<br>        return;
<br>#endif
<br>
<br>    wxCoord x, y;
<br>    event.GetPosition( &x, &y );
<br>    ocpnToolBarTool *tool = (ocpnToolBarTool *) FindToolForPosition( x, y );
<br>
<br>#ifndef __OCPN__ANDROID__
<br>    if( event.LeftDown() ) {
<br>        CaptureMouse();
<br>        s_dragx = x;
<br>        s_dragy = y;
<br>    }
<br>    if( event.LeftUp() ) {
<br>        if( HasCapture() ) ReleaseMouse();
<br>    }
<br>#endif
<br>
<br>    if( tool && tool->IsButton() && IsShown() ) {
<br>
<br>        //    ToolTips
<br>        if( NULL == m_pToolTipWin ) {
<br>            m_pToolTipWin = new ToolTipWin( GetParent() );
<br>            m_pToolTipWin->SetColorScheme( m_currentColorScheme );
<br>            m_pToolTipWin->Hide();
<br>        }
<br>
<br>        if( tool != m_last_ro_tool ) m_pToolTipWin->Hide();
<br>
<br>#ifndef __OCPN__ANDROID__
<br>        if( !m_pToolTipWin->IsShown() ) {
<br>            m_tooltip_timer.Start( m_one_shot, wxTIMER_ONE_SHOT );
<br>        }
<br>#endif
<br>
<br>        //    Tool Rollover highlighting
<br>        if(!g_btouch){
<br>            if( tool != m_last_ro_tool ) {
<br>                if( tool->IsEnabled() ) {
<br>                    tool->rollover = true;
<br>                    tool->bitmapOK = false;
<br>                }
<br>                if( m_last_ro_tool ) {
<br>                    if( m_last_ro_tool->IsEnabled() ) {
<br>                        m_last_ro_tool->rollover = false;
<br>                        m_last_ro_tool->bitmapOK = false;
<br>                    }
<br>                }
<br>                m_last_ro_tool = tool;
<br>                if(g_toolbar)
<br>                    g_toolbar->Refresh( false );
<br>            }
<br>        }
<br>    } else {
<br>        //    Tooltips
<br>        if( m_pToolTipWin && m_pToolTipWin->IsShown() ) m_pToolTipWin->Hide();
<br>
<br>        //    Remove Highlighting
<br>        if( m_last_ro_tool ) {
<br>            if( m_last_ro_tool->IsEnabled() ) {
<br>                m_last_ro_tool->rollover = false;
<br>                m_last_ro_tool->bitmapOK = false;
<br>            }
<br>            g_toolbar->Refresh( false );
<br>        }
<br>    }
<br>
<br>    m_last_ro_tool = tool;
<br>
<br>    // allow smooth zooming while toolbutton is held down
<br>    if(g_bsmoothpanzoom && !g_btouch) {
<br>        if(event.LeftUp() && m_btoolbar_is_zooming) {
<br>            cc1->StopMovement();
<br>            m_btoolbar_is_zooming = false;
<br>            return;
<br>        }
<br>
<br>        if( event.LeftDown() && tool &&
<br>            (tool->GetId() == ID_ZOOMIN || tool->GetId() == ID_ZOOMOUT) ) {
<br>            cc1->ZoomCanvas( tool->GetId() == ID_ZOOMIN ? 2.0 : .5, false, false );
<br>            m_btoolbar_is_zooming = true;
<br>            return;
<br>        }
<br>    }
<br>
<br>    if( !tool ) {
<br>        if( m_currentTool > -1 ) {
<br>            if( event.LeftIsDown() ) SpringUpButton( m_currentTool );
<br>            m_currentTool = -1;
<br>            OnMouseEnter( -1 );
<br>        }
<br>
<br>        wxMouseEvent *pev = (wxMouseEvent *) event.Clone();
<br>        GetParent()->GetEventHandler()->AddPendingEvent( *pev );
<br>        wxDELETE( pev );
<br>
<br>        return;
<br>    }
<br>
<br>    if( !event.IsButton() ) {
<br>        if( tool->GetId() != m_currentTool ) {
<br>            // If the left button is kept down and moved over buttons,
<br>            // press those buttons.
<br>            if( event.LeftIsDown() && tool->IsEnabled() ) {
<br>                SpringUpButton( m_currentTool );
<br>
<br>                if( tool->CanBeToggled() ) {
<br>                    tool->Toggle();
<br>                }
<br>
<br>                DrawTool( tool );
<br>            }
<br>
<br>            m_currentTool = tool->GetId();
<br>            OnMouseEnter( m_currentTool );
<br>        }
<br>
<br>        wxMouseEvent *pev = (wxMouseEvent *) event.Clone();
<br>        GetParent()->GetEventHandler()->AddPendingEvent( *pev );
<br>        wxDELETE( pev );
<br>
<br>        return;
<br>    }
<br>
<br>    // Left button pressed.
<br>    if( event.LeftDown() && tool->IsEnabled() ) {
<br>        if( tool->CanBeToggled() ) {
<br>            tool->Toggle();
<br>            tool->bitmapOK = false;
<br>            
<br>        }
<br>
<br>        DrawTool( tool );
<br>
<br>        //        Look for PlugIn tools
<br>        //        If found, make the callback.
<br>        if( g_pi_manager ) {
<br>            ArrayOfPlugInToolbarTools tool_array = g_pi_manager->GetPluginToolbarToolArray();
<br>            for( unsigned int i = 0; i < tool_array.GetCount(); i++ ) {
<br>                PlugInToolbarToolContainer *pttc = tool_array.Item( i );
<br>                if( tool->GetId() == pttc->id ) {
<br>                    opencpn_plugin_113 *ppi = dynamic_cast<opencpn_plugin_113 *>(pttc->m_pplugin);
<br>                    if( ppi ) {
<br>                        ppi->OnToolbarToolDownCallback( pttc->id );
<br>                        m_last_plugin_down_id = pttc->id;
<br>                    }
<br>                }
<br>            }
<br>        }
<br>    } else
<br>        if( event.RightDown() ) {
<br>            OnRightClick( tool->GetId(), x, y );
<br>        }
<br>
<br>    // Left Button Released.  Only this action confirms selection.
<br>    // If the button is enabled and it is not a toggle tool and it is
<br>    // in the pressed state, then raise the button and call OnLeftClick.
<br>    //
<br>    if( event.LeftUp() && tool->IsEnabled() ) {
<br>        // Pass the OnLeftClick event to tool
<br>        if( !OnLeftClick( tool->GetId(), tool->IsToggled() ) && tool->CanBeToggled() ) {
<br>            // If it was a toggle, and OnLeftClick says No Toggle allowed,
<br>            // then change it back
<br>            tool->Toggle();
<br>            tool->bitmapOK = false;
<br>        }
<br>
<br>        DoPluginToolUp();
<br>    }
<br>
<br>    wxMouseEvent *pev = (wxMouseEvent *) event.Clone();
<br>    GetParent()->GetEventHandler()->AddPendingEvent( *pev );
<br>    wxDELETE( pev );
<br>    event.Skip();
<br>}
<br>
<br>// ----------------------------------------------------------------------------
<br>// drawing
<br>// ----------------------------------------------------------------------------
<br>
<br>void ocpnToolBarSimple::DrawTool( wxToolBarToolBase *tool )
<br>{
<br>    wxClientDC dc( this );
<br>    DrawTool( dc, tool );
<br>}
<br>
<br>// NB! The current DrawTool code assumes that plugin tools are never disabled
<br>// when they are present on the toolbar, since disabled plugins are removed.
<br>
<br>void ocpnToolBarSimple::DrawTool( wxDC& dc, wxToolBarToolBase *toolBase )
<br>{
<br>    ocpnToolBarTool *tool = (ocpnToolBarTool *) toolBase;
<br>    PrepareDC( dc );
<br>
<br>    wxPoint drawAt( tool->m_x, tool->m_y );
<br>    wxBitmap bmp;
<br>
<br>    if( tool->bitmapOK ) {
<br>        if( tool->IsEnabled() ) {
<br>            bmp = tool->GetNormalBitmap();
<br>            if( !bmp.IsOk() ){
<br>                bmp = m_style->GetToolIcon( tool->GetToolname(), TOOLICON_NORMAL, tool->rollover );
<br>                if(m_sizefactor > 1.0 ){
<br><mark>                    wxImage scaled_image = bmp.ConvertToImage();
</mark><br><mark>                    bmp = wxBitmap(scaled_image.Scale(tool->m_width, tool->m_height, wxIMAGE_QUALITY_HIGH));
</mark><br>                }
<br>                tool->SetNormalBitmap( bmp );
<br>                tool->bitmapOK = true;
<br>            }
<br>        } else {
<br>            bmp = tool->GetDisabledBitmap();
<br>            if( !bmp.IsOk() ){
<br>                bmp = m_style->GetToolIcon( tool->GetToolname(), TOOLICON_DISABLED );
<br>                if(m_sizefactor > 1.0 ){
<br><mark>                    wxImage scaled_image = bmp.ConvertToImage();
</mark><br><mark>                    bmp = wxBitmap(scaled_image.Scale(tool->m_width, tool->m_height, wxIMAGE_QUALITY_HIGH));
</mark><br>                }
<br>                tool->SetDisabledBitmap( bmp );
<br>                tool->bitmapOK = true;
<br>            }
<br>        }
<br>    } else {
<br>        if ( tool->isPluginTool ) {
<br>
<br>            // First try getting the icon from the Style.
<br>            // If it is not in the style we build a new icon from the style BG and the plugin icon.
<br>
<br>            if( tool->IsToggled() ) {
<br>                bmp = m_style->GetToolIcon( tool->GetToolname(), TOOLICON_TOGGLED, tool->rollover );
<br>                if( bmp.GetDepth() == 1 ) {
<br>                    if( tool->rollover ) {
<br>                        bmp = m_style->BuildPluginIcon( tool->pluginRolloverIcon, TOOLICON_TOGGLED );
<br>                        if( ! bmp.IsOk() )
<br>                            bmp = m_style->BuildPluginIcon( tool->pluginNormalIcon, TOOLICON_TOGGLED );
<br>                    }
<br>                    else
<br>                        bmp = m_style->BuildPluginIcon( tool->pluginNormalIcon, TOOLICON_TOGGLED );
<br>                }
<br>            } else {
<br>                bmp = m_style->GetToolIcon( tool->GetToolname(), TOOLICON_NORMAL, tool->rollover );
<br>                if( bmp.GetDepth() == 1 ) {
<br>                    if( tool->rollover ) {
<br>                        bmp = m_style->BuildPluginIcon( tool->pluginRolloverIcon, TOOLICON_NORMAL );
<br>                        if( ! bmp.IsOk() )
<br>                            bmp = m_style->BuildPluginIcon( tool->pluginNormalIcon, TOOLICON_NORMAL );
<br>                    }
<br>                    else
<br>                        bmp = m_style->BuildPluginIcon( tool->pluginNormalIcon, TOOLICON_NORMAL );
<br>                }
<br>            }
<br>            if(m_sizefactor > 1.0 ){
<br><mark>                wxImage scaled_image = bmp.ConvertToImage();
</mark><br><mark>                bmp = wxBitmap(scaled_image.Scale(tool->m_width, tool->m_height, wxIMAGE_QUALITY_HIGH));
</mark><br>            }
<br>            tool->SetNormalBitmap( bmp );
<br>            tool->bitmapOK = true;
<br>        } else {
<br>            if( tool->IsEnabled() ) {
<br>                if( tool->IsToggled() )
<br>                    bmp = m_style->GetToolIcon( tool->GetToolname(), TOOLICON_TOGGLED, tool->rollover );
<br>                else
<br>                    bmp = m_style->GetToolIcon( tool->GetIconName(), TOOLICON_NORMAL, tool->rollover );
<br>
<br>                if(m_sizefactor > 1.0 ){
<br><mark>                    wxImage scaled_image = bmp.ConvertToImage();
</mark><br><mark>                    bmp = wxBitmap(scaled_image.Scale(tool->m_width, tool->m_height, wxIMAGE_QUALITY_HIGH));
</mark><br>                }
<br>                tool->SetNormalBitmap( bmp );
<br>                tool->bitmapOK = true;
<br>            } else {
<br>                bmp = m_style->GetToolIcon( tool->GetToolname(), TOOLICON_DISABLED );
<br>                if(m_sizefactor > 1.0 ){
<br><mark>                    wxImage scaled_image = bmp.ConvertToImage();
</mark><br><mark>                    bmp = wxBitmap(scaled_image.Scale(tool->m_width, tool->m_height, wxIMAGE_QUALITY_HIGH));
</mark><br>                }
<br>                tool->SetDisabledBitmap( bmp );
<br>                tool->bitmapOK = true;
<br>            }
<br>        }
<br>    }
<br>
<br>    if( tool->firstInLine ) {
<br>        m_style->DrawToolbarLineStart( bmp );
<br>    }
<br>    if( tool->lastInLine ) {
<br>        m_style->DrawToolbarLineEnd( bmp );
<br>    }
<br>
<br>    if( bmp.GetWidth() != m_style->GetToolSize().x
<br>            || bmp.GetHeight() != m_style->GetToolSize().y ) {
<br>//        drawAt.x -= ( bmp.GetWidth() - m_style->GetToolSize().x ) / 2;
<br>//        drawAt.y -= ( bmp.GetHeight() - m_style->GetToolSize().y ) / 2;
<br>    }
<br>
<br>    //      Clear the last drawn tool if necessary
<br>    if( tool->last_rect.width && ((tool->last_rect.x != drawAt.x) || (tool->last_rect.y != drawAt.y)) ){
<br>        wxBrush bb(GetGlobalColor( _T("GREY2") ));
<br>        dc.SetBrush(bb);
<br>        dc.SetPen( *wxTRANSPARENT_PEN );
<br>        dc.DrawRectangle(tool->last_rect.x, tool->last_rect.y, tool->last_rect.width, tool->last_rect.height);
<br>    }
<br>
<br>    //  could cache this in the tool...
<br>    //  A bit of a hack here.  We only scale tools if they are to be magnified globally
<br>    if(0/*m_sizefactor > 1.0*/ )
<br>    {
<br><mark>        wxImage scaled_image = bmp.ConvertToImage();
</mark><br><mark>        wxBitmap sbmp = wxBitmap(scaled_image.Scale(tool->m_width, tool->m_height, wxIMAGE_QUALITY_HIGH));
</mark><br>        dc.DrawBitmap( sbmp, drawAt );
<br>        tool->last_rect = wxRect(drawAt.x, drawAt.y, sbmp.GetWidth(), sbmp.GetHeight());
<br>
<br>    }
<br>    else
<br>    {
<br>        dc.DrawBitmap( bmp, drawAt );
<br>        tool->last_rect = wxRect(drawAt.x, drawAt.y, bmp.GetWidth(), bmp.GetHeight());
<br>    }
<br>
<br>}
<br>
<br>// ----------------------------------------------------------------------------
<br>// toolbar geometry
<br>// ----------------------------------------------------------------------------
<br>
<br>wxToolBarToolBase *ocpnToolBarSimple::FindToolForPosition( wxCoord x, wxCoord y )
<br>{
<br>    wxToolBarToolsList::compatibility_iterator node = m_tools.GetFirst();
<br>    while( node ) {
<br>        ocpnToolBarTool *tool = (ocpnToolBarTool *) node->GetData();
<br>        if( ( x >= tool->m_x ) && ( y >= tool->m_y ) && ( x < ( tool->m_x + tool->GetWidth() ) )
<br>                && ( y < ( tool->m_y + tool->GetHeight() ) ) ) {
<br>            return tool;
<br>        }
<br>
<br>        node = node->GetNext();
<br>    }
<br>
<br>    return (wxToolBarToolBase *) NULL;
<br>}
<br>
<br>void ocpnToolBarSimple::InvalidateBitmaps()
<br>{
<br>    wxToolBarToolsList::compatibility_iterator node = m_tools.GetFirst();
<br>    while( node ) {
<br>        ocpnToolBarTool *tool = (ocpnToolBarTool *) node->GetData();
<br>        tool->bitmapOK = false;
<br>        node = node->GetNext();
<br>    }
<br>}
<br>
<br>wxRect ocpnToolBarSimple::GetToolRect( int tool_id )
<br>{
<br>    wxRect rect;
<br>    wxToolBarToolBase *tool = FindById( tool_id );
<br>    if( tool ) {
<br>        ocpnToolBarTool *otool = (ocpnToolBarTool *) tool;
<br>        if( otool ) rect = otool->trect;
<br>    }
<br>
<br>    return rect;
<br>}
<br>
<br>// ----------------------------------------------------------------------------
<br>// tool state change handlers
<br>// ----------------------------------------------------------------------------
<br>
<br>void ocpnToolBarSimple::DoEnableTool( wxToolBarToolBase *tool, bool WXUNUSED(enable) )
<br>{
<br>    DrawTool( tool );
<br>}
<br>
<br>void ocpnToolBarSimple::DoToggleTool( wxToolBarToolBase *tool, bool WXUNUSED(toggle) )
<br>{
<br>    ocpnToolBarTool *t = (ocpnToolBarTool *) tool;
<br>    t->bitmapOK = false;
<br>    DrawTool( tool );
<br>}
<br>
<br>// Okay, so we've left the tool we're in ... we must check if the tool we're
<br>// leaving was a 'sprung push button' and if so, spring it back to the up
<br>// state.
<br>void ocpnToolBarSimple::SpringUpButton( int id )
<br>{
<br>    wxToolBarToolBase *tool = FindById( id );
<br>
<br>    if( tool && tool->CanBeToggled() ) {
<br>        if( tool->IsToggled() ) tool->Toggle();
<br>
<br>        DrawTool( tool );
<br>    }
<br>}
<br>
<br>// ----------------------------------------------------------------------------
<br>// scrolling implementation
<br>// ----------------------------------------------------------------------------
<br>
<br>wxString ocpnToolBarSimple::GetToolShortHelp( int id ) const
<br>{
<br>    wxToolBarToolBase *tool = FindById( id );
<br>    wxCHECK_MSG( tool, wxEmptyString, _T("no such tool") );
<br>
<br>    return tool->GetShortHelp();
<br>}
<br>
<br>wxString ocpnToolBarSimple::GetToolLongHelp( int id ) const
<br>{
<br>    wxToolBarToolBase *tool = FindById( id );
<br>    wxCHECK_MSG( tool, wxEmptyString, _T("no such tool") );
<br>
<br>    return tool->GetLongHelp();
<br>}
<br>
<br>void ocpnToolBarSimple::SetToolShortHelp( int id, const wxString& help )
<br>{
<br>    wxToolBarToolBase *tool = FindById( id );
<br>    if( tool ) {
<br>        (void) tool->SetShortHelp( help );
<br>    }
<br>}
<br>
<br>void ocpnToolBarSimple::SetToolLongHelp( int id, const wxString& help )
<br>{
<br>    wxToolBarToolBase *tool = FindById( id );
<br>    if( tool ) {
<br>        (void) tool->SetLongHelp( help );
<br>    }
<br>}
<br>
<br>int ocpnToolBarSimple::GetToolPos( int id ) const
<br>{
<br>    size_t pos = 0;
<br>    wxToolBarToolsList::compatibility_iterator node;
<br>
<br>    for( node = m_tools.GetFirst(); node; node = node->GetNext() ) {
<br>        if( node->GetData()->GetId() == id ) return pos;
<br>
<br>        pos++;
<br>    }
<br>
<br>    return wxNOT_FOUND;
<br>}
<br>bool ocpnToolBarSimple::GetToolState( int id ) const
<br>{
<br>    wxToolBarToolBase *tool = FindById( id );
<br>    wxCHECK_MSG( tool, false, _T("no such tool") );
<br>
<br>    return tool->IsToggled();
<br>}
<br>
<br>bool ocpnToolBarSimple::GetToolEnabled( int id ) const
<br>{
<br>    wxToolBarToolBase *tool = FindById( id );
<br>    wxCHECK_MSG( tool, false, _T("no such tool") );
<br>
<br>    return tool->IsEnabled();
<br>}
<br>
<br>void ocpnToolBarSimple::ToggleTool( int id, bool toggle )
<br>{
<br>    wxToolBarToolBase *tool = FindById( id );
<br>        
<br>    if( tool && tool->CanBeToggled() && tool->Toggle( toggle ) ) {
<br>        DoToggleTool( tool, toggle );
<br>        if( g_toolbar ) g_toolbar->Refresh();
<br>    }
<br>}
<br>
<br>wxObject *ocpnToolBarSimple::GetToolClientData( int id ) const
<br>{
<br>    wxToolBarToolBase *tool = FindById( id );
<br>    return tool ? tool->GetClientData() : (wxObject *) NULL;
<br>}
<br>
<br>void ocpnToolBarSimple::SetToolClientData( int id, wxObject *clientData )
<br>{
<br>    wxToolBarToolBase *tool = FindById( id );
<br>
<br>    wxCHECK_RET( tool, _T("no such tool in wxToolBar::SetToolClientData") );
<br>
<br>    tool->SetClientData( clientData );
<br>}
<br>
<br>void ocpnToolBarSimple::EnableTool( int id, bool enable )
<br>{
<br>    wxToolBarToolBase *tool = FindById( id );
<br>    if( tool ) {
<br>        if( tool->Enable( enable ) ) {
<br>            DoEnableTool( tool, enable );
<br>        }
<br>    }
<br>    wxMenuItem* configItem = g_FloatingToolbarConfigMenu->FindItem( id );
<br>    configItem->Check( true );
<br>}
<br>
<br>void ocpnToolBarSimple::SetToolBitmaps( int id, wxBitmap *bmp, wxBitmap *bmpRollover )
<br>{
<br>    ocpnToolBarTool *tool = (ocpnToolBarTool*)FindById( id );
<br>    if( tool ) {
<br>        tool->pluginNormalIcon = bmp;
<br>        tool->pluginRolloverIcon = bmpRollover;
<br>        tool->bitmapOK = false;
<br>    }
<br>}
<br>
<br>void ocpnToolBarSimple::SetToolTooltipHiViz( int id, bool b_hiviz )
<br>{
<br>    ocpnToolBarTool *tool = (ocpnToolBarTool*)FindById( id );
<br>    if( tool ) {
<br>        tool->SetTooltipHiviz( b_hiviz );
<br>    }
<br>}
<br>
<br>
<br>void ocpnToolBarSimple::ClearTools()
<br>{
<br>    while( GetToolsCount() ) {
<br>        DeleteToolByPos( 0 );
<br>    }
<br>}
<br>
<br>int ocpnToolBarSimple::GetVisibleToolCount()
<br>{
<br>    int counter = 0;
<br>    wxToolBarToolsList::compatibility_iterator node = m_tools.GetFirst();
<br>    while( node ) {
<br>        ocpnToolBarTool *tool = (ocpnToolBarTool *) node->GetData();
<br>        counter++;
<br>        node = node->GetNext();
<br>    }
<br>    return counter;
<br>}
<br>
<br>bool ocpnToolBarSimple::DeleteToolByPos( size_t pos )
<br>{
<br>    wxCHECK_MSG( pos < GetToolsCount(), false,
<br>            _T("invalid position in wxToolBar::DeleteToolByPos()") );
<br>
<br>    wxToolBarToolsList::compatibility_iterator node = m_tools.Item( pos );
<br>
<br>    if( !DoDeleteTool( pos, node->GetData() ) ) {
<br>        return false;
<br>    }
<br>
<br>    delete node->GetData();
<br>    m_tools.Erase( node );
<br>
<br>    return true;
<br>}
<br>
<br>bool ocpnToolBarSimple::DeleteTool( int id )
<br>{
<br>    size_t pos = 0;
<br>    wxToolBarToolsList::compatibility_iterator node;
<br>    for( node = m_tools.GetFirst(); node; node = node->GetNext() ) {
<br>        if( node->GetData()->GetId() == id ) break;
<br>
<br>        pos++;
<br>    }
<br>
<br>    if( !node || !DoDeleteTool( pos, node->GetData() ) ) {
<br>        return false;
<br>    }
<br>
<br>    delete node->GetData();
<br>    m_tools.Erase( node );
<br>
<br>    return true;
<br>}
<br>
<br>wxToolBarToolBase *ocpnToolBarSimple::AddSeparator()
<br>{
<br>    return InsertSeparator( GetToolsCount() );
<br>}
<br>
<br>wxToolBarToolBase *ocpnToolBarSimple::InsertSeparator( size_t pos )
<br>{
<br>    wxCHECK_MSG( pos <= GetToolsCount(), (wxToolBarToolBase *)NULL,
<br>            _T("invalid position in wxToolBar::InsertSeparator()") );
<br>
<br>    wxToolBarToolBase *tool = CreateTool( wxID_SEPARATOR, wxEmptyString, wxNullBitmap, wxNullBitmap,
<br>            wxITEM_SEPARATOR, (wxObject *) NULL, wxEmptyString, wxEmptyString );
<br>
<br>    if( !tool || !DoInsertTool( pos, tool ) ) {
<br>        delete tool;
<br>
<br>        return NULL;
<br>    }
<br>
<br>    m_tools.Insert( pos, tool );
<br>
<br>    return tool;
<br>}
<br>
<br>wxToolBarToolBase *ocpnToolBarSimple::RemoveTool( int id )
<br>{
<br>    size_t pos = 0;
<br>    wxToolBarToolsList::compatibility_iterator node;
<br>    for( node = m_tools.GetFirst(); node; node = node->GetNext() ) {
<br>        if( node->GetData()->GetId() == id ) break;
<br>
<br>        pos++;
<br>    }
<br>
<br>    if( !node ) {
<br>        // don't give any error messages - sometimes we might call RemoveTool()
<br>        // without knowing whether the tool is or not in the toolbar
<br>        return (wxToolBarToolBase *) NULL;
<br>    }
<br>
<br>    wxToolBarToolBase *tool = node->GetData();
<br>    if( !DoDeleteTool( pos, tool ) ) {
<br>        return (wxToolBarToolBase *) NULL;
<br>    }
<br>
<br>    m_tools.Erase( node );
<br>
<br>    return tool;
<br>}
<br>
<br>
<br>wxControl *ocpnToolBarSimple::FindControl( int id )
<br>{
<br>    for( wxToolBarToolsList::compatibility_iterator node = m_tools.GetFirst(); node;
<br>            node = node->GetNext() ) {
<br>        const wxToolBarToolBase * const tool = node->GetData();
<br>        if( tool->IsControl() ) {
<br>            wxControl * const control = tool->GetControl();
<br>
<br>            if( !control ) {
<br>                wxFAIL_MSG( _T("NULL control in toolbar?") );
<br>            } else
<br>                if( control->GetId() == id ) {
<br>                    // found
<br>                    return control;
<br>                }
<br>        }
<br>    }
<br>
<br>    return NULL;
<br>}
<br>
<br>wxToolBarToolBase *ocpnToolBarSimple::FindById( int id ) const
<br>{
<br>    wxToolBarToolBase *tool = (wxToolBarToolBase *) NULL;
<br>
<br>    for( wxToolBarToolsList::compatibility_iterator node = m_tools.GetFirst(); node;
<br>            node = node->GetNext() ) {
<br>        tool = node->GetData();
<br>        if( tool->GetId() == id ) {
<br>            // found
<br>            break;
<br>        }
<br>
<br>        tool = NULL;
<br>    }
<br>
<br>    return tool;
<br>}
<br>
<br>// ----------------------------------------------------------------------------
<br>// event processing
<br>// ----------------------------------------------------------------------------
<br>
<br>// Only allow toggle if returns true
<br>bool ocpnToolBarSimple::OnLeftClick( int id, bool toggleDown )
<br>{
<br>    wxCommandEvent event( wxEVT_COMMAND_TOOL_CLICKED, id );
<br>    event.SetEventObject( this );
<br>
<br>    // we use SetInt() to make wxCommandEvent::IsChecked() return toggleDown
<br>    event.SetInt( (int) toggleDown );
<br>
<br>    // and SetExtraLong() for backwards compatibility
<br>    event.SetExtraLong( (long) toggleDown );
<br>
<br>    // Send events to this toolbar instead (and thence up the window hierarchy)
<br>    GetEventHandler()->ProcessEvent( event );
<br>
<br>    return true;
<br>}
<br>
<br>// Call when right button down.
<br>void ocpnToolBarSimple::OnRightClick( int id, long WXUNUSED(x), long WXUNUSED(y) )
<br>{
<br>    wxCommandEvent event( wxEVT_COMMAND_TOOL_RCLICKED, id );
<br>    event.SetEventObject( this );
<br>    event.SetInt( id );
<br>
<br>    HideTooltip();
<br>    ((ocpnFloatingToolbarDialog*)GetParent())->toolbarConfigChanged = false;
<br>    wxMenu* contextMenu = new wxMenu();
<br>    wxMenuItem* submenu = contextMenu->AppendSubMenu( g_FloatingToolbarConfigMenu, _("Visible buttons") );
<br>
<br>    PopupMenu( contextMenu );
<br>
<br>    contextMenu->Remove( submenu );
<br>    delete contextMenu;
<br>
<br>    if( ((ocpnFloatingToolbarDialog*)GetParent())->toolbarConfigChanged )
<br>        gFrame->GetEventHandler()->AddPendingEvent( event );
<br>}
<br>
<br>// Called when the mouse cursor enters a tool bitmap (no button pressed).
<br>// Argument is wxID_ANY if mouse is exiting the toolbar.
<br>// Note that for this event, the id of the window is used,
<br>// and the integer parameter of wxCommandEvent is used to retrieve
<br>// the tool id.
<br>void ocpnToolBarSimple::OnMouseEnter( int id )
<br>{
<br>    wxCommandEvent event( wxEVT_COMMAND_TOOL_ENTER, GetId() );
<br>    event.SetEventObject( this );
<br>    event.SetInt( id );
<br>
<br>    wxFrame *frame = wxDynamicCast(GetParent(), wxFrame);
<br>    if( frame ) {
<br>        wxString help;
<br>        wxToolBarToolBase* tool = id == wxID_ANY ? (wxToolBarToolBase*) NULL : FindById( id );
<br>        if( tool ) help = tool->GetLongHelp();
<br>        frame->DoGiveHelp( help, id != wxID_ANY );
<br>    }
<br>
<br>    (void) GetEventHandler()->ProcessEvent( event );
<br>
<br>    DoPluginToolUp();
<br>}
<br>
<br>void ocpnToolBarSimple::DoPluginToolUp()
<br>{
<br>    //        Look for PlugIn tools
<br>    //        If found, make the callback.
<br>    if( !g_pi_manager)
<br>        return;
<br>
<br>    ArrayOfPlugInToolbarTools tool_array = g_pi_manager->GetPluginToolbarToolArray();
<br>    for( unsigned int i = 0; i < tool_array.GetCount(); i++ ) {
<br>        PlugInToolbarToolContainer *pttc = tool_array.Item( i );
<br>        if( m_last_plugin_down_id == pttc->id ) {
<br>            opencpn_plugin_113 *ppi = dynamic_cast<opencpn_plugin_113 *>(pttc->m_pplugin);
<br>            if( ppi )
<br>                ppi->OnToolbarToolUpCallback( pttc->id );
<br>        }
<br>    }
<br>
<br>    m_last_plugin_down_id = -1;
<br>}
<br>
<br>void ocpnToolBarSimple::SetToolNormalBitmapEx( wxToolBarToolBase *tool, const wxString &iconName)
<br>{
<br>    if( tool ) {
<br>        ocpnToolBarTool *otool = (ocpnToolBarTool *) tool;
<br>        if(otool){
<br>            ocpnStyle::Style *style = g_StyleManager->GetCurrentStyle();
<br>
<br>            wxBitmap bmp = style->GetToolIcon( iconName, TOOLICON_NORMAL );
<br>            if(m_sizefactor > 1.0 ){
<br><mark>                wxImage scaled_image = bmp.ConvertToImage();
</mark><br><mark>                bmp = wxBitmap(scaled_image.Scale(otool->m_width, otool->m_height, wxIMAGE_QUALITY_HIGH));
</mark><br>            }
<br>        
<br>            tool->SetNormalBitmap( bmp );
<br>            otool->SetIconName( iconName );
<br>        }
<br>    }
<br>}
<br>
<br>
<br>//-------------------------------------------------------------------------------------
<br>
<br>ToolbarMOBDialog::ToolbarMOBDialog( wxWindow* parent )
<br>       : wxDialog( parent, wxID_ANY, _("OpenCPN Alert"), wxDefaultPosition, wxSize(250, 230) )
<br>{
<br>    wxBoxSizer* topSizer = new wxBoxSizer( wxVERTICAL );
<br>
<br>    wxBoxSizer* sizer = new wxBoxSizer( wxVERTICAL );
<br>    topSizer->Add( sizer, 0, wxALIGN_CENTER_HORIZONTAL | wxALL, 5 );
<br>
<br>    choices.push_back( new wxRadioButton( this, 0,  _("No, I don't want to hide it."),
<br>            wxDefaultPosition, wxDefaultSize, wxRB_GROUP ) );
<br>
<br>    choices.push_back( new wxRadioButton( this, 1, _("No, and permanently remove the option to hide it."),
<br>            wxDefaultPosition) );
<br>
<br>    choices.push_back( new wxRadioButton( this, 2, _("Yes, hide it."),
<br>            wxDefaultPosition) );
<br>
<br>    wxStdDialogButtonSizer* buttonSizer = CreateStdDialogButtonSizer( wxOK | wxCANCEL );
<br>
<br>
<br>    wxStaticText* textCtrl = new wxStaticText( this, wxID_ANY, _("The Man Over Board button could be an important safety feature.\nAre you sure you want to hide it?") );
<br>
<br>    sizer->Add( textCtrl, 0, wxEXPAND | wxALL, 5 );
<br>    sizer->Add( choices[0], 0, wxEXPAND | wxALL, 5 );
<br>    sizer->Add( choices[1], 0, wxEXPAND | wxALL, 5 );
<br>    sizer->Add( choices[2], 0, wxEXPAND | wxALL, 5 );
<br>    sizer->Add( buttonSizer, 0, wxEXPAND | wxTOP, 5 );
<br>
<br>    topSizer->SetSizeHints(this);
<br>    SetSizer( topSizer );
<br>}
<br>
<br>int ToolbarMOBDialog::GetSelection() {
<br>    for( unsigned int i=0; i<choices.size(); i++ ) {
<br>        if( choices[i]->GetValue() ) return choices[i]->GetId();
<br>    }
<br>    return 0;
<br>}
</p></body>
    </html><html>
    <head></head>
    <body><p><br>/***************************************************************************
<br> *
<br> * Project:  OpenCPN
<br> * Purpose:  OpenCPN Toolbar
<br> * Author:   David Register
<br> *
<br> ***************************************************************************
<br> *   Copyright (C) 2010 by David S. Register                               *
<br> *                                                                         *
<br> *   This program is free software; you can redistribute it and/or modify  *
<br> *   it under the terms of the GNU General Public License as published by  *
<br> *   the Free Software Foundation; either version 2 of the License, or     *
<br> *   (at your option) any later version.                                   *
<br> *                                                                         *
<br> *   This program is distributed in the hope that it will be useful,       *
<br> *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
<br> *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
<br> *   GNU General Public License for more details.                          *
<br> *                                                                         *
<br> *   You should have received a copy of the GNU General Public License     *
<br> *   along with this program; if not, write to the                         *
<br> *   Free Software Foundation, Inc.,                                       *
<br> *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,  USA.         *
<br> **************************************************************************/
<br>
<br>#include "wx/wxprec.h"
<br>
<br>#ifndef  WX_PRECOMP
<br>#include "wx/wx.h"
<br>#endif
<br>
<br>#include <vector>
<br>
<br>#include "ocpn_types.h"
<br>#include "navutil.h"
<br>#include "styles.h"
<br>#include "toolbar.h"
<br>#include "chart1.h"
<br>#include "pluginmanager.h"
<br>#include "FontMgr.h"
<br>
<br>extern ocpnFloatingToolbarDialog* g_FloatingToolbarDialog;
<br>extern bool                       g_bTransparentToolbar;
<br>extern bool                       g_bTransparentToolbarInOpenGLOK;
<br>extern ChartCanvas*               cc1;
<br>extern bool                       g_bopengl;
<br>extern ocpnToolBarSimple*         g_toolbar;
<br>extern ocpnStyle::StyleManager*   g_StyleManager;
<br>extern MyFrame*                   gFrame;
<br>extern PlugInManager*             g_pi_manager;
<br>extern wxMenu*                    g_FloatingToolbarConfigMenu;
<br>extern wxString                   g_toolbarConfig;
<br>extern bool                       g_bPermanentMOBIcon;
<br>extern bool                       g_btouch;
<br>extern bool                       g_bsmoothpanzoom;
<br>
<br>//----------------------------------------------------------------------------
<br>// GrabberWindow Implementation
<br>//----------------------------------------------------------------------------
<br>BEGIN_EVENT_TABLE(GrabberWin, wxPanel) EVT_MOUSE_EVENTS ( GrabberWin::MouseEvent )
<br>EVT_PAINT ( GrabberWin::OnPaint )
<br>END_EVENT_TABLE()
<br>
<br>GrabberWin::GrabberWin( wxWindow *parent, ocpnFloatingToolbarDialog *toolbar, float scale_factor, wxString icon_name, wxPoint position ):
<br>    wxPanel( parent, wxID_ANY, position, wxDefaultSize, wxNO_BORDER )
<br>{
<br>    m_icon_name = icon_name;
<br>    m_style = g_StyleManager->GetCurrentStyle();
<br>    wxBitmap bitmap = m_style->GetIcon( icon_name );
<br>    if(scale_factor > 1.0f){
<br>        int new_width = bitmap.GetWidth() * scale_factor;
<br>        int new_height = bitmap.GetHeight() * scale_factor;
<br><mark>        wxImage scaled_image = bitmap.ConvertToImage();
</mark><br><mark>        m_bitmap = wxBitmap(scaled_image.Scale(new_width, new_height, wxIMAGE_QUALITY_HIGH));
</mark><br>    }
<br>    else
<br>        m_bitmap = bitmap;
<br>
<br>    SetSize( wxSize( m_bitmap.GetWidth(), m_bitmap.GetHeight() ) );
<br>    SetMinSize( wxSize( m_bitmap.GetWidth(), m_bitmap.GetHeight() ) );
<br>
<br>    m_bLeftDown = false;
<br>    m_bRightDown = false;
<br>    m_scale_factor = scale_factor;
<br>    m_ptoolbar = toolbar;
<br>    m_dragging = false;
<br>    Hide();
<br>    
<br>}
<br>
<br>
<br>void GrabberWin::OnPaint( wxPaintEvent& event )
<br>{
<br>    wxPaintDC dc( this );
<br>    
<br>    wxColour back_color = GetGlobalColor( _T("GREY2") );
<br>    SetBackgroundColour( back_color );
<br>    ClearBackground();
<br>    
<br>    dc.DrawBitmap( m_bitmap, 0, 0, true );
<br>}
<br>
<br>void GrabberWin::SetColorScheme( ColorScheme cs )
<br>{
<br>    wxColour back_color = GetGlobalColor( _T("GREY2") );
<br>
<br>    SetBackgroundColour( back_color );
<br>    ClearBackground();
<br>
<br>    wxBitmap bitmap = m_style->GetIcon( m_icon_name) ;
<br>    if(m_scale_factor > 1.0f){
<br>        int new_width = bitmap.GetWidth() * m_scale_factor;
<br>        int new_height = bitmap.GetHeight() * m_scale_factor;
<br><mark>        wxImage scaled_image = bitmap.ConvertToImage();
</mark><br><mark>        m_bitmap = wxBitmap(scaled_image.Scale(new_width, new_height, wxIMAGE_QUALITY_HIGH));
</mark><br>    }
<br>    else
<br>        m_bitmap = bitmap;
<br>}
<br>
<br>void GrabberWin::MouseEvent( wxMouseEvent& event )
<br>{
<br>    static wxPoint s_gspt;
<br>    int x, y;
<br>
<br>    event.GetPosition( &x, &y );
<br>
<br>    wxPoint spt = ClientToScreen( wxPoint( x, y ) );
<br>    if( event.LeftDown() ) {
<br>        s_gspt = spt;
<br>    }
<br>    
<br>    
<br>#ifndef __WXQT__
<br>
<br>    if( event.LeftDown() ) {
<br>        CaptureMouse();
<br>    }
<br>
<br>    if( event.LeftUp() ) {
<br>        if( HasCapture() ) ReleaseMouse();
<br>    }
<br>
<br>#endif
<br>
<br>
<br>    if( event.RightDown() ){
<br>        if(m_ptoolbar){
<br>            m_dragging = true;
<br>            
<br>            if( !m_ptoolbar->m_bnavgrabber ){
<br>                m_ptoolbar->m_bnavgrabber = true;
<br>                m_ptoolbar->SetGrabber(_T("4WayMove") );
<br>            }
<br>            else{
<br>                m_ptoolbar->m_bnavgrabber = false;
<br>                m_ptoolbar->SetGrabber(_T("grabber_hi") );
<br>            }
<br>                
<br>        }
<br>    }
<br>    
<br>
<br>
<br>    if( event.Dragging() ) {
<br>        if(m_ptoolbar && m_ptoolbar->IsShown() /*&& m_ptoolbar->m_bnavgrabber*/){
<br>            wxPoint par_pos_old = m_ptoolbar->GetPosition();
<br>
<br>            wxPoint par_pos = par_pos_old;
<br>            par_pos.x += spt.x - s_gspt.x;
<br>            par_pos.y += spt.y - s_gspt.y;
<br>
<br>            m_ptoolbar->MoveDialogInScreenCoords( par_pos, par_pos_old );
<br>
<br>            s_gspt = spt;
<br>            m_dragging = true;
<br>        }
<br>
<br>    }
<br>
<br>    if( event.LeftUp() ) {
<br>        if(m_ptoolbar){
<br>            if(m_ptoolbar->m_bnavgrabber){
<br>                if(!m_dragging)
<br>                    m_ptoolbar->ToggleOrientation();
<br>            }
<br>            else if(!m_dragging){
<br>                if(m_ptoolbar->m_bsubmerged){
<br>                    m_ptoolbar->SurfaceFromGrabber();
<br>                }
<br>                else{
<br>                    m_ptoolbar->SubmergeToGrabber();
<br>                 }
<br>            }
<br>        }
<br>        m_dragging = false;
<br>    }
<br>    
<br>    
<br>#ifndef __OCPN__ANDROID__
<br>    gFrame->Raise();
<br>#endif
<br>    
<br>}
<br>
<br>class ocpnToolBarTool: public wxToolBarToolBase {
<br>public:
<br>    ocpnToolBarTool( ocpnToolBarSimple *tbar, int id, const wxString& label,
<br>            const wxBitmap& bmpNormal, const wxBitmap& bmpRollover, wxItemKind kind,
<br>            wxObject *clientData, const wxString& shortHelp, const wxString& longHelp ) :
<br>            wxToolBarToolBase( (wxToolBarBase*) tbar, id, label, bmpNormal, bmpRollover, kind,
<br>                    clientData, shortHelp, longHelp )
<br>    {
<br>        m_enabled = true;
<br>        m_toggled = false;
<br>        rollover = false;
<br>        bitmapOK = false;
<br>        m_btooltip_hiviz = false;
<br>
<br>        toolname = g_pi_manager->GetToolOwnerCommonName( id );
<br>        if( toolname == _T("") ) {
<br>            isPluginTool = false;
<br>            toolname = label;
<br>            iconName = label;
<br>        } else {
<br>            isPluginTool = true;
<br>            pluginNormalIcon = &bmpNormal;
<br>            pluginRolloverIcon = &bmpRollover;
<br>        }
<br>    }
<br>
<br>    void SetSize( const wxSize& size )
<br>    {
<br>        m_width = size.x;
<br>        m_height = size.y;
<br>    }
<br>
<br>    wxCoord GetWidth() const
<br>    {
<br>        return m_width;
<br>    }
<br>
<br>    wxCoord GetHeight() const
<br>    {
<br>        return m_height;
<br>    }
<br>
<br>    wxString GetToolname()
<br>    {
<br>        return toolname;
<br>    }
<br>
<br>    void SetIconName(wxString name)
<br>    {
<br>        iconName = name;
<br>    }
<br>    wxString GetIconName()
<br>    {
<br>        return iconName;
<br>    }
<br>
<br>    void SetTooltipHiviz( bool enable){ m_btooltip_hiviz = enable; }
<br>
<br>    wxCoord m_x;
<br>    wxCoord m_y;
<br>    wxCoord m_width;
<br>    wxCoord m_height;
<br>    wxRect trect;
<br>    wxString toolname;
<br>    wxString iconName;
<br>    const wxBitmap* pluginNormalIcon;
<br>    const wxBitmap* pluginRolloverIcon;
<br>    bool firstInLine;
<br>    bool lastInLine;
<br>    bool rollover;
<br>    bool bitmapOK;
<br>    bool isPluginTool;
<br>    bool b_hilite;
<br>    bool m_btooltip_hiviz;
<br>    wxRect last_rect;
<br>};
<br>
<br>//---------------------------------------------------------------------------------------
<br>//          ocpnFloatingToolbarDialog Implementation
<br>//---------------------------------------------------------------------------------------
<br>BEGIN_EVENT_TABLE(ocpnFloatingToolbarDialog, wxDialog)
<br>    EVT_MOUSE_EVENTS ( ocpnFloatingToolbarDialog::MouseEvent )
<br>    EVT_MENU(wxID_ANY, ocpnFloatingToolbarDialog::OnToolLeftClick)
<br>    EVT_TIMER ( FADE_TIMER, ocpnFloatingToolbarDialog::FadeTimerEvent )
<br>    EVT_TIMER ( DESTROY_TIMER, ocpnFloatingToolbarDialog::DestroyTimerEvent )
<br>    EVT_WINDOW_CREATE(ocpnFloatingToolbarDialog::OnWindowCreate)
<br>END_EVENT_TABLE()
<br>
<br>ocpnFloatingToolbarDialog::ocpnFloatingToolbarDialog( wxWindow *parent, wxPoint position,
<br>                                                      long orient, float size_factor )
<br>{
<br>    m_pparent = parent;
<br>    long wstyle = wxNO_BORDER | wxFRAME_NO_TASKBAR;
<br>#ifndef __WXMAC__
<br>    wstyle |= wxFRAME_SHAPED;
<br>#endif
<br>
<br>    m_ptoolbar = NULL;
<br>
<br>#ifdef __WXOSX__
<br>    wstyle |= wxSTAY_ON_TOP;
<br>#endif
<br>    wxDialog::Create( parent, -1, _T("ocpnToolbarDialog"), wxPoint( -1, -1 ), wxSize( -1, -1 ),
<br>            wstyle );
<br>
<br>    m_opacity = 255;
<br>
<br>    m_pGrabberwin = new GrabberWin( this, this, size_factor, _T("grabber_hi") );
<br>    m_pGrabberwin->Show();
<br>    
<br>    m_pRecoverwin = NULL;
<br>    m_position = position;
<br>    m_orient = orient;
<br>    m_sizefactor = size_factor;
<br>    
<br>    m_bAutoHideToolbar = false;
<br>    m_nAutoHideToolbar = 5;
<br>    
<br>
<br>    m_style = g_StyleManager->GetCurrentStyle();
<br>
<br>// A top-level sizer
<br>    m_topSizer = new wxBoxSizer( wxHORIZONTAL );
<br>    SetSizer( m_topSizer );
<br>
<br>    //    Set initial "Dock" parameters
<br>    m_dock_x = 0;
<br>    m_dock_y = 0;
<br>    m_block = false;
<br>
<br>    m_marginsInvisible = m_style->marginsInvisible;
<br>
<br>//    if(m_sizefactor > 1.0 )
<br> //       m_marginsInvisible = true;
<br>
<br>    m_bnavgrabber = false;    
<br>    
<br>    Hide();
<br>
<br>    m_bsubmerged = false;
<br>    
<br>    m_fade_timer.SetOwner( this, FADE_TIMER );
<br>    if( g_bTransparentToolbar )
<br>        m_fade_timer.Start( 5000 );
<br>    
<br>    if( m_bAutoHideToolbar && (m_nAutoHideToolbar > 0))
<br>        m_fade_timer.Start( m_nAutoHideToolbar * 1000 );
<br>    
<br>    m_destroyTimer.SetOwner( this, DESTROY_TIMER );
<br>}
<br>
<br>ocpnFloatingToolbarDialog::~ocpnFloatingToolbarDialog()
<br>{
<br>    DestroyToolBar();
<br>}
<br>
<br>void ocpnFloatingToolbarDialog::OnWindowCreate( wxWindowCreateEvent& event )
<br>{
<br>    Realize();
<br>}
<br>
<br>void ocpnFloatingToolbarDialog::SetGrabber( wxString icon_name )
<br>{
<br>//    m_pGrabberwin->Destroy();
<br>    m_pGrabberwin = new GrabberWin( this, this, m_sizefactor, icon_name );
<br>    m_pGrabberwin->Show();
<br>    
<br>    Realize();
<br>    
<br>#ifdef __WXOSX__    
<br>    m_pGrabberwin->Refresh();
<br>#endif    
<br>    
<br>}
<br>
<br>
<br>    
<br>void ocpnFloatingToolbarDialog::SetColorScheme( ColorScheme cs )
<br>{
<br>    m_cs = cs;
<br>
<br>    wxColour back_color = GetGlobalColor( _T("GREY2") );
<br>
<br>    //  Set background
<br>    SetBackgroundColour( back_color );
<br>    ClearBackground();
<br>
<br>    if( m_ptoolbar ) {
<br>        wxColour back_color = GetGlobalColor( _T("GREY2") );
<br>
<br>        //  Set background
<br>        m_ptoolbar->SetBackgroundColour( back_color );
<br>        m_ptoolbar->ClearBackground();
<br>
<br>        m_ptoolbar->SetToggledBackgroundColour( GetGlobalColor( _T("GREY1") ) );
<br>
<br>        m_ptoolbar->SetColorScheme( cs );
<br>        m_ptoolbar->Refresh( true );
<br>    }
<br>
<br>    if( m_pGrabberwin ) m_pGrabberwin->SetColorScheme( cs );
<br>
<br>}
<br>
<br>void ocpnFloatingToolbarDialog::SetGeometry(bool bAvoid, wxRect rectAvoid)
<br>{
<br>
<br>    if( m_ptoolbar ) {
<br>        wxSize style_tool_size = m_style->GetToolSize();
<br>
<br>        style_tool_size.x *= m_sizefactor;
<br>        style_tool_size.y *= m_sizefactor;
<br>
<br>        m_ptoolbar->SetToolBitmapSize( style_tool_size );
<br>
<br>        wxSize tool_size = m_ptoolbar->GetToolBitmapSize();
<br>        int grabber_width =  m_style->GetIcon( _T("grabber") ).GetWidth();
<br>        
<br>        int max_rows = 10;
<br>        int max_cols = 100;
<br>        if(cc1){
<br>
<br>            int avoid_start = cc1->GetClientSize().x - (tool_size.x + m_style->GetToolSeparation()) * 2;  // default
<br>            if(bAvoid && !rectAvoid.IsEmpty()){
<br>                avoid_start = cc1->GetClientSize().x - rectAvoid.width - 10;  // this is compass window, if shown
<br>            }
<br>            
<br>            
<br>            max_rows = (cc1->GetClientSize().y / ( tool_size.y + m_style->GetToolSeparation())) - 1;
<br>            
<br>            max_cols = (avoid_start - grabber_width) / ( tool_size.x + m_style->GetToolSeparation());
<br>            max_cols -= 1;
<br>            
<br>            if(m_orient == wxTB_VERTICAL)
<br>                max_rows = wxMax( max_rows, 2);             // at least two rows
<br>            else
<br>                max_cols = wxMax( max_cols, 2);             // at least two columns
<br>        }
<br>
<br>        if( m_orient == wxTB_VERTICAL )
<br>            m_ptoolbar->SetMaxRowsCols(max_rows, 100);
<br>        else
<br>            m_ptoolbar->SetMaxRowsCols( 100, max_cols);
<br>        m_ptoolbar->SetSizeFactor(m_sizefactor);
<br>        
<br>    }
<br> }
<br>
<br>void ocpnFloatingToolbarDialog::RePosition()
<br>{
<br>    if(m_block) return;
<br>
<br>    if( m_pparent && m_ptoolbar ) {
<br>        wxSize cs = m_pparent->GetClientSize();
<br>        if( -1 == m_dock_x ) m_position.x = 0;
<br>        else
<br>            if( 1 == m_dock_x ) m_position.x = cs.x - GetSize().x;
<br>
<br>        if( -1 == m_dock_y ) m_position.y = 0;
<br>        else
<br>            if( 1 == m_dock_y ) m_position.y = cs.y - GetSize().y;
<br>
<br>        m_position.x = wxMin(cs.x - GetSize().x, m_position.x);
<br>        m_position.y = wxMin(cs.y - GetSize().y, m_position.y);
<br>
<br>        m_position.x = wxMax(0, m_position.x);
<br>        m_position.y = wxMax(0, m_position.y);
<br>
<br>        wxPoint screen_pos = m_pparent->ClientToScreen( m_position );
<br>
<br>        Move( screen_pos );
<br>
<br>#ifdef __WXQT__
<br>        Raise();
<br>#endif
<br>
<br>    }
<br>}
<br>
<br>void ocpnFloatingToolbarDialog::Submerge()
<br>{
<br>    m_bsubmerged = true;
<br>    Hide();
<br>    if( m_ptoolbar ) m_ptoolbar->KillTooltip();
<br>}
<br>
<br>void ocpnFloatingToolbarDialog::SubmergeToGrabber()
<br>{
<br>//Submerge();
<br>    m_bsubmerged = true;
<br>    Hide();
<br>    if( m_ptoolbar ) m_ptoolbar->KillTooltip();
<br>
<br>    m_pRecoverwin = new GrabberWin( m_pparent, this, m_sizefactor, _T("grabber_ext" ), wxPoint(10,10) );
<br>   
<br>    m_pRecoverwin->Show();
<br>    m_pRecoverwin->Raise();
<br>#ifdef __WXQT__
<br>    wxSize s = gFrame->GetSize();
<br>    m_recoversize = s;
<br>    s.y--;
<br>    gFrame->TriggerResize(s);
<br>    Raise();
<br>#endif    
<br>
<br>    gFrame->Refresh();          // Needed for MSW OpenGL
<br>}
<br>
<br>void ocpnFloatingToolbarDialog::Surface()
<br>{
<br>    
<br>    if(m_pRecoverwin){
<br>        m_pRecoverwin->Show();
<br>        m_pRecoverwin->Raise();
<br>    }
<br>    else {
<br>        m_bsubmerged = false;
<br>        #ifndef __WXOSX__
<br>        Hide();
<br>        Move( 0, 0 );
<br>        #endif
<br>
<br>        RePosition();
<br>        Show();
<br>        if( m_ptoolbar )
<br>            m_ptoolbar->EnableTooltips();
<br>
<br>        #ifdef __WXQT__
<br>        Raise();
<br>        #endif
<br>    }
<br>    
<br>    if( m_bAutoHideToolbar && (m_nAutoHideToolbar > 0) ){
<br>        m_fade_timer.Start( m_nAutoHideToolbar * 1000 );
<br>    }
<br>}
<br>
<br>bool ocpnFloatingToolbarDialog::CheckSurfaceRequest( wxMouseEvent &event )
<br>{
<br>    if( m_bsubmerged ){
<br>        if( event.LeftUp() ){
<br>            int x,y;
<br>            event.GetPosition( &x, &y );
<br>            if( m_pRecoverwin ){
<br>                wxRect winRect = m_pRecoverwin->GetRect();
<br>                if( winRect.Contains( x, y ) ){
<br>                    SurfaceFromGrabber();
<br>                    return true;
<br>                }
<br>            }
<br>        }
<br>    }
<br>    
<br>    return false;
<br>}
<br>        
<br>void ocpnFloatingToolbarDialog::SurfaceFromGrabber()
<br>{
<br>    m_bsubmerged = false;
<br>    
<br>#ifndef __WXOSX__
<br>    Hide();
<br>    Move( 0, 0 );
<br>#endif
<br>
<br>    if( m_ptoolbar )
<br>        m_ptoolbar->InvalidateBitmaps();
<br>    
<br>    RePosition();
<br>    Show();
<br>    if( m_ptoolbar )
<br>        m_ptoolbar->EnableTooltips();
<br>    
<br>    if( m_bAutoHideToolbar && (m_nAutoHideToolbar > 0) ){
<br>        m_fade_timer.Start( m_nAutoHideToolbar * 1000 );
<br>    }
<br>    
<br>#ifdef __WXQT__
<br>    wxSize s = gFrame->GetSize();               // check for rotation
<br>    if(m_recoversize.x == s.x)
<br>        gFrame->TriggerResize(m_recoversize);
<br>    Raise();
<br>#endif
<br>    
<br>    m_destroyGrabber = m_pRecoverwin;
<br>    m_destroyTimer.Start( 5, wxTIMER_ONE_SHOT );           //  Destor the unneeded recovery grabber
<br>    
<br>}
<br>
<br>void ocpnFloatingToolbarDialog::DestroyTimerEvent( wxTimerEvent& event )
<br>{
<br>    delete m_destroyGrabber;
<br>    m_destroyGrabber = NULL;
<br>    m_pRecoverwin = NULL;
<br>}
<br>
<br>void ocpnFloatingToolbarDialog::HideTooltip()
<br>{
<br>    if( m_ptoolbar ) m_ptoolbar->HideTooltip();
<br>}
<br>
<br>void ocpnFloatingToolbarDialog::ShowTooltips()
<br>{
<br>    if( m_ptoolbar ) m_ptoolbar->EnableTooltips();
<br>}
<br>
<br>void ocpnFloatingToolbarDialog::ToggleOrientation()
<br>{
<br>    if( m_orient == wxTB_HORIZONTAL )
<br>        m_orient = wxTB_VERTICAL;
<br>    else
<br>        m_orient = wxTB_HORIZONTAL;
<br>
<br>    m_style->SetOrientation( m_orient );
<br>
<br>    wxPoint old_screen_pos = m_pparent->ClientToScreen( m_position );
<br>    wxPoint grabber_point_abs = ClientToScreen( m_pGrabberwin->GetPosition() );
<br>
<br>    gFrame->RequestNewToolbar();
<br>    wxPoint pos_abs = grabber_point_abs;
<br>    pos_abs.x -= m_pGrabberwin->GetPosition().x;
<br>    MoveDialogInScreenCoords( pos_abs, old_screen_pos );
<br>
<br>
<br>    Show();   // this seems to be necessary on GTK to kick the sizer into gear...(FS#553)
<br>    Refresh(true);
<br>    Raise();
<br>}
<br>
<br>void ocpnFloatingToolbarDialog::MouseEvent( wxMouseEvent& event )
<br>{
<br>    if( g_bTransparentToolbar ) {
<br>        if( event.Entering() && ( m_opacity < 255 ) ) {
<br>            SetTransparent( 255 );
<br>            m_opacity = 255;
<br>        }
<br>
<br>        m_fade_timer.Start( 5000 );           // retrigger the continuous timer
<br>    }
<br>    
<br>    if(m_bAutoHideToolbar && (m_nAutoHideToolbar > 0) ){
<br>        m_fade_timer.Start( m_nAutoHideToolbar * 1000 );
<br>    }
<br>}
<br>
<br>void ocpnFloatingToolbarDialog::FadeTimerEvent( wxTimerEvent& event )
<br>{
<br>    if(m_bnavgrabber){
<br>        m_fade_timer.Start( 5000 );           // do nothing if nav grabber is shown
<br>    }
<br>    else{
<br>        if( g_bTransparentToolbar && (!g_bopengl || g_bTransparentToolbarInOpenGLOK) ){
<br>            DoFade( 128 );
<br>            m_fade_timer.Start( 5000 );           // retrigger the continuous timer
<br>        }
<br>        
<br>        if(m_bAutoHideToolbar && (m_nAutoHideToolbar > 0) && !m_bsubmerged){
<br>            SubmergeToGrabber();
<br>//            m_fade_timer.Stop();
<br>        }
<br>    }
<br>}
<br>
<br>void ocpnFloatingToolbarDialog::SetAutoHideTimer(int time)
<br>{
<br>    m_nAutoHideToolbar = time;
<br>    if(m_bAutoHideToolbar){
<br>        m_fade_timer.Stop();
<br>        m_fade_timer.Start( m_nAutoHideToolbar * 1000 );
<br>    }
<br>}
<br>        
<br>void ocpnFloatingToolbarDialog::DoFade( int value )
<br>{
<br>    if( value != m_opacity ) SetTransparent( value );
<br>    m_opacity = value;
<br>}
<br>
<br>void ocpnFloatingToolbarDialog::RefreshFadeTimer()
<br>{
<br>    SetTransparent( 255 );
<br>    m_opacity = 255;
<br>    m_fade_timer.Start( 500 );           // retrigger the continuous timer
<br>    
<br>    if(m_bAutoHideToolbar && (m_nAutoHideToolbar > 0) ){
<br>        m_fade_timer.Start( m_nAutoHideToolbar * 1000 );
<br>    }
<br>    
<br>}
<br>
<br>void ocpnFloatingToolbarDialog::MoveDialogInScreenCoords( wxPoint posn, wxPoint posn_old )
<br>{
<br>    wxPoint pos_in_parent = m_pparent->ScreenToClient( posn );
<br>    wxPoint pos_in_parent_old = m_pparent->ScreenToClient( posn_old );
<br>
<br>    //    "Docking" support
<br>#define DOCK_MARGIN 40
<br>
<br>    // X
<br>    m_dock_x = 0;
<br>    if( pos_in_parent.x < pos_in_parent_old.x )            // moving left
<br>            {
<br>        if( pos_in_parent.x < DOCK_MARGIN ) {
<br>            pos_in_parent.x = 0;
<br>            m_dock_x = -1;
<br>        }
<br>    } else
<br>        if( pos_in_parent.x > pos_in_parent_old.x )            // moving right
<br>                {
<br>            int max_right = m_pparent->GetClientSize().x - GetSize().x;
<br>            if( pos_in_parent.x > ( max_right - DOCK_MARGIN ) ) {
<br>                pos_in_parent.x = max_right;
<br>                m_dock_x = 1;
<br>            }
<br>        }
<br>
<br>    // Y
<br>    m_dock_y = 0;
<br>    if( pos_in_parent.y < pos_in_parent_old.y )            // moving up
<br>            {
<br>        if( pos_in_parent.y < DOCK_MARGIN ) {
<br>            pos_in_parent.y = 0;
<br>            m_dock_y = -1;
<br>        }
<br>    } else
<br>        if( pos_in_parent.y > pos_in_parent_old.y )            // moving down
<br>                {
<br>            int max_down = m_pparent->GetClientSize().y - GetSize().y;
<br>            if( pos_in_parent.y > ( max_down - DOCK_MARGIN ) ) {
<br>                pos_in_parent.y = max_down;
<br>                m_dock_y = 1;
<br>            }
<br>        }
<br>
<br>    m_position = pos_in_parent;
<br>
<br>    wxPoint final_pos = m_pparent->ClientToScreen( pos_in_parent );
<br>
<br>    Move( final_pos );
<br>}
<br>
<br>void ocpnFloatingToolbarDialog::Realize()
<br>{
<br>    if( m_ptoolbar ) {
<br>        m_ptoolbar->Realize();
<br>
<br>        m_topSizer->Clear();
<br>        m_topSizer->Add( m_ptoolbar );
<br>        m_topSizer->Add( m_pGrabberwin, 0, wxTOP, m_style->GetTopMargin() );
<br>
<br>        m_topSizer->Layout();
<br>        Fit();
<br>
<br>        //    Update "Dock" parameters
<br>        if( m_position.x == 0 ) m_dock_x = -1;
<br>        else
<br>            if( m_position.x == m_pparent->GetClientSize().x - GetSize().x ) m_dock_x = 1;
<br>
<br>        if( m_position.y == 0 ) m_dock_y = -1;
<br>        else
<br>            if( m_position.y == m_pparent->GetClientSize().y - GetSize().y ) m_dock_y = 1;
<br>
<br>        // Now create a bitmap mask forthe frame shape.
<br>
<br>        if( m_marginsInvisible ) {
<br>
<br>            wxSize tool_size = m_ptoolbar->GetToolBitmapSize();
<br>
<br>            //  Determine whether the tool icons are meant (by style) to join without speces between
<br>            //  This will determine what type of region to draw.
<br>            bool b_overlap = false;
<br>
<br>            wxToolBarToolsList::compatibility_iterator node1 = m_ptoolbar->m_tools.GetFirst();
<br>            wxToolBarToolsList::compatibility_iterator node2 = node1->GetNext() ;
<br>
<br>            wxToolBarToolBase *tool1 = node1->GetData();
<br>            ocpnToolBarTool *tools1 = (ocpnToolBarTool *) tool1;
<br>
<br>            wxToolBarToolBase *tool2 = node2->GetData();
<br>            ocpnToolBarTool *tools2 = (ocpnToolBarTool *) tool2;
<br>
<br>            if( (tools1->m_x + tools1->m_width) >= tools2->m_x)
<br>                b_overlap = true;
<br>
<br>
<br>
<br>
<br>            int toolCount = m_ptoolbar->GetVisibleToolCount();
<br>
<br>            wxPoint upperLeft( m_style->GetLeftMargin(), m_style->GetTopMargin() );
<br>            wxSize visibleSize;
<br>            if( m_ptoolbar->IsVertical() ) {
<br>                int noTools = m_ptoolbar->GetMaxRows();
<br>                if( noTools > toolCount )
<br>                    noTools = toolCount;
<br>                visibleSize.x = m_ptoolbar->GetLineCount() * ( tool_size.x + m_style->GetTopMargin() );
<br>                visibleSize.y = noTools * ( tool_size.y + m_style->GetToolSeparation() );
<br>                visibleSize.x -= m_style->GetTopMargin();
<br>                visibleSize.y -= m_style->GetToolSeparation();
<br>            } else {
<br>                    int noTools = m_ptoolbar->GetMaxCols();
<br>                    if( noTools > toolCount )
<br>                        noTools = toolCount;
<br>                visibleSize.x = noTools * ( tool_size.x + m_style->GetToolSeparation() );
<br>                visibleSize.y = m_ptoolbar->GetLineCount() * ( tool_size.y + m_style->GetTopMargin() );
<br>                visibleSize.x -= m_style->GetToolSeparation();
<br>                visibleSize.y -= m_style->GetTopMargin();
<br>            }
<br>
<br>            wxBitmap shape( visibleSize.x + tool_size.x, visibleSize.y + tool_size.y);          // + fluff
<br>            wxMemoryDC sdc( shape );
<br>            sdc.SetBackground( *wxWHITE_BRUSH );
<br>            sdc.SetBrush( *wxBLACK_BRUSH );
<br>            sdc.SetPen( *wxBLACK_PEN );
<br>            sdc.Clear();
<br>
<br>            if(b_overlap) {
<br>                int lines = m_ptoolbar->GetLineCount();
<br>                for( int i = 1; i <= lines; i++ ) {
<br>                    if( m_ptoolbar->IsVertical() ) {
<br>                        wxSize barsize( tool_size.x, visibleSize.y );
<br>                        if( i == lines && i > 1 ) {
<br>                            int toolsInLastLine = toolCount % m_ptoolbar->GetMaxRows();
<br>                            if( toolsInLastLine == 0 ) toolsInLastLine = m_ptoolbar->GetMaxRows();
<br>                            int emptySpace = ( m_ptoolbar->GetMaxRows() - toolsInLastLine );
<br>                            barsize.y -= emptySpace
<br>                            * ( tool_size.y + m_style->GetToolSeparation() );
<br>                        }
<br>                        if( i == lines ) {
<br>                            // Also do grabber here, since it is to the right of the last line.
<br>                            wxRect grabMask( upperLeft, barsize );
<br>                            grabMask.width += m_style->GetIcon( _T("grabber") ).GetWidth();
<br>                            grabMask.height = m_style->GetIcon( _T("grabber") ).GetHeight();
<br>                            sdc.DrawRoundedRectangle( grabMask, m_style->GetToolbarCornerRadius() );
<br>                        }
<br>                        sdc.DrawRoundedRectangle( upperLeft, barsize,
<br>                                m_style->GetToolbarCornerRadius() );
<br>                        upperLeft.x += m_style->GetTopMargin() + tool_size.x;
<br>                    } else {
<br>                        wxSize barsize( visibleSize.x, tool_size.y );
<br>
<br>                        if( i == 1 ) {
<br>                            barsize.x += m_style->GetIcon( _T("grabber") ).GetWidth();
<br>                        }
<br>                        if( i == lines && i > 1 ) {
<br>                            int toolsInLastLine = toolCount % m_ptoolbar->GetMaxCols();
<br>                            if( toolsInLastLine == 0 ) toolsInLastLine = m_ptoolbar->GetMaxCols();
<br>                            int emptySpace = ( m_ptoolbar->GetMaxCols() - toolsInLastLine );
<br>                            barsize.x -= emptySpace * ( tool_size.x + m_style->GetToolSeparation() );
<br>                        }
<br>
<br>                        sdc.DrawRoundedRectangle( upperLeft, barsize,
<br>                                m_style->GetToolbarCornerRadius() );
<br>                        upperLeft.y += m_style->GetTopMargin() + tool_size.y;
<br>                    }
<br>                }
<br>            } //b_overlap
<br>            else {
<br>                for( wxToolBarToolsList::compatibility_iterator node = m_ptoolbar->m_tools.GetFirst(); node; node = node->GetNext() ) {
<br>                    wxToolBarToolBase *tool = node->GetData();
<br>                    ocpnToolBarTool *tools = (ocpnToolBarTool *) tool;
<br>                    wxRect toolRect = tools->trect;
<br>
<br>                    sdc.DrawRoundedRectangle( tools->m_x, tools->m_y, tool_size.x, tool_size.y,
<br>                                              m_style->GetToolbarCornerRadius() );
<br>                }
<br>            }
<br>
<br>#ifndef __OCPN__ANDROID__
<br>            if(shape.GetWidth() && shape.GetHeight())
<br>                SetShape( wxRegion( shape, *wxWHITE, 10 ) );
<br>#endif
<br>        }
<br>    }
<br>}
<br>
<br>void ocpnFloatingToolbarDialog::OnToolLeftClick( wxCommandEvent& event )
<br>{
<br>    // First see if it was actually the context menu that was clicked.
<br>
<br>    if( event.GetId() >= ID_PLUGIN_BASE + 100 ) {
<br>
<br>        int itemId = event.GetId() - ID_PLUGIN_BASE - 100;
<br>        wxMenuItem *item = g_FloatingToolbarConfigMenu->FindItem( event.GetId() );
<br>
<br>        if(item){
<br>            bool toolIsChecked = item->IsChecked();
<br>
<br>            if( toolIsChecked ) {
<br>                g_toolbarConfig.SetChar( itemId, _T('X') );
<br>            } else {
<br>
<br>                if( itemId + ID_ZOOMIN == ID_MOB ) {
<br>                    ToolbarMOBDialog mdlg( this );
<br>                    int dialog_ret = mdlg.ShowModal();
<br>                    int answer = mdlg.GetSelection();
<br>
<br>                    if( answer == 0 || answer == 1 || dialog_ret == wxID_CANCEL ) {
<br>                        g_FloatingToolbarConfigMenu->FindItem( event.GetId() )->Check( true );
<br>                        if( answer == 1 && dialog_ret == wxID_OK ) {
<br>                            g_bPermanentMOBIcon = true;
<br>                            delete g_FloatingToolbarConfigMenu;
<br>                            g_FloatingToolbarConfigMenu = new wxMenu();
<br>                            toolbarConfigChanged = true;
<br>                        }
<br>                        return;
<br>                    }
<br>                }
<br>
<br>                if( m_ptoolbar->GetVisibleToolCount() == 1 ) {
<br>                    OCPNMessageBox( this,
<br>                            _("You can't hide the last tool from the toolbar\nas this would make it inaccessible."),
<br>                            _("OpenCPN Alert"), wxOK );
<br>                    g_FloatingToolbarConfigMenu->FindItem( event.GetId() )->Check( true );
<br>                    return;
<br>                }
<br>
<br>                g_toolbarConfig.SetChar( itemId, _T('.') );
<br>            }
<br>        }
<br>
<br>        toolbarConfigChanged = true;
<br>        return;
<br>    }
<br>
<br>    // No it was a button that was clicked.
<br>    // Since Dialog events don't propagate automatically, we send it explicitly
<br>    // (instead of relying on event.Skip()). Send events up the window hierarchy
<br>
<br>    m_pparent->GetEventHandler()->AddPendingEvent( event );
<br>#ifndef __WXQT__
<br>    gFrame->Raise();
<br>#endif    
<br>}
<br>
<br>ocpnToolBarSimple *ocpnFloatingToolbarDialog::GetToolbar()
<br>{
<br>    if( !m_ptoolbar ) {
<br>        long winstyle = wxNO_BORDER | wxTB_FLAT;
<br>        winstyle |= m_orient;
<br>
<br>        m_ptoolbar = new ocpnToolBarSimple( this, -1, wxPoint( -1, -1 ), wxSize( -1, -1 ),
<br>                winstyle );
<br>
<br>        m_ptoolbar->SetBackgroundColour( GetGlobalColor( _T("GREY2") ) );
<br>        m_ptoolbar->ClearBackground();
<br>        m_ptoolbar->SetToggledBackgroundColour( GetGlobalColor( _T("GREY1") ) );
<br>        m_ptoolbar->SetColorScheme( m_cs );
<br>
<br>        SetGeometry(false, wxRect());
<br>    }
<br>
<br>    return m_ptoolbar;
<br>}
<br>
<br>void ocpnFloatingToolbarDialog::DestroyToolBar()
<br>{
<br>    if( m_ptoolbar ) {
<br>        m_ptoolbar->ClearTools();
<br>        delete m_ptoolbar;                  //->Destroy();
<br>        m_ptoolbar = NULL;
<br>    }
<br> 
<br>    m_destroyGrabber = m_pRecoverwin;
<br>    m_destroyTimer.Start( 5, wxTIMER_ONE_SHOT );           //  Destor the unneeded recovery grabber
<br>    
<br>}
<br>
<br>//----------------------------------------------------------------------------
<br>// Toolbar Tooltip Popup Window Definition
<br>//----------------------------------------------------------------------------
<br>class ToolTipWin: public wxDialog {
<br>public:
<br>    ToolTipWin( wxWindow *parent );
<br>    ~ToolTipWin();
<br>
<br>    void OnPaint( wxPaintEvent& event );
<br>
<br>    void SetColorScheme( ColorScheme cs );
<br>    void SetString( wxString &s )
<br>    {
<br>        m_string = s;
<br>    }
<br>    void SetPosition( wxPoint pt )
<br>    {
<br>        m_position = pt;
<br>    }
<br>    void SetBitmap( void );
<br>
<br>    void SetHiviz( bool hiviz){ m_hiviz = hiviz; }
<br>    
<br>    wxSize GetRenderedSize( void );
<br>    
<br>private:
<br>
<br>    wxString m_string;
<br>    wxSize m_size;
<br>    wxPoint m_position;
<br>    wxBitmap *m_pbm;
<br>    wxColour m_back_color;
<br>    wxColour m_text_color;
<br>    ColorScheme m_cs ;
<br>    bool m_hiviz;
<br>
<br>DECLARE_EVENT_TABLE()
<br>};
<br>//-----------------------------------------------------------------------
<br>//
<br>//    Toolbar Tooltip window implementation
<br>//
<br>//-----------------------------------------------------------------------
<br>BEGIN_EVENT_TABLE(ToolTipWin, wxDialog) EVT_PAINT(ToolTipWin::OnPaint)
<br>
<br>END_EVENT_TABLE()
<br>
<br>// Define a constructor
<br>ToolTipWin::ToolTipWin( wxWindow *parent ) :
<br>        wxDialog( parent, wxID_ANY, _T(""), wxPoint( 0, 0 ), wxSize( 1, 1 ),
<br>                wxNO_BORDER | wxSTAY_ON_TOP )
<br>{
<br>    m_pbm = NULL;
<br>
<br>    m_back_color = GetGlobalColor( _T ( "UIBCK" ) );
<br>    m_text_color = GetGlobalColor( _T ( "UITX1" ) );
<br>
<br>    SetBackgroundStyle( wxBG_STYLE_CUSTOM );
<br>    SetBackgroundColour( m_back_color );
<br>    m_cs = GLOBAL_COLOR_SCHEME_RGB;
<br>
<br>    Hide();
<br>}
<br>
<br>ToolTipWin::~ToolTipWin()
<br>{
<br>    delete m_pbm;
<br>}
<br>
<br>void ToolTipWin::SetColorScheme( ColorScheme cs )
<br>{
<br>    m_back_color = GetGlobalColor( _T ( "UIBCK" ) );
<br>    m_text_color = FontMgr::Get().GetFontColor( _("ToolTips") );
<br>
<br>    m_cs = cs;
<br>}
<br>
<br>wxSize ToolTipWin::GetRenderedSize( void )
<br>{
<br>    int h, w;
<br>    wxSize sz;
<br>
<br>    wxClientDC cdc( GetParent() );
<br>
<br>    wxFont *plabelFont = FontMgr::Get().GetFont( _("ToolTips") );
<br>    cdc.GetTextExtent( m_string, &w, &h, NULL, NULL, plabelFont );
<br>
<br>    sz.x = w + 8;
<br>    sz.y = h + 4;
<br>    
<br>    return sz;
<br>
<br>}
<br>
<br>void ToolTipWin::SetBitmap()
<br>{
<br>    int h, w;
<br>
<br>    wxClientDC cdc( GetParent() );
<br>
<br>    wxFont *plabelFont = FontMgr::Get().GetFont( _("ToolTips") );
<br>    cdc.GetTextExtent( m_string, &w, &h, NULL, NULL, plabelFont );
<br>
<br>    m_size.x = w + 8;
<br>    m_size.y = h + 4;
<br>
<br>    wxMemoryDC mdc;
<br>
<br>    delete m_pbm;
<br>    m_pbm = new wxBitmap( m_size.x, m_size.y, -1 );
<br>    mdc.SelectObject( *m_pbm );
<br>
<br>    wxPen pborder( m_text_color );
<br>    wxBrush bback( m_back_color );
<br>    mdc.SetPen( pborder );
<br>    mdc.SetBrush( bback );
<br>
<br>    if(m_hiviz){
<br>        if((m_cs == GLOBAL_COLOR_SCHEME_DUSK) || (m_cs == GLOBAL_COLOR_SCHEME_NIGHT)){
<br>            wxBrush hv_back( wxColour(200,200,200));
<br>            mdc.SetBrush( hv_back );
<br>        }
<br>    }
<br>    mdc.DrawRectangle( 0, 0, m_size.x, m_size.y );
<br>
<br>    //    Draw the text
<br>    mdc.SetFont( *plabelFont );
<br>    mdc.SetTextForeground( m_text_color );
<br>    mdc.SetTextBackground( m_back_color );
<br>
<br>    mdc.DrawText( m_string, 4, 2 );
<br>
<br>    SetSize( m_position.x, m_position.y, m_size.x, m_size.y );
<br>
<br>}
<br>
<br>void ToolTipWin::OnPaint( wxPaintEvent& event )
<br>{
<br>    int width, height;
<br>    GetClientSize( &width, &height );
<br>    wxPaintDC dc( this );
<br>
<br>    if( m_string.Len() ) {
<br>        wxMemoryDC mdc;
<br>        mdc.SelectObject( *m_pbm );
<br>        dc.Blit( 0, 0, width, height, &mdc, 0, 0 );
<br>    }
<br>}
<br>
<br>
<br>// ----------------------------------------------------------------------------
<br>BEGIN_EVENT_TABLE(ocpnToolBarSimple, wxControl) EVT_SIZE(ocpnToolBarSimple::OnSize)
<br>EVT_PAINT(ocpnToolBarSimple::OnPaint)
<br>EVT_KILL_FOCUS(ocpnToolBarSimple::OnKillFocus)
<br>EVT_MOUSE_EVENTS(ocpnToolBarSimple::OnMouseEvent)
<br>EVT_TIMER(TOOLTIPON_TIMER, ocpnToolBarSimple::OnToolTipTimerEvent)
<br>EVT_TIMER(TOOLTIPOFF_TIMER, ocpnToolBarSimple::OnToolTipOffTimerEvent)
<br>
<br>END_EVENT_TABLE()
<br>
<br>// ============================================================================
<br>// implementation
<br>// ============================================================================
<br>
<br>// ----------------------------------------------------------------------------
<br>// tool bar tools creation
<br>// ----------------------------------------------------------------------------
<br>
<br>wxToolBarToolBase *ocpnToolBarSimple::CreateTool( int id, const wxString& label,
<br>        const wxBitmap& bmpNormal, const wxBitmap& bmpDisabled, wxItemKind kind,
<br>        wxObject *clientData, const wxString& shortHelp, const wxString& longHelp )
<br>{
<br>    return new ocpnToolBarTool( this, id, label, bmpNormal, bmpDisabled, kind, clientData,
<br>            shortHelp, longHelp );
<br>}
<br>
<br>// ----------------------------------------------------------------------------
<br>// ocpnToolBarSimple creation
<br>// ----------------------------------------------------------------------------
<br>
<br>void ocpnToolBarSimple::Init()
<br>{
<br>    m_currentRowsOrColumns = 0;
<br>
<br>    m_lastX = m_lastY = 0;
<br>
<br>    m_maxWidth = m_maxHeight = 0;
<br>
<br>    m_pressedTool = m_currentTool = -1;
<br>
<br>    m_xPos = m_yPos = wxDefaultCoord;
<br>
<br>    m_style = g_StyleManager->GetCurrentStyle();
<br>
<br>    m_defaultWidth = 16;
<br>    m_defaultHeight = 15;
<br>
<br>    m_toggle_bg_color = wxSystemSettings::GetColour( wxSYS_COLOUR_3DFACE );
<br>    m_toolOutlineColour.Set( _T("BLACK") );
<br>    m_pToolTipWin = NULL;
<br>    m_last_ro_tool = NULL;
<br>
<br>    m_btoolbar_is_zooming = false;
<br>    m_sizefactor = 1.0f;
<br>
<br>    m_last_plugin_down_id = -1;
<br>    
<br>    EnableTooltips();
<br>}
<br>
<br>wxToolBarToolBase *ocpnToolBarSimple::DoAddTool( int id, const wxString& label,
<br>        const wxBitmap& bitmap, const wxBitmap& bmpDisabled, wxItemKind kind,
<br>        const wxString& shortHelp, const wxString& longHelp, wxObject *clientData, wxCoord xPos,
<br>        wxCoord yPos )
<br>{
<br>    // rememeber the position for DoInsertTool()
<br>    m_xPos = xPos;
<br>    m_yPos = yPos;
<br>
<br>    InvalidateBestSize();
<br>    return InsertTool( GetToolsCount(), id, label, bitmap, bmpDisabled, kind, shortHelp, longHelp,
<br>            clientData );
<br>
<br>}
<br>
<br>///
<br>
<br>wxToolBarToolBase *ocpnToolBarSimple::AddTool( int toolid, const wxString& label,
<br>        const wxBitmap& bitmap, const wxBitmap& bmpDisabled, wxItemKind kind,
<br>        const wxString& shortHelp, const wxString& longHelp, wxObject *data )
<br>{
<br>    InvalidateBestSize();
<br>    ocpnToolBarTool* tool = (ocpnToolBarTool*)InsertTool( GetToolsCount(), toolid, label, bitmap, bmpDisabled, kind,
<br>            shortHelp, longHelp, data );
<br>    return tool;
<br>}
<br>
<br>wxToolBarToolBase *ocpnToolBarSimple::InsertTool( size_t pos, int id, const wxString& label,
<br>        const wxBitmap& bitmap, const wxBitmap& bmpDisabled, wxItemKind kind,
<br>        const wxString& shortHelp, const wxString& longHelp, wxObject *clientData )
<br>{
<br>    wxCHECK_MSG( pos <= GetToolsCount(), (wxToolBarToolBase *)NULL,
<br>            _T("invalid position in wxToolBar::InsertTool()") );
<br>
<br>    wxToolBarToolBase *tool = CreateTool( id, label, bitmap, bmpDisabled, kind, clientData,
<br>            shortHelp, longHelp );
<br>
<br>    if( !InsertTool( pos, tool ) ) {
<br>        delete tool;
<br>
<br>        return NULL;
<br>    }
<br>
<br>    return tool;
<br>}
<br>
<br>wxToolBarToolBase *ocpnToolBarSimple::InsertTool( size_t pos, wxToolBarToolBase *tool )
<br>{
<br>    wxCHECK_MSG( pos <= GetToolsCount(), (wxToolBarToolBase *)NULL,
<br>            _T("invalid position in wxToolBar::InsertTool()") );
<br>
<br>    if( !tool || !DoInsertTool( pos, tool ) ) {
<br>        return NULL;
<br>    }
<br>
<br>    m_tools.Insert( pos, tool );
<br>
<br>    return tool;
<br>}
<br>
<br>bool ocpnToolBarSimple::DoInsertTool( size_t WXUNUSED(pos), wxToolBarToolBase *toolBase )
<br>{
<br>    ocpnToolBarTool *tool = (ocpnToolBarTool *) toolBase;
<br>
<br>    // Check if the plugin is inserting same-named tools. Make sure they have different names,
<br>    // otherwise the style manager cannot differentiate between them.
<br>    if( tool->isPluginTool ) {
<br>        for( unsigned int i=0; i<GetToolsCount(); i++ ) {
<br>            if( tool->GetToolname() == ((ocpnToolBarTool *)m_tools.Item(i)->GetData())->GetToolname()) {
<br>                tool->toolname << _T("1");
<br>            }
<br>        }
<br>    }
<br>
<br>    tool->m_x = m_xPos;
<br>    if( tool->m_x == wxDefaultCoord ) tool->m_x = m_style->GetLeftMargin();
<br>
<br>    tool->m_y = m_yPos;
<br>    if( tool->m_y == wxDefaultCoord ) tool->m_y = m_style->GetTopMargin();
<br>
<br>    if( tool->IsButton() ) {
<br>        tool->SetSize( GetToolSize() );
<br>
<br>        // Calculate reasonable max size in case Layout() not called
<br>        if( ( tool->m_x + tool->GetNormalBitmap().GetWidth() + m_style->GetLeftMargin() )
<br>                > m_maxWidth ) m_maxWidth = (wxCoord) ( ( tool->m_x + tool->GetWidth()
<br>                + m_style->GetLeftMargin() ) );
<br>
<br>        if( ( tool->m_y + tool->GetNormalBitmap().GetHeight() + m_style->GetTopMargin() )
<br>                > m_maxHeight ) m_maxHeight = (wxCoord) ( ( tool->m_y + tool->GetHeight()
<br>                + m_style->GetTopMargin() ) );
<br>    }
<br>
<br>    else
<br>        if( tool->IsControl() ) {
<br>            tool->SetSize( tool->GetControl()->GetSize() );
<br>        }
<br>
<br>    tool->b_hilite = false;
<br>
<br>    return true;
<br>}
<br>
<br>bool ocpnToolBarSimple::DoDeleteTool( size_t WXUNUSED(pos), wxToolBarToolBase *tool )
<br>{
<br>    // VZ: didn't test whether it works, but why not...
<br>    tool->Detach();
<br>
<br>    if( m_last_ro_tool == tool ) m_last_ro_tool = NULL;
<br>
<br>    Refresh( false );
<br>
<br>    return true;
<br>}
<br>
<br>bool ocpnToolBarSimple::Create( wxWindow *parent, wxWindowID id, const wxPoint& pos,
<br>        const wxSize& size, long style, const wxString& name )
<br>{
<br>    if( !wxWindow::Create( parent, id, pos, size, style, name ) ) return false;
<br>
<br>    // Set it to grey (or other 3D face colour)
<br>    SetBackgroundColour( wxSystemSettings::GetColour( wxSYS_COLOUR_3DFACE ) );
<br>
<br>    if( GetWindowStyleFlag() & wxTB_VERTICAL ) {
<br>        m_lastX = 7;
<br>        m_lastY = 3;
<br>
<br>        m_maxRows = 32000;      // a lot
<br>        m_maxCols = 1;
<br>    } else {
<br>        m_lastX = 3;
<br>        m_lastY = 7;
<br>
<br>        m_maxRows = 1;
<br>        m_maxCols = 32000;      // a lot
<br>    }
<br>
<br>    SetCursor( *wxSTANDARD_CURSOR );
<br>
<br>    m_tooltip_timer.SetOwner( this, TOOLTIPON_TIMER );
<br>    m_tooltipoff_timer.SetOwner( this, TOOLTIPOFF_TIMER );
<br>    m_tooltip_off = 3000;
<br>
<br>    return true;
<br>}
<br>
<br>ocpnToolBarSimple::~ocpnToolBarSimple()
<br>{
<br>    if( m_pToolTipWin ) {
<br>        m_pToolTipWin->Destroy();
<br>        m_pToolTipWin = NULL;
<br>    }
<br>
<br>}
<br>
<br>void ocpnToolBarSimple::KillTooltip()
<br>{
<br>    m_btooltip_show = false;
<br>
<br>    if( m_pToolTipWin ) {
<br>        m_pToolTipWin->Hide();
<br>        m_pToolTipWin->Destroy();
<br>        m_pToolTipWin = NULL;
<br>    }
<br>    m_tooltip_timer.Stop();
<br>
<br>    if( m_last_ro_tool ) {
<br>        if( m_last_ro_tool->IsEnabled() ) {
<br>            if( m_last_ro_tool->IsToggled() ) {
<br>                m_last_ro_tool->SetNormalBitmap( m_style->GetToolIcon( m_last_ro_tool->GetToolname(), TOOLICON_TOGGLED ) );
<br>            }
<br>            else {
<br>                m_last_ro_tool->SetNormalBitmap( m_style->GetToolIcon( m_last_ro_tool->GetToolname(), TOOLICON_NORMAL ) );
<br>            }
<br>        }
<br>    }
<br>}
<br>
<br>void ocpnToolBarSimple::HideTooltip()
<br>{
<br>    if( m_pToolTipWin ) {
<br>        m_pToolTipWin->Hide();
<br>    }
<br>}
<br>
<br>void ocpnToolBarSimple::SetColorScheme( ColorScheme cs )
<br>{
<br>    if( m_pToolTipWin ) {
<br>        m_pToolTipWin->Destroy();
<br>        m_pToolTipWin = NULL;
<br>    }
<br>
<br>    m_toolOutlineColour = GetGlobalColor( _T("UIBDR") );
<br>
<br>    m_currentColorScheme = cs;
<br>}
<br>
<br>bool ocpnToolBarSimple::Realize()
<br>{
<br>    m_currentRowsOrColumns = 0;
<br>    m_LineCount = 1;
<br>    m_lastX = m_style->GetLeftMargin();
<br>    m_lastY = m_style->GetTopMargin();
<br>    m_maxWidth = 0;
<br>    m_maxHeight = 0;
<br>
<br>    if( IsVertical() ) m_style->SetOrientation( wxTB_VERTICAL );
<br>    else
<br>        m_style->SetOrientation( wxTB_HORIZONTAL );
<br>
<br>    wxSize toolSize = wxSize(-1, -1);
<br>    int separatorSize = m_style->GetToolSeparation();
<br>
<br>    ocpnToolBarTool *lastTool = NULL;
<br>    bool firstNode = true;
<br>    wxToolBarToolsList::compatibility_iterator node = m_tools.GetFirst();
<br>
<br>    while( node ) {
<br>        ocpnToolBarTool *tool = (ocpnToolBarTool *) node->GetData();
<br>
<br>        // Set the tool size to be the size of the first non-separator tool, usually the first one
<br>        if(toolSize.x == -1){
<br>            if( !tool->IsSeparator() ){
<br>                toolSize.x = tool->m_width;
<br>                toolSize.y = tool->m_height;
<br>            }
<br>        }
<br>
<br>        tool->firstInLine = firstNode;
<br>        tool->lastInLine = false;
<br>        firstNode = false;
<br>
<br>        tool->last_rect.width = 0;              // mark it invalid
<br>        
<br>        if( tool->IsSeparator() ) {
<br>            if( GetWindowStyleFlag() & wxTB_HORIZONTAL ) {
<br>                if( m_currentRowsOrColumns >= m_maxCols ) m_lastY += separatorSize;
<br>                else
<br>                    m_lastX += separatorSize;
<br>            } else {
<br>                if( m_currentRowsOrColumns >= m_maxRows ) m_lastX += separatorSize;
<br>                else
<br>                    m_lastY += separatorSize;
<br>            }
<br>        } else
<br>            if( tool->IsButton() ) {
<br>                if( !IsVertical() ) {
<br>                    if( m_currentRowsOrColumns >= m_maxCols ) {
<br>                        tool->firstInLine = true;
<br>                        if( lastTool && m_LineCount > 1 ) lastTool->lastInLine = true;
<br>                        m_LineCount++;
<br>                        m_currentRowsOrColumns = 0;
<br>                        m_lastX = m_style->GetLeftMargin();
<br>                        m_lastY += toolSize.y + m_style->GetTopMargin();
<br>                    }
<br>                    tool->m_x = (wxCoord) m_lastX;
<br>                    tool->m_y = (wxCoord) m_lastY;
<br>
<br>                    tool->trect = wxRect( tool->m_x, tool->m_y, toolSize.x, toolSize.y );
<br>                    tool->trect.Inflate( m_style->GetToolSeparation() / 2,
<br>                            m_style->GetTopMargin() );
<br>
<br>                    m_lastX += toolSize.x + m_style->GetToolSeparation();
<br>                } else {
<br>                    if( m_currentRowsOrColumns >= m_maxRows ) {
<br>                        tool->firstInLine = true;
<br>                        if( lastTool ) lastTool->lastInLine = true;
<br>                        m_LineCount++;
<br>                        m_currentRowsOrColumns = 0;
<br>                        m_lastX += toolSize.x + m_style->GetTopMargin();
<br>                        m_lastY = m_style->GetTopMargin();
<br>                    }
<br>                    tool->m_x = (wxCoord) m_lastX;
<br>                    tool->m_y = (wxCoord) m_lastY;
<br>
<br>                    tool->trect = wxRect( tool->m_x, tool->m_y, toolSize.x, toolSize.y );
<br>                    tool->trect.Inflate( m_style->GetToolSeparation() / 2,
<br>                            m_style->GetTopMargin() );
<br>
<br>                    m_lastY += toolSize.y + m_style->GetToolSeparation();
<br>                }
<br>                m_currentRowsOrColumns++;
<br>            } else
<br>                if( tool->IsControl() ) {
<br>                    tool->m_x = (wxCoord) ( m_lastX );
<br>                    tool->m_y = (wxCoord) ( m_lastY - ( m_style->GetTopMargin() / 2 ) );
<br>
<br>                    tool->trect = wxRect( tool->m_x, tool->m_y, tool->GetWidth(),
<br>                            tool->GetHeight() );
<br>                    tool->trect.Inflate( m_style->GetToolSeparation() / 2,
<br>                            m_style->GetTopMargin() );
<br>                    ;
<br>
<br>                    wxSize s = tool->GetControl()->GetSize();
<br>                    m_lastX += s.x + m_style->GetToolSeparation();
<br>
<br>                }
<br>
<br>        if( m_lastX > m_maxWidth ) m_maxWidth = m_lastX;
<br>        if( m_lastY > m_maxHeight ) m_maxHeight = m_lastY;
<br>
<br>        lastTool = tool;
<br>        node = node->GetNext();
<br>    }
<br>    if( lastTool && (m_LineCount > 1 || IsVertical()) )
<br>        lastTool->lastInLine = true;
<br>
<br>    if( GetWindowStyleFlag() & wxTB_HORIZONTAL ) m_maxHeight += toolSize.y;
<br>    else
<br>        m_maxWidth += toolSize.x;
<br>
<br>    m_maxWidth += m_style->GetRightMargin();
<br>    m_maxHeight += m_style->GetBottomMargin();
<br>
<br>    SetSize( m_maxWidth, m_maxHeight );
<br>    SetMinSize( wxSize( m_maxWidth, m_maxHeight ) );
<br>
<br>    return true;
<br>}
<br>
<br>// ----------------------------------------------------------------------------
<br>// event handlers
<br>// ----------------------------------------------------------------------------
<br>
<br>void ocpnToolBarSimple::OnPaint( wxPaintEvent& WXUNUSED(event) )
<br>{
<br>    wxPaintDC dc( this );
<br>    PrepareDC( dc );
<br>
<br>    wxRegion ru = GetUpdateRegion();
<br>    wxRect upRect = ru.GetBox();
<br>
<br>    static int count = 0;
<br>    // Prevent reentry of OnPaint which would cause wxMemoryDC errors.
<br>    if( count > 0 ) return;
<br>    count++;
<br>
<br>    for( wxToolBarToolsList::compatibility_iterator node = m_tools.GetFirst(); node;
<br>            node = node->GetNext() ) {
<br>        wxToolBarToolBase *tool = node->GetData();
<br>        ocpnToolBarTool *tools = (ocpnToolBarTool *) tool;
<br>        wxRect toolRect = tools->trect;
<br>
<br>        if( toolRect.Intersects( upRect ) ) {
<br>
<br>            if( tool->IsButton() ) {
<br>                DrawTool( dc, tool );
<br>            } else
<br>                if( tool->IsControl() ) {
<br>                    if( tool->GetControl()->IsKindOf( CLASSINFO(wxStaticBitmap) ) ) {
<br>                        wxStaticBitmap *psbm = (wxStaticBitmap *) tool->GetControl();
<br>                        ocpnToolBarTool *toolsimp = (ocpnToolBarTool *) tool;
<br>                        dc.DrawBitmap( psbm->GetBitmap(), toolsimp->m_x, toolsimp->m_y, false );
<br>                    }
<br>                }
<br>        }
<br>    }
<br>
<br>    count--;
<br>}
<br>
<br>void ocpnToolBarSimple::OnSize( wxSizeEvent& WXUNUSED(event) )
<br>{
<br>    if( GetAutoLayout() ) Layout();
<br>}
<br>
<br>void ocpnToolBarSimple::OnKillFocus( wxFocusEvent& WXUNUSED(event) )
<br>{
<br>    OnMouseEnter( m_pressedTool = m_currentTool = -1 );
<br>}
<br>
<br>void ocpnToolBarSimple::OnToolTipTimerEvent( wxTimerEvent& event )
<br>{
<br>    if( !gFrame->IsActive() ) return;
<br>
<br>    if( m_btooltip_show && IsShown() && m_pToolTipWin && ( !m_pToolTipWin->IsShown() ) ) {
<br>        if( m_last_ro_tool ) {
<br>            wxString s = m_last_ro_tool->GetShortHelp();
<br>
<br>            if( s.Len() ) {
<br>                m_pToolTipWin->SetString( s );
<br>                m_pToolTipWin->SetHiviz(m_last_ro_tool->m_btooltip_hiviz);
<br>
<br>                wxPoint pos_in_toolbar( m_last_ro_tool->m_x, m_last_ro_tool->m_y );
<br>                pos_in_toolbar.x += m_last_ro_tool->m_width + 2;
<br>
<br>                m_pToolTipWin->Move(0,0);       // workaround for gtk autocentre dialog behavior
<br>
<br>                wxPoint screenPosition = ClientToScreen( pos_in_toolbar );
<br>                wxPoint framePosition = gFrame->ScreenToClient(screenPosition);
<br>                wxSize tipSize = m_pToolTipWin->GetRenderedSize();
<br>                
<br>                if( (framePosition.x + tipSize.x) > gFrame->GetSize().x)
<br>                    screenPosition.x -= (tipSize.x + m_last_ro_tool->m_width + 4);
<br>                
<br>                m_pToolTipWin->SetPosition( screenPosition );
<br>                m_pToolTipWin->SetBitmap();
<br>                m_pToolTipWin->Show();
<br>                gFrame->Raise();
<br>                if( g_btouch )
<br>                    m_tooltipoff_timer.Start(m_tooltip_off, wxTIMER_ONE_SHOT);
<br>            }
<br>        }
<br>    }
<br>}
<br>
<br>void ocpnToolBarSimple::OnToolTipOffTimerEvent( wxTimerEvent& event )
<br>{
<br>    HideTooltip();
<br>}
<br>
<br>
<br>int s_dragx, s_dragy;
<br>
<br>void ocpnToolBarSimple::OnMouseEvent( wxMouseEvent & event )
<br>{
<br>#ifdef __OCPN__ANDROID__
<br>    if(!event.IsButton())
<br>        return;
<br>#endif
<br>
<br>    wxCoord x, y;
<br>    event.GetPosition( &x, &y );
<br>    ocpnToolBarTool *tool = (ocpnToolBarTool *) FindToolForPosition( x, y );
<br>
<br>#ifndef __OCPN__ANDROID__
<br>    if( event.LeftDown() ) {
<br>        CaptureMouse();
<br>        s_dragx = x;
<br>        s_dragy = y;
<br>    }
<br>    if( event.LeftUp() ) {
<br>        if( HasCapture() ) ReleaseMouse();
<br>    }
<br>#endif
<br>
<br>    if( tool && tool->IsButton() && IsShown() ) {
<br>
<br>        //    ToolTips
<br>        if( NULL == m_pToolTipWin ) {
<br>            m_pToolTipWin = new ToolTipWin( GetParent() );
<br>            m_pToolTipWin->SetColorScheme( m_currentColorScheme );
<br>            m_pToolTipWin->Hide();
<br>        }
<br>
<br>        if( tool != m_last_ro_tool ) m_pToolTipWin->Hide();
<br>
<br>#ifndef __OCPN__ANDROID__
<br>        if( !m_pToolTipWin->IsShown() ) {
<br>            m_tooltip_timer.Start( m_one_shot, wxTIMER_ONE_SHOT );
<br>        }
<br>#endif
<br>
<br>        //    Tool Rollover highlighting
<br>        if(!g_btouch){
<br>            if( tool != m_last_ro_tool ) {
<br>                if( tool->IsEnabled() ) {
<br>                    tool->rollover = true;
<br>                    tool->bitmapOK = false;
<br>                }
<br>                if( m_last_ro_tool ) {
<br>                    if( m_last_ro_tool->IsEnabled() ) {
<br>                        m_last_ro_tool->rollover = false;
<br>                        m_last_ro_tool->bitmapOK = false;
<br>                    }
<br>                }
<br>                m_last_ro_tool = tool;
<br>                if(g_toolbar)
<br>                    g_toolbar->Refresh( false );
<br>            }
<br>        }
<br>    } else {
<br>        //    Tooltips
<br>        if( m_pToolTipWin && m_pToolTipWin->IsShown() ) m_pToolTipWin->Hide();
<br>
<br>        //    Remove Highlighting
<br>        if( m_last_ro_tool ) {
<br>            if( m_last_ro_tool->IsEnabled() ) {
<br>                m_last_ro_tool->rollover = false;
<br>                m_last_ro_tool->bitmapOK = false;
<br>            }
<br>            g_toolbar->Refresh( false );
<br>        }
<br>    }
<br>
<br>    m_last_ro_tool = tool;
<br>
<br>    // allow smooth zooming while toolbutton is held down
<br>    if(g_bsmoothpanzoom && !g_btouch) {
<br>        if(event.LeftUp() && m_btoolbar_is_zooming) {
<br>            cc1->StopMovement();
<br>            m_btoolbar_is_zooming = false;
<br>            return;
<br>        }
<br>
<br>        if( event.LeftDown() && tool &&
<br>            (tool->GetId() == ID_ZOOMIN || tool->GetId() == ID_ZOOMOUT) ) {
<br>            cc1->ZoomCanvas( tool->GetId() == ID_ZOOMIN ? 2.0 : .5, false, false );
<br>            m_btoolbar_is_zooming = true;
<br>            return;
<br>        }
<br>    }
<br>
<br>    if( !tool ) {
<br>        if( m_currentTool > -1 ) {
<br>            if( event.LeftIsDown() ) SpringUpButton( m_currentTool );
<br>            m_currentTool = -1;
<br>            OnMouseEnter( -1 );
<br>        }
<br>
<br>        wxMouseEvent *pev = (wxMouseEvent *) event.Clone();
<br>        GetParent()->GetEventHandler()->AddPendingEvent( *pev );
<br>        wxDELETE( pev );
<br>
<br>        return;
<br>    }
<br>
<br>    if( !event.IsButton() ) {
<br>        if( tool->GetId() != m_currentTool ) {
<br>            // If the left button is kept down and moved over buttons,
<br>            // press those buttons.
<br>            if( event.LeftIsDown() && tool->IsEnabled() ) {
<br>                SpringUpButton( m_currentTool );
<br>
<br>                if( tool->CanBeToggled() ) {
<br>                    tool->Toggle();
<br>                }
<br>
<br>                DrawTool( tool );
<br>            }
<br>
<br>            m_currentTool = tool->GetId();
<br>            OnMouseEnter( m_currentTool );
<br>        }
<br>
<br>        wxMouseEvent *pev = (wxMouseEvent *) event.Clone();
<br>        GetParent()->GetEventHandler()->AddPendingEvent( *pev );
<br>        wxDELETE( pev );
<br>
<br>        return;
<br>    }
<br>
<br>    // Left button pressed.
<br>    if( event.LeftDown() && tool->IsEnabled() ) {
<br>        if( tool->CanBeToggled() ) {
<br>            tool->Toggle();
<br>            tool->bitmapOK = false;
<br>            
<br>        }
<br>
<br>        DrawTool( tool );
<br>
<br>        //        Look for PlugIn tools
<br>        //        If found, make the callback.
<br>        if( g_pi_manager ) {
<br>            ArrayOfPlugInToolbarTools tool_array = g_pi_manager->GetPluginToolbarToolArray();
<br>            for( unsigned int i = 0; i < tool_array.GetCount(); i++ ) {
<br>                PlugInToolbarToolContainer *pttc = tool_array.Item( i );
<br>                if( tool->GetId() == pttc->id ) {
<br>                    opencpn_plugin_113 *ppi = dynamic_cast<opencpn_plugin_113 *>(pttc->m_pplugin);
<br>                    if( ppi ) {
<br>                        ppi->OnToolbarToolDownCallback( pttc->id );
<br>                        m_last_plugin_down_id = pttc->id;
<br>                    }
<br>                }
<br>            }
<br>        }
<br>    } else
<br>        if( event.RightDown() ) {
<br>            OnRightClick( tool->GetId(), x, y );
<br>        }
<br>
<br>    // Left Button Released.  Only this action confirms selection.
<br>    // If the button is enabled and it is not a toggle tool and it is
<br>    // in the pressed state, then raise the button and call OnLeftClick.
<br>    //
<br>    if( event.LeftUp() && tool->IsEnabled() ) {
<br>        // Pass the OnLeftClick event to tool
<br>        if( !OnLeftClick( tool->GetId(), tool->IsToggled() ) && tool->CanBeToggled() ) {
<br>            // If it was a toggle, and OnLeftClick says No Toggle allowed,
<br>            // then change it back
<br>            tool->Toggle();
<br>            tool->bitmapOK = false;
<br>        }
<br>
<br>        DoPluginToolUp();
<br>    }
<br>
<br>    wxMouseEvent *pev = (wxMouseEvent *) event.Clone();
<br>    GetParent()->GetEventHandler()->AddPendingEvent( *pev );
<br>    wxDELETE( pev );
<br>    event.Skip();
<br>}
<br>
<br>// ----------------------------------------------------------------------------
<br>// drawing
<br>// ----------------------------------------------------------------------------
<br>
<br>void ocpnToolBarSimple::DrawTool( wxToolBarToolBase *tool )
<br>{
<br>    wxClientDC dc( this );
<br>    DrawTool( dc, tool );
<br>}
<br>
<br>// NB! The current DrawTool code assumes that plugin tools are never disabled
<br>// when they are present on the toolbar, since disabled plugins are removed.
<br>
<br>void ocpnToolBarSimple::DrawTool( wxDC& dc, wxToolBarToolBase *toolBase )
<br>{
<br>    ocpnToolBarTool *tool = (ocpnToolBarTool *) toolBase;
<br>    PrepareDC( dc );
<br>
<br>    wxPoint drawAt( tool->m_x, tool->m_y );
<br>    wxBitmap bmp;
<br>
<br>    if( tool->bitmapOK ) {
<br>        if( tool->IsEnabled() ) {
<br>            bmp = tool->GetNormalBitmap();
<br>            if( !bmp.IsOk() ){
<br>                bmp = m_style->GetToolIcon( tool->GetToolname(), TOOLICON_NORMAL, tool->rollover );
<br>                if(m_sizefactor > 1.0 ){
<br><mark>                    wxImage scaled_image = bmp.ConvertToImage();
</mark><br><mark>                    bmp = wxBitmap(scaled_image.Scale(tool->m_width, tool->m_height, wxIMAGE_QUALITY_HIGH));
</mark><br>                }
<br>                tool->SetNormalBitmap( bmp );
<br>                tool->bitmapOK = true;
<br>            }
<br>        } else {
<br>            bmp = tool->GetDisabledBitmap();
<br>            if( !bmp.IsOk() ){
<br>                bmp = m_style->GetToolIcon( tool->GetToolname(), TOOLICON_DISABLED );
<br>                if(m_sizefactor > 1.0 ){
<br><mark>                    wxImage scaled_image = bmp.ConvertToImage();
</mark><br><mark>                    bmp = wxBitmap(scaled_image.Scale(tool->m_width, tool->m_height, wxIMAGE_QUALITY_HIGH));
</mark><br>                }
<br>                tool->SetDisabledBitmap( bmp );
<br>                tool->bitmapOK = true;
<br>            }
<br>        }
<br>    } else {
<br>        if ( tool->isPluginTool ) {
<br>
<br>            // First try getting the icon from the Style.
<br>            // If it is not in the style we build a new icon from the style BG and the plugin icon.
<br>
<br>            if( tool->IsToggled() ) {
<br>                bmp = m_style->GetToolIcon( tool->GetToolname(), TOOLICON_TOGGLED, tool->rollover );
<br>                if( bmp.GetDepth() == 1 ) {
<br>                    if( tool->rollover ) {
<br>                        bmp = m_style->BuildPluginIcon( tool->pluginRolloverIcon, TOOLICON_TOGGLED );
<br>                        if( ! bmp.IsOk() )
<br>                            bmp = m_style->BuildPluginIcon( tool->pluginNormalIcon, TOOLICON_TOGGLED );
<br>                    }
<br>                    else
<br>                        bmp = m_style->BuildPluginIcon( tool->pluginNormalIcon, TOOLICON_TOGGLED );
<br>                }
<br>            } else {
<br>                bmp = m_style->GetToolIcon( tool->GetToolname(), TOOLICON_NORMAL, tool->rollover );
<br>                if( bmp.GetDepth() == 1 ) {
<br>                    if( tool->rollover ) {
<br>                        bmp = m_style->BuildPluginIcon( tool->pluginRolloverIcon, TOOLICON_NORMAL );
<br>                        if( ! bmp.IsOk() )
<br>                            bmp = m_style->BuildPluginIcon( tool->pluginNormalIcon, TOOLICON_NORMAL );
<br>                    }
<br>                    else
<br>                        bmp = m_style->BuildPluginIcon( tool->pluginNormalIcon, TOOLICON_NORMAL );
<br>                }
<br>            }
<br>            if(m_sizefactor > 1.0 ){
<br><mark>                wxImage scaled_image = bmp.ConvertToImage();
</mark><br><mark>                bmp = wxBitmap(scaled_image.Scale(tool->m_width, tool->m_height, wxIMAGE_QUALITY_HIGH));
</mark><br>            }
<br>            tool->SetNormalBitmap( bmp );
<br>            tool->bitmapOK = true;
<br>        } else {
<br>            if( tool->IsEnabled() ) {
<br>                if( tool->IsToggled() )
<br>                    bmp = m_style->GetToolIcon( tool->GetToolname(), TOOLICON_TOGGLED, tool->rollover );
<br>                else
<br>                    bmp = m_style->GetToolIcon( tool->GetIconName(), TOOLICON_NORMAL, tool->rollover );
<br>
<br>                if(m_sizefactor > 1.0 ){
<br><mark>                    wxImage scaled_image = bmp.ConvertToImage();
</mark><br><mark>                    bmp = wxBitmap(scaled_image.Scale(tool->m_width, tool->m_height, wxIMAGE_QUALITY_HIGH));
</mark><br>                }
<br>                tool->SetNormalBitmap( bmp );
<br>                tool->bitmapOK = true;
<br>            } else {
<br>                bmp = m_style->GetToolIcon( tool->GetToolname(), TOOLICON_DISABLED );
<br>                if(m_sizefactor > 1.0 ){
<br><mark>                    wxImage scaled_image = bmp.ConvertToImage();
</mark><br><mark>                    bmp = wxBitmap(scaled_image.Scale(tool->m_width, tool->m_height, wxIMAGE_QUALITY_HIGH));
</mark><br>                }
<br>                tool->SetDisabledBitmap( bmp );
<br>                tool->bitmapOK = true;
<br>            }
<br>        }
<br>    }
<br>
<br>    if( tool->firstInLine ) {
<br>        m_style->DrawToolbarLineStart( bmp );
<br>    }
<br>    if( tool->lastInLine ) {
<br>        m_style->DrawToolbarLineEnd( bmp );
<br>    }
<br>
<br>    if( bmp.GetWidth() != m_style->GetToolSize().x
<br>            || bmp.GetHeight() != m_style->GetToolSize().y ) {
<br>//        drawAt.x -= ( bmp.GetWidth() - m_style->GetToolSize().x ) / 2;
<br>//        drawAt.y -= ( bmp.GetHeight() - m_style->GetToolSize().y ) / 2;
<br>    }
<br>
<br>    //      Clear the last drawn tool if necessary
<br>    if( tool->last_rect.width && ((tool->last_rect.x != drawAt.x) || (tool->last_rect.y != drawAt.y)) ){
<br>        wxBrush bb(GetGlobalColor( _T("GREY2") ));
<br>        dc.SetBrush(bb);
<br>        dc.SetPen( *wxTRANSPARENT_PEN );
<br>        dc.DrawRectangle(tool->last_rect.x, tool->last_rect.y, tool->last_rect.width, tool->last_rect.height);
<br>    }
<br>
<br>    //  could cache this in the tool...
<br>    //  A bit of a hack here.  We only scale tools if they are to be magnified globally
<br>    if(0/*m_sizefactor > 1.0*/ )
<br>    {
<br><mark>        wxImage scaled_image = bmp.ConvertToImage();
</mark><br><mark>        wxBitmap sbmp = wxBitmap(scaled_image.Scale(tool->m_width, tool->m_height, wxIMAGE_QUALITY_HIGH));
</mark><br>        dc.DrawBitmap( sbmp, drawAt );
<br>        tool->last_rect = wxRect(drawAt.x, drawAt.y, sbmp.GetWidth(), sbmp.GetHeight());
<br>
<br>    }
<br>    else
<br>    {
<br>        dc.DrawBitmap( bmp, drawAt );
<br>        tool->last_rect = wxRect(drawAt.x, drawAt.y, bmp.GetWidth(), bmp.GetHeight());
<br>    }
<br>
<br>}
<br>
<br>// ----------------------------------------------------------------------------
<br>// toolbar geometry
<br>// ----------------------------------------------------------------------------
<br>
<br>wxToolBarToolBase *ocpnToolBarSimple::FindToolForPosition( wxCoord x, wxCoord y )
<br>{
<br>    wxToolBarToolsList::compatibility_iterator node = m_tools.GetFirst();
<br>    while( node ) {
<br>        ocpnToolBarTool *tool = (ocpnToolBarTool *) node->GetData();
<br>        if( ( x >= tool->m_x ) && ( y >= tool->m_y ) && ( x < ( tool->m_x + tool->GetWidth() ) )
<br>                && ( y < ( tool->m_y + tool->GetHeight() ) ) ) {
<br>            return tool;
<br>        }
<br>
<br>        node = node->GetNext();
<br>    }
<br>
<br>    return (wxToolBarToolBase *) NULL;
<br>}
<br>
<br>void ocpnToolBarSimple::InvalidateBitmaps()
<br>{
<br>    wxToolBarToolsList::compatibility_iterator node = m_tools.GetFirst();
<br>    while( node ) {
<br>        ocpnToolBarTool *tool = (ocpnToolBarTool *) node->GetData();
<br>        tool->bitmapOK = false;
<br>        node = node->GetNext();
<br>    }
<br>}
<br>
<br>wxRect ocpnToolBarSimple::GetToolRect( int tool_id )
<br>{
<br>    wxRect rect;
<br>    wxToolBarToolBase *tool = FindById( tool_id );
<br>    if( tool ) {
<br>        ocpnToolBarTool *otool = (ocpnToolBarTool *) tool;
<br>        if( otool ) rect = otool->trect;
<br>    }
<br>
<br>    return rect;
<br>}
<br>
<br>// ----------------------------------------------------------------------------
<br>// tool state change handlers
<br>// ----------------------------------------------------------------------------
<br>
<br>void ocpnToolBarSimple::DoEnableTool( wxToolBarToolBase *tool, bool WXUNUSED(enable) )
<br>{
<br>    DrawTool( tool );
<br>}
<br>
<br>void ocpnToolBarSimple::DoToggleTool( wxToolBarToolBase *tool, bool WXUNUSED(toggle) )
<br>{
<br>    ocpnToolBarTool *t = (ocpnToolBarTool *) tool;
<br>    t->bitmapOK = false;
<br>    DrawTool( tool );
<br>}
<br>
<br>// Okay, so we've left the tool we're in ... we must check if the tool we're
<br>// leaving was a 'sprung push button' and if so, spring it back to the up
<br>// state.
<br>void ocpnToolBarSimple::SpringUpButton( int id )
<br>{
<br>    wxToolBarToolBase *tool = FindById( id );
<br>
<br>    if( tool && tool->CanBeToggled() ) {
<br>        if( tool->IsToggled() ) tool->Toggle();
<br>
<br>        DrawTool( tool );
<br>    }
<br>}
<br>
<br>// ----------------------------------------------------------------------------
<br>// scrolling implementation
<br>// ----------------------------------------------------------------------------
<br>
<br>wxString ocpnToolBarSimple::GetToolShortHelp( int id ) const
<br>{
<br>    wxToolBarToolBase *tool = FindById( id );
<br>    wxCHECK_MSG( tool, wxEmptyString, _T("no such tool") );
<br>
<br>    return tool->GetShortHelp();
<br>}
<br>
<br>wxString ocpnToolBarSimple::GetToolLongHelp( int id ) const
<br>{
<br>    wxToolBarToolBase *tool = FindById( id );
<br>    wxCHECK_MSG( tool, wxEmptyString, _T("no such tool") );
<br>
<br>    return tool->GetLongHelp();
<br>}
<br>
<br>void ocpnToolBarSimple::SetToolShortHelp( int id, const wxString& help )
<br>{
<br>    wxToolBarToolBase *tool = FindById( id );
<br>    if( tool ) {
<br>        (void) tool->SetShortHelp( help );
<br>    }
<br>}
<br>
<br>void ocpnToolBarSimple::SetToolLongHelp( int id, const wxString& help )
<br>{
<br>    wxToolBarToolBase *tool = FindById( id );
<br>    if( tool ) {
<br>        (void) tool->SetLongHelp( help );
<br>    }
<br>}
<br>
<br>int ocpnToolBarSimple::GetToolPos( int id ) const
<br>{
<br>    size_t pos = 0;
<br>    wxToolBarToolsList::compatibility_iterator node;
<br>
<br>    for( node = m_tools.GetFirst(); node; node = node->GetNext() ) {
<br>        if( node->GetData()->GetId() == id ) return pos;
<br>
<br>        pos++;
<br>    }
<br>
<br>    return wxNOT_FOUND;
<br>}
<br>bool ocpnToolBarSimple::GetToolState( int id ) const
<br>{
<br>    wxToolBarToolBase *tool = FindById( id );
<br>    wxCHECK_MSG( tool, false, _T("no such tool") );
<br>
<br>    return tool->IsToggled();
<br>}
<br>
<br>bool ocpnToolBarSimple::GetToolEnabled( int id ) const
<br>{
<br>    wxToolBarToolBase *tool = FindById( id );
<br>    wxCHECK_MSG( tool, false, _T("no such tool") );
<br>
<br>    return tool->IsEnabled();
<br>}
<br>
<br>void ocpnToolBarSimple::ToggleTool( int id, bool toggle )
<br>{
<br>    wxToolBarToolBase *tool = FindById( id );
<br>        
<br>    if( tool && tool->CanBeToggled() && tool->Toggle( toggle ) ) {
<br>        DoToggleTool( tool, toggle );
<br>        if( g_toolbar ) g_toolbar->Refresh();
<br>    }
<br>}
<br>
<br>wxObject *ocpnToolBarSimple::GetToolClientData( int id ) const
<br>{
<br>    wxToolBarToolBase *tool = FindById( id );
<br>    return tool ? tool->GetClientData() : (wxObject *) NULL;
<br>}
<br>
<br>void ocpnToolBarSimple::SetToolClientData( int id, wxObject *clientData )
<br>{
<br>    wxToolBarToolBase *tool = FindById( id );
<br>
<br>    wxCHECK_RET( tool, _T("no such tool in wxToolBar::SetToolClientData") );
<br>
<br>    tool->SetClientData( clientData );
<br>}
<br>
<br>void ocpnToolBarSimple::EnableTool( int id, bool enable )
<br>{
<br>    wxToolBarToolBase *tool = FindById( id );
<br>    if( tool ) {
<br>        if( tool->Enable( enable ) ) {
<br>            DoEnableTool( tool, enable );
<br>        }
<br>    }
<br>    wxMenuItem* configItem = g_FloatingToolbarConfigMenu->FindItem( id );
<br>    configItem->Check( true );
<br>}
<br>
<br>void ocpnToolBarSimple::SetToolBitmaps( int id, wxBitmap *bmp, wxBitmap *bmpRollover )
<br>{
<br>    ocpnToolBarTool *tool = (ocpnToolBarTool*)FindById( id );
<br>    if( tool ) {
<br>        tool->pluginNormalIcon = bmp;
<br>        tool->pluginRolloverIcon = bmpRollover;
<br>        tool->bitmapOK = false;
<br>    }
<br>}
<br>
<br>void ocpnToolBarSimple::SetToolTooltipHiViz( int id, bool b_hiviz )
<br>{
<br>    ocpnToolBarTool *tool = (ocpnToolBarTool*)FindById( id );
<br>    if( tool ) {
<br>        tool->SetTooltipHiviz( b_hiviz );
<br>    }
<br>}
<br>
<br>
<br>void ocpnToolBarSimple::ClearTools()
<br>{
<br>    while( GetToolsCount() ) {
<br>        DeleteToolByPos( 0 );
<br>    }
<br>}
<br>
<br>int ocpnToolBarSimple::GetVisibleToolCount()
<br>{
<br>    int counter = 0;
<br>    wxToolBarToolsList::compatibility_iterator node = m_tools.GetFirst();
<br>    while( node ) {
<br>        ocpnToolBarTool *tool = (ocpnToolBarTool *) node->GetData();
<br>        counter++;
<br>        node = node->GetNext();
<br>    }
<br>    return counter;
<br>}
<br>
<br>bool ocpnToolBarSimple::DeleteToolByPos( size_t pos )
<br>{
<br>    wxCHECK_MSG( pos < GetToolsCount(), false,
<br>            _T("invalid position in wxToolBar::DeleteToolByPos()") );
<br>
<br>    wxToolBarToolsList::compatibility_iterator node = m_tools.Item( pos );
<br>
<br>    if( !DoDeleteTool( pos, node->GetData() ) ) {
<br>        return false;
<br>    }
<br>
<br>    delete node->GetData();
<br>    m_tools.Erase( node );
<br>
<br>    return true;
<br>}
<br>
<br>bool ocpnToolBarSimple::DeleteTool( int id )
<br>{
<br>    size_t pos = 0;
<br>    wxToolBarToolsList::compatibility_iterator node;
<br>    for( node = m_tools.GetFirst(); node; node = node->GetNext() ) {
<br>        if( node->GetData()->GetId() == id ) break;
<br>
<br>        pos++;
<br>    }
<br>
<br>    if( !node || !DoDeleteTool( pos, node->GetData() ) ) {
<br>        return false;
<br>    }
<br>
<br>    delete node->GetData();
<br>    m_tools.Erase( node );
<br>
<br>    return true;
<br>}
<br>
<br>wxToolBarToolBase *ocpnToolBarSimple::AddSeparator()
<br>{
<br>    return InsertSeparator( GetToolsCount() );
<br>}
<br>
<br>wxToolBarToolBase *ocpnToolBarSimple::InsertSeparator( size_t pos )
<br>{
<br>    wxCHECK_MSG( pos <= GetToolsCount(), (wxToolBarToolBase *)NULL,
<br>            _T("invalid position in wxToolBar::InsertSeparator()") );
<br>
<br>    wxToolBarToolBase *tool = CreateTool( wxID_SEPARATOR, wxEmptyString, wxNullBitmap, wxNullBitmap,
<br>            wxITEM_SEPARATOR, (wxObject *) NULL, wxEmptyString, wxEmptyString );
<br>
<br>    if( !tool || !DoInsertTool( pos, tool ) ) {
<br>        delete tool;
<br>
<br>        return NULL;
<br>    }
<br>
<br>    m_tools.Insert( pos, tool );
<br>
<br>    return tool;
<br>}
<br>
<br>wxToolBarToolBase *ocpnToolBarSimple::RemoveTool( int id )
<br>{
<br>    size_t pos = 0;
<br>    wxToolBarToolsList::compatibility_iterator node;
<br>    for( node = m_tools.GetFirst(); node; node = node->GetNext() ) {
<br>        if( node->GetData()->GetId() == id ) break;
<br>
<br>        pos++;
<br>    }
<br>
<br>    if( !node ) {
<br>        // don't give any error messages - sometimes we might call RemoveTool()
<br>        // without knowing whether the tool is or not in the toolbar
<br>        return (wxToolBarToolBase *) NULL;
<br>    }
<br>
<br>    wxToolBarToolBase *tool = node->GetData();
<br>    if( !DoDeleteTool( pos, tool ) ) {
<br>        return (wxToolBarToolBase *) NULL;
<br>    }
<br>
<br>    m_tools.Erase( node );
<br>
<br>    return tool;
<br>}
<br>
<br>
<br>wxControl *ocpnToolBarSimple::FindControl( int id )
<br>{
<br>    for( wxToolBarToolsList::compatibility_iterator node = m_tools.GetFirst(); node;
<br>            node = node->GetNext() ) {
<br>        const wxToolBarToolBase * const tool = node->GetData();
<br>        if( tool->IsControl() ) {
<br>            wxControl * const control = tool->GetControl();
<br>
<br>            if( !control ) {
<br>                wxFAIL_MSG( _T("NULL control in toolbar?") );
<br>            } else
<br>                if( control->GetId() == id ) {
<br>                    // found
<br>                    return control;
<br>                }
<br>        }
<br>    }
<br>
<br>    return NULL;
<br>}
<br>
<br>wxToolBarToolBase *ocpnToolBarSimple::FindById( int id ) const
<br>{
<br>    wxToolBarToolBase *tool = (wxToolBarToolBase *) NULL;
<br>
<br>    for( wxToolBarToolsList::compatibility_iterator node = m_tools.GetFirst(); node;
<br>            node = node->GetNext() ) {
<br>        tool = node->GetData();
<br>        if( tool->GetId() == id ) {
<br>            // found
<br>            break;
<br>        }
<br>
<br>        tool = NULL;
<br>    }
<br>
<br>    return tool;
<br>}
<br>
<br>// ----------------------------------------------------------------------------
<br>// event processing
<br>// ----------------------------------------------------------------------------
<br>
<br>// Only allow toggle if returns true
<br>bool ocpnToolBarSimple::OnLeftClick( int id, bool toggleDown )
<br>{
<br>    wxCommandEvent event( wxEVT_COMMAND_TOOL_CLICKED, id );
<br>    event.SetEventObject( this );
<br>
<br>    // we use SetInt() to make wxCommandEvent::IsChecked() return toggleDown
<br>    event.SetInt( (int) toggleDown );
<br>
<br>    // and SetExtraLong() for backwards compatibility
<br>    event.SetExtraLong( (long) toggleDown );
<br>
<br>    // Send events to this toolbar instead (and thence up the window hierarchy)
<br>    GetEventHandler()->ProcessEvent( event );
<br>
<br>    return true;
<br>}
<br>
<br>// Call when right button down.
<br>void ocpnToolBarSimple::OnRightClick( int id, long WXUNUSED(x), long WXUNUSED(y) )
<br>{
<br>    wxCommandEvent event( wxEVT_COMMAND_TOOL_RCLICKED, id );
<br>    event.SetEventObject( this );
<br>    event.SetInt( id );
<br>
<br>    HideTooltip();
<br>    ((ocpnFloatingToolbarDialog*)GetParent())->toolbarConfigChanged = false;
<br>    wxMenu* contextMenu = new wxMenu();
<br>    wxMenuItem* submenu = contextMenu->AppendSubMenu( g_FloatingToolbarConfigMenu, _("Visible buttons") );
<br>
<br>    PopupMenu( contextMenu );
<br>
<br>    contextMenu->Remove( submenu );
<br>    delete contextMenu;
<br>
<br>    if( ((ocpnFloatingToolbarDialog*)GetParent())->toolbarConfigChanged )
<br>        gFrame->GetEventHandler()->AddPendingEvent( event );
<br>}
<br>
<br>// Called when the mouse cursor enters a tool bitmap (no button pressed).
<br>// Argument is wxID_ANY if mouse is exiting the toolbar.
<br>// Note that for this event, the id of the window is used,
<br>// and the integer parameter of wxCommandEvent is used to retrieve
<br>// the tool id.
<br>void ocpnToolBarSimple::OnMouseEnter( int id )
<br>{
<br>    wxCommandEvent event( wxEVT_COMMAND_TOOL_ENTER, GetId() );
<br>    event.SetEventObject( this );
<br>    event.SetInt( id );
<br>
<br>    wxFrame *frame = wxDynamicCast(GetParent(), wxFrame);
<br>    if( frame ) {
<br>        wxString help;
<br>        wxToolBarToolBase* tool = id == wxID_ANY ? (wxToolBarToolBase*) NULL : FindById( id );
<br>        if( tool ) help = tool->GetLongHelp();
<br>        frame->DoGiveHelp( help, id != wxID_ANY );
<br>    }
<br>
<br>    (void) GetEventHandler()->ProcessEvent( event );
<br>
<br>    DoPluginToolUp();
<br>}
<br>
<br>void ocpnToolBarSimple::DoPluginToolUp()
<br>{
<br>    //        Look for PlugIn tools
<br>    //        If found, make the callback.
<br>    if( !g_pi_manager)
<br>        return;
<br>
<br>    ArrayOfPlugInToolbarTools tool_array = g_pi_manager->GetPluginToolbarToolArray();
<br>    for( unsigned int i = 0; i < tool_array.GetCount(); i++ ) {
<br>        PlugInToolbarToolContainer *pttc = tool_array.Item( i );
<br>        if( m_last_plugin_down_id == pttc->id ) {
<br>            opencpn_plugin_113 *ppi = dynamic_cast<opencpn_plugin_113 *>(pttc->m_pplugin);
<br>            if( ppi )
<br>                ppi->OnToolbarToolUpCallback( pttc->id );
<br>        }
<br>    }
<br>
<br>    m_last_plugin_down_id = -1;
<br>}
<br>
<br>void ocpnToolBarSimple::SetToolNormalBitmapEx( wxToolBarToolBase *tool, const wxString &iconName)
<br>{
<br>    if( tool ) {
<br>        ocpnToolBarTool *otool = (ocpnToolBarTool *) tool;
<br>        if(otool){
<br>            ocpnStyle::Style *style = g_StyleManager->GetCurrentStyle();
<br>
<br>            wxBitmap bmp = style->GetToolIcon( iconName, TOOLICON_NORMAL );
<br>            if(m_sizefactor > 1.0 ){
<br><mark>                wxImage scaled_image = bmp.ConvertToImage();
</mark><br><mark>                bmp = wxBitmap(scaled_image.Scale(otool->m_width, otool->m_height, wxIMAGE_QUALITY_HIGH));
</mark><br>            }
<br>        
<br>            tool->SetNormalBitmap( bmp );
<br>            otool->SetIconName( iconName );
<br>        }
<br>    }
<br>}
<br>
<br>
<br>//-------------------------------------------------------------------------------------
<br>
<br>ToolbarMOBDialog::ToolbarMOBDialog( wxWindow* parent )
<br>       : wxDialog( parent, wxID_ANY, _("OpenCPN Alert"), wxDefaultPosition, wxSize(250, 230) )
<br>{
<br>    wxBoxSizer* topSizer = new wxBoxSizer( wxVERTICAL );
<br>
<br>    wxBoxSizer* sizer = new wxBoxSizer( wxVERTICAL );
<br>    topSizer->Add( sizer, 0, wxALIGN_CENTER_HORIZONTAL | wxALL, 5 );
<br>
<br>    choices.push_back( new wxRadioButton( this, 0,  _("No, I don't want to hide it."),
<br>            wxDefaultPosition, wxDefaultSize, wxRB_GROUP ) );
<br>
<br>    choices.push_back( new wxRadioButton( this, 1, _("No, and permanently remove the option to hide it."),
<br>            wxDefaultPosition) );
<br>
<br>    choices.push_back( new wxRadioButton( this, 2, _("Yes, hide it."),
<br>            wxDefaultPosition) );
<br>
<br>    wxStdDialogButtonSizer* buttonSizer = CreateStdDialogButtonSizer( wxOK | wxCANCEL );
<br>
<br>
<br>    wxStaticText* textCtrl = new wxStaticText( this, wxID_ANY, _("The Man Over Board button could be an important safety feature.\nAre you sure you want to hide it?") );
<br>
<br>    sizer->Add( textCtrl, 0, wxEXPAND | wxALL, 5 );
<br>    sizer->Add( choices[0], 0, wxEXPAND | wxALL, 5 );
<br>    sizer->Add( choices[1], 0, wxEXPAND | wxALL, 5 );
<br>    sizer->Add( choices[2], 0, wxEXPAND | wxALL, 5 );
<br>    sizer->Add( buttonSizer, 0, wxEXPAND | wxTOP, 5 );
<br>
<br>    topSizer->SetSizeHints(this);
<br>    SetSizer( topSizer );
<br>}
<br>
<br>int ToolbarMOBDialog::GetSelection() {
<br>    for( unsigned int i=0; i<choices.size(); i++ ) {
<br>        if( choices[i]->GetValue() ) return choices[i]->GetId();
<br>    }
<br>    return 0;
<br>}
</p></body>
    </html><html>
    <head></head>
    <body><p><br>/***************************************************************************
<br> *
<br> * Project:  OpenCPN
<br> * Purpose:  OpenCPN Toolbar
<br> * Author:   David Register
<br> *
<br> ***************************************************************************
<br> *   Copyright (C) 2010 by David S. Register                               *
<br> *                                                                         *
<br> *   This program is free software; you can redistribute it and/or modify  *
<br> *   it under the terms of the GNU General Public License as published by  *
<br> *   the Free Software Foundation; either version 2 of the License, or     *
<br> *   (at your option) any later version.                                   *
<br> *                                                                         *
<br> *   This program is distributed in the hope that it will be useful,       *
<br> *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
<br> *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
<br> *   GNU General Public License for more details.                          *
<br> *                                                                         *
<br> *   You should have received a copy of the GNU General Public License     *
<br> *   along with this program; if not, write to the                         *
<br> *   Free Software Foundation, Inc.,                                       *
<br> *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,  USA.         *
<br> **************************************************************************/
<br>
<br>#include "wx/wxprec.h"
<br>
<br>#ifndef  WX_PRECOMP
<br>#include "wx/wx.h"
<br>#endif
<br>
<br>#include <vector>
<br>
<br>#include "ocpn_types.h"
<br>#include "navutil.h"
<br>#include "styles.h"
<br>#include "toolbar.h"
<br>#include "chart1.h"
<br>#include "pluginmanager.h"
<br>#include "FontMgr.h"
<br>
<br>extern ocpnFloatingToolbarDialog* g_FloatingToolbarDialog;
<br>extern bool                       g_bTransparentToolbar;
<br>extern bool                       g_bTransparentToolbarInOpenGLOK;
<br>extern ChartCanvas*               cc1;
<br>extern bool                       g_bopengl;
<br>extern ocpnToolBarSimple*         g_toolbar;
<br>extern ocpnStyle::StyleManager*   g_StyleManager;
<br>extern MyFrame*                   gFrame;
<br>extern PlugInManager*             g_pi_manager;
<br>extern wxMenu*                    g_FloatingToolbarConfigMenu;
<br>extern wxString                   g_toolbarConfig;
<br>extern bool                       g_bPermanentMOBIcon;
<br>extern bool                       g_btouch;
<br>extern bool                       g_bsmoothpanzoom;
<br>
<br>//----------------------------------------------------------------------------
<br>// GrabberWindow Implementation
<br>//----------------------------------------------------------------------------
<br>BEGIN_EVENT_TABLE(GrabberWin, wxPanel) EVT_MOUSE_EVENTS ( GrabberWin::MouseEvent )
<br>EVT_PAINT ( GrabberWin::OnPaint )
<br>END_EVENT_TABLE()
<br>
<br>GrabberWin::GrabberWin( wxWindow *parent, ocpnFloatingToolbarDialog *toolbar, float scale_factor, wxString icon_name, wxPoint position ):
<br>    wxPanel( parent, wxID_ANY, position, wxDefaultSize, wxNO_BORDER )
<br>{
<br>    m_icon_name = icon_name;
<br>    m_style = g_StyleManager->GetCurrentStyle();
<br>    wxBitmap bitmap = m_style->GetIcon( icon_name );
<br>    if(scale_factor > 1.0f){
<br>        int new_width = bitmap.GetWidth() * scale_factor;
<br>        int new_height = bitmap.GetHeight() * scale_factor;
<br><mark>        wxImage scaled_image = bitmap.ConvertToImage();
</mark><br><mark>        m_bitmap = wxBitmap(scaled_image.Scale(new_width, new_height, wxIMAGE_QUALITY_HIGH));
</mark><br>    }
<br>    else
<br>        m_bitmap = bitmap;
<br>
<br>    SetSize( wxSize( m_bitmap.GetWidth(), m_bitmap.GetHeight() ) );
<br>    SetMinSize( wxSize( m_bitmap.GetWidth(), m_bitmap.GetHeight() ) );
<br>
<br>    m_bLeftDown = false;
<br>    m_bRightDown = false;
<br>    m_scale_factor = scale_factor;
<br>    m_ptoolbar = toolbar;
<br>    m_dragging = false;
<br>    Hide();
<br>    
<br>}
<br>
<br>
<br>void GrabberWin::OnPaint( wxPaintEvent& event )
<br>{
<br>    wxPaintDC dc( this );
<br>    
<br>    wxColour back_color = GetGlobalColor( _T("GREY2") );
<br>    SetBackgroundColour( back_color );
<br>    ClearBackground();
<br>    
<br>    dc.DrawBitmap( m_bitmap, 0, 0, true );
<br>}
<br>
<br>void GrabberWin::SetColorScheme( ColorScheme cs )
<br>{
<br>    wxColour back_color = GetGlobalColor( _T("GREY2") );
<br>
<br>    SetBackgroundColour( back_color );
<br>    ClearBackground();
<br>
<br>    wxBitmap bitmap = m_style->GetIcon( m_icon_name) ;
<br>    if(m_scale_factor > 1.0f){
<br>        int new_width = bitmap.GetWidth() * m_scale_factor;
<br>        int new_height = bitmap.GetHeight() * m_scale_factor;
<br><mark>        wxImage scaled_image = bitmap.ConvertToImage();
</mark><br><mark>        m_bitmap = wxBitmap(scaled_image.Scale(new_width, new_height, wxIMAGE_QUALITY_HIGH));
</mark><br>    }
<br>    else
<br>        m_bitmap = bitmap;
<br>}
<br>
<br>void GrabberWin::MouseEvent( wxMouseEvent& event )
<br>{
<br>    static wxPoint s_gspt;
<br>    int x, y;
<br>
<br>    event.GetPosition( &x, &y );
<br>
<br>    wxPoint spt = ClientToScreen( wxPoint( x, y ) );
<br>    if( event.LeftDown() ) {
<br>        s_gspt = spt;
<br>    }
<br>    
<br>    
<br>#ifndef __WXQT__
<br>
<br>    if( event.LeftDown() ) {
<br>        CaptureMouse();
<br>    }
<br>
<br>    if( event.LeftUp() ) {
<br>        if( HasCapture() ) ReleaseMouse();
<br>    }
<br>
<br>#endif
<br>
<br>
<br>    if( event.RightDown() ){
<br>        if(m_ptoolbar){
<br>            m_dragging = true;
<br>            
<br>            if( !m_ptoolbar->m_bnavgrabber ){
<br>                m_ptoolbar->m_bnavgrabber = true;
<br>                m_ptoolbar->SetGrabber(_T("4WayMove") );
<br>            }
<br>            else{
<br>                m_ptoolbar->m_bnavgrabber = false;
<br>                m_ptoolbar->SetGrabber(_T("grabber_hi") );
<br>            }
<br>                
<br>        }
<br>    }
<br>    
<br>
<br>
<br>    if( event.Dragging() ) {
<br>        if(m_ptoolbar && m_ptoolbar->IsShown() /*&& m_ptoolbar->m_bnavgrabber*/){
<br>            wxPoint par_pos_old = m_ptoolbar->GetPosition();
<br>
<br>            wxPoint par_pos = par_pos_old;
<br>            par_pos.x += spt.x - s_gspt.x;
<br>            par_pos.y += spt.y - s_gspt.y;
<br>
<br>            m_ptoolbar->MoveDialogInScreenCoords( par_pos, par_pos_old );
<br>
<br>            s_gspt = spt;
<br>            m_dragging = true;
<br>        }
<br>
<br>    }
<br>
<br>    if( event.LeftUp() ) {
<br>        if(m_ptoolbar){
<br>            if(m_ptoolbar->m_bnavgrabber){
<br>                if(!m_dragging)
<br>                    m_ptoolbar->ToggleOrientation();
<br>            }
<br>            else if(!m_dragging){
<br>                if(m_ptoolbar->m_bsubmerged){
<br>                    m_ptoolbar->SurfaceFromGrabber();
<br>                }
<br>                else{
<br>                    m_ptoolbar->SubmergeToGrabber();
<br>                 }
<br>            }
<br>        }
<br>        m_dragging = false;
<br>    }
<br>    
<br>    
<br>#ifndef __OCPN__ANDROID__
<br>    gFrame->Raise();
<br>#endif
<br>    
<br>}
<br>
<br>class ocpnToolBarTool: public wxToolBarToolBase {
<br>public:
<br>    ocpnToolBarTool( ocpnToolBarSimple *tbar, int id, const wxString& label,
<br>            const wxBitmap& bmpNormal, const wxBitmap& bmpRollover, wxItemKind kind,
<br>            wxObject *clientData, const wxString& shortHelp, const wxString& longHelp ) :
<br>            wxToolBarToolBase( (wxToolBarBase*) tbar, id, label, bmpNormal, bmpRollover, kind,
<br>                    clientData, shortHelp, longHelp )
<br>    {
<br>        m_enabled = true;
<br>        m_toggled = false;
<br>        rollover = false;
<br>        bitmapOK = false;
<br>        m_btooltip_hiviz = false;
<br>
<br>        toolname = g_pi_manager->GetToolOwnerCommonName( id );
<br>        if( toolname == _T("") ) {
<br>            isPluginTool = false;
<br>            toolname = label;
<br>            iconName = label;
<br>        } else {
<br>            isPluginTool = true;
<br>            pluginNormalIcon = &bmpNormal;
<br>            pluginRolloverIcon = &bmpRollover;
<br>        }
<br>    }
<br>
<br>    void SetSize( const wxSize& size )
<br>    {
<br>        m_width = size.x;
<br>        m_height = size.y;
<br>    }
<br>
<br>    wxCoord GetWidth() const
<br>    {
<br>        return m_width;
<br>    }
<br>
<br>    wxCoord GetHeight() const
<br>    {
<br>        return m_height;
<br>    }
<br>
<br>    wxString GetToolname()
<br>    {
<br>        return toolname;
<br>    }
<br>
<br>    void SetIconName(wxString name)
<br>    {
<br>        iconName = name;
<br>    }
<br>    wxString GetIconName()
<br>    {
<br>        return iconName;
<br>    }
<br>
<br>    void SetTooltipHiviz( bool enable){ m_btooltip_hiviz = enable; }
<br>
<br>    wxCoord m_x;
<br>    wxCoord m_y;
<br>    wxCoord m_width;
<br>    wxCoord m_height;
<br>    wxRect trect;
<br>    wxString toolname;
<br>    wxString iconName;
<br>    const wxBitmap* pluginNormalIcon;
<br>    const wxBitmap* pluginRolloverIcon;
<br>    bool firstInLine;
<br>    bool lastInLine;
<br>    bool rollover;
<br>    bool bitmapOK;
<br>    bool isPluginTool;
<br>    bool b_hilite;
<br>    bool m_btooltip_hiviz;
<br>    wxRect last_rect;
<br>};
<br>
<br>//---------------------------------------------------------------------------------------
<br>//          ocpnFloatingToolbarDialog Implementation
<br>//---------------------------------------------------------------------------------------
<br>BEGIN_EVENT_TABLE(ocpnFloatingToolbarDialog, wxDialog)
<br>    EVT_MOUSE_EVENTS ( ocpnFloatingToolbarDialog::MouseEvent )
<br>    EVT_MENU(wxID_ANY, ocpnFloatingToolbarDialog::OnToolLeftClick)
<br>    EVT_TIMER ( FADE_TIMER, ocpnFloatingToolbarDialog::FadeTimerEvent )
<br>    EVT_TIMER ( DESTROY_TIMER, ocpnFloatingToolbarDialog::DestroyTimerEvent )
<br>    EVT_WINDOW_CREATE(ocpnFloatingToolbarDialog::OnWindowCreate)
<br>END_EVENT_TABLE()
<br>
<br>ocpnFloatingToolbarDialog::ocpnFloatingToolbarDialog( wxWindow *parent, wxPoint position,
<br>                                                      long orient, float size_factor )
<br>{
<br>    m_pparent = parent;
<br>    long wstyle = wxNO_BORDER | wxFRAME_NO_TASKBAR;
<br>#ifndef __WXMAC__
<br>    wstyle |= wxFRAME_SHAPED;
<br>#endif
<br>
<br>    m_ptoolbar = NULL;
<br>
<br>#ifdef __WXOSX__
<br>    wstyle |= wxSTAY_ON_TOP;
<br>#endif
<br>    wxDialog::Create( parent, -1, _T("ocpnToolbarDialog"), wxPoint( -1, -1 ), wxSize( -1, -1 ),
<br>            wstyle );
<br>
<br>    m_opacity = 255;
<br>
<br>    m_pGrabberwin = new GrabberWin( this, this, size_factor, _T("grabber_hi") );
<br>    m_pGrabberwin->Show();
<br>    
<br>    m_pRecoverwin = NULL;
<br>    m_position = position;
<br>    m_orient = orient;
<br>    m_sizefactor = size_factor;
<br>    
<br>    m_bAutoHideToolbar = false;
<br>    m_nAutoHideToolbar = 5;
<br>    
<br>
<br>    m_style = g_StyleManager->GetCurrentStyle();
<br>
<br>// A top-level sizer
<br>    m_topSizer = new wxBoxSizer( wxHORIZONTAL );
<br>    SetSizer( m_topSizer );
<br>
<br>    //    Set initial "Dock" parameters
<br>    m_dock_x = 0;
<br>    m_dock_y = 0;
<br>    m_block = false;
<br>
<br>    m_marginsInvisible = m_style->marginsInvisible;
<br>
<br>//    if(m_sizefactor > 1.0 )
<br> //       m_marginsInvisible = true;
<br>
<br>    m_bnavgrabber = false;    
<br>    
<br>    Hide();
<br>
<br>    m_bsubmerged = false;
<br>    
<br>    m_fade_timer.SetOwner( this, FADE_TIMER );
<br>    if( g_bTransparentToolbar )
<br>        m_fade_timer.Start( 5000 );
<br>    
<br>    if( m_bAutoHideToolbar && (m_nAutoHideToolbar > 0))
<br>        m_fade_timer.Start( m_nAutoHideToolbar * 1000 );
<br>    
<br>    m_destroyTimer.SetOwner( this, DESTROY_TIMER );
<br>}
<br>
<br>ocpnFloatingToolbarDialog::~ocpnFloatingToolbarDialog()
<br>{
<br>    DestroyToolBar();
<br>}
<br>
<br>void ocpnFloatingToolbarDialog::OnWindowCreate( wxWindowCreateEvent& event )
<br>{
<br>    Realize();
<br>}
<br>
<br>void ocpnFloatingToolbarDialog::SetGrabber( wxString icon_name )
<br>{
<br>//    m_pGrabberwin->Destroy();
<br>    m_pGrabberwin = new GrabberWin( this, this, m_sizefactor, icon_name );
<br>    m_pGrabberwin->Show();
<br>    
<br>    Realize();
<br>    
<br>#ifdef __WXOSX__    
<br>    m_pGrabberwin->Refresh();
<br>#endif    
<br>    
<br>}
<br>
<br>
<br>    
<br>void ocpnFloatingToolbarDialog::SetColorScheme( ColorScheme cs )
<br>{
<br>    m_cs = cs;
<br>
<br>    wxColour back_color = GetGlobalColor( _T("GREY2") );
<br>
<br>    //  Set background
<br>    SetBackgroundColour( back_color );
<br>    ClearBackground();
<br>
<br>    if( m_ptoolbar ) {
<br>        wxColour back_color = GetGlobalColor( _T("GREY2") );
<br>
<br>        //  Set background
<br>        m_ptoolbar->SetBackgroundColour( back_color );
<br>        m_ptoolbar->ClearBackground();
<br>
<br>        m_ptoolbar->SetToggledBackgroundColour( GetGlobalColor( _T("GREY1") ) );
<br>
<br>        m_ptoolbar->SetColorScheme( cs );
<br>        m_ptoolbar->Refresh( true );
<br>    }
<br>
<br>    if( m_pGrabberwin ) m_pGrabberwin->SetColorScheme( cs );
<br>
<br>}
<br>
<br>void ocpnFloatingToolbarDialog::SetGeometry(bool bAvoid, wxRect rectAvoid)
<br>{
<br>
<br>    if( m_ptoolbar ) {
<br>        wxSize style_tool_size = m_style->GetToolSize();
<br>
<br>        style_tool_size.x *= m_sizefactor;
<br>        style_tool_size.y *= m_sizefactor;
<br>
<br>        m_ptoolbar->SetToolBitmapSize( style_tool_size );
<br>
<br>        wxSize tool_size = m_ptoolbar->GetToolBitmapSize();
<br>        int grabber_width =  m_style->GetIcon( _T("grabber") ).GetWidth();
<br>        
<br>        int max_rows = 10;
<br>        int max_cols = 100;
<br>        if(cc1){
<br>
<br>            int avoid_start = cc1->GetClientSize().x - (tool_size.x + m_style->GetToolSeparation()) * 2;  // default
<br>            if(bAvoid && !rectAvoid.IsEmpty()){
<br>                avoid_start = cc1->GetClientSize().x - rectAvoid.width - 10;  // this is compass window, if shown
<br>            }
<br>            
<br>            
<br>            max_rows = (cc1->GetClientSize().y / ( tool_size.y + m_style->GetToolSeparation())) - 1;
<br>            
<br>            max_cols = (avoid_start - grabber_width) / ( tool_size.x + m_style->GetToolSeparation());
<br>            max_cols -= 1;
<br>            
<br>            if(m_orient == wxTB_VERTICAL)
<br>                max_rows = wxMax( max_rows, 2);             // at least two rows
<br>            else
<br>                max_cols = wxMax( max_cols, 2);             // at least two columns
<br>        }
<br>
<br>        if( m_orient == wxTB_VERTICAL )
<br>            m_ptoolbar->SetMaxRowsCols(max_rows, 100);
<br>        else
<br>            m_ptoolbar->SetMaxRowsCols( 100, max_cols);
<br>        m_ptoolbar->SetSizeFactor(m_sizefactor);
<br>        
<br>    }
<br> }
<br>
<br>void ocpnFloatingToolbarDialog::RePosition()
<br>{
<br>    if(m_block) return;
<br>
<br>    if( m_pparent && m_ptoolbar ) {
<br>        wxSize cs = m_pparent->GetClientSize();
<br>        if( -1 == m_dock_x ) m_position.x = 0;
<br>        else
<br>            if( 1 == m_dock_x ) m_position.x = cs.x - GetSize().x;
<br>
<br>        if( -1 == m_dock_y ) m_position.y = 0;
<br>        else
<br>            if( 1 == m_dock_y ) m_position.y = cs.y - GetSize().y;
<br>
<br>        m_position.x = wxMin(cs.x - GetSize().x, m_position.x);
<br>        m_position.y = wxMin(cs.y - GetSize().y, m_position.y);
<br>
<br>        m_position.x = wxMax(0, m_position.x);
<br>        m_position.y = wxMax(0, m_position.y);
<br>
<br>        wxPoint screen_pos = m_pparent->ClientToScreen( m_position );
<br>
<br>        Move( screen_pos );
<br>
<br>#ifdef __WXQT__
<br>        Raise();
<br>#endif
<br>
<br>    }
<br>}
<br>
<br>void ocpnFloatingToolbarDialog::Submerge()
<br>{
<br>    m_bsubmerged = true;
<br>    Hide();
<br>    if( m_ptoolbar ) m_ptoolbar->KillTooltip();
<br>}
<br>
<br>void ocpnFloatingToolbarDialog::SubmergeToGrabber()
<br>{
<br>//Submerge();
<br>    m_bsubmerged = true;
<br>    Hide();
<br>    if( m_ptoolbar ) m_ptoolbar->KillTooltip();
<br>
<br>    m_pRecoverwin = new GrabberWin( m_pparent, this, m_sizefactor, _T("grabber_ext" ), wxPoint(10,10) );
<br>   
<br>    m_pRecoverwin->Show();
<br>    m_pRecoverwin->Raise();
<br>#ifdef __WXQT__
<br>    wxSize s = gFrame->GetSize();
<br>    m_recoversize = s;
<br>    s.y--;
<br>    gFrame->TriggerResize(s);
<br>    Raise();
<br>#endif    
<br>
<br>    gFrame->Refresh();          // Needed for MSW OpenGL
<br>}
<br>
<br>void ocpnFloatingToolbarDialog::Surface()
<br>{
<br>    
<br>    if(m_pRecoverwin){
<br>        m_pRecoverwin->Show();
<br>        m_pRecoverwin->Raise();
<br>    }
<br>    else {
<br>        m_bsubmerged = false;
<br>        #ifndef __WXOSX__
<br>        Hide();
<br>        Move( 0, 0 );
<br>        #endif
<br>
<br>        RePosition();
<br>        Show();
<br>        if( m_ptoolbar )
<br>            m_ptoolbar->EnableTooltips();
<br>
<br>        #ifdef __WXQT__
<br>        Raise();
<br>        #endif
<br>    }
<br>    
<br>    if( m_bAutoHideToolbar && (m_nAutoHideToolbar > 0) ){
<br>        m_fade_timer.Start( m_nAutoHideToolbar * 1000 );
<br>    }
<br>}
<br>
<br>bool ocpnFloatingToolbarDialog::CheckSurfaceRequest( wxMouseEvent &event )
<br>{
<br>    if( m_bsubmerged ){
<br>        if( event.LeftUp() ){
<br>            int x,y;
<br>            event.GetPosition( &x, &y );
<br>            if( m_pRecoverwin ){
<br>                wxRect winRect = m_pRecoverwin->GetRect();
<br>                if( winRect.Contains( x, y ) ){
<br>                    SurfaceFromGrabber();
<br>                    return true;
<br>                }
<br>            }
<br>        }
<br>    }
<br>    
<br>    return false;
<br>}
<br>        
<br>void ocpnFloatingToolbarDialog::SurfaceFromGrabber()
<br>{
<br>    m_bsubmerged = false;
<br>    
<br>#ifndef __WXOSX__
<br>    Hide();
<br>    Move( 0, 0 );
<br>#endif
<br>
<br>    if( m_ptoolbar )
<br>        m_ptoolbar->InvalidateBitmaps();
<br>    
<br>    RePosition();
<br>    Show();
<br>    if( m_ptoolbar )
<br>        m_ptoolbar->EnableTooltips();
<br>    
<br>    if( m_bAutoHideToolbar && (m_nAutoHideToolbar > 0) ){
<br>        m_fade_timer.Start( m_nAutoHideToolbar * 1000 );
<br>    }
<br>    
<br>#ifdef __WXQT__
<br>    wxSize s = gFrame->GetSize();               // check for rotation
<br>    if(m_recoversize.x == s.x)
<br>        gFrame->TriggerResize(m_recoversize);
<br>    Raise();
<br>#endif
<br>    
<br>    m_destroyGrabber = m_pRecoverwin;
<br>    m_destroyTimer.Start( 5, wxTIMER_ONE_SHOT );           //  Destor the unneeded recovery grabber
<br>    
<br>}
<br>
<br>void ocpnFloatingToolbarDialog::DestroyTimerEvent( wxTimerEvent& event )
<br>{
<br>    delete m_destroyGrabber;
<br>    m_destroyGrabber = NULL;
<br>    m_pRecoverwin = NULL;
<br>}
<br>
<br>void ocpnFloatingToolbarDialog::HideTooltip()
<br>{
<br>    if( m_ptoolbar ) m_ptoolbar->HideTooltip();
<br>}
<br>
<br>void ocpnFloatingToolbarDialog::ShowTooltips()
<br>{
<br>    if( m_ptoolbar ) m_ptoolbar->EnableTooltips();
<br>}
<br>
<br>void ocpnFloatingToolbarDialog::ToggleOrientation()
<br>{
<br>    if( m_orient == wxTB_HORIZONTAL )
<br>        m_orient = wxTB_VERTICAL;
<br>    else
<br>        m_orient = wxTB_HORIZONTAL;
<br>
<br>    m_style->SetOrientation( m_orient );
<br>
<br>    wxPoint old_screen_pos = m_pparent->ClientToScreen( m_position );
<br>    wxPoint grabber_point_abs = ClientToScreen( m_pGrabberwin->GetPosition() );
<br>
<br>    gFrame->RequestNewToolbar();
<br>    wxPoint pos_abs = grabber_point_abs;
<br>    pos_abs.x -= m_pGrabberwin->GetPosition().x;
<br>    MoveDialogInScreenCoords( pos_abs, old_screen_pos );
<br>
<br>
<br>    Show();   // this seems to be necessary on GTK to kick the sizer into gear...(FS#553)
<br>    Refresh(true);
<br>    Raise();
<br>}
<br>
<br>void ocpnFloatingToolbarDialog::MouseEvent( wxMouseEvent& event )
<br>{
<br>    if( g_bTransparentToolbar ) {
<br>        if( event.Entering() && ( m_opacity < 255 ) ) {
<br>            SetTransparent( 255 );
<br>            m_opacity = 255;
<br>        }
<br>
<br>        m_fade_timer.Start( 5000 );           // retrigger the continuous timer
<br>    }
<br>    
<br>    if(m_bAutoHideToolbar && (m_nAutoHideToolbar > 0) ){
<br>        m_fade_timer.Start( m_nAutoHideToolbar * 1000 );
<br>    }
<br>}
<br>
<br>void ocpnFloatingToolbarDialog::FadeTimerEvent( wxTimerEvent& event )
<br>{
<br>    if(m_bnavgrabber){
<br>        m_fade_timer.Start( 5000 );           // do nothing if nav grabber is shown
<br>    }
<br>    else{
<br>        if( g_bTransparentToolbar && (!g_bopengl || g_bTransparentToolbarInOpenGLOK) ){
<br>            DoFade( 128 );
<br>            m_fade_timer.Start( 5000 );           // retrigger the continuous timer
<br>        }
<br>        
<br>        if(m_bAutoHideToolbar && (m_nAutoHideToolbar > 0) && !m_bsubmerged){
<br>            SubmergeToGrabber();
<br>//            m_fade_timer.Stop();
<br>        }
<br>    }
<br>}
<br>
<br>void ocpnFloatingToolbarDialog::SetAutoHideTimer(int time)
<br>{
<br>    m_nAutoHideToolbar = time;
<br>    if(m_bAutoHideToolbar){
<br>        m_fade_timer.Stop();
<br>        m_fade_timer.Start( m_nAutoHideToolbar * 1000 );
<br>    }
<br>}
<br>        
<br>void ocpnFloatingToolbarDialog::DoFade( int value )
<br>{
<br>    if( value != m_opacity ) SetTransparent( value );
<br>    m_opacity = value;
<br>}
<br>
<br>void ocpnFloatingToolbarDialog::RefreshFadeTimer()
<br>{
<br>    SetTransparent( 255 );
<br>    m_opacity = 255;
<br>    m_fade_timer.Start( 500 );           // retrigger the continuous timer
<br>    
<br>    if(m_bAutoHideToolbar && (m_nAutoHideToolbar > 0) ){
<br>        m_fade_timer.Start( m_nAutoHideToolbar * 1000 );
<br>    }
<br>    
<br>}
<br>
<br>void ocpnFloatingToolbarDialog::MoveDialogInScreenCoords( wxPoint posn, wxPoint posn_old )
<br>{
<br>    wxPoint pos_in_parent = m_pparent->ScreenToClient( posn );
<br>    wxPoint pos_in_parent_old = m_pparent->ScreenToClient( posn_old );
<br>
<br>    //    "Docking" support
<br>#define DOCK_MARGIN 40
<br>
<br>    // X
<br>    m_dock_x = 0;
<br>    if( pos_in_parent.x < pos_in_parent_old.x )            // moving left
<br>            {
<br>        if( pos_in_parent.x < DOCK_MARGIN ) {
<br>            pos_in_parent.x = 0;
<br>            m_dock_x = -1;
<br>        }
<br>    } else
<br>        if( pos_in_parent.x > pos_in_parent_old.x )            // moving right
<br>                {
<br>            int max_right = m_pparent->GetClientSize().x - GetSize().x;
<br>            if( pos_in_parent.x > ( max_right - DOCK_MARGIN ) ) {
<br>                pos_in_parent.x = max_right;
<br>                m_dock_x = 1;
<br>            }
<br>        }
<br>
<br>    // Y
<br>    m_dock_y = 0;
<br>    if( pos_in_parent.y < pos_in_parent_old.y )            // moving up
<br>            {
<br>        if( pos_in_parent.y < DOCK_MARGIN ) {
<br>            pos_in_parent.y = 0;
<br>            m_dock_y = -1;
<br>        }
<br>    } else
<br>        if( pos_in_parent.y > pos_in_parent_old.y )            // moving down
<br>                {
<br>            int max_down = m_pparent->GetClientSize().y - GetSize().y;
<br>            if( pos_in_parent.y > ( max_down - DOCK_MARGIN ) ) {
<br>                pos_in_parent.y = max_down;
<br>                m_dock_y = 1;
<br>            }
<br>        }
<br>
<br>    m_position = pos_in_parent;
<br>
<br>    wxPoint final_pos = m_pparent->ClientToScreen( pos_in_parent );
<br>
<br>    Move( final_pos );
<br>}
<br>
<br>void ocpnFloatingToolbarDialog::Realize()
<br>{
<br>    if( m_ptoolbar ) {
<br>        m_ptoolbar->Realize();
<br>
<br>        m_topSizer->Clear();
<br>        m_topSizer->Add( m_ptoolbar );
<br>        m_topSizer->Add( m_pGrabberwin, 0, wxTOP, m_style->GetTopMargin() );
<br>
<br>        m_topSizer->Layout();
<br>        Fit();
<br>
<br>        //    Update "Dock" parameters
<br>        if( m_position.x == 0 ) m_dock_x = -1;
<br>        else
<br>            if( m_position.x == m_pparent->GetClientSize().x - GetSize().x ) m_dock_x = 1;
<br>
<br>        if( m_position.y == 0 ) m_dock_y = -1;
<br>        else
<br>            if( m_position.y == m_pparent->GetClientSize().y - GetSize().y ) m_dock_y = 1;
<br>
<br>        // Now create a bitmap mask forthe frame shape.
<br>
<br>        if( m_marginsInvisible ) {
<br>
<br>            wxSize tool_size = m_ptoolbar->GetToolBitmapSize();
<br>
<br>            //  Determine whether the tool icons are meant (by style) to join without speces between
<br>            //  This will determine what type of region to draw.
<br>            bool b_overlap = false;
<br>
<br>            wxToolBarToolsList::compatibility_iterator node1 = m_ptoolbar->m_tools.GetFirst();
<br>            wxToolBarToolsList::compatibility_iterator node2 = node1->GetNext() ;
<br>
<br>            wxToolBarToolBase *tool1 = node1->GetData();
<br>            ocpnToolBarTool *tools1 = (ocpnToolBarTool *) tool1;
<br>
<br>            wxToolBarToolBase *tool2 = node2->GetData();
<br>            ocpnToolBarTool *tools2 = (ocpnToolBarTool *) tool2;
<br>
<br>            if( (tools1->m_x + tools1->m_width) >= tools2->m_x)
<br>                b_overlap = true;
<br>
<br>
<br>
<br>
<br>            int toolCount = m_ptoolbar->GetVisibleToolCount();
<br>
<br>            wxPoint upperLeft( m_style->GetLeftMargin(), m_style->GetTopMargin() );
<br>            wxSize visibleSize;
<br>            if( m_ptoolbar->IsVertical() ) {
<br>                int noTools = m_ptoolbar->GetMaxRows();
<br>                if( noTools > toolCount )
<br>                    noTools = toolCount;
<br>                visibleSize.x = m_ptoolbar->GetLineCount() * ( tool_size.x + m_style->GetTopMargin() );
<br>                visibleSize.y = noTools * ( tool_size.y + m_style->GetToolSeparation() );
<br>                visibleSize.x -= m_style->GetTopMargin();
<br>                visibleSize.y -= m_style->GetToolSeparation();
<br>            } else {
<br>                    int noTools = m_ptoolbar->GetMaxCols();
<br>                    if( noTools > toolCount )
<br>                        noTools = toolCount;
<br>                visibleSize.x = noTools * ( tool_size.x + m_style->GetToolSeparation() );
<br>                visibleSize.y = m_ptoolbar->GetLineCount() * ( tool_size.y + m_style->GetTopMargin() );
<br>                visibleSize.x -= m_style->GetToolSeparation();
<br>                visibleSize.y -= m_style->GetTopMargin();
<br>            }
<br>
<br>            wxBitmap shape( visibleSize.x + tool_size.x, visibleSize.y + tool_size.y);          // + fluff
<br>            wxMemoryDC sdc( shape );
<br>            sdc.SetBackground( *wxWHITE_BRUSH );
<br>            sdc.SetBrush( *wxBLACK_BRUSH );
<br>            sdc.SetPen( *wxBLACK_PEN );
<br>            sdc.Clear();
<br>
<br>            if(b_overlap) {
<br>                int lines = m_ptoolbar->GetLineCount();
<br>                for( int i = 1; i <= lines; i++ ) {
<br>                    if( m_ptoolbar->IsVertical() ) {
<br>                        wxSize barsize( tool_size.x, visibleSize.y );
<br>                        if( i == lines && i > 1 ) {
<br>                            int toolsInLastLine = toolCount % m_ptoolbar->GetMaxRows();
<br>                            if( toolsInLastLine == 0 ) toolsInLastLine = m_ptoolbar->GetMaxRows();
<br>                            int emptySpace = ( m_ptoolbar->GetMaxRows() - toolsInLastLine );
<br>                            barsize.y -= emptySpace
<br>                            * ( tool_size.y + m_style->GetToolSeparation() );
<br>                        }
<br>                        if( i == lines ) {
<br>                            // Also do grabber here, since it is to the right of the last line.
<br>                            wxRect grabMask( upperLeft, barsize );
<br>                            grabMask.width += m_style->GetIcon( _T("grabber") ).GetWidth();
<br>                            grabMask.height = m_style->GetIcon( _T("grabber") ).GetHeight();
<br>                            sdc.DrawRoundedRectangle( grabMask, m_style->GetToolbarCornerRadius() );
<br>                        }
<br>                        sdc.DrawRoundedRectangle( upperLeft, barsize,
<br>                                m_style->GetToolbarCornerRadius() );
<br>                        upperLeft.x += m_style->GetTopMargin() + tool_size.x;
<br>                    } else {
<br>                        wxSize barsize( visibleSize.x, tool_size.y );
<br>
<br>                        if( i == 1 ) {
<br>                            barsize.x += m_style->GetIcon( _T("grabber") ).GetWidth();
<br>                        }
<br>                        if( i == lines && i > 1 ) {
<br>                            int toolsInLastLine = toolCount % m_ptoolbar->GetMaxCols();
<br>                            if( toolsInLastLine == 0 ) toolsInLastLine = m_ptoolbar->GetMaxCols();
<br>                            int emptySpace = ( m_ptoolbar->GetMaxCols() - toolsInLastLine );
<br>                            barsize.x -= emptySpace * ( tool_size.x + m_style->GetToolSeparation() );
<br>                        }
<br>
<br>                        sdc.DrawRoundedRectangle( upperLeft, barsize,
<br>                                m_style->GetToolbarCornerRadius() );
<br>                        upperLeft.y += m_style->GetTopMargin() + tool_size.y;
<br>                    }
<br>                }
<br>            } //b_overlap
<br>            else {
<br>                for( wxToolBarToolsList::compatibility_iterator node = m_ptoolbar->m_tools.GetFirst(); node; node = node->GetNext() ) {
<br>                    wxToolBarToolBase *tool = node->GetData();
<br>                    ocpnToolBarTool *tools = (ocpnToolBarTool *) tool;
<br>                    wxRect toolRect = tools->trect;
<br>
<br>                    sdc.DrawRoundedRectangle( tools->m_x, tools->m_y, tool_size.x, tool_size.y,
<br>                                              m_style->GetToolbarCornerRadius() );
<br>                }
<br>            }
<br>
<br>#ifndef __OCPN__ANDROID__
<br>            if(shape.GetWidth() && shape.GetHeight())
<br>                SetShape( wxRegion( shape, *wxWHITE, 10 ) );
<br>#endif
<br>        }
<br>    }
<br>}
<br>
<br>void ocpnFloatingToolbarDialog::OnToolLeftClick( wxCommandEvent& event )
<br>{
<br>    // First see if it was actually the context menu that was clicked.
<br>
<br>    if( event.GetId() >= ID_PLUGIN_BASE + 100 ) {
<br>
<br>        int itemId = event.GetId() - ID_PLUGIN_BASE - 100;
<br>        wxMenuItem *item = g_FloatingToolbarConfigMenu->FindItem( event.GetId() );
<br>
<br>        if(item){
<br>            bool toolIsChecked = item->IsChecked();
<br>
<br>            if( toolIsChecked ) {
<br>                g_toolbarConfig.SetChar( itemId, _T('X') );
<br>            } else {
<br>
<br>                if( itemId + ID_ZOOMIN == ID_MOB ) {
<br>                    ToolbarMOBDialog mdlg( this );
<br>                    int dialog_ret = mdlg.ShowModal();
<br>                    int answer = mdlg.GetSelection();
<br>
<br>                    if( answer == 0 || answer == 1 || dialog_ret == wxID_CANCEL ) {
<br>                        g_FloatingToolbarConfigMenu->FindItem( event.GetId() )->Check( true );
<br>                        if( answer == 1 && dialog_ret == wxID_OK ) {
<br>                            g_bPermanentMOBIcon = true;
<br>                            delete g_FloatingToolbarConfigMenu;
<br>                            g_FloatingToolbarConfigMenu = new wxMenu();
<br>                            toolbarConfigChanged = true;
<br>                        }
<br>                        return;
<br>                    }
<br>                }
<br>
<br>                if( m_ptoolbar->GetVisibleToolCount() == 1 ) {
<br>                    OCPNMessageBox( this,
<br>                            _("You can't hide the last tool from the toolbar\nas this would make it inaccessible."),
<br>                            _("OpenCPN Alert"), wxOK );
<br>                    g_FloatingToolbarConfigMenu->FindItem( event.GetId() )->Check( true );
<br>                    return;
<br>                }
<br>
<br>                g_toolbarConfig.SetChar( itemId, _T('.') );
<br>            }
<br>        }
<br>
<br>        toolbarConfigChanged = true;
<br>        return;
<br>    }
<br>
<br>    // No it was a button that was clicked.
<br>    // Since Dialog events don't propagate automatically, we send it explicitly
<br>    // (instead of relying on event.Skip()). Send events up the window hierarchy
<br>
<br>    m_pparent->GetEventHandler()->AddPendingEvent( event );
<br>#ifndef __WXQT__
<br>    gFrame->Raise();
<br>#endif    
<br>}
<br>
<br>ocpnToolBarSimple *ocpnFloatingToolbarDialog::GetToolbar()
<br>{
<br>    if( !m_ptoolbar ) {
<br>        long winstyle = wxNO_BORDER | wxTB_FLAT;
<br>        winstyle |= m_orient;
<br>
<br>        m_ptoolbar = new ocpnToolBarSimple( this, -1, wxPoint( -1, -1 ), wxSize( -1, -1 ),
<br>                winstyle );
<br>
<br>        m_ptoolbar->SetBackgroundColour( GetGlobalColor( _T("GREY2") ) );
<br>        m_ptoolbar->ClearBackground();
<br>        m_ptoolbar->SetToggledBackgroundColour( GetGlobalColor( _T("GREY1") ) );
<br>        m_ptoolbar->SetColorScheme( m_cs );
<br>
<br>        SetGeometry(false, wxRect());
<br>    }
<br>
<br>    return m_ptoolbar;
<br>}
<br>
<br>void ocpnFloatingToolbarDialog::DestroyToolBar()
<br>{
<br>    if( m_ptoolbar ) {
<br>        m_ptoolbar->ClearTools();
<br>        delete m_ptoolbar;                  //->Destroy();
<br>        m_ptoolbar = NULL;
<br>    }
<br> 
<br>    m_destroyGrabber = m_pRecoverwin;
<br>    m_destroyTimer.Start( 5, wxTIMER_ONE_SHOT );           //  Destor the unneeded recovery grabber
<br>    
<br>}
<br>
<br>//----------------------------------------------------------------------------
<br>// Toolbar Tooltip Popup Window Definition
<br>//----------------------------------------------------------------------------
<br>class ToolTipWin: public wxDialog {
<br>public:
<br>    ToolTipWin( wxWindow *parent );
<br>    ~ToolTipWin();
<br>
<br>    void OnPaint( wxPaintEvent& event );
<br>
<br>    void SetColorScheme( ColorScheme cs );
<br>    void SetString( wxString &s )
<br>    {
<br>        m_string = s;
<br>    }
<br>    void SetPosition( wxPoint pt )
<br>    {
<br>        m_position = pt;
<br>    }
<br>    void SetBitmap( void );
<br>
<br>    void SetHiviz( bool hiviz){ m_hiviz = hiviz; }
<br>    
<br>    wxSize GetRenderedSize( void );
<br>    
<br>private:
<br>
<br>    wxString m_string;
<br>    wxSize m_size;
<br>    wxPoint m_position;
<br>    wxBitmap *m_pbm;
<br>    wxColour m_back_color;
<br>    wxColour m_text_color;
<br>    ColorScheme m_cs ;
<br>    bool m_hiviz;
<br>
<br>DECLARE_EVENT_TABLE()
<br>};
<br>//-----------------------------------------------------------------------
<br>//
<br>//    Toolbar Tooltip window implementation
<br>//
<br>//-----------------------------------------------------------------------
<br>BEGIN_EVENT_TABLE(ToolTipWin, wxDialog) EVT_PAINT(ToolTipWin::OnPaint)
<br>
<br>END_EVENT_TABLE()
<br>
<br>// Define a constructor
<br>ToolTipWin::ToolTipWin( wxWindow *parent ) :
<br>        wxDialog( parent, wxID_ANY, _T(""), wxPoint( 0, 0 ), wxSize( 1, 1 ),
<br>                wxNO_BORDER | wxSTAY_ON_TOP )
<br>{
<br>    m_pbm = NULL;
<br>
<br>    m_back_color = GetGlobalColor( _T ( "UIBCK" ) );
<br>    m_text_color = GetGlobalColor( _T ( "UITX1" ) );
<br>
<br>    SetBackgroundStyle( wxBG_STYLE_CUSTOM );
<br>    SetBackgroundColour( m_back_color );
<br>    m_cs = GLOBAL_COLOR_SCHEME_RGB;
<br>
<br>    Hide();
<br>}
<br>
<br>ToolTipWin::~ToolTipWin()
<br>{
<br>    delete m_pbm;
<br>}
<br>
<br>void ToolTipWin::SetColorScheme( ColorScheme cs )
<br>{
<br>    m_back_color = GetGlobalColor( _T ( "UIBCK" ) );
<br>    m_text_color = FontMgr::Get().GetFontColor( _("ToolTips") );
<br>
<br>    m_cs = cs;
<br>}
<br>
<br>wxSize ToolTipWin::GetRenderedSize( void )
<br>{
<br>    int h, w;
<br>    wxSize sz;
<br>
<br>    wxClientDC cdc( GetParent() );
<br>
<br>    wxFont *plabelFont = FontMgr::Get().GetFont( _("ToolTips") );
<br>    cdc.GetTextExtent( m_string, &w, &h, NULL, NULL, plabelFont );
<br>
<br>    sz.x = w + 8;
<br>    sz.y = h + 4;
<br>    
<br>    return sz;
<br>
<br>}
<br>
<br>void ToolTipWin::SetBitmap()
<br>{
<br>    int h, w;
<br>
<br>    wxClientDC cdc( GetParent() );
<br>
<br>    wxFont *plabelFont = FontMgr::Get().GetFont( _("ToolTips") );
<br>    cdc.GetTextExtent( m_string, &w, &h, NULL, NULL, plabelFont );
<br>
<br>    m_size.x = w + 8;
<br>    m_size.y = h + 4;
<br>
<br>    wxMemoryDC mdc;
<br>
<br>    delete m_pbm;
<br>    m_pbm = new wxBitmap( m_size.x, m_size.y, -1 );
<br>    mdc.SelectObject( *m_pbm );
<br>
<br>    wxPen pborder( m_text_color );
<br>    wxBrush bback( m_back_color );
<br>    mdc.SetPen( pborder );
<br>    mdc.SetBrush( bback );
<br>
<br>    if(m_hiviz){
<br>        if((m_cs == GLOBAL_COLOR_SCHEME_DUSK) || (m_cs == GLOBAL_COLOR_SCHEME_NIGHT)){
<br>            wxBrush hv_back( wxColour(200,200,200));
<br>            mdc.SetBrush( hv_back );
<br>        }
<br>    }
<br>    mdc.DrawRectangle( 0, 0, m_size.x, m_size.y );
<br>
<br>    //    Draw the text
<br>    mdc.SetFont( *plabelFont );
<br>    mdc.SetTextForeground( m_text_color );
<br>    mdc.SetTextBackground( m_back_color );
<br>
<br>    mdc.DrawText( m_string, 4, 2 );
<br>
<br>    SetSize( m_position.x, m_position.y, m_size.x, m_size.y );
<br>
<br>}
<br>
<br>void ToolTipWin::OnPaint( wxPaintEvent& event )
<br>{
<br>    int width, height;
<br>    GetClientSize( &width, &height );
<br>    wxPaintDC dc( this );
<br>
<br>    if( m_string.Len() ) {
<br>        wxMemoryDC mdc;
<br>        mdc.SelectObject( *m_pbm );
<br>        dc.Blit( 0, 0, width, height, &mdc, 0, 0 );
<br>    }
<br>}
<br>
<br>
<br>// ----------------------------------------------------------------------------
<br>BEGIN_EVENT_TABLE(ocpnToolBarSimple, wxControl) EVT_SIZE(ocpnToolBarSimple::OnSize)
<br>EVT_PAINT(ocpnToolBarSimple::OnPaint)
<br>EVT_KILL_FOCUS(ocpnToolBarSimple::OnKillFocus)
<br>EVT_MOUSE_EVENTS(ocpnToolBarSimple::OnMouseEvent)
<br>EVT_TIMER(TOOLTIPON_TIMER, ocpnToolBarSimple::OnToolTipTimerEvent)
<br>EVT_TIMER(TOOLTIPOFF_TIMER, ocpnToolBarSimple::OnToolTipOffTimerEvent)
<br>
<br>END_EVENT_TABLE()
<br>
<br>// ============================================================================
<br>// implementation
<br>// ============================================================================
<br>
<br>// ----------------------------------------------------------------------------
<br>// tool bar tools creation
<br>// ----------------------------------------------------------------------------
<br>
<br>wxToolBarToolBase *ocpnToolBarSimple::CreateTool( int id, const wxString& label,
<br>        const wxBitmap& bmpNormal, const wxBitmap& bmpDisabled, wxItemKind kind,
<br>        wxObject *clientData, const wxString& shortHelp, const wxString& longHelp )
<br>{
<br>    return new ocpnToolBarTool( this, id, label, bmpNormal, bmpDisabled, kind, clientData,
<br>            shortHelp, longHelp );
<br>}
<br>
<br>// ----------------------------------------------------------------------------
<br>// ocpnToolBarSimple creation
<br>// ----------------------------------------------------------------------------
<br>
<br>void ocpnToolBarSimple::Init()
<br>{
<br>    m_currentRowsOrColumns = 0;
<br>
<br>    m_lastX = m_lastY = 0;
<br>
<br>    m_maxWidth = m_maxHeight = 0;
<br>
<br>    m_pressedTool = m_currentTool = -1;
<br>
<br>    m_xPos = m_yPos = wxDefaultCoord;
<br>
<br>    m_style = g_StyleManager->GetCurrentStyle();
<br>
<br>    m_defaultWidth = 16;
<br>    m_defaultHeight = 15;
<br>
<br>    m_toggle_bg_color = wxSystemSettings::GetColour( wxSYS_COLOUR_3DFACE );
<br>    m_toolOutlineColour.Set( _T("BLACK") );
<br>    m_pToolTipWin = NULL;
<br>    m_last_ro_tool = NULL;
<br>
<br>    m_btoolbar_is_zooming = false;
<br>    m_sizefactor = 1.0f;
<br>
<br>    m_last_plugin_down_id = -1;
<br>    
<br>    EnableTooltips();
<br>}
<br>
<br>wxToolBarToolBase *ocpnToolBarSimple::DoAddTool( int id, const wxString& label,
<br>        const wxBitmap& bitmap, const wxBitmap& bmpDisabled, wxItemKind kind,
<br>        const wxString& shortHelp, const wxString& longHelp, wxObject *clientData, wxCoord xPos,
<br>        wxCoord yPos )
<br>{
<br>    // rememeber the position for DoInsertTool()
<br>    m_xPos = xPos;
<br>    m_yPos = yPos;
<br>
<br>    InvalidateBestSize();
<br>    return InsertTool( GetToolsCount(), id, label, bitmap, bmpDisabled, kind, shortHelp, longHelp,
<br>            clientData );
<br>
<br>}
<br>
<br>///
<br>
<br>wxToolBarToolBase *ocpnToolBarSimple::AddTool( int toolid, const wxString& label,
<br>        const wxBitmap& bitmap, const wxBitmap& bmpDisabled, wxItemKind kind,
<br>        const wxString& shortHelp, const wxString& longHelp, wxObject *data )
<br>{
<br>    InvalidateBestSize();
<br>    ocpnToolBarTool* tool = (ocpnToolBarTool*)InsertTool( GetToolsCount(), toolid, label, bitmap, bmpDisabled, kind,
<br>            shortHelp, longHelp, data );
<br>    return tool;
<br>}
<br>
<br>wxToolBarToolBase *ocpnToolBarSimple::InsertTool( size_t pos, int id, const wxString& label,
<br>        const wxBitmap& bitmap, const wxBitmap& bmpDisabled, wxItemKind kind,
<br>        const wxString& shortHelp, const wxString& longHelp, wxObject *clientData )
<br>{
<br>    wxCHECK_MSG( pos <= GetToolsCount(), (wxToolBarToolBase *)NULL,
<br>            _T("invalid position in wxToolBar::InsertTool()") );
<br>
<br>    wxToolBarToolBase *tool = CreateTool( id, label, bitmap, bmpDisabled, kind, clientData,
<br>            shortHelp, longHelp );
<br>
<br>    if( !InsertTool( pos, tool ) ) {
<br>        delete tool;
<br>
<br>        return NULL;
<br>    }
<br>
<br>    return tool;
<br>}
<br>
<br>wxToolBarToolBase *ocpnToolBarSimple::InsertTool( size_t pos, wxToolBarToolBase *tool )
<br>{
<br>    wxCHECK_MSG( pos <= GetToolsCount(), (wxToolBarToolBase *)NULL,
<br>            _T("invalid position in wxToolBar::InsertTool()") );
<br>
<br>    if( !tool || !DoInsertTool( pos, tool ) ) {
<br>        return NULL;
<br>    }
<br>
<br>    m_tools.Insert( pos, tool );
<br>
<br>    return tool;
<br>}
<br>
<br>bool ocpnToolBarSimple::DoInsertTool( size_t WXUNUSED(pos), wxToolBarToolBase *toolBase )
<br>{
<br>    ocpnToolBarTool *tool = (ocpnToolBarTool *) toolBase;
<br>
<br>    // Check if the plugin is inserting same-named tools. Make sure they have different names,
<br>    // otherwise the style manager cannot differentiate between them.
<br>    if( tool->isPluginTool ) {
<br>        for( unsigned int i=0; i<GetToolsCount(); i++ ) {
<br>            if( tool->GetToolname() == ((ocpnToolBarTool *)m_tools.Item(i)->GetData())->GetToolname()) {
<br>                tool->toolname << _T("1");
<br>            }
<br>        }
<br>    }
<br>
<br>    tool->m_x = m_xPos;
<br>    if( tool->m_x == wxDefaultCoord ) tool->m_x = m_style->GetLeftMargin();
<br>
<br>    tool->m_y = m_yPos;
<br>    if( tool->m_y == wxDefaultCoord ) tool->m_y = m_style->GetTopMargin();
<br>
<br>    if( tool->IsButton() ) {
<br>        tool->SetSize( GetToolSize() );
<br>
<br>        // Calculate reasonable max size in case Layout() not called
<br>        if( ( tool->m_x + tool->GetNormalBitmap().GetWidth() + m_style->GetLeftMargin() )
<br>                > m_maxWidth ) m_maxWidth = (wxCoord) ( ( tool->m_x + tool->GetWidth()
<br>                + m_style->GetLeftMargin() ) );
<br>
<br>        if( ( tool->m_y + tool->GetNormalBitmap().GetHeight() + m_style->GetTopMargin() )
<br>                > m_maxHeight ) m_maxHeight = (wxCoord) ( ( tool->m_y + tool->GetHeight()
<br>                + m_style->GetTopMargin() ) );
<br>    }
<br>
<br>    else
<br>        if( tool->IsControl() ) {
<br>            tool->SetSize( tool->GetControl()->GetSize() );
<br>        }
<br>
<br>    tool->b_hilite = false;
<br>
<br>    return true;
<br>}
<br>
<br>bool ocpnToolBarSimple::DoDeleteTool( size_t WXUNUSED(pos), wxToolBarToolBase *tool )
<br>{
<br>    // VZ: didn't test whether it works, but why not...
<br>    tool->Detach();
<br>
<br>    if( m_last_ro_tool == tool ) m_last_ro_tool = NULL;
<br>
<br>    Refresh( false );
<br>
<br>    return true;
<br>}
<br>
<br>bool ocpnToolBarSimple::Create( wxWindow *parent, wxWindowID id, const wxPoint& pos,
<br>        const wxSize& size, long style, const wxString& name )
<br>{
<br>    if( !wxWindow::Create( parent, id, pos, size, style, name ) ) return false;
<br>
<br>    // Set it to grey (or other 3D face colour)
<br>    SetBackgroundColour( wxSystemSettings::GetColour( wxSYS_COLOUR_3DFACE ) );
<br>
<br>    if( GetWindowStyleFlag() & wxTB_VERTICAL ) {
<br>        m_lastX = 7;
<br>        m_lastY = 3;
<br>
<br>        m_maxRows = 32000;      // a lot
<br>        m_maxCols = 1;
<br>    } else {
<br>        m_lastX = 3;
<br>        m_lastY = 7;
<br>
<br>        m_maxRows = 1;
<br>        m_maxCols = 32000;      // a lot
<br>    }
<br>
<br>    SetCursor( *wxSTANDARD_CURSOR );
<br>
<br>    m_tooltip_timer.SetOwner( this, TOOLTIPON_TIMER );
<br>    m_tooltipoff_timer.SetOwner( this, TOOLTIPOFF_TIMER );
<br>    m_tooltip_off = 3000;
<br>
<br>    return true;
<br>}
<br>
<br>ocpnToolBarSimple::~ocpnToolBarSimple()
<br>{
<br>    if( m_pToolTipWin ) {
<br>        m_pToolTipWin->Destroy();
<br>        m_pToolTipWin = NULL;
<br>    }
<br>
<br>}
<br>
<br>void ocpnToolBarSimple::KillTooltip()
<br>{
<br>    m_btooltip_show = false;
<br>
<br>    if( m_pToolTipWin ) {
<br>        m_pToolTipWin->Hide();
<br>        m_pToolTipWin->Destroy();
<br>        m_pToolTipWin = NULL;
<br>    }
<br>    m_tooltip_timer.Stop();
<br>
<br>    if( m_last_ro_tool ) {
<br>        if( m_last_ro_tool->IsEnabled() ) {
<br>            if( m_last_ro_tool->IsToggled() ) {
<br>                m_last_ro_tool->SetNormalBitmap( m_style->GetToolIcon( m_last_ro_tool->GetToolname(), TOOLICON_TOGGLED ) );
<br>            }
<br>            else {
<br>                m_last_ro_tool->SetNormalBitmap( m_style->GetToolIcon( m_last_ro_tool->GetToolname(), TOOLICON_NORMAL ) );
<br>            }
<br>        }
<br>    }
<br>}
<br>
<br>void ocpnToolBarSimple::HideTooltip()
<br>{
<br>    if( m_pToolTipWin ) {
<br>        m_pToolTipWin->Hide();
<br>    }
<br>}
<br>
<br>void ocpnToolBarSimple::SetColorScheme( ColorScheme cs )
<br>{
<br>    if( m_pToolTipWin ) {
<br>        m_pToolTipWin->Destroy();
<br>        m_pToolTipWin = NULL;
<br>    }
<br>
<br>    m_toolOutlineColour = GetGlobalColor( _T("UIBDR") );
<br>
<br>    m_currentColorScheme = cs;
<br>}
<br>
<br>bool ocpnToolBarSimple::Realize()
<br>{
<br>    m_currentRowsOrColumns = 0;
<br>    m_LineCount = 1;
<br>    m_lastX = m_style->GetLeftMargin();
<br>    m_lastY = m_style->GetTopMargin();
<br>    m_maxWidth = 0;
<br>    m_maxHeight = 0;
<br>
<br>    if( IsVertical() ) m_style->SetOrientation( wxTB_VERTICAL );
<br>    else
<br>        m_style->SetOrientation( wxTB_HORIZONTAL );
<br>
<br>    wxSize toolSize = wxSize(-1, -1);
<br>    int separatorSize = m_style->GetToolSeparation();
<br>
<br>    ocpnToolBarTool *lastTool = NULL;
<br>    bool firstNode = true;
<br>    wxToolBarToolsList::compatibility_iterator node = m_tools.GetFirst();
<br>
<br>    while( node ) {
<br>        ocpnToolBarTool *tool = (ocpnToolBarTool *) node->GetData();
<br>
<br>        // Set the tool size to be the size of the first non-separator tool, usually the first one
<br>        if(toolSize.x == -1){
<br>            if( !tool->IsSeparator() ){
<br>                toolSize.x = tool->m_width;
<br>                toolSize.y = tool->m_height;
<br>            }
<br>        }
<br>
<br>        tool->firstInLine = firstNode;
<br>        tool->lastInLine = false;
<br>        firstNode = false;
<br>
<br>        tool->last_rect.width = 0;              // mark it invalid
<br>        
<br>        if( tool->IsSeparator() ) {
<br>            if( GetWindowStyleFlag() & wxTB_HORIZONTAL ) {
<br>                if( m_currentRowsOrColumns >= m_maxCols ) m_lastY += separatorSize;
<br>                else
<br>                    m_lastX += separatorSize;
<br>            } else {
<br>                if( m_currentRowsOrColumns >= m_maxRows ) m_lastX += separatorSize;
<br>                else
<br>                    m_lastY += separatorSize;
<br>            }
<br>        } else
<br>            if( tool->IsButton() ) {
<br>                if( !IsVertical() ) {
<br>                    if( m_currentRowsOrColumns >= m_maxCols ) {
<br>                        tool->firstInLine = true;
<br>                        if( lastTool && m_LineCount > 1 ) lastTool->lastInLine = true;
<br>                        m_LineCount++;
<br>                        m_currentRowsOrColumns = 0;
<br>                        m_lastX = m_style->GetLeftMargin();
<br>                        m_lastY += toolSize.y + m_style->GetTopMargin();
<br>                    }
<br>                    tool->m_x = (wxCoord) m_lastX;
<br>                    tool->m_y = (wxCoord) m_lastY;
<br>
<br>                    tool->trect = wxRect( tool->m_x, tool->m_y, toolSize.x, toolSize.y );
<br>                    tool->trect.Inflate( m_style->GetToolSeparation() / 2,
<br>                            m_style->GetTopMargin() );
<br>
<br>                    m_lastX += toolSize.x + m_style->GetToolSeparation();
<br>                } else {
<br>                    if( m_currentRowsOrColumns >= m_maxRows ) {
<br>                        tool->firstInLine = true;
<br>                        if( lastTool ) lastTool->lastInLine = true;
<br>                        m_LineCount++;
<br>                        m_currentRowsOrColumns = 0;
<br>                        m_lastX += toolSize.x + m_style->GetTopMargin();
<br>                        m_lastY = m_style->GetTopMargin();
<br>                    }
<br>                    tool->m_x = (wxCoord) m_lastX;
<br>                    tool->m_y = (wxCoord) m_lastY;
<br>
<br>                    tool->trect = wxRect( tool->m_x, tool->m_y, toolSize.x, toolSize.y );
<br>                    tool->trect.Inflate( m_style->GetToolSeparation() / 2,
<br>                            m_style->GetTopMargin() );
<br>
<br>                    m_lastY += toolSize.y + m_style->GetToolSeparation();
<br>                }
<br>                m_currentRowsOrColumns++;
<br>            } else
<br>                if( tool->IsControl() ) {
<br>                    tool->m_x = (wxCoord) ( m_lastX );
<br>                    tool->m_y = (wxCoord) ( m_lastY - ( m_style->GetTopMargin() / 2 ) );
<br>
<br>                    tool->trect = wxRect( tool->m_x, tool->m_y, tool->GetWidth(),
<br>                            tool->GetHeight() );
<br>                    tool->trect.Inflate( m_style->GetToolSeparation() / 2,
<br>                            m_style->GetTopMargin() );
<br>                    ;
<br>
<br>                    wxSize s = tool->GetControl()->GetSize();
<br>                    m_lastX += s.x + m_style->GetToolSeparation();
<br>
<br>                }
<br>
<br>        if( m_lastX > m_maxWidth ) m_maxWidth = m_lastX;
<br>        if( m_lastY > m_maxHeight ) m_maxHeight = m_lastY;
<br>
<br>        lastTool = tool;
<br>        node = node->GetNext();
<br>    }
<br>    if( lastTool && (m_LineCount > 1 || IsVertical()) )
<br>        lastTool->lastInLine = true;
<br>
<br>    if( GetWindowStyleFlag() & wxTB_HORIZONTAL ) m_maxHeight += toolSize.y;
<br>    else
<br>        m_maxWidth += toolSize.x;
<br>
<br>    m_maxWidth += m_style->GetRightMargin();
<br>    m_maxHeight += m_style->GetBottomMargin();
<br>
<br>    SetSize( m_maxWidth, m_maxHeight );
<br>    SetMinSize( wxSize( m_maxWidth, m_maxHeight ) );
<br>
<br>    return true;
<br>}
<br>
<br>// ----------------------------------------------------------------------------
<br>// event handlers
<br>// ----------------------------------------------------------------------------
<br>
<br>void ocpnToolBarSimple::OnPaint( wxPaintEvent& WXUNUSED(event) )
<br>{
<br>    wxPaintDC dc( this );
<br>    PrepareDC( dc );
<br>
<br>    wxRegion ru = GetUpdateRegion();
<br>    wxRect upRect = ru.GetBox();
<br>
<br>    static int count = 0;
<br>    // Prevent reentry of OnPaint which would cause wxMemoryDC errors.
<br>    if( count > 0 ) return;
<br>    count++;
<br>
<br>    for( wxToolBarToolsList::compatibility_iterator node = m_tools.GetFirst(); node;
<br>            node = node->GetNext() ) {
<br>        wxToolBarToolBase *tool = node->GetData();
<br>        ocpnToolBarTool *tools = (ocpnToolBarTool *) tool;
<br>        wxRect toolRect = tools->trect;
<br>
<br>        if( toolRect.Intersects( upRect ) ) {
<br>
<br>            if( tool->IsButton() ) {
<br>                DrawTool( dc, tool );
<br>            } else
<br>                if( tool->IsControl() ) {
<br>                    if( tool->GetControl()->IsKindOf( CLASSINFO(wxStaticBitmap) ) ) {
<br>                        wxStaticBitmap *psbm = (wxStaticBitmap *) tool->GetControl();
<br>                        ocpnToolBarTool *toolsimp = (ocpnToolBarTool *) tool;
<br>                        dc.DrawBitmap( psbm->GetBitmap(), toolsimp->m_x, toolsimp->m_y, false );
<br>                    }
<br>                }
<br>        }
<br>    }
<br>
<br>    count--;
<br>}
<br>
<br>void ocpnToolBarSimple::OnSize( wxSizeEvent& WXUNUSED(event) )
<br>{
<br>    if( GetAutoLayout() ) Layout();
<br>}
<br>
<br>void ocpnToolBarSimple::OnKillFocus( wxFocusEvent& WXUNUSED(event) )
<br>{
<br>    OnMouseEnter( m_pressedTool = m_currentTool = -1 );
<br>}
<br>
<br>void ocpnToolBarSimple::OnToolTipTimerEvent( wxTimerEvent& event )
<br>{
<br>    if( !gFrame->IsActive() ) return;
<br>
<br>    if( m_btooltip_show && IsShown() && m_pToolTipWin && ( !m_pToolTipWin->IsShown() ) ) {
<br>        if( m_last_ro_tool ) {
<br>            wxString s = m_last_ro_tool->GetShortHelp();
<br>
<br>            if( s.Len() ) {
<br>                m_pToolTipWin->SetString( s );
<br>                m_pToolTipWin->SetHiviz(m_last_ro_tool->m_btooltip_hiviz);
<br>
<br>                wxPoint pos_in_toolbar( m_last_ro_tool->m_x, m_last_ro_tool->m_y );
<br>                pos_in_toolbar.x += m_last_ro_tool->m_width + 2;
<br>
<br>                m_pToolTipWin->Move(0,0);       // workaround for gtk autocentre dialog behavior
<br>
<br>                wxPoint screenPosition = ClientToScreen( pos_in_toolbar );
<br>                wxPoint framePosition = gFrame->ScreenToClient(screenPosition);
<br>                wxSize tipSize = m_pToolTipWin->GetRenderedSize();
<br>                
<br>                if( (framePosition.x + tipSize.x) > gFrame->GetSize().x)
<br>                    screenPosition.x -= (tipSize.x + m_last_ro_tool->m_width + 4);
<br>                
<br>                m_pToolTipWin->SetPosition( screenPosition );
<br>                m_pToolTipWin->SetBitmap();
<br>                m_pToolTipWin->Show();
<br>                gFrame->Raise();
<br>                if( g_btouch )
<br>                    m_tooltipoff_timer.Start(m_tooltip_off, wxTIMER_ONE_SHOT);
<br>            }
<br>        }
<br>    }
<br>}
<br>
<br>void ocpnToolBarSimple::OnToolTipOffTimerEvent( wxTimerEvent& event )
<br>{
<br>    HideTooltip();
<br>}
<br>
<br>
<br>int s_dragx, s_dragy;
<br>
<br>void ocpnToolBarSimple::OnMouseEvent( wxMouseEvent & event )
<br>{
<br>#ifdef __OCPN__ANDROID__
<br>    if(!event.IsButton())
<br>        return;
<br>#endif
<br>
<br>    wxCoord x, y;
<br>    event.GetPosition( &x, &y );
<br>    ocpnToolBarTool *tool = (ocpnToolBarTool *) FindToolForPosition( x, y );
<br>
<br>#ifndef __OCPN__ANDROID__
<br>    if( event.LeftDown() ) {
<br>        CaptureMouse();
<br>        s_dragx = x;
<br>        s_dragy = y;
<br>    }
<br>    if( event.LeftUp() ) {
<br>        if( HasCapture() ) ReleaseMouse();
<br>    }
<br>#endif
<br>
<br>    if( tool && tool->IsButton() && IsShown() ) {
<br>
<br>        //    ToolTips
<br>        if( NULL == m_pToolTipWin ) {
<br>            m_pToolTipWin = new ToolTipWin( GetParent() );
<br>            m_pToolTipWin->SetColorScheme( m_currentColorScheme );
<br>            m_pToolTipWin->Hide();
<br>        }
<br>
<br>        if( tool != m_last_ro_tool ) m_pToolTipWin->Hide();
<br>
<br>#ifndef __OCPN__ANDROID__
<br>        if( !m_pToolTipWin->IsShown() ) {
<br>            m_tooltip_timer.Start( m_one_shot, wxTIMER_ONE_SHOT );
<br>        }
<br>#endif
<br>
<br>        //    Tool Rollover highlighting
<br>        if(!g_btouch){
<br>            if( tool != m_last_ro_tool ) {
<br>                if( tool->IsEnabled() ) {
<br>                    tool->rollover = true;
<br>                    tool->bitmapOK = false;
<br>                }
<br>                if( m_last_ro_tool ) {
<br>                    if( m_last_ro_tool->IsEnabled() ) {
<br>                        m_last_ro_tool->rollover = false;
<br>                        m_last_ro_tool->bitmapOK = false;
<br>                    }
<br>                }
<br>                m_last_ro_tool = tool;
<br>                if(g_toolbar)
<br>                    g_toolbar->Refresh( false );
<br>            }
<br>        }
<br>    } else {
<br>        //    Tooltips
<br>        if( m_pToolTipWin && m_pToolTipWin->IsShown() ) m_pToolTipWin->Hide();
<br>
<br>        //    Remove Highlighting
<br>        if( m_last_ro_tool ) {
<br>            if( m_last_ro_tool->IsEnabled() ) {
<br>                m_last_ro_tool->rollover = false;
<br>                m_last_ro_tool->bitmapOK = false;
<br>            }
<br>            g_toolbar->Refresh( false );
<br>        }
<br>    }
<br>
<br>    m_last_ro_tool = tool;
<br>
<br>    // allow smooth zooming while toolbutton is held down
<br>    if(g_bsmoothpanzoom && !g_btouch) {
<br>        if(event.LeftUp() && m_btoolbar_is_zooming) {
<br>            cc1->StopMovement();
<br>            m_btoolbar_is_zooming = false;
<br>            return;
<br>        }
<br>
<br>        if( event.LeftDown() && tool &&
<br>            (tool->GetId() == ID_ZOOMIN || tool->GetId() == ID_ZOOMOUT) ) {
<br>            cc1->ZoomCanvas( tool->GetId() == ID_ZOOMIN ? 2.0 : .5, false, false );
<br>            m_btoolbar_is_zooming = true;
<br>            return;
<br>        }
<br>    }
<br>
<br>    if( !tool ) {
<br>        if( m_currentTool > -1 ) {
<br>            if( event.LeftIsDown() ) SpringUpButton( m_currentTool );
<br>            m_currentTool = -1;
<br>            OnMouseEnter( -1 );
<br>        }
<br>
<br>        wxMouseEvent *pev = (wxMouseEvent *) event.Clone();
<br>        GetParent()->GetEventHandler()->AddPendingEvent( *pev );
<br>        wxDELETE( pev );
<br>
<br>        return;
<br>    }
<br>
<br>    if( !event.IsButton() ) {
<br>        if( tool->GetId() != m_currentTool ) {
<br>            // If the left button is kept down and moved over buttons,
<br>            // press those buttons.
<br>            if( event.LeftIsDown() && tool->IsEnabled() ) {
<br>                SpringUpButton( m_currentTool );
<br>
<br>                if( tool->CanBeToggled() ) {
<br>                    tool->Toggle();
<br>                }
<br>
<br>                DrawTool( tool );
<br>            }
<br>
<br>            m_currentTool = tool->GetId();
<br>            OnMouseEnter( m_currentTool );
<br>        }
<br>
<br>        wxMouseEvent *pev = (wxMouseEvent *) event.Clone();
<br>        GetParent()->GetEventHandler()->AddPendingEvent( *pev );
<br>        wxDELETE( pev );
<br>
<br>        return;
<br>    }
<br>
<br>    // Left button pressed.
<br>    if( event.LeftDown() && tool->IsEnabled() ) {
<br>        if( tool->CanBeToggled() ) {
<br>            tool->Toggle();
<br>            tool->bitmapOK = false;
<br>            
<br>        }
<br>
<br>        DrawTool( tool );
<br>
<br>        //        Look for PlugIn tools
<br>        //        If found, make the callback.
<br>        if( g_pi_manager ) {
<br>            ArrayOfPlugInToolbarTools tool_array = g_pi_manager->GetPluginToolbarToolArray();
<br>            for( unsigned int i = 0; i < tool_array.GetCount(); i++ ) {
<br>                PlugInToolbarToolContainer *pttc = tool_array.Item( i );
<br>                if( tool->GetId() == pttc->id ) {
<br>                    opencpn_plugin_113 *ppi = dynamic_cast<opencpn_plugin_113 *>(pttc->m_pplugin);
<br>                    if( ppi ) {
<br>                        ppi->OnToolbarToolDownCallback( pttc->id );
<br>                        m_last_plugin_down_id = pttc->id;
<br>                    }
<br>                }
<br>            }
<br>        }
<br>    } else
<br>        if( event.RightDown() ) {
<br>            OnRightClick( tool->GetId(), x, y );
<br>        }
<br>
<br>    // Left Button Released.  Only this action confirms selection.
<br>    // If the button is enabled and it is not a toggle tool and it is
<br>    // in the pressed state, then raise the button and call OnLeftClick.
<br>    //
<br>    if( event.LeftUp() && tool->IsEnabled() ) {
<br>        // Pass the OnLeftClick event to tool
<br>        if( !OnLeftClick( tool->GetId(), tool->IsToggled() ) && tool->CanBeToggled() ) {
<br>            // If it was a toggle, and OnLeftClick says No Toggle allowed,
<br>            // then change it back
<br>            tool->Toggle();
<br>            tool->bitmapOK = false;
<br>        }
<br>
<br>        DoPluginToolUp();
<br>    }
<br>
<br>    wxMouseEvent *pev = (wxMouseEvent *) event.Clone();
<br>    GetParent()->GetEventHandler()->AddPendingEvent( *pev );
<br>    wxDELETE( pev );
<br>    event.Skip();
<br>}
<br>
<br>// ----------------------------------------------------------------------------
<br>// drawing
<br>// ----------------------------------------------------------------------------
<br>
<br>void ocpnToolBarSimple::DrawTool( wxToolBarToolBase *tool )
<br>{
<br>    wxClientDC dc( this );
<br>    DrawTool( dc, tool );
<br>}
<br>
<br>// NB! The current DrawTool code assumes that plugin tools are never disabled
<br>// when they are present on the toolbar, since disabled plugins are removed.
<br>
<br>void ocpnToolBarSimple::DrawTool( wxDC& dc, wxToolBarToolBase *toolBase )
<br>{
<br>    ocpnToolBarTool *tool = (ocpnToolBarTool *) toolBase;
<br>    PrepareDC( dc );
<br>
<br>    wxPoint drawAt( tool->m_x, tool->m_y );
<br>    wxBitmap bmp;
<br>
<br>    if( tool->bitmapOK ) {
<br>        if( tool->IsEnabled() ) {
<br>            bmp = tool->GetNormalBitmap();
<br>            if( !bmp.IsOk() ){
<br>                bmp = m_style->GetToolIcon( tool->GetToolname(), TOOLICON_NORMAL, tool->rollover );
<br>                if(m_sizefactor > 1.0 ){
<br><mark>                    wxImage scaled_image = bmp.ConvertToImage();
</mark><br><mark>                    bmp = wxBitmap(scaled_image.Scale(tool->m_width, tool->m_height, wxIMAGE_QUALITY_HIGH));
</mark><br>                }
<br>                tool->SetNormalBitmap( bmp );
<br>                tool->bitmapOK = true;
<br>            }
<br>        } else {
<br>            bmp = tool->GetDisabledBitmap();
<br>            if( !bmp.IsOk() ){
<br>                bmp = m_style->GetToolIcon( tool->GetToolname(), TOOLICON_DISABLED );
<br>                if(m_sizefactor > 1.0 ){
<br><mark>                    wxImage scaled_image = bmp.ConvertToImage();
</mark><br><mark>                    bmp = wxBitmap(scaled_image.Scale(tool->m_width, tool->m_height, wxIMAGE_QUALITY_HIGH));
</mark><br>                }
<br>                tool->SetDisabledBitmap( bmp );
<br>                tool->bitmapOK = true;
<br>            }
<br>        }
<br>    } else {
<br>        if ( tool->isPluginTool ) {
<br>
<br>            // First try getting the icon from the Style.
<br>            // If it is not in the style we build a new icon from the style BG and the plugin icon.
<br>
<br>            if( tool->IsToggled() ) {
<br>                bmp = m_style->GetToolIcon( tool->GetToolname(), TOOLICON_TOGGLED, tool->rollover );
<br>                if( bmp.GetDepth() == 1 ) {
<br>                    if( tool->rollover ) {
<br>                        bmp = m_style->BuildPluginIcon( tool->pluginRolloverIcon, TOOLICON_TOGGLED );
<br>                        if( ! bmp.IsOk() )
<br>                            bmp = m_style->BuildPluginIcon( tool->pluginNormalIcon, TOOLICON_TOGGLED );
<br>                    }
<br>                    else
<br>                        bmp = m_style->BuildPluginIcon( tool->pluginNormalIcon, TOOLICON_TOGGLED );
<br>                }
<br>            } else {
<br>                bmp = m_style->GetToolIcon( tool->GetToolname(), TOOLICON_NORMAL, tool->rollover );
<br>                if( bmp.GetDepth() == 1 ) {
<br>                    if( tool->rollover ) {
<br>                        bmp = m_style->BuildPluginIcon( tool->pluginRolloverIcon, TOOLICON_NORMAL );
<br>                        if( ! bmp.IsOk() )
<br>                            bmp = m_style->BuildPluginIcon( tool->pluginNormalIcon, TOOLICON_NORMAL );
<br>                    }
<br>                    else
<br>                        bmp = m_style->BuildPluginIcon( tool->pluginNormalIcon, TOOLICON_NORMAL );
<br>                }
<br>            }
<br>            if(m_sizefactor > 1.0 ){
<br><mark>                wxImage scaled_image = bmp.ConvertToImage();
</mark><br><mark>                bmp = wxBitmap(scaled_image.Scale(tool->m_width, tool->m_height, wxIMAGE_QUALITY_HIGH));
</mark><br>            }
<br>            tool->SetNormalBitmap( bmp );
<br>            tool->bitmapOK = true;
<br>        } else {
<br>            if( tool->IsEnabled() ) {
<br>                if( tool->IsToggled() )
<br>                    bmp = m_style->GetToolIcon( tool->GetToolname(), TOOLICON_TOGGLED, tool->rollover );
<br>                else
<br>                    bmp = m_style->GetToolIcon( tool->GetIconName(), TOOLICON_NORMAL, tool->rollover );
<br>
<br>                if(m_sizefactor > 1.0 ){
<br><mark>                    wxImage scaled_image = bmp.ConvertToImage();
</mark><br><mark>                    bmp = wxBitmap(scaled_image.Scale(tool->m_width, tool->m_height, wxIMAGE_QUALITY_HIGH));
</mark><br>                }
<br>                tool->SetNormalBitmap( bmp );
<br>                tool->bitmapOK = true;
<br>            } else {
<br>                bmp = m_style->GetToolIcon( tool->GetToolname(), TOOLICON_DISABLED );
<br>                if(m_sizefactor > 1.0 ){
<br><mark>                    wxImage scaled_image = bmp.ConvertToImage();
</mark><br><mark>                    bmp = wxBitmap(scaled_image.Scale(tool->m_width, tool->m_height, wxIMAGE_QUALITY_HIGH));
</mark><br>                }
<br>                tool->SetDisabledBitmap( bmp );
<br>                tool->bitmapOK = true;
<br>            }
<br>        }
<br>    }
<br>
<br>    if( tool->firstInLine ) {
<br>        m_style->DrawToolbarLineStart( bmp );
<br>    }
<br>    if( tool->lastInLine ) {
<br>        m_style->DrawToolbarLineEnd( bmp );
<br>    }
<br>
<br>    if( bmp.GetWidth() != m_style->GetToolSize().x
<br>            || bmp.GetHeight() != m_style->GetToolSize().y ) {
<br>//        drawAt.x -= ( bmp.GetWidth() - m_style->GetToolSize().x ) / 2;
<br>//        drawAt.y -= ( bmp.GetHeight() - m_style->GetToolSize().y ) / 2;
<br>    }
<br>
<br>    //      Clear the last drawn tool if necessary
<br>    if( tool->last_rect.width && ((tool->last_rect.x != drawAt.x) || (tool->last_rect.y != drawAt.y)) ){
<br>        wxBrush bb(GetGlobalColor( _T("GREY2") ));
<br>        dc.SetBrush(bb);
<br>        dc.SetPen( *wxTRANSPARENT_PEN );
<br>        dc.DrawRectangle(tool->last_rect.x, tool->last_rect.y, tool->last_rect.width, tool->last_rect.height);
<br>    }
<br>
<br>    //  could cache this in the tool...
<br>    //  A bit of a hack here.  We only scale tools if they are to be magnified globally
<br>    if(0/*m_sizefactor > 1.0*/ )
<br>    {
<br><mark>        wxImage scaled_image = bmp.ConvertToImage();
</mark><br><mark>        wxBitmap sbmp = wxBitmap(scaled_image.Scale(tool->m_width, tool->m_height, wxIMAGE_QUALITY_HIGH));
</mark><br>        dc.DrawBitmap( sbmp, drawAt );
<br>        tool->last_rect = wxRect(drawAt.x, drawAt.y, sbmp.GetWidth(), sbmp.GetHeight());
<br>
<br>    }
<br>    else
<br>    {
<br>        dc.DrawBitmap( bmp, drawAt );
<br>        tool->last_rect = wxRect(drawAt.x, drawAt.y, bmp.GetWidth(), bmp.GetHeight());
<br>    }
<br>
<br>}
<br>
<br>// ----------------------------------------------------------------------------
<br>// toolbar geometry
<br>// ----------------------------------------------------------------------------
<br>
<br>wxToolBarToolBase *ocpnToolBarSimple::FindToolForPosition( wxCoord x, wxCoord y )
<br>{
<br>    wxToolBarToolsList::compatibility_iterator node = m_tools.GetFirst();
<br>    while( node ) {
<br>        ocpnToolBarTool *tool = (ocpnToolBarTool *) node->GetData();
<br>        if( ( x >= tool->m_x ) && ( y >= tool->m_y ) && ( x < ( tool->m_x + tool->GetWidth() ) )
<br>                && ( y < ( tool->m_y + tool->GetHeight() ) ) ) {
<br>            return tool;
<br>        }
<br>
<br>        node = node->GetNext();
<br>    }
<br>
<br>    return (wxToolBarToolBase *) NULL;
<br>}
<br>
<br>void ocpnToolBarSimple::InvalidateBitmaps()
<br>{
<br>    wxToolBarToolsList::compatibility_iterator node = m_tools.GetFirst();
<br>    while( node ) {
<br>        ocpnToolBarTool *tool = (ocpnToolBarTool *) node->GetData();
<br>        tool->bitmapOK = false;
<br>        node = node->GetNext();
<br>    }
<br>}
<br>
<br>wxRect ocpnToolBarSimple::GetToolRect( int tool_id )
<br>{
<br>    wxRect rect;
<br>    wxToolBarToolBase *tool = FindById( tool_id );
<br>    if( tool ) {
<br>        ocpnToolBarTool *otool = (ocpnToolBarTool *) tool;
<br>        if( otool ) rect = otool->trect;
<br>    }
<br>
<br>    return rect;
<br>}
<br>
<br>// ----------------------------------------------------------------------------
<br>// tool state change handlers
<br>// ----------------------------------------------------------------------------
<br>
<br>void ocpnToolBarSimple::DoEnableTool( wxToolBarToolBase *tool, bool WXUNUSED(enable) )
<br>{
<br>    DrawTool( tool );
<br>}
<br>
<br>void ocpnToolBarSimple::DoToggleTool( wxToolBarToolBase *tool, bool WXUNUSED(toggle) )
<br>{
<br>    ocpnToolBarTool *t = (ocpnToolBarTool *) tool;
<br>    t->bitmapOK = false;
<br>    DrawTool( tool );
<br>}
<br>
<br>// Okay, so we've left the tool we're in ... we must check if the tool we're
<br>// leaving was a 'sprung push button' and if so, spring it back to the up
<br>// state.
<br>void ocpnToolBarSimple::SpringUpButton( int id )
<br>{
<br>    wxToolBarToolBase *tool = FindById( id );
<br>
<br>    if( tool && tool->CanBeToggled() ) {
<br>        if( tool->IsToggled() ) tool->Toggle();
<br>
<br>        DrawTool( tool );
<br>    }
<br>}
<br>
<br>// ----------------------------------------------------------------------------
<br>// scrolling implementation
<br>// ----------------------------------------------------------------------------
<br>
<br>wxString ocpnToolBarSimple::GetToolShortHelp( int id ) const
<br>{
<br>    wxToolBarToolBase *tool = FindById( id );
<br>    wxCHECK_MSG( tool, wxEmptyString, _T("no such tool") );
<br>
<br>    return tool->GetShortHelp();
<br>}
<br>
<br>wxString ocpnToolBarSimple::GetToolLongHelp( int id ) const
<br>{
<br>    wxToolBarToolBase *tool = FindById( id );
<br>    wxCHECK_MSG( tool, wxEmptyString, _T("no such tool") );
<br>
<br>    return tool->GetLongHelp();
<br>}
<br>
<br>void ocpnToolBarSimple::SetToolShortHelp( int id, const wxString& help )
<br>{
<br>    wxToolBarToolBase *tool = FindById( id );
<br>    if( tool ) {
<br>        (void) tool->SetShortHelp( help );
<br>    }
<br>}
<br>
<br>void ocpnToolBarSimple::SetToolLongHelp( int id, const wxString& help )
<br>{
<br>    wxToolBarToolBase *tool = FindById( id );
<br>    if( tool ) {
<br>        (void) tool->SetLongHelp( help );
<br>    }
<br>}
<br>
<br>int ocpnToolBarSimple::GetToolPos( int id ) const
<br>{
<br>    size_t pos = 0;
<br>    wxToolBarToolsList::compatibility_iterator node;
<br>
<br>    for( node = m_tools.GetFirst(); node; node = node->GetNext() ) {
<br>        if( node->GetData()->GetId() == id ) return pos;
<br>
<br>        pos++;
<br>    }
<br>
<br>    return wxNOT_FOUND;
<br>}
<br>bool ocpnToolBarSimple::GetToolState( int id ) const
<br>{
<br>    wxToolBarToolBase *tool = FindById( id );
<br>    wxCHECK_MSG( tool, false, _T("no such tool") );
<br>
<br>    return tool->IsToggled();
<br>}
<br>
<br>bool ocpnToolBarSimple::GetToolEnabled( int id ) const
<br>{
<br>    wxToolBarToolBase *tool = FindById( id );
<br>    wxCHECK_MSG( tool, false, _T("no such tool") );
<br>
<br>    return tool->IsEnabled();
<br>}
<br>
<br>void ocpnToolBarSimple::ToggleTool( int id, bool toggle )
<br>{
<br>    wxToolBarToolBase *tool = FindById( id );
<br>        
<br>    if( tool && tool->CanBeToggled() && tool->Toggle( toggle ) ) {
<br>        DoToggleTool( tool, toggle );
<br>        if( g_toolbar ) g_toolbar->Refresh();
<br>    }
<br>}
<br>
<br>wxObject *ocpnToolBarSimple::GetToolClientData( int id ) const
<br>{
<br>    wxToolBarToolBase *tool = FindById( id );
<br>    return tool ? tool->GetClientData() : (wxObject *) NULL;
<br>}
<br>
<br>void ocpnToolBarSimple::SetToolClientData( int id, wxObject *clientData )
<br>{
<br>    wxToolBarToolBase *tool = FindById( id );
<br>
<br>    wxCHECK_RET( tool, _T("no such tool in wxToolBar::SetToolClientData") );
<br>
<br>    tool->SetClientData( clientData );
<br>}
<br>
<br>void ocpnToolBarSimple::EnableTool( int id, bool enable )
<br>{
<br>    wxToolBarToolBase *tool = FindById( id );
<br>    if( tool ) {
<br>        if( tool->Enable( enable ) ) {
<br>            DoEnableTool( tool, enable );
<br>        }
<br>    }
<br>    wxMenuItem* configItem = g_FloatingToolbarConfigMenu->FindItem( id );
<br>    configItem->Check( true );
<br>}
<br>
<br>void ocpnToolBarSimple::SetToolBitmaps( int id, wxBitmap *bmp, wxBitmap *bmpRollover )
<br>{
<br>    ocpnToolBarTool *tool = (ocpnToolBarTool*)FindById( id );
<br>    if( tool ) {
<br>        tool->pluginNormalIcon = bmp;
<br>        tool->pluginRolloverIcon = bmpRollover;
<br>        tool->bitmapOK = false;
<br>    }
<br>}
<br>
<br>void ocpnToolBarSimple::SetToolTooltipHiViz( int id, bool b_hiviz )
<br>{
<br>    ocpnToolBarTool *tool = (ocpnToolBarTool*)FindById( id );
<br>    if( tool ) {
<br>        tool->SetTooltipHiviz( b_hiviz );
<br>    }
<br>}
<br>
<br>
<br>void ocpnToolBarSimple::ClearTools()
<br>{
<br>    while( GetToolsCount() ) {
<br>        DeleteToolByPos( 0 );
<br>    }
<br>}
<br>
<br>int ocpnToolBarSimple::GetVisibleToolCount()
<br>{
<br>    int counter = 0;
<br>    wxToolBarToolsList::compatibility_iterator node = m_tools.GetFirst();
<br>    while( node ) {
<br>        ocpnToolBarTool *tool = (ocpnToolBarTool *) node->GetData();
<br>        counter++;
<br>        node = node->GetNext();
<br>    }
<br>    return counter;
<br>}
<br>
<br>bool ocpnToolBarSimple::DeleteToolByPos( size_t pos )
<br>{
<br>    wxCHECK_MSG( pos < GetToolsCount(), false,
<br>            _T("invalid position in wxToolBar::DeleteToolByPos()") );
<br>
<br>    wxToolBarToolsList::compatibility_iterator node = m_tools.Item( pos );
<br>
<br>    if( !DoDeleteTool( pos, node->GetData() ) ) {
<br>        return false;
<br>    }
<br>
<br>    delete node->GetData();
<br>    m_tools.Erase( node );
<br>
<br>    return true;
<br>}
<br>
<br>bool ocpnToolBarSimple::DeleteTool( int id )
<br>{
<br>    size_t pos = 0;
<br>    wxToolBarToolsList::compatibility_iterator node;
<br>    for( node = m_tools.GetFirst(); node; node = node->GetNext() ) {
<br>        if( node->GetData()->GetId() == id ) break;
<br>
<br>        pos++;
<br>    }
<br>
<br>    if( !node || !DoDeleteTool( pos, node->GetData() ) ) {
<br>        return false;
<br>    }
<br>
<br>    delete node->GetData();
<br>    m_tools.Erase( node );
<br>
<br>    return true;
<br>}
<br>
<br>wxToolBarToolBase *ocpnToolBarSimple::AddSeparator()
<br>{
<br>    return InsertSeparator( GetToolsCount() );
<br>}
<br>
<br>wxToolBarToolBase *ocpnToolBarSimple::InsertSeparator( size_t pos )
<br>{
<br>    wxCHECK_MSG( pos <= GetToolsCount(), (wxToolBarToolBase *)NULL,
<br>            _T("invalid position in wxToolBar::InsertSeparator()") );
<br>
<br>    wxToolBarToolBase *tool = CreateTool( wxID_SEPARATOR, wxEmptyString, wxNullBitmap, wxNullBitmap,
<br>            wxITEM_SEPARATOR, (wxObject *) NULL, wxEmptyString, wxEmptyString );
<br>
<br>    if( !tool || !DoInsertTool( pos, tool ) ) {
<br>        delete tool;
<br>
<br>        return NULL;
<br>    }
<br>
<br>    m_tools.Insert( pos, tool );
<br>
<br>    return tool;
<br>}
<br>
<br>wxToolBarToolBase *ocpnToolBarSimple::RemoveTool( int id )
<br>{
<br>    size_t pos = 0;
<br>    wxToolBarToolsList::compatibility_iterator node;
<br>    for( node = m_tools.GetFirst(); node; node = node->GetNext() ) {
<br>        if( node->GetData()->GetId() == id ) break;
<br>
<br>        pos++;
<br>    }
<br>
<br>    if( !node ) {
<br>        // don't give any error messages - sometimes we might call RemoveTool()
<br>        // without knowing whether the tool is or not in the toolbar
<br>        return (wxToolBarToolBase *) NULL;
<br>    }
<br>
<br>    wxToolBarToolBase *tool = node->GetData();
<br>    if( !DoDeleteTool( pos, tool ) ) {
<br>        return (wxToolBarToolBase *) NULL;
<br>    }
<br>
<br>    m_tools.Erase( node );
<br>
<br>    return tool;
<br>}
<br>
<br>
<br>wxControl *ocpnToolBarSimple::FindControl( int id )
<br>{
<br>    for( wxToolBarToolsList::compatibility_iterator node = m_tools.GetFirst(); node;
<br>            node = node->GetNext() ) {
<br>        const wxToolBarToolBase * const tool = node->GetData();
<br>        if( tool->IsControl() ) {
<br>            wxControl * const control = tool->GetControl();
<br>
<br>            if( !control ) {
<br>                wxFAIL_MSG( _T("NULL control in toolbar?") );
<br>            } else
<br>                if( control->GetId() == id ) {
<br>                    // found
<br>                    return control;
<br>                }
<br>        }
<br>    }
<br>
<br>    return NULL;
<br>}
<br>
<br>wxToolBarToolBase *ocpnToolBarSimple::FindById( int id ) const
<br>{
<br>    wxToolBarToolBase *tool = (wxToolBarToolBase *) NULL;
<br>
<br>    for( wxToolBarToolsList::compatibility_iterator node = m_tools.GetFirst(); node;
<br>            node = node->GetNext() ) {
<br>        tool = node->GetData();
<br>        if( tool->GetId() == id ) {
<br>            // found
<br>            break;
<br>        }
<br>
<br>        tool = NULL;
<br>    }
<br>
<br>    return tool;
<br>}
<br>
<br>// ----------------------------------------------------------------------------
<br>// event processing
<br>// ----------------------------------------------------------------------------
<br>
<br>// Only allow toggle if returns true
<br>bool ocpnToolBarSimple::OnLeftClick( int id, bool toggleDown )
<br>{
<br>    wxCommandEvent event( wxEVT_COMMAND_TOOL_CLICKED, id );
<br>    event.SetEventObject( this );
<br>
<br>    // we use SetInt() to make wxCommandEvent::IsChecked() return toggleDown
<br>    event.SetInt( (int) toggleDown );
<br>
<br>    // and SetExtraLong() for backwards compatibility
<br>    event.SetExtraLong( (long) toggleDown );
<br>
<br>    // Send events to this toolbar instead (and thence up the window hierarchy)
<br>    GetEventHandler()->ProcessEvent( event );
<br>
<br>    return true;
<br>}
<br>
<br>// Call when right button down.
<br>void ocpnToolBarSimple::OnRightClick( int id, long WXUNUSED(x), long WXUNUSED(y) )
<br>{
<br>    wxCommandEvent event( wxEVT_COMMAND_TOOL_RCLICKED, id );
<br>    event.SetEventObject( this );
<br>    event.SetInt( id );
<br>
<br>    HideTooltip();
<br>    ((ocpnFloatingToolbarDialog*)GetParent())->toolbarConfigChanged = false;
<br>    wxMenu* contextMenu = new wxMenu();
<br>    wxMenuItem* submenu = contextMenu->AppendSubMenu( g_FloatingToolbarConfigMenu, _("Visible buttons") );
<br>
<br>    PopupMenu( contextMenu );
<br>
<br>    contextMenu->Remove( submenu );
<br>    delete contextMenu;
<br>
<br>    if( ((ocpnFloatingToolbarDialog*)GetParent())->toolbarConfigChanged )
<br>        gFrame->GetEventHandler()->AddPendingEvent( event );
<br>}
<br>
<br>// Called when the mouse cursor enters a tool bitmap (no button pressed).
<br>// Argument is wxID_ANY if mouse is exiting the toolbar.
<br>// Note that for this event, the id of the window is used,
<br>// and the integer parameter of wxCommandEvent is used to retrieve
<br>// the tool id.
<br>void ocpnToolBarSimple::OnMouseEnter( int id )
<br>{
<br>    wxCommandEvent event( wxEVT_COMMAND_TOOL_ENTER, GetId() );
<br>    event.SetEventObject( this );
<br>    event.SetInt( id );
<br>
<br>    wxFrame *frame = wxDynamicCast(GetParent(), wxFrame);
<br>    if( frame ) {
<br>        wxString help;
<br>        wxToolBarToolBase* tool = id == wxID_ANY ? (wxToolBarToolBase*) NULL : FindById( id );
<br>        if( tool ) help = tool->GetLongHelp();
<br>        frame->DoGiveHelp( help, id != wxID_ANY );
<br>    }
<br>
<br>    (void) GetEventHandler()->ProcessEvent( event );
<br>
<br>    DoPluginToolUp();
<br>}
<br>
<br>void ocpnToolBarSimple::DoPluginToolUp()
<br>{
<br>    //        Look for PlugIn tools
<br>    //        If found, make the callback.
<br>    if( !g_pi_manager)
<br>        return;
<br>
<br>    ArrayOfPlugInToolbarTools tool_array = g_pi_manager->GetPluginToolbarToolArray();
<br>    for( unsigned int i = 0; i < tool_array.GetCount(); i++ ) {
<br>        PlugInToolbarToolContainer *pttc = tool_array.Item( i );
<br>        if( m_last_plugin_down_id == pttc->id ) {
<br>            opencpn_plugin_113 *ppi = dynamic_cast<opencpn_plugin_113 *>(pttc->m_pplugin);
<br>            if( ppi )
<br>                ppi->OnToolbarToolUpCallback( pttc->id );
<br>        }
<br>    }
<br>
<br>    m_last_plugin_down_id = -1;
<br>}
<br>
<br>void ocpnToolBarSimple::SetToolNormalBitmapEx( wxToolBarToolBase *tool, const wxString &iconName)
<br>{
<br>    if( tool ) {
<br>        ocpnToolBarTool *otool = (ocpnToolBarTool *) tool;
<br>        if(otool){
<br>            ocpnStyle::Style *style = g_StyleManager->GetCurrentStyle();
<br>
<br>            wxBitmap bmp = style->GetToolIcon( iconName, TOOLICON_NORMAL );
<br>            if(m_sizefactor > 1.0 ){
<br><mark>                wxImage scaled_image = bmp.ConvertToImage();
</mark><br><mark>                bmp = wxBitmap(scaled_image.Scale(otool->m_width, otool->m_height, wxIMAGE_QUALITY_HIGH));
</mark><br>            }
<br>        
<br>            tool->SetNormalBitmap( bmp );
<br>            otool->SetIconName( iconName );
<br>        }
<br>    }
<br>}
<br>
<br>
<br>//-------------------------------------------------------------------------------------
<br>
<br>ToolbarMOBDialog::ToolbarMOBDialog( wxWindow* parent )
<br>       : wxDialog( parent, wxID_ANY, _("OpenCPN Alert"), wxDefaultPosition, wxSize(250, 230) )
<br>{
<br>    wxBoxSizer* topSizer = new wxBoxSizer( wxVERTICAL );
<br>
<br>    wxBoxSizer* sizer = new wxBoxSizer( wxVERTICAL );
<br>    topSizer->Add( sizer, 0, wxALIGN_CENTER_HORIZONTAL | wxALL, 5 );
<br>
<br>    choices.push_back( new wxRadioButton( this, 0,  _("No, I don't want to hide it."),
<br>            wxDefaultPosition, wxDefaultSize, wxRB_GROUP ) );
<br>
<br>    choices.push_back( new wxRadioButton( this, 1, _("No, and permanently remove the option to hide it."),
<br>            wxDefaultPosition) );
<br>
<br>    choices.push_back( new wxRadioButton( this, 2, _("Yes, hide it."),
<br>            wxDefaultPosition) );
<br>
<br>    wxStdDialogButtonSizer* buttonSizer = CreateStdDialogButtonSizer( wxOK | wxCANCEL );
<br>
<br>
<br>    wxStaticText* textCtrl = new wxStaticText( this, wxID_ANY, _("The Man Over Board button could be an important safety feature.\nAre you sure you want to hide it?") );
<br>
<br>    sizer->Add( textCtrl, 0, wxEXPAND | wxALL, 5 );
<br>    sizer->Add( choices[0], 0, wxEXPAND | wxALL, 5 );
<br>    sizer->Add( choices[1], 0, wxEXPAND | wxALL, 5 );
<br>    sizer->Add( choices[2], 0, wxEXPAND | wxALL, 5 );
<br>    sizer->Add( buttonSizer, 0, wxEXPAND | wxTOP, 5 );
<br>
<br>    topSizer->SetSizeHints(this);
<br>    SetSizer( topSizer );
<br>}
<br>
<br>int ToolbarMOBDialog::GetSelection() {
<br>    for( unsigned int i=0; i<choices.size(); i++ ) {
<br>        if( choices[i]->GetValue() ) return choices[i]->GetId();
<br>    }
<br>    return 0;
<br>}
</p></body>
    </html><html>
    <head></head>
    <body><p><br>/***************************************************************************
<br> *
<br> * Project:  OpenCPN
<br> * Purpose:  OpenCPN Toolbar
<br> * Author:   David Register
<br> *
<br> ***************************************************************************
<br> *   Copyright (C) 2010 by David S. Register                               *
<br> *                                                                         *
<br> *   This program is free software; you can redistribute it and/or modify  *
<br> *   it under the terms of the GNU General Public License as published by  *
<br> *   the Free Software Foundation; either version 2 of the License, or     *
<br> *   (at your option) any later version.                                   *
<br> *                                                                         *
<br> *   This program is distributed in the hope that it will be useful,       *
<br> *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
<br> *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
<br> *   GNU General Public License for more details.                          *
<br> *                                                                         *
<br> *   You should have received a copy of the GNU General Public License     *
<br> *   along with this program; if not, write to the                         *
<br> *   Free Software Foundation, Inc.,                                       *
<br> *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,  USA.         *
<br> **************************************************************************/
<br>
<br>#include "wx/wxprec.h"
<br>
<br>#ifndef  WX_PRECOMP
<br>#include "wx/wx.h"
<br>#endif
<br>
<br>#include <vector>
<br>
<br>#include "ocpn_types.h"
<br>#include "navutil.h"
<br>#include "styles.h"
<br>#include "toolbar.h"
<br>#include "chart1.h"
<br>#include "pluginmanager.h"
<br>#include "FontMgr.h"
<br>
<br>extern ocpnFloatingToolbarDialog* g_FloatingToolbarDialog;
<br>extern bool                       g_bTransparentToolbar;
<br>extern bool                       g_bTransparentToolbarInOpenGLOK;
<br>extern ChartCanvas*               cc1;
<br>extern bool                       g_bopengl;
<br>extern ocpnToolBarSimple*         g_toolbar;
<br>extern ocpnStyle::StyleManager*   g_StyleManager;
<br>extern MyFrame*                   gFrame;
<br>extern PlugInManager*             g_pi_manager;
<br>extern wxMenu*                    g_FloatingToolbarConfigMenu;
<br>extern wxString                   g_toolbarConfig;
<br>extern bool                       g_bPermanentMOBIcon;
<br>extern bool                       g_btouch;
<br>extern bool                       g_bsmoothpanzoom;
<br>
<br>//----------------------------------------------------------------------------
<br>// GrabberWindow Implementation
<br>//----------------------------------------------------------------------------
<br>BEGIN_EVENT_TABLE(GrabberWin, wxPanel) EVT_MOUSE_EVENTS ( GrabberWin::MouseEvent )
<br>EVT_PAINT ( GrabberWin::OnPaint )
<br>END_EVENT_TABLE()
<br>
<br>GrabberWin::GrabberWin( wxWindow *parent, ocpnFloatingToolbarDialog *toolbar, float scale_factor, wxString icon_name, wxPoint position ):
<br>    wxPanel( parent, wxID_ANY, position, wxDefaultSize, wxNO_BORDER )
<br>{
<br>    m_icon_name = icon_name;
<br>    m_style = g_StyleManager->GetCurrentStyle();
<br>    wxBitmap bitmap = m_style->GetIcon( icon_name );
<br>    if(scale_factor > 1.0f){
<br>        int new_width = bitmap.GetWidth() * scale_factor;
<br>        int new_height = bitmap.GetHeight() * scale_factor;
<br>        wxImage scaled_image = bitmap.ConvertToImage();
<br>        m_bitmap = wxBitmap(scaled_image.Scale(new_width, new_height, wxIMAGE_QUALITY_HIGH));
<br>    }
<br>    else
<br>        m_bitmap = bitmap;
<br>
<br>    SetSize( wxSize( m_bitmap.GetWidth(), m_bitmap.GetHeight() ) );
<br>    SetMinSize( wxSize( m_bitmap.GetWidth(), m_bitmap.GetHeight() ) );
<br>
<br>    m_bLeftDown = false;
<br>    m_bRightDown = false;
<br>    m_scale_factor = scale_factor;
<br>    m_ptoolbar = toolbar;
<br>    m_dragging = false;
<br>    Hide();
<br>    
<br>}
<br>
<br>
<br>void GrabberWin::OnPaint( wxPaintEvent& event )
<br>{
<br>    wxPaintDC dc( this );
<br>    
<br>    wxColour back_color = GetGlobalColor( _T("GREY2") );
<br>    SetBackgroundColour( back_color );
<br>    ClearBackground();
<br>    
<br>    dc.DrawBitmap( m_bitmap, 0, 0, true );
<br>}
<br>
<br>void GrabberWin::SetColorScheme( ColorScheme cs )
<br>{
<br>    wxColour back_color = GetGlobalColor( _T("GREY2") );
<br>
<br>    SetBackgroundColour( back_color );
<br>    ClearBackground();
<br>
<br>    wxBitmap bitmap = m_style->GetIcon( m_icon_name) ;
<br>    if(m_scale_factor > 1.0f){
<br>        int new_width = bitmap.GetWidth() * m_scale_factor;
<br>        int new_height = bitmap.GetHeight() * m_scale_factor;
<br>        wxImage scaled_image = bitmap.ConvertToImage();
<br>        m_bitmap = wxBitmap(scaled_image.Scale(new_width, new_height, wxIMAGE_QUALITY_HIGH));
<br>    }
<br>    else
<br>        m_bitmap = bitmap;
<br>}
<br>
<br>void GrabberWin::MouseEvent( wxMouseEvent& event )
<br>{
<br>    static wxPoint s_gspt;
<br>    int x, y;
<br>
<br>    event.GetPosition( &x, &y );
<br>
<br>    wxPoint spt = ClientToScreen( wxPoint( x, y ) );
<br>    if( event.LeftDown() ) {
<br>        s_gspt = spt;
<br>    }
<br>    
<br>    
<br>#ifndef __WXQT__
<br>
<br>    if( event.LeftDown() ) {
<br>        CaptureMouse();
<br>    }
<br>
<br>    if( event.LeftUp() ) {
<br>        if( HasCapture() ) ReleaseMouse();
<br>    }
<br>
<br>#endif
<br>
<br>
<br>    if( event.RightDown() ){
<br>        if(m_ptoolbar){
<br>            m_dragging = true;
<br>            
<br>            if( !m_ptoolbar->m_bnavgrabber ){
<br>                m_ptoolbar->m_bnavgrabber = true;
<br>                m_ptoolbar->SetGrabber(_T("4WayMove") );
<br>            }
<br>            else{
<br>                m_ptoolbar->m_bnavgrabber = false;
<br>                m_ptoolbar->SetGrabber(_T("grabber_hi") );
<br>            }
<br>                
<br>        }
<br>    }
<br>    
<br>
<br>
<br>    if( event.Dragging() ) {
<br>        if(m_ptoolbar && m_ptoolbar->IsShown() /*&& m_ptoolbar->m_bnavgrabber*/){
<br>            wxPoint par_pos_old = m_ptoolbar->GetPosition();
<br>
<br>            wxPoint par_pos = par_pos_old;
<br>            par_pos.x += spt.x - s_gspt.x;
<br>            par_pos.y += spt.y - s_gspt.y;
<br>
<br>            m_ptoolbar->MoveDialogInScreenCoords( par_pos, par_pos_old );
<br>
<br>            s_gspt = spt;
<br>            m_dragging = true;
<br>        }
<br>
<br>    }
<br>
<br>    if( event.LeftUp() ) {
<br>        if(m_ptoolbar){
<br>            if(m_ptoolbar->m_bnavgrabber){
<br>                if(!m_dragging)
<br>                    m_ptoolbar->ToggleOrientation();
<br>            }
<br>            else if(!m_dragging){
<br>                if(m_ptoolbar->m_bsubmerged){
<br>                    m_ptoolbar->SurfaceFromGrabber();
<br>                }
<br>                else{
<br>                    m_ptoolbar->SubmergeToGrabber();
<br>                 }
<br>            }
<br>        }
<br>        m_dragging = false;
<br>    }
<br>    
<br>    
<br>#ifndef __OCPN__ANDROID__
<br>    gFrame->Raise();
<br>#endif
<br>    
<br>}
<br>
<br>class ocpnToolBarTool: public wxToolBarToolBase {
<br>public:
<br>    ocpnToolBarTool( ocpnToolBarSimple *tbar, int id, const wxString& label,
<br>            const wxBitmap& bmpNormal, const wxBitmap& bmpRollover, wxItemKind kind,
<br>            wxObject *clientData, const wxString& shortHelp, const wxString& longHelp ) :
<br>            wxToolBarToolBase( (wxToolBarBase*) tbar, id, label, bmpNormal, bmpRollover, kind,
<br>                    clientData, shortHelp, longHelp )
<br>    {
<br>        m_enabled = true;
<br>        m_toggled = false;
<br>        rollover = false;
<br>        bitmapOK = false;
<br>        m_btooltip_hiviz = false;
<br>
<br>        toolname = g_pi_manager->GetToolOwnerCommonName( id );
<br>        if( toolname == _T("") ) {
<br>            isPluginTool = false;
<br>            toolname = label;
<br>            iconName = label;
<br>        } else {
<br>            isPluginTool = true;
<br>            pluginNormalIcon = &bmpNormal;
<br>            pluginRolloverIcon = &bmpRollover;
<br>        }
<br>    }
<br>
<br>    void SetSize( const wxSize& size )
<br>    {
<br>        m_width = size.x;
<br>        m_height = size.y;
<br>    }
<br>
<br>    wxCoord GetWidth() const
<br>    {
<br>        return m_width;
<br>    }
<br>
<br>    wxCoord GetHeight() const
<br>    {
<br>        return m_height;
<br>    }
<br>
<br>    wxString GetToolname()
<br>    {
<br>        return toolname;
<br>    }
<br>
<br>    void SetIconName(wxString name)
<br>    {
<br>        iconName = name;
<br>    }
<br>    wxString GetIconName()
<br>    {
<br>        return iconName;
<br>    }
<br>
<br>    void SetTooltipHiviz( bool enable){ m_btooltip_hiviz = enable; }
<br>
<br>    wxCoord m_x;
<br>    wxCoord m_y;
<br>    wxCoord m_width;
<br>    wxCoord m_height;
<br>    wxRect trect;
<br>    wxString toolname;
<br>    wxString iconName;
<br>    const wxBitmap* pluginNormalIcon;
<br>    const wxBitmap* pluginRolloverIcon;
<br>    bool firstInLine;
<br>    bool lastInLine;
<br>    bool rollover;
<br>    bool bitmapOK;
<br>    bool isPluginTool;
<br>    bool b_hilite;
<br>    bool m_btooltip_hiviz;
<br>    wxRect last_rect;
<br>};
<br>
<br>//---------------------------------------------------------------------------------------
<br>//          ocpnFloatingToolbarDialog Implementation
<br>//---------------------------------------------------------------------------------------
<br>BEGIN_EVENT_TABLE(ocpnFloatingToolbarDialog, wxDialog)
<br>    EVT_MOUSE_EVENTS ( ocpnFloatingToolbarDialog::MouseEvent )
<br>    EVT_MENU(wxID_ANY, ocpnFloatingToolbarDialog::OnToolLeftClick)
<br>    EVT_TIMER ( FADE_TIMER, ocpnFloatingToolbarDialog::FadeTimerEvent )
<br>    EVT_TIMER ( DESTROY_TIMER, ocpnFloatingToolbarDialog::DestroyTimerEvent )
<br>    EVT_WINDOW_CREATE(ocpnFloatingToolbarDialog::OnWindowCreate)
<br>END_EVENT_TABLE()
<br>
<br>ocpnFloatingToolbarDialog::ocpnFloatingToolbarDialog( wxWindow *parent, wxPoint position,
<br>                                                      long orient, float size_factor )
<br>{
<br>    m_pparent = parent;
<br>    long wstyle = wxNO_BORDER | wxFRAME_NO_TASKBAR;
<br>#ifndef __WXMAC__
<br>    wstyle |= wxFRAME_SHAPED;
<br>#endif
<br>
<br>    m_ptoolbar = NULL;
<br>
<br>#ifdef __WXOSX__
<br>    wstyle |= wxSTAY_ON_TOP;
<br>#endif
<br>    wxDialog::Create( parent, -1, _T("ocpnToolbarDialog"), wxPoint( -1, -1 ), wxSize( -1, -1 ),
<br>            wstyle );
<br>
<br>    m_opacity = 255;
<br>
<br>    m_pGrabberwin = new GrabberWin( this, this, size_factor, _T("grabber_hi") );
<br>    m_pGrabberwin->Show();
<br>    
<br>    m_pRecoverwin = NULL;
<br>    m_position = position;
<br>    m_orient = orient;
<br>    m_sizefactor = size_factor;
<br>    
<br>    m_bAutoHideToolbar = false;
<br>    m_nAutoHideToolbar = 5;
<br>    
<br>
<br>    m_style = g_StyleManager->GetCurrentStyle();
<br>
<br>// A top-level sizer
<br>    m_topSizer = new wxBoxSizer( wxHORIZONTAL );
<br>    SetSizer( m_topSizer );
<br>
<br>    //    Set initial "Dock" parameters
<br>    m_dock_x = 0;
<br>    m_dock_y = 0;
<br>    m_block = false;
<br>
<br>    m_marginsInvisible = m_style->marginsInvisible;
<br>
<br>//    if(m_sizefactor > 1.0 )
<br> //       m_marginsInvisible = true;
<br>
<br>    m_bnavgrabber = false;    
<br>    
<br>    Hide();
<br>
<br>    m_bsubmerged = false;
<br>    
<br>    m_fade_timer.SetOwner( this, FADE_TIMER );
<br>    if( g_bTransparentToolbar )
<br>        m_fade_timer.Start( 5000 );
<br>    
<br>    if( m_bAutoHideToolbar && (m_nAutoHideToolbar > 0))
<br>        m_fade_timer.Start( m_nAutoHideToolbar * 1000 );
<br>    
<br>    m_destroyTimer.SetOwner( this, DESTROY_TIMER );
<br>}
<br>
<br>ocpnFloatingToolbarDialog::~ocpnFloatingToolbarDialog()
<br>{
<br>    DestroyToolBar();
<br>}
<br>
<br>void ocpnFloatingToolbarDialog::OnWindowCreate( wxWindowCreateEvent& event )
<br>{
<br>    Realize();
<br>}
<br>
<br>void ocpnFloatingToolbarDialog::SetGrabber( wxString icon_name )
<br>{
<br>//    m_pGrabberwin->Destroy();
<br>    m_pGrabberwin = new GrabberWin( this, this, m_sizefactor, icon_name );
<br>    m_pGrabberwin->Show();
<br>    
<br>    Realize();
<br>    
<br>#ifdef __WXOSX__    
<br>    m_pGrabberwin->Refresh();
<br>#endif    
<br>    
<br>}
<br>
<br>
<br>    
<br>void ocpnFloatingToolbarDialog::SetColorScheme( ColorScheme cs )
<br>{
<br>    m_cs = cs;
<br>
<br>    wxColour back_color = GetGlobalColor( _T("GREY2") );
<br>
<br>    //  Set background
<br>    SetBackgroundColour( back_color );
<br>    ClearBackground();
<br>
<br>    if( m_ptoolbar ) {
<br>        wxColour back_color = GetGlobalColor( _T("GREY2") );
<br>
<br>        //  Set background
<br>        m_ptoolbar->SetBackgroundColour( back_color );
<br>        m_ptoolbar->ClearBackground();
<br>
<br>        m_ptoolbar->SetToggledBackgroundColour( GetGlobalColor( _T("GREY1") ) );
<br>
<br>        m_ptoolbar->SetColorScheme( cs );
<br>        m_ptoolbar->Refresh( true );
<br>    }
<br>
<br>    if( m_pGrabberwin ) m_pGrabberwin->SetColorScheme( cs );
<br>
<br>}
<br>
<br>void ocpnFloatingToolbarDialog::SetGeometry(bool bAvoid, wxRect rectAvoid)
<br>{
<br>
<br>    if( m_ptoolbar ) {
<br>        wxSize style_tool_size = m_style->GetToolSize();
<br>
<br>        style_tool_size.x *= m_sizefactor;
<br>        style_tool_size.y *= m_sizefactor;
<br>
<br>        m_ptoolbar->SetToolBitmapSize( style_tool_size );
<br>
<br>        wxSize tool_size = m_ptoolbar->GetToolBitmapSize();
<br>        int grabber_width =  m_style->GetIcon( _T("grabber") ).GetWidth();
<br>        
<br>        int max_rows = 10;
<br>        int max_cols = 100;
<br>        if(cc1){
<br>
<br>            int avoid_start = cc1->GetClientSize().x - (tool_size.x + m_style->GetToolSeparation()) * 2;  // default
<br>            if(bAvoid && !rectAvoid.IsEmpty()){
<br>                avoid_start = cc1->GetClientSize().x - rectAvoid.width - 10;  // this is compass window, if shown
<br>            }
<br>            
<br>            
<br>            max_rows = (cc1->GetClientSize().y / ( tool_size.y + m_style->GetToolSeparation())) - 1;
<br>            
<br>            max_cols = (avoid_start - grabber_width) / ( tool_size.x + m_style->GetToolSeparation());
<br>            max_cols -= 1;
<br>            
<br>            if(m_orient == wxTB_VERTICAL)
<br>                max_rows = wxMax( max_rows, 2);             // at least two rows
<br>            else
<br>                max_cols = wxMax( max_cols, 2);             // at least two columns
<br>        }
<br>
<br>        if( m_orient == wxTB_VERTICAL )
<br>            m_ptoolbar->SetMaxRowsCols(max_rows, 100);
<br>        else
<br>            m_ptoolbar->SetMaxRowsCols( 100, max_cols);
<br>        m_ptoolbar->SetSizeFactor(m_sizefactor);
<br>        
<br>    }
<br> }
<br>
<br>void ocpnFloatingToolbarDialog::RePosition()
<br>{
<br>    if(m_block) return;
<br>
<br>    if( m_pparent && m_ptoolbar ) {
<br>        wxSize cs = m_pparent->GetClientSize();
<br>        if( -1 == m_dock_x ) m_position.x = 0;
<br>        else
<br>            if( 1 == m_dock_x ) m_position.x = cs.x - GetSize().x;
<br>
<br>        if( -1 == m_dock_y ) m_position.y = 0;
<br>        else
<br>            if( 1 == m_dock_y ) m_position.y = cs.y - GetSize().y;
<br>
<br>        m_position.x = wxMin(cs.x - GetSize().x, m_position.x);
<br>        m_position.y = wxMin(cs.y - GetSize().y, m_position.y);
<br>
<br>        m_position.x = wxMax(0, m_position.x);
<br>        m_position.y = wxMax(0, m_position.y);
<br>
<br>        wxPoint screen_pos = m_pparent->ClientToScreen( m_position );
<br>
<br>        Move( screen_pos );
<br>
<br>#ifdef __WXQT__
<br>        Raise();
<br>#endif
<br>
<br>    }
<br>}
<br>
<br>void ocpnFloatingToolbarDialog::Submerge()
<br>{
<br>    m_bsubmerged = true;
<br>    Hide();
<br>    if( m_ptoolbar ) m_ptoolbar->KillTooltip();
<br>}
<br>
<br>void ocpnFloatingToolbarDialog::SubmergeToGrabber()
<br>{
<br>//Submerge();
<br>    m_bsubmerged = true;
<br>    Hide();
<br>    if( m_ptoolbar ) m_ptoolbar->KillTooltip();
<br>
<br>    m_pRecoverwin = new GrabberWin( m_pparent, this, m_sizefactor, _T("grabber_ext" ), wxPoint(10,10) );
<br>   
<br>    m_pRecoverwin->Show();
<br>    m_pRecoverwin->Raise();
<br>#ifdef __WXQT__
<br>    wxSize s = gFrame->GetSize();
<br>    m_recoversize = s;
<br>    s.y--;
<br>    gFrame->TriggerResize(s);
<br>    Raise();
<br>#endif    
<br>
<br>    gFrame->Refresh();          // Needed for MSW OpenGL
<br>}
<br>
<br>void ocpnFloatingToolbarDialog::Surface()
<br>{
<br>    
<br>    if(m_pRecoverwin){
<br>        m_pRecoverwin->Show();
<br>        m_pRecoverwin->Raise();
<br>    }
<br>    else {
<br>        m_bsubmerged = false;
<br>        #ifndef __WXOSX__
<br>        Hide();
<br>        Move( 0, 0 );
<br>        #endif
<br>
<br>        RePosition();
<br>        Show();
<br>        if( m_ptoolbar )
<br>            m_ptoolbar->EnableTooltips();
<br>
<br>        #ifdef __WXQT__
<br>        Raise();
<br>        #endif
<br>    }
<br>    
<br>    if( m_bAutoHideToolbar && (m_nAutoHideToolbar > 0) ){
<br>        m_fade_timer.Start( m_nAutoHideToolbar * 1000 );
<br>    }
<br>}
<br>
<br>bool ocpnFloatingToolbarDialog::CheckSurfaceRequest( wxMouseEvent &event )
<br>{
<br>    if( m_bsubmerged ){
<br>        if( event.LeftUp() ){
<br>            int x,y;
<br>            event.GetPosition( &x, &y );
<br>            if( m_pRecoverwin ){
<br>                wxRect winRect = m_pRecoverwin->GetRect();
<br>                if( winRect.Contains( x, y ) ){
<br>                    SurfaceFromGrabber();
<br>                    return true;
<br>                }
<br>            }
<br>        }
<br>    }
<br>    
<br>    return false;
<br>}
<br>        
<br>void ocpnFloatingToolbarDialog::SurfaceFromGrabber()
<br>{
<br>    m_bsubmerged = false;
<br>    
<br>#ifndef __WXOSX__
<br>    Hide();
<br>    Move( 0, 0 );
<br>#endif
<br>
<br>    if( m_ptoolbar )
<br>        m_ptoolbar->InvalidateBitmaps();
<br>    
<br>    RePosition();
<br>    Show();
<br>    if( m_ptoolbar )
<br>        m_ptoolbar->EnableTooltips();
<br>    
<br>    if( m_bAutoHideToolbar && (m_nAutoHideToolbar > 0) ){
<br>        m_fade_timer.Start( m_nAutoHideToolbar * 1000 );
<br>    }
<br>    
<br>#ifdef __WXQT__
<br>    wxSize s = gFrame->GetSize();               // check for rotation
<br>    if(m_recoversize.x == s.x)
<br>        gFrame->TriggerResize(m_recoversize);
<br>    Raise();
<br>#endif
<br>    
<br>    m_destroyGrabber = m_pRecoverwin;
<br>    m_destroyTimer.Start( 5, wxTIMER_ONE_SHOT );           //  Destor the unneeded recovery grabber
<br>    
<br>}
<br>
<br>void ocpnFloatingToolbarDialog::DestroyTimerEvent( wxTimerEvent& event )
<br>{
<br>    delete m_destroyGrabber;
<br>    m_destroyGrabber = NULL;
<br>    m_pRecoverwin = NULL;
<br>}
<br>
<br>void ocpnFloatingToolbarDialog::HideTooltip()
<br>{
<br>    if( m_ptoolbar ) m_ptoolbar->HideTooltip();
<br>}
<br>
<br>void ocpnFloatingToolbarDialog::ShowTooltips()
<br>{
<br>    if( m_ptoolbar ) m_ptoolbar->EnableTooltips();
<br>}
<br>
<br>void ocpnFloatingToolbarDialog::ToggleOrientation()
<br>{
<br>    if( m_orient == wxTB_HORIZONTAL )
<br>        m_orient = wxTB_VERTICAL;
<br>    else
<br>        m_orient = wxTB_HORIZONTAL;
<br>
<br>    m_style->SetOrientation( m_orient );
<br>
<br>    wxPoint old_screen_pos = m_pparent->ClientToScreen( m_position );
<br>    wxPoint grabber_point_abs = ClientToScreen( m_pGrabberwin->GetPosition() );
<br>
<br>    gFrame->RequestNewToolbar();
<br>    wxPoint pos_abs = grabber_point_abs;
<br>    pos_abs.x -= m_pGrabberwin->GetPosition().x;
<br>    MoveDialogInScreenCoords( pos_abs, old_screen_pos );
<br>
<br>
<br>    Show();   // this seems to be necessary on GTK to kick the sizer into gear...(FS#553)
<br>    Refresh(true);
<br>    Raise();
<br>}
<br>
<br>void ocpnFloatingToolbarDialog::MouseEvent( wxMouseEvent& event )
<br>{
<br>    if( g_bTransparentToolbar ) {
<br>        if( event.Entering() && ( m_opacity < 255 ) ) {
<br>            SetTransparent( 255 );
<br>            m_opacity = 255;
<br>        }
<br>
<br>        m_fade_timer.Start( 5000 );           // retrigger the continuous timer
<br>    }
<br>    
<br>    if(m_bAutoHideToolbar && (m_nAutoHideToolbar > 0) ){
<br>        m_fade_timer.Start( m_nAutoHideToolbar * 1000 );
<br>    }
<br>}
<br>
<br>void ocpnFloatingToolbarDialog::FadeTimerEvent( wxTimerEvent& event )
<br>{
<br>    if(m_bnavgrabber){
<br>        m_fade_timer.Start( 5000 );           // do nothing if nav grabber is shown
<br>    }
<br>    else{
<br>        if( g_bTransparentToolbar && (!g_bopengl || g_bTransparentToolbarInOpenGLOK) ){
<br>            DoFade( 128 );
<br>            m_fade_timer.Start( 5000 );           // retrigger the continuous timer
<br>        }
<br>        
<br>        if(m_bAutoHideToolbar && (m_nAutoHideToolbar > 0) && !m_bsubmerged){
<br>            SubmergeToGrabber();
<br>//            m_fade_timer.Stop();
<br>        }
<br>    }
<br>}
<br>
<br>void ocpnFloatingToolbarDialog::SetAutoHideTimer(int time)
<br>{
<br>    m_nAutoHideToolbar = time;
<br>    if(m_bAutoHideToolbar){
<br>        m_fade_timer.Stop();
<br>        m_fade_timer.Start( m_nAutoHideToolbar * 1000 );
<br>    }
<br>}
<br>        
<br>void ocpnFloatingToolbarDialog::DoFade( int value )
<br>{
<br>    if( value != m_opacity ) SetTransparent( value );
<br>    m_opacity = value;
<br>}
<br>
<br>void ocpnFloatingToolbarDialog::RefreshFadeTimer()
<br>{
<br>    SetTransparent( 255 );
<br>    m_opacity = 255;
<br>    m_fade_timer.Start( 500 );           // retrigger the continuous timer
<br>    
<br>    if(m_bAutoHideToolbar && (m_nAutoHideToolbar > 0) ){
<br>        m_fade_timer.Start( m_nAutoHideToolbar * 1000 );
<br>    }
<br>    
<br>}
<br>
<br>void ocpnFloatingToolbarDialog::MoveDialogInScreenCoords( wxPoint posn, wxPoint posn_old )
<br>{
<br>    wxPoint pos_in_parent = m_pparent->ScreenToClient( posn );
<br>    wxPoint pos_in_parent_old = m_pparent->ScreenToClient( posn_old );
<br>
<br>    //    "Docking" support
<br>#define DOCK_MARGIN 40
<br>
<br>    // X
<br>    m_dock_x = 0;
<br>    if( pos_in_parent.x < pos_in_parent_old.x )            // moving left
<br>            {
<br>        if( pos_in_parent.x < DOCK_MARGIN ) {
<br>            pos_in_parent.x = 0;
<br>            m_dock_x = -1;
<br>        }
<br>    } else
<br>        if( pos_in_parent.x > pos_in_parent_old.x )            // moving right
<br>                {
<br>            int max_right = m_pparent->GetClientSize().x - GetSize().x;
<br>            if( pos_in_parent.x > ( max_right - DOCK_MARGIN ) ) {
<br>                pos_in_parent.x = max_right;
<br>                m_dock_x = 1;
<br>            }
<br>        }
<br>
<br>    // Y
<br>    m_dock_y = 0;
<br>    if( pos_in_parent.y < pos_in_parent_old.y )            // moving up
<br>            {
<br>        if( pos_in_parent.y < DOCK_MARGIN ) {
<br>            pos_in_parent.y = 0;
<br>            m_dock_y = -1;
<br>        }
<br>    } else
<br>        if( pos_in_parent.y > pos_in_parent_old.y )            // moving down
<br>                {
<br>            int max_down = m_pparent->GetClientSize().y - GetSize().y;
<br>            if( pos_in_parent.y > ( max_down - DOCK_MARGIN ) ) {
<br>                pos_in_parent.y = max_down;
<br>                m_dock_y = 1;
<br>            }
<br>        }
<br>
<br>    m_position = pos_in_parent;
<br>
<br>    wxPoint final_pos = m_pparent->ClientToScreen( pos_in_parent );
<br>
<br>    Move( final_pos );
<br>}
<br>
<br>void ocpnFloatingToolbarDialog::Realize()
<br>{
<br>    if( m_ptoolbar ) {
<br>        m_ptoolbar->Realize();
<br>
<br>        m_topSizer->Clear();
<br>        m_topSizer->Add( m_ptoolbar );
<br>        m_topSizer->Add( m_pGrabberwin, 0, wxTOP, m_style->GetTopMargin() );
<br>
<br>        m_topSizer->Layout();
<br>        Fit();
<br>
<br>        //    Update "Dock" parameters
<br>        if( m_position.x == 0 ) m_dock_x = -1;
<br>        else
<br>            if( m_position.x == m_pparent->GetClientSize().x - GetSize().x ) m_dock_x = 1;
<br>
<br>        if( m_position.y == 0 ) m_dock_y = -1;
<br>        else
<br>            if( m_position.y == m_pparent->GetClientSize().y - GetSize().y ) m_dock_y = 1;
<br>
<br>        // Now create a bitmap mask forthe frame shape.
<br>
<br>        if( m_marginsInvisible ) {
<br>
<br>            wxSize tool_size = m_ptoolbar->GetToolBitmapSize();
<br>
<br>            //  Determine whether the tool icons are meant (by style) to join without speces between
<br>            //  This will determine what type of region to draw.
<br>            bool b_overlap = false;
<br>
<br>            wxToolBarToolsList::compatibility_iterator node1 = m_ptoolbar->m_tools.GetFirst();
<br>            wxToolBarToolsList::compatibility_iterator node2 = node1->GetNext() ;
<br>
<br>            wxToolBarToolBase *tool1 = node1->GetData();
<br>            ocpnToolBarTool *tools1 = (ocpnToolBarTool *) tool1;
<br>
<br>            wxToolBarToolBase *tool2 = node2->GetData();
<br>            ocpnToolBarTool *tools2 = (ocpnToolBarTool *) tool2;
<br>
<br>            if( (tools1->m_x + tools1->m_width) >= tools2->m_x)
<br>                b_overlap = true;
<br>
<br>
<br>
<br>
<br>            int toolCount = m_ptoolbar->GetVisibleToolCount();
<br>
<br>            wxPoint upperLeft( m_style->GetLeftMargin(), m_style->GetTopMargin() );
<br>            wxSize visibleSize;
<br>            if( m_ptoolbar->IsVertical() ) {
<br>                int noTools = m_ptoolbar->GetMaxRows();
<br>                if( noTools > toolCount )
<br>                    noTools = toolCount;
<br>                visibleSize.x = m_ptoolbar->GetLineCount() * ( tool_size.x + m_style->GetTopMargin() );
<br>                visibleSize.y = noTools * ( tool_size.y + m_style->GetToolSeparation() );
<br>                visibleSize.x -= m_style->GetTopMargin();
<br>                visibleSize.y -= m_style->GetToolSeparation();
<br>            } else {
<br>                    int noTools = m_ptoolbar->GetMaxCols();
<br>                    if( noTools > toolCount )
<br>                        noTools = toolCount;
<br>                visibleSize.x = noTools * ( tool_size.x + m_style->GetToolSeparation() );
<br>                visibleSize.y = m_ptoolbar->GetLineCount() * ( tool_size.y + m_style->GetTopMargin() );
<br>                visibleSize.x -= m_style->GetToolSeparation();
<br>                visibleSize.y -= m_style->GetTopMargin();
<br>            }
<br>
<br>            wxBitmap shape( visibleSize.x + tool_size.x, visibleSize.y + tool_size.y);          // + fluff
<br>            wxMemoryDC sdc( shape );
<br>            sdc.SetBackground( *wxWHITE_BRUSH );
<br>            sdc.SetBrush( *wxBLACK_BRUSH );
<br>            sdc.SetPen( *wxBLACK_PEN );
<br>            sdc.Clear();
<br>
<br>            if(b_overlap) {
<br>                int lines = m_ptoolbar->GetLineCount();
<br>                for( int i = 1; i <= lines; i++ ) {
<br>                    if( m_ptoolbar->IsVertical() ) {
<br>                        wxSize barsize( tool_size.x, visibleSize.y );
<br>                        if( i == lines && i > 1 ) {
<br>                            int toolsInLastLine = toolCount % m_ptoolbar->GetMaxRows();
<br>                            if( toolsInLastLine == 0 ) toolsInLastLine = m_ptoolbar->GetMaxRows();
<br>                            int emptySpace = ( m_ptoolbar->GetMaxRows() - toolsInLastLine );
<br>                            barsize.y -= emptySpace
<br>                            * ( tool_size.y + m_style->GetToolSeparation() );
<br>                        }
<br>                        if( i == lines ) {
<br>                            // Also do grabber here, since it is to the right of the last line.
<br>                            wxRect grabMask( upperLeft, barsize );
<br>                            grabMask.width += m_style->GetIcon( _T("grabber") ).GetWidth();
<br>                            grabMask.height = m_style->GetIcon( _T("grabber") ).GetHeight();
<br>                            sdc.DrawRoundedRectangle( grabMask, m_style->GetToolbarCornerRadius() );
<br>                        }
<br>                        sdc.DrawRoundedRectangle( upperLeft, barsize,
<br>                                m_style->GetToolbarCornerRadius() );
<br>                        upperLeft.x += m_style->GetTopMargin() + tool_size.x;
<br>                    } else {
<br>                        wxSize barsize( visibleSize.x, tool_size.y );
<br>
<br>                        if( i == 1 ) {
<br>                            barsize.x += m_style->GetIcon( _T("grabber") ).GetWidth();
<br>                        }
<br>                        if( i == lines && i > 1 ) {
<br>                            int toolsInLastLine = toolCount % m_ptoolbar->GetMaxCols();
<br>                            if( toolsInLastLine == 0 ) toolsInLastLine = m_ptoolbar->GetMaxCols();
<br>                            int emptySpace = ( m_ptoolbar->GetMaxCols() - toolsInLastLine );
<br>                            barsize.x -= emptySpace * ( tool_size.x + m_style->GetToolSeparation() );
<br>                        }
<br>
<br>                        sdc.DrawRoundedRectangle( upperLeft, barsize,
<br>                                m_style->GetToolbarCornerRadius() );
<br>                        upperLeft.y += m_style->GetTopMargin() + tool_size.y;
<br>                    }
<br>                }
<br>            } //b_overlap
<br>            else {
<br>                for( wxToolBarToolsList::compatibility_iterator node = m_ptoolbar->m_tools.GetFirst(); node; node = node->GetNext() ) {
<br>                    wxToolBarToolBase *tool = node->GetData();
<br>                    ocpnToolBarTool *tools = (ocpnToolBarTool *) tool;
<br>                    wxRect toolRect = tools->trect;
<br>
<br>                    sdc.DrawRoundedRectangle( tools->m_x, tools->m_y, tool_size.x, tool_size.y,
<br>                                              m_style->GetToolbarCornerRadius() );
<br>                }
<br>            }
<br>
<br>#ifndef __OCPN__ANDROID__
<br>            if(shape.GetWidth() && shape.GetHeight())
<br>                SetShape( wxRegion( shape, *wxWHITE, 10 ) );
<br>#endif
<br>        }
<br>    }
<br>}
<br>
<br>void ocpnFloatingToolbarDialog::OnToolLeftClick( wxCommandEvent& event )
<br>{
<br>    // First see if it was actually the context menu that was clicked.
<br>
<br>    if( event.GetId() >= ID_PLUGIN_BASE + 100 ) {
<br>
<br>        int itemId = event.GetId() - ID_PLUGIN_BASE - 100;
<br>        wxMenuItem *item = g_FloatingToolbarConfigMenu->FindItem( event.GetId() );
<br>
<br>        if(item){
<br>            bool toolIsChecked = item->IsChecked();
<br>
<br>            if( toolIsChecked ) {
<br>                g_toolbarConfig.SetChar( itemId, _T('X') );
<br>            } else {
<br>
<br>                if( itemId + ID_ZOOMIN == ID_MOB ) {
<br>                    ToolbarMOBDialog mdlg( this );
<br>                    int dialog_ret = mdlg.ShowModal();
<br>                    int answer = mdlg.GetSelection();
<br>
<br>                    if( answer == 0 || answer == 1 || dialog_ret == wxID_CANCEL ) {
<br>                        g_FloatingToolbarConfigMenu->FindItem( event.GetId() )->Check( true );
<br>                        if( answer == 1 && dialog_ret == wxID_OK ) {
<br>                            g_bPermanentMOBIcon = true;
<br>                            delete g_FloatingToolbarConfigMenu;
<br>                            g_FloatingToolbarConfigMenu = new wxMenu();
<br>                            toolbarConfigChanged = true;
<br>                        }
<br>                        return;
<br>                    }
<br>                }
<br>
<br>                if( m_ptoolbar->GetVisibleToolCount() == 1 ) {
<br>                    OCPNMessageBox( this,
<br>                            _("You can't hide the last tool from the toolbar\nas this would make it inaccessible."),
<br>                            _("OpenCPN Alert"), wxOK );
<br>                    g_FloatingToolbarConfigMenu->FindItem( event.GetId() )->Check( true );
<br>                    return;
<br>                }
<br>
<br>                g_toolbarConfig.SetChar( itemId, _T('.') );
<br>            }
<br>        }
<br>
<br>        toolbarConfigChanged = true;
<br>        return;
<br>    }
<br>
<br>    // No it was a button that was clicked.
<br>    // Since Dialog events don't propagate automatically, we send it explicitly
<br>    // (instead of relying on event.Skip()). Send events up the window hierarchy
<br>
<br>    m_pparent->GetEventHandler()->AddPendingEvent( event );
<br>#ifndef __WXQT__
<br>    gFrame->Raise();
<br>#endif    
<br>}
<br>
<br>ocpnToolBarSimple *ocpnFloatingToolbarDialog::GetToolbar()
<br>{
<br>    if( !m_ptoolbar ) {
<br>        long winstyle = wxNO_BORDER | wxTB_FLAT;
<br>        winstyle |= m_orient;
<br>
<br>        m_ptoolbar = new ocpnToolBarSimple( this, -1, wxPoint( -1, -1 ), wxSize( -1, -1 ),
<br>                winstyle );
<br>
<br>        m_ptoolbar->SetBackgroundColour( GetGlobalColor( _T("GREY2") ) );
<br>        m_ptoolbar->ClearBackground();
<br>        m_ptoolbar->SetToggledBackgroundColour( GetGlobalColor( _T("GREY1") ) );
<br>        m_ptoolbar->SetColorScheme( m_cs );
<br>
<br>        SetGeometry(false, wxRect());
<br>    }
<br>
<br>    return m_ptoolbar;
<br>}
<br>
<br>void ocpnFloatingToolbarDialog::DestroyToolBar()
<br>{
<br>    if( m_ptoolbar ) {
<br>        m_ptoolbar->ClearTools();
<br>        delete m_ptoolbar;                  //->Destroy();
<br>        m_ptoolbar = NULL;
<br>    }
<br> 
<br>    m_destroyGrabber = m_pRecoverwin;
<br>    m_destroyTimer.Start( 5, wxTIMER_ONE_SHOT );           //  Destor the unneeded recovery grabber
<br>    
<br>}
<br>
<br>//----------------------------------------------------------------------------
<br>// Toolbar Tooltip Popup Window Definition
<br>//----------------------------------------------------------------------------
<br>class ToolTipWin: public wxDialog {
<br>public:
<br>    ToolTipWin( wxWindow *parent );
<br>    ~ToolTipWin();
<br>
<br>    void OnPaint( wxPaintEvent& event );
<br>
<br>    void SetColorScheme( ColorScheme cs );
<br>    void SetString( wxString &s )
<br>    {
<br>        m_string = s;
<br>    }
<br>    void SetPosition( wxPoint pt )
<br>    {
<br>        m_position = pt;
<br>    }
<br>    void SetBitmap( void );
<br>
<br>    void SetHiviz( bool hiviz){ m_hiviz = hiviz; }
<br>    
<br>    wxSize GetRenderedSize( void );
<br>    
<br>private:
<br>
<br>    wxString m_string;
<br>    wxSize m_size;
<br>    wxPoint m_position;
<br>    wxBitmap *m_pbm;
<br>    wxColour m_back_color;
<br>    wxColour m_text_color;
<br>    ColorScheme m_cs ;
<br>    bool m_hiviz;
<br>
<br>DECLARE_EVENT_TABLE()
<br>};
<br>//-----------------------------------------------------------------------
<br>//
<br>//    Toolbar Tooltip window implementation
<br>//
<br>//-----------------------------------------------------------------------
<br>BEGIN_EVENT_TABLE(ToolTipWin, wxDialog) EVT_PAINT(ToolTipWin::OnPaint)
<br>
<br>END_EVENT_TABLE()
<br>
<br>// Define a constructor
<br>ToolTipWin::ToolTipWin( wxWindow *parent ) :
<br>        wxDialog( parent, wxID_ANY, _T(""), wxPoint( 0, 0 ), wxSize( 1, 1 ),
<br>                wxNO_BORDER | wxSTAY_ON_TOP )
<br>{
<br>    m_pbm = NULL;
<br>
<br>    m_back_color = GetGlobalColor( _T ( "UIBCK" ) );
<br>    m_text_color = GetGlobalColor( _T ( "UITX1" ) );
<br>
<br>    SetBackgroundStyle( wxBG_STYLE_CUSTOM );
<br>    SetBackgroundColour( m_back_color );
<br>    m_cs = GLOBAL_COLOR_SCHEME_RGB;
<br>
<br>    Hide();
<br>}
<br>
<br>ToolTipWin::~ToolTipWin()
<br>{
<br>    delete m_pbm;
<br>}
<br>
<br>void ToolTipWin::SetColorScheme( ColorScheme cs )
<br>{
<br>    m_back_color = GetGlobalColor( _T ( "UIBCK" ) );
<br>    m_text_color = FontMgr::Get().GetFontColor( _("ToolTips") );
<br>
<br>    m_cs = cs;
<br>}
<br>
<br>wxSize ToolTipWin::GetRenderedSize( void )
<br>{
<br>    int h, w;
<br>    wxSize sz;
<br>
<br>    wxClientDC cdc( GetParent() );
<br>
<br>    wxFont *plabelFont = FontMgr::Get().GetFont( _("ToolTips") );
<br>    cdc.GetTextExtent( m_string, &w, &h, NULL, NULL, plabelFont );
<br>
<br>    sz.x = w + 8;
<br>    sz.y = h + 4;
<br>    
<br>    return sz;
<br>
<br>}
<br>
<br>void ToolTipWin::SetBitmap()
<br>{
<br>    int h, w;
<br>
<br>    wxClientDC cdc( GetParent() );
<br>
<br>    wxFont *plabelFont = FontMgr::Get().GetFont( _("ToolTips") );
<br>    cdc.GetTextExtent( m_string, &w, &h, NULL, NULL, plabelFont );
<br>
<br>    m_size.x = w + 8;
<br>    m_size.y = h + 4;
<br>
<br>    wxMemoryDC mdc;
<br>
<br>    delete m_pbm;
<br>    m_pbm = new wxBitmap( m_size.x, m_size.y, -1 );
<br>    mdc.SelectObject( *m_pbm );
<br>
<br>    wxPen pborder( m_text_color );
<br>    wxBrush bback( m_back_color );
<br>    mdc.SetPen( pborder );
<br>    mdc.SetBrush( bback );
<br>
<br>    if(m_hiviz){
<br>        if((m_cs == GLOBAL_COLOR_SCHEME_DUSK) || (m_cs == GLOBAL_COLOR_SCHEME_NIGHT)){
<br>            wxBrush hv_back( wxColour(200,200,200));
<br>            mdc.SetBrush( hv_back );
<br>        }
<br>    }
<br>    mdc.DrawRectangle( 0, 0, m_size.x, m_size.y );
<br>
<br>    //    Draw the text
<br>    mdc.SetFont( *plabelFont );
<br>    mdc.SetTextForeground( m_text_color );
<br>    mdc.SetTextBackground( m_back_color );
<br>
<br>    mdc.DrawText( m_string, 4, 2 );
<br>
<br>    SetSize( m_position.x, m_position.y, m_size.x, m_size.y );
<br>
<br>}
<br>
<br>void ToolTipWin::OnPaint( wxPaintEvent& event )
<br>{
<br>    int width, height;
<br>    GetClientSize( &width, &height );
<br>    wxPaintDC dc( this );
<br>
<br>    if( m_string.Len() ) {
<br>        wxMemoryDC mdc;
<br>        mdc.SelectObject( *m_pbm );
<br>        dc.Blit( 0, 0, width, height, &mdc, 0, 0 );
<br>    }
<br>}
<br>
<br>
<br>// ----------------------------------------------------------------------------
<br>BEGIN_EVENT_TABLE(ocpnToolBarSimple, wxControl) EVT_SIZE(ocpnToolBarSimple::OnSize)
<br>EVT_PAINT(ocpnToolBarSimple::OnPaint)
<br>EVT_KILL_FOCUS(ocpnToolBarSimple::OnKillFocus)
<br>EVT_MOUSE_EVENTS(ocpnToolBarSimple::OnMouseEvent)
<br>EVT_TIMER(TOOLTIPON_TIMER, ocpnToolBarSimple::OnToolTipTimerEvent)
<br>EVT_TIMER(TOOLTIPOFF_TIMER, ocpnToolBarSimple::OnToolTipOffTimerEvent)
<br>
<br>END_EVENT_TABLE()
<br>
<br>// ============================================================================
<br>// implementation
<br>// ============================================================================
<br>
<br>// ----------------------------------------------------------------------------
<br>// tool bar tools creation
<br>// ----------------------------------------------------------------------------
<br>
<br>wxToolBarToolBase *ocpnToolBarSimple::CreateTool( int id, const wxString& label,
<br>        const wxBitmap& bmpNormal, const wxBitmap& bmpDisabled, wxItemKind kind,
<br>        wxObject *clientData, const wxString& shortHelp, const wxString& longHelp )
<br>{
<br>    return new ocpnToolBarTool( this, id, label, bmpNormal, bmpDisabled, kind, clientData,
<br>            shortHelp, longHelp );
<br>}
<br>
<br>// ----------------------------------------------------------------------------
<br>// ocpnToolBarSimple creation
<br>// ----------------------------------------------------------------------------
<br>
<br>void ocpnToolBarSimple::Init()
<br>{
<br>    m_currentRowsOrColumns = 0;
<br>
<br>    m_lastX = m_lastY = 0;
<br>
<br>    m_maxWidth = m_maxHeight = 0;
<br>
<br>    m_pressedTool = m_currentTool = -1;
<br>
<br>    m_xPos = m_yPos = wxDefaultCoord;
<br>
<br>    m_style = g_StyleManager->GetCurrentStyle();
<br>
<br>    m_defaultWidth = 16;
<br>    m_defaultHeight = 15;
<br>
<br>    m_toggle_bg_color = wxSystemSettings::GetColour( wxSYS_COLOUR_3DFACE );
<br>    m_toolOutlineColour.Set( _T("BLACK") );
<br>    m_pToolTipWin = NULL;
<br>    m_last_ro_tool = NULL;
<br>
<br>    m_btoolbar_is_zooming = false;
<br>    m_sizefactor = 1.0f;
<br>
<br>    m_last_plugin_down_id = -1;
<br>    
<br>    EnableTooltips();
<br>}
<br>
<br>wxToolBarToolBase *ocpnToolBarSimple::DoAddTool( int id, const wxString& label,
<br>        const wxBitmap& bitmap, const wxBitmap& bmpDisabled, wxItemKind kind,
<br>        const wxString& shortHelp, const wxString& longHelp, wxObject *clientData, wxCoord xPos,
<br>        wxCoord yPos )
<br>{
<br>    // rememeber the position for DoInsertTool()
<br>    m_xPos = xPos;
<br>    m_yPos = yPos;
<br>
<br>    InvalidateBestSize();
<br>    return InsertTool( GetToolsCount(), id, label, bitmap, bmpDisabled, kind, shortHelp, longHelp,
<br>            clientData );
<br>
<br>}
<br>
<br>///
<br>
<br>wxToolBarToolBase *ocpnToolBarSimple::AddTool( int toolid, const wxString& label,
<br>        const wxBitmap& bitmap, const wxBitmap& bmpDisabled, wxItemKind kind,
<br>        const wxString& shortHelp, const wxString& longHelp, wxObject *data )
<br>{
<br>    InvalidateBestSize();
<br>    ocpnToolBarTool* tool = (ocpnToolBarTool*)InsertTool( GetToolsCount(), toolid, label, bitmap, bmpDisabled, kind,
<br>            shortHelp, longHelp, data );
<br>    return tool;
<br>}
<br>
<br>wxToolBarToolBase *ocpnToolBarSimple::InsertTool( size_t pos, int id, const wxString& label,
<br>        const wxBitmap& bitmap, const wxBitmap& bmpDisabled, wxItemKind kind,
<br>        const wxString& shortHelp, const wxString& longHelp, wxObject *clientData )
<br>{
<br>    wxCHECK_MSG( pos <= GetToolsCount(), (wxToolBarToolBase *)NULL,
<br>            _T("invalid position in wxToolBar::InsertTool()") );
<br>
<br>    wxToolBarToolBase *tool = CreateTool( id, label, bitmap, bmpDisabled, kind, clientData,
<br>            shortHelp, longHelp );
<br>
<br>    if( !InsertTool( pos, tool ) ) {
<br>        delete tool;
<br>
<br>        return NULL;
<br>    }
<br>
<br>    return tool;
<br>}
<br>
<br>wxToolBarToolBase *ocpnToolBarSimple::InsertTool( size_t pos, wxToolBarToolBase *tool )
<br>{
<br>    wxCHECK_MSG( pos <= GetToolsCount(), (wxToolBarToolBase *)NULL,
<br>            _T("invalid position in wxToolBar::InsertTool()") );
<br>
<br>    if( !tool || !DoInsertTool( pos, tool ) ) {
<br>        return NULL;
<br>    }
<br>
<br>    m_tools.Insert( pos, tool );
<br>
<br>    return tool;
<br>}
<br>
<br>bool ocpnToolBarSimple::DoInsertTool( size_t WXUNUSED(pos), wxToolBarToolBase *toolBase )
<br>{
<br>    ocpnToolBarTool *tool = (ocpnToolBarTool *) toolBase;
<br>
<br>    // Check if the plugin is inserting same-named tools. Make sure they have different names,
<br>    // otherwise the style manager cannot differentiate between them.
<br>    if( tool->isPluginTool ) {
<br>        for( unsigned int i=0; i<GetToolsCount(); i++ ) {
<br>            if( tool->GetToolname() == ((ocpnToolBarTool *)m_tools.Item(i)->GetData())->GetToolname()) {
<br>                tool->toolname << _T("1");
<br>            }
<br>        }
<br>    }
<br>
<br>    tool->m_x = m_xPos;
<br>    if( tool->m_x == wxDefaultCoord ) tool->m_x = m_style->GetLeftMargin();
<br>
<br>    tool->m_y = m_yPos;
<br>    if( tool->m_y == wxDefaultCoord ) tool->m_y = m_style->GetTopMargin();
<br>
<br>    if( tool->IsButton() ) {
<br>        tool->SetSize( GetToolSize() );
<br>
<br>        // Calculate reasonable max size in case Layout() not called
<br>        if( ( tool->m_x + tool->GetNormalBitmap().GetWidth() + m_style->GetLeftMargin() )
<br>                > m_maxWidth ) m_maxWidth = (wxCoord) ( ( tool->m_x + tool->GetWidth()
<br>                + m_style->GetLeftMargin() ) );
<br>
<br>        if( ( tool->m_y + tool->GetNormalBitmap().GetHeight() + m_style->GetTopMargin() )
<br>                > m_maxHeight ) m_maxHeight = (wxCoord) ( ( tool->m_y + tool->GetHeight()
<br>                + m_style->GetTopMargin() ) );
<br>    }
<br>
<br>    else
<br>        if( tool->IsControl() ) {
<br>            tool->SetSize( tool->GetControl()->GetSize() );
<br>        }
<br>
<br>    tool->b_hilite = false;
<br>
<br>    return true;
<br>}
<br>
<br>bool ocpnToolBarSimple::DoDeleteTool( size_t WXUNUSED(pos), wxToolBarToolBase *tool )
<br>{
<br>    // VZ: didn't test whether it works, but why not...
<br>    tool->Detach();
<br>
<br>    if( m_last_ro_tool == tool ) m_last_ro_tool = NULL;
<br>
<br>    Refresh( false );
<br>
<br>    return true;
<br>}
<br>
<br>bool ocpnToolBarSimple::Create( wxWindow *parent, wxWindowID id, const wxPoint& pos,
<br>        const wxSize& size, long style, const wxString& name )
<br>{
<br>    if( !wxWindow::Create( parent, id, pos, size, style, name ) ) return false;
<br>
<br>    // Set it to grey (or other 3D face colour)
<br>    SetBackgroundColour( wxSystemSettings::GetColour( wxSYS_COLOUR_3DFACE ) );
<br>
<br>    if( GetWindowStyleFlag() & wxTB_VERTICAL ) {
<br>        m_lastX = 7;
<br>        m_lastY = 3;
<br>
<br>        m_maxRows = 32000;      // a lot
<br>        m_maxCols = 1;
<br>    } else {
<br>        m_lastX = 3;
<br>        m_lastY = 7;
<br>
<br>        m_maxRows = 1;
<br>        m_maxCols = 32000;      // a lot
<br>    }
<br>
<br>    SetCursor( *wxSTANDARD_CURSOR );
<br>
<br>    m_tooltip_timer.SetOwner( this, TOOLTIPON_TIMER );
<br>    m_tooltipoff_timer.SetOwner( this, TOOLTIPOFF_TIMER );
<br>    m_tooltip_off = 3000;
<br>
<br>    return true;
<br>}
<br>
<br>ocpnToolBarSimple::~ocpnToolBarSimple()
<br>{
<br>    if( m_pToolTipWin ) {
<br>        m_pToolTipWin->Destroy();
<br>        m_pToolTipWin = NULL;
<br>    }
<br>
<br>}
<br>
<br>void ocpnToolBarSimple::KillTooltip()
<br>{
<br>    m_btooltip_show = false;
<br>
<br>    if( m_pToolTipWin ) {
<br>        m_pToolTipWin->Hide();
<br>        m_pToolTipWin->Destroy();
<br>        m_pToolTipWin = NULL;
<br>    }
<br>    m_tooltip_timer.Stop();
<br>
<br>    if( m_last_ro_tool ) {
<br>        if( m_last_ro_tool->IsEnabled() ) {
<br>            if( m_last_ro_tool->IsToggled() ) {
<br>                m_last_ro_tool->SetNormalBitmap( m_style->GetToolIcon( m_last_ro_tool->GetToolname(), TOOLICON_TOGGLED ) );
<br>            }
<br>            else {
<br>                m_last_ro_tool->SetNormalBitmap( m_style->GetToolIcon( m_last_ro_tool->GetToolname(), TOOLICON_NORMAL ) );
<br>            }
<br>        }
<br>    }
<br>}
<br>
<br>void ocpnToolBarSimple::HideTooltip()
<br>{
<br>    if( m_pToolTipWin ) {
<br>        m_pToolTipWin->Hide();
<br>    }
<br>}
<br>
<br>void ocpnToolBarSimple::SetColorScheme( ColorScheme cs )
<br>{
<br>    if( m_pToolTipWin ) {
<br>        m_pToolTipWin->Destroy();
<br>        m_pToolTipWin = NULL;
<br>    }
<br>
<br>    m_toolOutlineColour = GetGlobalColor( _T("UIBDR") );
<br>
<br>    m_currentColorScheme = cs;
<br>}
<br>
<br>bool ocpnToolBarSimple::Realize()
<br>{
<br>    m_currentRowsOrColumns = 0;
<br>    m_LineCount = 1;
<br>    m_lastX = m_style->GetLeftMargin();
<br>    m_lastY = m_style->GetTopMargin();
<br>    m_maxWidth = 0;
<br>    m_maxHeight = 0;
<br>
<br>    if( IsVertical() ) m_style->SetOrientation( wxTB_VERTICAL );
<br>    else
<br>        m_style->SetOrientation( wxTB_HORIZONTAL );
<br>
<br>    wxSize toolSize = wxSize(-1, -1);
<br>    int separatorSize = m_style->GetToolSeparation();
<br>
<br>    ocpnToolBarTool *lastTool = NULL;
<br>    bool firstNode = true;
<br>    wxToolBarToolsList::compatibility_iterator node = m_tools.GetFirst();
<br>
<br>    while( node ) {
<br>        ocpnToolBarTool *tool = (ocpnToolBarTool *) node->GetData();
<br>
<br>        // Set the tool size to be the size of the first non-separator tool, usually the first one
<br>        if(toolSize.x == -1){
<br>            if( !tool->IsSeparator() ){
<br>                toolSize.x = tool->m_width;
<br>                toolSize.y = tool->m_height;
<br>            }
<br>        }
<br>
<br>        tool->firstInLine = firstNode;
<br>        tool->lastInLine = false;
<br>        firstNode = false;
<br>
<br>        tool->last_rect.width = 0;              // mark it invalid
<br>        
<br>        if( tool->IsSeparator() ) {
<br>            if( GetWindowStyleFlag() & wxTB_HORIZONTAL ) {
<br>                if( m_currentRowsOrColumns >= m_maxCols ) m_lastY += separatorSize;
<br>                else
<br>                    m_lastX += separatorSize;
<br>            } else {
<br>                if( m_currentRowsOrColumns >= m_maxRows ) m_lastX += separatorSize;
<br>                else
<br>                    m_lastY += separatorSize;
<br>            }
<br>        } else
<br>            if( tool->IsButton() ) {
<br>                if( !IsVertical() ) {
<br>                    if( m_currentRowsOrColumns >= m_maxCols ) {
<br>                        tool->firstInLine = true;
<br>                        if( lastTool && m_LineCount > 1 ) lastTool->lastInLine = true;
<br>                        m_LineCount++;
<br>                        m_currentRowsOrColumns = 0;
<br>                        m_lastX = m_style->GetLeftMargin();
<br>                        m_lastY += toolSize.y + m_style->GetTopMargin();
<br>                    }
<br>                    tool->m_x = (wxCoord) m_lastX;
<br>                    tool->m_y = (wxCoord) m_lastY;
<br>
<br>                    tool->trect = wxRect( tool->m_x, tool->m_y, toolSize.x, toolSize.y );
<br>                    tool->trect.Inflate( m_style->GetToolSeparation() / 2,
<br>                            m_style->GetTopMargin() );
<br>
<br>                    m_lastX += toolSize.x + m_style->GetToolSeparation();
<br>                } else {
<br>                    if( m_currentRowsOrColumns >= m_maxRows ) {
<br>                        tool->firstInLine = true;
<br>                        if( lastTool ) lastTool->lastInLine = true;
<br>                        m_LineCount++;
<br>                        m_currentRowsOrColumns = 0;
<br>                        m_lastX += toolSize.x + m_style->GetTopMargin();
<br>                        m_lastY = m_style->GetTopMargin();
<br>                    }
<br>                    tool->m_x = (wxCoord) m_lastX;
<br>                    tool->m_y = (wxCoord) m_lastY;
<br>
<br>                    tool->trect = wxRect( tool->m_x, tool->m_y, toolSize.x, toolSize.y );
<br>                    tool->trect.Inflate( m_style->GetToolSeparation() / 2,
<br>                            m_style->GetTopMargin() );
<br>
<br>                    m_lastY += toolSize.y + m_style->GetToolSeparation();
<br>                }
<br>                m_currentRowsOrColumns++;
<br>            } else
<br>                if( tool->IsControl() ) {
<br>                    tool->m_x = (wxCoord) ( m_lastX );
<br>                    tool->m_y = (wxCoord) ( m_lastY - ( m_style->GetTopMargin() / 2 ) );
<br>
<br>                    tool->trect = wxRect( tool->m_x, tool->m_y, tool->GetWidth(),
<br>                            tool->GetHeight() );
<br>                    tool->trect.Inflate( m_style->GetToolSeparation() / 2,
<br>                            m_style->GetTopMargin() );
<br>                    ;
<br>
<br>                    wxSize s = tool->GetControl()->GetSize();
<br>                    m_lastX += s.x + m_style->GetToolSeparation();
<br>
<br>                }
<br>
<br>        if( m_lastX > m_maxWidth ) m_maxWidth = m_lastX;
<br>        if( m_lastY > m_maxHeight ) m_maxHeight = m_lastY;
<br>
<br>        lastTool = tool;
<br>        node = node->GetNext();
<br>    }
<br>    if( lastTool && (m_LineCount > 1 || IsVertical()) )
<br>        lastTool->lastInLine = true;
<br>
<br>    if( GetWindowStyleFlag() & wxTB_HORIZONTAL ) m_maxHeight += toolSize.y;
<br>    else
<br>        m_maxWidth += toolSize.x;
<br>
<br>    m_maxWidth += m_style->GetRightMargin();
<br>    m_maxHeight += m_style->GetBottomMargin();
<br>
<br>    SetSize( m_maxWidth, m_maxHeight );
<br>    SetMinSize( wxSize( m_maxWidth, m_maxHeight ) );
<br>
<br>    return true;
<br>}
<br>
<br>// ----------------------------------------------------------------------------
<br>// event handlers
<br>// ----------------------------------------------------------------------------
<br>
<br>void ocpnToolBarSimple::OnPaint( wxPaintEvent& WXUNUSED(event) )
<br>{
<br>    wxPaintDC dc( this );
<br>    PrepareDC( dc );
<br>
<br>    wxRegion ru = GetUpdateRegion();
<br>    wxRect upRect = ru.GetBox();
<br>
<br>    static int count = 0;
<br>    // Prevent reentry of OnPaint which would cause wxMemoryDC errors.
<br>    if( count > 0 ) return;
<br>    count++;
<br>
<br>    for( wxToolBarToolsList::compatibility_iterator node = m_tools.GetFirst(); node;
<br>            node = node->GetNext() ) {
<br>        wxToolBarToolBase *tool = node->GetData();
<br>        ocpnToolBarTool *tools = (ocpnToolBarTool *) tool;
<br>        wxRect toolRect = tools->trect;
<br>
<br>        if( toolRect.Intersects( upRect ) ) {
<br>
<br>            if( tool->IsButton() ) {
<br>                DrawTool( dc, tool );
<br>            } else
<br>                if( tool->IsControl() ) {
<br>                    if( tool->GetControl()->IsKindOf( CLASSINFO(wxStaticBitmap) ) ) {
<br>                        wxStaticBitmap *psbm = (wxStaticBitmap *) tool->GetControl();
<br>                        ocpnToolBarTool *toolsimp = (ocpnToolBarTool *) tool;
<br>                        dc.DrawBitmap( psbm->GetBitmap(), toolsimp->m_x, toolsimp->m_y, false );
<br>                    }
<br>                }
<br>        }
<br>    }
<br>
<br>    count--;
<br>}
<br>
<br>void ocpnToolBarSimple::OnSize( wxSizeEvent& WXUNUSED(event) )
<br>{
<br>    if( GetAutoLayout() ) Layout();
<br>}
<br>
<br>void ocpnToolBarSimple::OnKillFocus( wxFocusEvent& WXUNUSED(event) )
<br>{
<br>    OnMouseEnter( m_pressedTool = m_currentTool = -1 );
<br>}
<br>
<br>void ocpnToolBarSimple::OnToolTipTimerEvent( wxTimerEvent& event )
<br>{
<br>    if( !gFrame->IsActive() ) return;
<br>
<br>    if( m_btooltip_show && IsShown() && m_pToolTipWin && ( !m_pToolTipWin->IsShown() ) ) {
<br>        if( m_last_ro_tool ) {
<br>            wxString s = m_last_ro_tool->GetShortHelp();
<br>
<br>            if( s.Len() ) {
<br>                m_pToolTipWin->SetString( s );
<br>                m_pToolTipWin->SetHiviz(m_last_ro_tool->m_btooltip_hiviz);
<br>
<br>                wxPoint pos_in_toolbar( m_last_ro_tool->m_x, m_last_ro_tool->m_y );
<br>                pos_in_toolbar.x += m_last_ro_tool->m_width + 2;
<br>
<br>                m_pToolTipWin->Move(0,0);       // workaround for gtk autocentre dialog behavior
<br>
<br>                wxPoint screenPosition = ClientToScreen( pos_in_toolbar );
<br>                wxPoint framePosition = gFrame->ScreenToClient(screenPosition);
<br>                wxSize tipSize = m_pToolTipWin->GetRenderedSize();
<br>                
<br>                if( (framePosition.x + tipSize.x) > gFrame->GetSize().x)
<br>                    screenPosition.x -= (tipSize.x + m_last_ro_tool->m_width + 4);
<br>                
<br>                m_pToolTipWin->SetPosition( screenPosition );
<br>                m_pToolTipWin->SetBitmap();
<br>                m_pToolTipWin->Show();
<br>                gFrame->Raise();
<br>                if( g_btouch )
<br>                    m_tooltipoff_timer.Start(m_tooltip_off, wxTIMER_ONE_SHOT);
<br>            }
<br>        }
<br>    }
<br>}
<br>
<br>void ocpnToolBarSimple::OnToolTipOffTimerEvent( wxTimerEvent& event )
<br>{
<br>    HideTooltip();
<br>}
<br>
<br>
<br>int s_dragx, s_dragy;
<br>
<br>void ocpnToolBarSimple::OnMouseEvent( wxMouseEvent & event )
<br>{
<br>#ifdef __OCPN__ANDROID__
<br>    if(!event.IsButton())
<br>        return;
<br>#endif
<br>
<br>    wxCoord x, y;
<br>    event.GetPosition( &x, &y );
<br>    ocpnToolBarTool *tool = (ocpnToolBarTool *) FindToolForPosition( x, y );
<br>
<br>#ifndef __OCPN__ANDROID__
<br>    if( event.LeftDown() ) {
<br>        CaptureMouse();
<br>        s_dragx = x;
<br>        s_dragy = y;
<br>    }
<br>    if( event.LeftUp() ) {
<br>        if( HasCapture() ) ReleaseMouse();
<br>    }
<br>#endif
<br>
<br>    if( tool && tool->IsButton() && IsShown() ) {
<br>
<br>        //    ToolTips
<br>        if( NULL == m_pToolTipWin ) {
<br>            m_pToolTipWin = new ToolTipWin( GetParent() );
<br>            m_pToolTipWin->SetColorScheme( m_currentColorScheme );
<br>            m_pToolTipWin->Hide();
<br>        }
<br>
<br>        if( tool != m_last_ro_tool ) m_pToolTipWin->Hide();
<br>
<br>#ifndef __OCPN__ANDROID__
<br>        if( !m_pToolTipWin->IsShown() ) {
<br>            m_tooltip_timer.Start( m_one_shot, wxTIMER_ONE_SHOT );
<br>        }
<br>#endif
<br>
<br>        //    Tool Rollover highlighting
<br>        if(!g_btouch){
<br>            if( tool != m_last_ro_tool ) {
<br>                if( tool->IsEnabled() ) {
<br>                    tool->rollover = true;
<br>                    tool->bitmapOK = false;
<br>                }
<br>                if( m_last_ro_tool ) {
<br>                    if( m_last_ro_tool->IsEnabled() ) {
<br>                        m_last_ro_tool->rollover = false;
<br>                        m_last_ro_tool->bitmapOK = false;
<br>                    }
<br>                }
<br>                m_last_ro_tool = tool;
<br>                if(g_toolbar)
<br>                    g_toolbar->Refresh( false );
<br>            }
<br>        }
<br>    } else {
<br>        //    Tooltips
<br>        if( m_pToolTipWin && m_pToolTipWin->IsShown() ) m_pToolTipWin->Hide();
<br>
<br>        //    Remove Highlighting
<br>        if( m_last_ro_tool ) {
<br>            if( m_last_ro_tool->IsEnabled() ) {
<br>                m_last_ro_tool->rollover = false;
<br>                m_last_ro_tool->bitmapOK = false;
<br>            }
<br>            g_toolbar->Refresh( false );
<br>        }
<br>    }
<br>
<br>    m_last_ro_tool = tool;
<br>
<br>    // allow smooth zooming while toolbutton is held down
<br>    if(g_bsmoothpanzoom && !g_btouch) {
<br>        if(event.LeftUp() && m_btoolbar_is_zooming) {
<br>            cc1->StopMovement();
<br>            m_btoolbar_is_zooming = false;
<br>            return;
<br>        }
<br>
<br>        if( event.LeftDown() && tool &&
<br>            (tool->GetId() == ID_ZOOMIN || tool->GetId() == ID_ZOOMOUT) ) {
<br>            cc1->ZoomCanvas( tool->GetId() == ID_ZOOMIN ? 2.0 : .5, false, false );
<br>            m_btoolbar_is_zooming = true;
<br>            return;
<br>        }
<br>    }
<br>
<br>    if( !tool ) {
<br>        if( m_currentTool > -1 ) {
<br>            if( event.LeftIsDown() ) SpringUpButton( m_currentTool );
<br>            m_currentTool = -1;
<br>            OnMouseEnter( -1 );
<br>        }
<br>
<br>        wxMouseEvent *pev = (wxMouseEvent *) event.Clone();
<br>        GetParent()->GetEventHandler()->AddPendingEvent( *pev );
<br>        wxDELETE( pev );
<br>
<br>        return;
<br>    }
<br>
<br>    if( !event.IsButton() ) {
<br>        if( tool->GetId() != m_currentTool ) {
<br>            // If the left button is kept down and moved over buttons,
<br>            // press those buttons.
<br>            if( event.LeftIsDown() && tool->IsEnabled() ) {
<br>                SpringUpButton( m_currentTool );
<br>
<br>                if( tool->CanBeToggled() ) {
<br>                    tool->Toggle();
<br>                }
<br>
<br>                DrawTool( tool );
<br>            }
<br>
<br>            m_currentTool = tool->GetId();
<br>            OnMouseEnter( m_currentTool );
<br>        }
<br>
<br>        wxMouseEvent *pev = (wxMouseEvent *) event.Clone();
<br>        GetParent()->GetEventHandler()->AddPendingEvent( *pev );
<br>        wxDELETE( pev );
<br>
<br>        return;
<br>    }
<br>
<br>    // Left button pressed.
<br>    if( event.LeftDown() && tool->IsEnabled() ) {
<br>        if( tool->CanBeToggled() ) {
<br>            tool->Toggle();
<br>            tool->bitmapOK = false;
<br>            
<br>        }
<br>
<br>        DrawTool( tool );
<br>
<br>        //        Look for PlugIn tools
<br>        //        If found, make the callback.
<br>        if( g_pi_manager ) {
<br>            ArrayOfPlugInToolbarTools tool_array = g_pi_manager->GetPluginToolbarToolArray();
<br>            for( unsigned int i = 0; i < tool_array.GetCount(); i++ ) {
<br>                PlugInToolbarToolContainer *pttc = tool_array.Item( i );
<br>                if( tool->GetId() == pttc->id ) {
<br>                    opencpn_plugin_113 *ppi = dynamic_cast<opencpn_plugin_113 *>(pttc->m_pplugin);
<br>                    if( ppi ) {
<br>                        ppi->OnToolbarToolDownCallback( pttc->id );
<br>                        m_last_plugin_down_id = pttc->id;
<br>                    }
<br>                }
<br>            }
<br>        }
<br>    } else
<br>        if( event.RightDown() ) {
<br>            OnRightClick( tool->GetId(), x, y );
<br>        }
<br>
<br>    // Left Button Released.  Only this action confirms selection.
<br>    // If the button is enabled and it is not a toggle tool and it is
<br>    // in the pressed state, then raise the button and call OnLeftClick.
<br>    //
<br>    if( event.LeftUp() && tool->IsEnabled() ) {
<br>        // Pass the OnLeftClick event to tool
<br>        if( !OnLeftClick( tool->GetId(), tool->IsToggled() ) && tool->CanBeToggled() ) {
<br>            // If it was a toggle, and OnLeftClick says No Toggle allowed,
<br>            // then change it back
<br>            tool->Toggle();
<br>            tool->bitmapOK = false;
<br>        }
<br>
<br>        DoPluginToolUp();
<br>    }
<br>
<br>    wxMouseEvent *pev = (wxMouseEvent *) event.Clone();
<br>    GetParent()->GetEventHandler()->AddPendingEvent( *pev );
<br>    wxDELETE( pev );
<br>    event.Skip();
<br>}
<br>
<br>// ----------------------------------------------------------------------------
<br>// drawing
<br>// ----------------------------------------------------------------------------
<br>
<br>void ocpnToolBarSimple::DrawTool( wxToolBarToolBase *tool )
<br>{
<br>    wxClientDC dc( this );
<br>    DrawTool( dc, tool );
<br>}
<br>
<br>// NB! The current DrawTool code assumes that plugin tools are never disabled
<br>// when they are present on the toolbar, since disabled plugins are removed.
<br>
<br>void ocpnToolBarSimple::DrawTool( wxDC& dc, wxToolBarToolBase *toolBase )
<br>{
<br>    ocpnToolBarTool *tool = (ocpnToolBarTool *) toolBase;
<br>    PrepareDC( dc );
<br>
<br>    wxPoint drawAt( tool->m_x, tool->m_y );
<br>    wxBitmap bmp;
<br>
<br>    if( tool->bitmapOK ) {
<br>        if( tool->IsEnabled() ) {
<br>            bmp = tool->GetNormalBitmap();
<br>            if( !bmp.IsOk() ){
<br>                bmp = m_style->GetToolIcon( tool->GetToolname(), TOOLICON_NORMAL, tool->rollover );
<br>                if(m_sizefactor > 1.0 ){
<br>                    wxImage scaled_image = bmp.ConvertToImage();
<br>                    bmp = wxBitmap(scaled_image.Scale(tool->m_width, tool->m_height, wxIMAGE_QUALITY_HIGH));
<br>                }
<br>                tool->SetNormalBitmap( bmp );
<br>                tool->bitmapOK = true;
<br>            }
<br>        } else {
<br>            bmp = tool->GetDisabledBitmap();
<br>            if( !bmp.IsOk() ){
<br>                bmp = m_style->GetToolIcon( tool->GetToolname(), TOOLICON_DISABLED );
<br>                if(m_sizefactor > 1.0 ){
<br>                    wxImage scaled_image = bmp.ConvertToImage();
<br>                    bmp = wxBitmap(scaled_image.Scale(tool->m_width, tool->m_height, wxIMAGE_QUALITY_HIGH));
<br>                }
<br>                tool->SetDisabledBitmap( bmp );
<br>                tool->bitmapOK = true;
<br>            }
<br>        }
<br>    } else {
<br>        if ( tool->isPluginTool ) {
<br>
<br>            // First try getting the icon from the Style.
<br>            // If it is not in the style we build a new icon from the style BG and the plugin icon.
<br>
<br>            if( tool->IsToggled() ) {
<br>                bmp = m_style->GetToolIcon( tool->GetToolname(), TOOLICON_TOGGLED, tool->rollover );
<br>                if( bmp.GetDepth() == 1 ) {
<br>                    if( tool->rollover ) {
<br>                        bmp = m_style->BuildPluginIcon( tool->pluginRolloverIcon, TOOLICON_TOGGLED );
<br>                        if( ! bmp.IsOk() )
<br>                            bmp = m_style->BuildPluginIcon( tool->pluginNormalIcon, TOOLICON_TOGGLED );
<br>                    }
<br>                    else
<br>                        bmp = m_style->BuildPluginIcon( tool->pluginNormalIcon, TOOLICON_TOGGLED );
<br>                }
<br>            } else {
<br>                bmp = m_style->GetToolIcon( tool->GetToolname(), TOOLICON_NORMAL, tool->rollover );
<br>                if( bmp.GetDepth() == 1 ) {
<br>                    if( tool->rollover ) {
<br>                        bmp = m_style->BuildPluginIcon( tool->pluginRolloverIcon, TOOLICON_NORMAL );
<br>                        if( ! bmp.IsOk() )
<br>                            bmp = m_style->BuildPluginIcon( tool->pluginNormalIcon, TOOLICON_NORMAL );
<br>                    }
<br>                    else
<br>                        bmp = m_style->BuildPluginIcon( tool->pluginNormalIcon, TOOLICON_NORMAL );
<br>                }
<br>            }
<br>            if(m_sizefactor > 1.0 ){
<br>                wxImage scaled_image = bmp.ConvertToImage();
<br>                bmp = wxBitmap(scaled_image.Scale(tool->m_width, tool->m_height, wxIMAGE_QUALITY_HIGH));
<br>            }
<br>            tool->SetNormalBitmap( bmp );
<br>            tool->bitmapOK = true;
<br>        } else {
<br>            if( tool->IsEnabled() ) {
<br>                if( tool->IsToggled() )
<br>                    bmp = m_style->GetToolIcon( tool->GetToolname(), TOOLICON_TOGGLED, tool->rollover );
<br>                else
<br>                    bmp = m_style->GetToolIcon( tool->GetIconName(), TOOLICON_NORMAL, tool->rollover );
<br>
<br>                if(m_sizefactor > 1.0 ){
<br>                    wxImage scaled_image = bmp.ConvertToImage();
<br>                    bmp = wxBitmap(scaled_image.Scale(tool->m_width, tool->m_height, wxIMAGE_QUALITY_HIGH));
<br>                }
<br>                tool->SetNormalBitmap( bmp );
<br>                tool->bitmapOK = true;
<br>            } else {
<br>                bmp = m_style->GetToolIcon( tool->GetToolname(), TOOLICON_DISABLED );
<br>                if(m_sizefactor > 1.0 ){
<br>                    wxImage scaled_image = bmp.ConvertToImage();
<br>                    bmp = wxBitmap(scaled_image.Scale(tool->m_width, tool->m_height, wxIMAGE_QUALITY_HIGH));
<br>                }
<br>                tool->SetDisabledBitmap( bmp );
<br>                tool->bitmapOK = true;
<br>            }
<br>        }
<br>    }
<br>
<br>    if( tool->firstInLine ) {
<br>        m_style->DrawToolbarLineStart( bmp );
<br>    }
<br>    if( tool->lastInLine ) {
<br>        m_style->DrawToolbarLineEnd( bmp );
<br>    }
<br>
<br>    if( bmp.GetWidth() != m_style->GetToolSize().x
<br>            || bmp.GetHeight() != m_style->GetToolSize().y ) {
<br>//        drawAt.x -= ( bmp.GetWidth() - m_style->GetToolSize().x ) / 2;
<br>//        drawAt.y -= ( bmp.GetHeight() - m_style->GetToolSize().y ) / 2;
<br>    }
<br>
<br>    //      Clear the last drawn tool if necessary
<br>    if( tool->last_rect.width && ((tool->last_rect.x != drawAt.x) || (tool->last_rect.y != drawAt.y)) ){
<br>        wxBrush bb(GetGlobalColor( _T("GREY2") ));
<br>        dc.SetBrush(bb);
<br>        dc.SetPen( *wxTRANSPARENT_PEN );
<br>        dc.DrawRectangle(tool->last_rect.x, tool->last_rect.y, tool->last_rect.width, tool->last_rect.height);
<br>    }
<br>
<br>    //  could cache this in the tool...
<br>    //  A bit of a hack here.  We only scale tools if they are to be magnified globally
<br>    if(0/*m_sizefactor > 1.0*/ )
<br>    {
<br>        wxImage scaled_image = bmp.ConvertToImage();
<br>        wxBitmap sbmp = wxBitmap(scaled_image.Scale(tool->m_width, tool->m_height, wxIMAGE_QUALITY_HIGH));
<br>        dc.DrawBitmap( sbmp, drawAt );
<br>        tool->last_rect = wxRect(drawAt.x, drawAt.y, sbmp.GetWidth(), sbmp.GetHeight());
<br>
<br>    }
<br>    else
<br>    {
<br>        dc.DrawBitmap( bmp, drawAt );
<br>        tool->last_rect = wxRect(drawAt.x, drawAt.y, bmp.GetWidth(), bmp.GetHeight());
<br>    }
<br>
<br>}
<br>
<br>// ----------------------------------------------------------------------------
<br>// toolbar geometry
<br>// ----------------------------------------------------------------------------
<br>
<br>wxToolBarToolBase *ocpnToolBarSimple::FindToolForPosition( wxCoord x, wxCoord y )
<br>{
<br>    wxToolBarToolsList::compatibility_iterator node = m_tools.GetFirst();
<br>    while( node ) {
<br>        ocpnToolBarTool *tool = (ocpnToolBarTool *) node->GetData();
<br>        if( ( x >= tool->m_x ) && ( y >= tool->m_y ) && ( x < ( tool->m_x + tool->GetWidth() ) )
<br>                && ( y < ( tool->m_y + tool->GetHeight() ) ) ) {
<br>            return tool;
<br>        }
<br>
<br>        node = node->GetNext();
<br>    }
<br>
<br>    return (wxToolBarToolBase *) NULL;
<br>}
<br>
<br>void ocpnToolBarSimple::InvalidateBitmaps()
<br>{
<br>    wxToolBarToolsList::compatibility_iterator node = m_tools.GetFirst();
<br>    while( node ) {
<br>        ocpnToolBarTool *tool = (ocpnToolBarTool *) node->GetData();
<br>        tool->bitmapOK = false;
<br>        node = node->GetNext();
<br>    }
<br>}
<br>
<br>wxRect ocpnToolBarSimple::GetToolRect( int tool_id )
<br>{
<br>    wxRect rect;
<br>    wxToolBarToolBase *tool = FindById( tool_id );
<br>    if( tool ) {
<br>        ocpnToolBarTool *otool = (ocpnToolBarTool *) tool;
<br>        if( otool ) rect = otool->trect;
<br>    }
<br>
<br>    return rect;
<br>}
<br>
<br>// ----------------------------------------------------------------------------
<br>// tool state change handlers
<br>// ----------------------------------------------------------------------------
<br>
<br>void ocpnToolBarSimple::DoEnableTool( wxToolBarToolBase *tool, bool WXUNUSED(enable) )
<br>{
<br>    DrawTool( tool );
<br>}
<br>
<br>void ocpnToolBarSimple::DoToggleTool( wxToolBarToolBase *tool, bool WXUNUSED(toggle) )
<br>{
<br>    ocpnToolBarTool *t = (ocpnToolBarTool *) tool;
<br>    t->bitmapOK = false;
<br>    DrawTool( tool );
<br>}
<br>
<br>// Okay, so we've left the tool we're in ... we must check if the tool we're
<br>// leaving was a 'sprung push button' and if so, spring it back to the up
<br>// state.
<br>void ocpnToolBarSimple::SpringUpButton( int id )
<br>{
<br>    wxToolBarToolBase *tool = FindById( id );
<br>
<br>    if( tool && tool->CanBeToggled() ) {
<br>        if( tool->IsToggled() ) tool->Toggle();
<br>
<br>        DrawTool( tool );
<br>    }
<br>}
<br>
<br>// ----------------------------------------------------------------------------
<br>// scrolling implementation
<br>// ----------------------------------------------------------------------------
<br>
<br>wxString ocpnToolBarSimple::GetToolShortHelp( int id ) const
<br>{
<br>    wxToolBarToolBase *tool = FindById( id );
<br>    wxCHECK_MSG( tool, wxEmptyString, _T("no such tool") );
<br>
<br>    return tool->GetShortHelp();
<br>}
<br>
<br>wxString ocpnToolBarSimple::GetToolLongHelp( int id ) const
<br>{
<br>    wxToolBarToolBase *tool = FindById( id );
<br>    wxCHECK_MSG( tool, wxEmptyString, _T("no such tool") );
<br>
<br>    return tool->GetLongHelp();
<br>}
<br>
<br>void ocpnToolBarSimple::SetToolShortHelp( int id, const wxString& help )
<br>{
<br>    wxToolBarToolBase *tool = FindById( id );
<br>    if( tool ) {
<br>        (void) tool->SetShortHelp( help );
<br>    }
<br>}
<br>
<br>void ocpnToolBarSimple::SetToolLongHelp( int id, const wxString& help )
<br>{
<br>    wxToolBarToolBase *tool = FindById( id );
<br>    if( tool ) {
<br>        (void) tool->SetLongHelp( help );
<br>    }
<br>}
<br>
<br>int ocpnToolBarSimple::GetToolPos( int id ) const
<br>{
<br>    size_t pos = 0;
<br>    wxToolBarToolsList::compatibility_iterator node;
<br>
<br>    for( node = m_tools.GetFirst(); node; node = node->GetNext() ) {
<br>        if( node->GetData()->GetId() == id ) return pos;
<br>
<br>        pos++;
<br>    }
<br>
<br>    return wxNOT_FOUND;
<br>}
<br>bool ocpnToolBarSimple::GetToolState( int id ) const
<br>{
<br>    wxToolBarToolBase *tool = FindById( id );
<br>    wxCHECK_MSG( tool, false, _T("no such tool") );
<br>
<br>    return tool->IsToggled();
<br>}
<br>
<br>bool ocpnToolBarSimple::GetToolEnabled( int id ) const
<br>{
<br>    wxToolBarToolBase *tool = FindById( id );
<br>    wxCHECK_MSG( tool, false, _T("no such tool") );
<br>
<br>    return tool->IsEnabled();
<br>}
<br>
<br>void ocpnToolBarSimple::ToggleTool( int id, bool toggle )
<br>{
<br>    wxToolBarToolBase *tool = FindById( id );
<br>        
<br>    if( tool && tool->CanBeToggled() && tool->Toggle( toggle ) ) {
<br>        DoToggleTool( tool, toggle );
<br>        if( g_toolbar ) g_toolbar->Refresh();
<br>    }
<br>}
<br>
<br>wxObject *ocpnToolBarSimple::GetToolClientData( int id ) const
<br>{
<br>    wxToolBarToolBase *tool = FindById( id );
<br>    return tool ? tool->GetClientData() : (wxObject *) NULL;
<br>}
<br>
<br>void ocpnToolBarSimple::SetToolClientData( int id, wxObject *clientData )
<br>{
<br>    wxToolBarToolBase *tool = FindById( id );
<br>
<br>    wxCHECK_RET( tool, _T("no such tool in wxToolBar::SetToolClientData") );
<br>
<br>    tool->SetClientData( clientData );
<br>}
<br>
<br>void ocpnToolBarSimple::EnableTool( int id, bool enable )
<br>{
<br>    wxToolBarToolBase *tool = FindById( id );
<br>    if( tool ) {
<br>        if( tool->Enable( enable ) ) {
<br>            DoEnableTool( tool, enable );
<br>        }
<br>    }
<br>    wxMenuItem* configItem = g_FloatingToolbarConfigMenu->FindItem( id );
<br>    configItem->Check( true );
<br>}
<br>
<br>void ocpnToolBarSimple::SetToolBitmaps( int id, wxBitmap *bmp, wxBitmap *bmpRollover )
<br>{
<br>    ocpnToolBarTool *tool = (ocpnToolBarTool*)FindById( id );
<br>    if( tool ) {
<br>        tool->pluginNormalIcon = bmp;
<br>        tool->pluginRolloverIcon = bmpRollover;
<br>        tool->bitmapOK = false;
<br>    }
<br>}
<br>
<br>void ocpnToolBarSimple::SetToolTooltipHiViz( int id, bool b_hiviz )
<br>{
<br>    ocpnToolBarTool *tool = (ocpnToolBarTool*)FindById( id );
<br>    if( tool ) {
<br>        tool->SetTooltipHiviz( b_hiviz );
<br>    }
<br>}
<br>
<br>
<br>void ocpnToolBarSimple::ClearTools()
<br>{
<br>    while( GetToolsCount() ) {
<br>        DeleteToolByPos( 0 );
<br>    }
<br>}
<br>
<br>int ocpnToolBarSimple::GetVisibleToolCount()
<br>{
<br>    int counter = 0;
<br>    wxToolBarToolsList::compatibility_iterator node = m_tools.GetFirst();
<br>    while( node ) {
<br>        ocpnToolBarTool *tool = (ocpnToolBarTool *) node->GetData();
<br>        counter++;
<br>        node = node->GetNext();
<br>    }
<br>    return counter;
<br>}
<br>
<br>bool ocpnToolBarSimple::DeleteToolByPos( size_t pos )
<br>{
<br>    wxCHECK_MSG( pos < GetToolsCount(), false,
<br>            _T("invalid position in wxToolBar::DeleteToolByPos()") );
<br>
<br>    wxToolBarToolsList::compatibility_iterator node = m_tools.Item( pos );
<br>
<br>    if( !DoDeleteTool( pos, node->GetData() ) ) {
<br>        return false;
<br>    }
<br>
<br>    delete node->GetData();
<br>    m_tools.Erase( node );
<br>
<br>    return true;
<br>}
<br>
<br>bool ocpnToolBarSimple::DeleteTool( int id )
<br>{
<br>    size_t pos = 0;
<br>    wxToolBarToolsList::compatibility_iterator node;
<br>    for( node = m_tools.GetFirst(); node; node = node->GetNext() ) {
<br>        if( node->GetData()->GetId() == id ) break;
<br>
<br>        pos++;
<br>    }
<br>
<br>    if( !node || !DoDeleteTool( pos, node->GetData() ) ) {
<br>        return false;
<br>    }
<br>
<br>    delete node->GetData();
<br>    m_tools.Erase( node );
<br>
<br>    return true;
<br>}
<br>
<br>wxToolBarToolBase *ocpnToolBarSimple::AddSeparator()
<br>{
<br>    return InsertSeparator( GetToolsCount() );
<br>}
<br>
<br>wxToolBarToolBase *ocpnToolBarSimple::InsertSeparator( size_t pos )
<br>{
<br>    wxCHECK_MSG( pos <= GetToolsCount(), (wxToolBarToolBase *)NULL,
<br>            _T("invalid position in wxToolBar::InsertSeparator()") );
<br>
<br>    wxToolBarToolBase *tool = CreateTool( wxID_SEPARATOR, wxEmptyString, wxNullBitmap, wxNullBitmap,
<br>            wxITEM_SEPARATOR, (wxObject *) NULL, wxEmptyString, wxEmptyString );
<br>
<br>    if( !tool || !DoInsertTool( pos, tool ) ) {
<br>        delete tool;
<br>
<br>        return NULL;
<br>    }
<br>
<br>    m_tools.Insert( pos, tool );
<br>
<br>    return tool;
<br>}
<br>
<br>wxToolBarToolBase *ocpnToolBarSimple::RemoveTool( int id )
<br>{
<br>    size_t pos = 0;
<br>    wxToolBarToolsList::compatibility_iterator node;
<br>    for( node = m_tools.GetFirst(); node; node = node->GetNext() ) {
<br>        if( node->GetData()->GetId() == id ) break;
<br>
<br>        pos++;
<br>    }
<br>
<br>    if( !node ) {
<br>        // don't give any error messages - sometimes we might call RemoveTool()
<br>        // without knowing whether the tool is or not in the toolbar
<br>        return (wxToolBarToolBase *) NULL;
<br>    }
<br>
<br>    wxToolBarToolBase *tool = node->GetData();
<br>    if( !DoDeleteTool( pos, tool ) ) {
<br>        return (wxToolBarToolBase *) NULL;
<br>    }
<br>
<br>    m_tools.Erase( node );
<br>
<br>    return tool;
<br>}
<br>
<br>
<br>wxControl *ocpnToolBarSimple::FindControl( int id )
<br>{
<br>    for( wxToolBarToolsList::compatibility_iterator node = m_tools.GetFirst(); node;
<br>            node = node->GetNext() ) {
<br>        const wxToolBarToolBase * const tool = node->GetData();
<br>        if( tool->IsControl() ) {
<br>            wxControl * const control = tool->GetControl();
<br>
<br>            if( !control ) {
<br>                wxFAIL_MSG( _T("NULL control in toolbar?") );
<br>            } else
<br>                if( control->GetId() == id ) {
<br>                    // found
<br>                    return control;
<br>                }
<br>        }
<br>    }
<br>
<br>    return NULL;
<br>}
<br>
<br>wxToolBarToolBase *ocpnToolBarSimple::FindById( int id ) const
<br>{
<br>    wxToolBarToolBase *tool = (wxToolBarToolBase *) NULL;
<br>
<br>    for( wxToolBarToolsList::compatibility_iterator node = m_tools.GetFirst(); node;
<br>            node = node->GetNext() ) {
<br>        tool = node->GetData();
<br>        if( tool->GetId() == id ) {
<br>            // found
<br>            break;
<br>        }
<br>
<br>        tool = NULL;
<br>    }
<br>
<br>    return tool;
<br>}
<br>
<br>// ----------------------------------------------------------------------------
<br>// event processing
<br>// ----------------------------------------------------------------------------
<br>
<br>// Only allow toggle if returns true
<br>bool ocpnToolBarSimple::OnLeftClick( int id, bool toggleDown )
<br>{
<br>    wxCommandEvent event( wxEVT_COMMAND_TOOL_CLICKED, id );
<br>    event.SetEventObject( this );
<br>
<br>    // we use SetInt() to make wxCommandEvent::IsChecked() return toggleDown
<br>    event.SetInt( (int) toggleDown );
<br>
<br>    // and SetExtraLong() for backwards compatibility
<br>    event.SetExtraLong( (long) toggleDown );
<br>
<br>    // Send events to this toolbar instead (and thence up the window hierarchy)
<br>    GetEventHandler()->ProcessEvent( event );
<br>
<br>    return true;
<br>}
<br>
<br>// Call when right button down.
<br>void ocpnToolBarSimple::OnRightClick( int id, long WXUNUSED(x), long WXUNUSED(y) )
<br>{
<br>    wxCommandEvent event( wxEVT_COMMAND_TOOL_RCLICKED, id );
<br>    event.SetEventObject( this );
<br>    event.SetInt( id );
<br>
<br>    HideTooltip();
<br>    ((ocpnFloatingToolbarDialog*)GetParent())->toolbarConfigChanged = false;
<br>    wxMenu* contextMenu = new wxMenu();
<br>    wxMenuItem* submenu = contextMenu->AppendSubMenu( g_FloatingToolbarConfigMenu, _("Visible buttons") );
<br>
<br>    PopupMenu( contextMenu );
<br>
<br>    contextMenu->Remove( submenu );
<br>    delete contextMenu;
<br>
<br>    if( ((ocpnFloatingToolbarDialog*)GetParent())->toolbarConfigChanged )
<br>        gFrame->GetEventHandler()->AddPendingEvent( event );
<br>}
<br>
<br>// Called when the mouse cursor enters a tool bitmap (no button pressed).
<br>// Argument is wxID_ANY if mouse is exiting the toolbar.
<br>// Note that for this event, the id of the window is used,
<br>// and the integer parameter of wxCommandEvent is used to retrieve
<br>// the tool id.
<br>void ocpnToolBarSimple::OnMouseEnter( int id )
<br>{
<br>    wxCommandEvent event( wxEVT_COMMAND_TOOL_ENTER, GetId() );
<br>    event.SetEventObject( this );
<br>    event.SetInt( id );
<br>
<br>    wxFrame *frame = wxDynamicCast(GetParent(), wxFrame);
<br>    if( frame ) {
<br>        wxString help;
<br>        wxToolBarToolBase* tool = id == wxID_ANY ? (wxToolBarToolBase*) NULL : FindById( id );
<br>        if( tool ) help = tool->GetLongHelp();
<br>        frame->DoGiveHelp( help, id != wxID_ANY );
<br>    }
<br>
<br>    (void) GetEventHandler()->ProcessEvent( event );
<br>
<br>    DoPluginToolUp();
<br>}
<br>
<br>void ocpnToolBarSimple::DoPluginToolUp()
<br>{
<br>    //        Look for PlugIn tools
<br>    //        If found, make the callback.
<br>    if( !g_pi_manager)
<br>        return;
<br>
<br>    ArrayOfPlugInToolbarTools tool_array = g_pi_manager->GetPluginToolbarToolArray();
<br>    for( unsigned int i = 0; i < tool_array.GetCount(); i++ ) {
<br>        PlugInToolbarToolContainer *pttc = tool_array.Item( i );
<br>        if( m_last_plugin_down_id == pttc->id ) {
<br>            opencpn_plugin_113 *ppi = dynamic_cast<opencpn_plugin_113 *>(pttc->m_pplugin);
<br>            if( ppi )
<br>                ppi->OnToolbarToolUpCallback( pttc->id );
<br>        }
<br>    }
<br>
<br>    m_last_plugin_down_id = -1;
<br>}
<br>
<br>void ocpnToolBarSimple::SetToolNormalBitmapEx( wxToolBarToolBase *tool, const wxString &iconName)
<br>{
<br>    if( tool ) {
<br>        ocpnToolBarTool *otool = (ocpnToolBarTool *) tool;
<br>        if(otool){
<br>            ocpnStyle::Style *style = g_StyleManager->GetCurrentStyle();
<br>
<br>            wxBitmap bmp = style->GetToolIcon( iconName, TOOLICON_NORMAL );
<br>            if(m_sizefactor > 1.0 ){
<br>                wxImage scaled_image = bmp.ConvertToImage();
<br>                bmp = wxBitmap(scaled_image.Scale(otool->m_width, otool->m_height, wxIMAGE_QUALITY_HIGH));
<br>            }
<br>        
<br>            tool->SetNormalBitmap( bmp );
<br>            otool->SetIconName( iconName );
<br>        }
<br>    }
<br>}
<br>
<br>
<br>//-------------------------------------------------------------------------------------
<br>
<br>ToolbarMOBDialog::ToolbarMOBDialog( wxWindow* parent )
<br>       : wxDialog( parent, wxID_ANY, _("OpenCPN Alert"), wxDefaultPosition, wxSize(250, 230) )
<br>{
<br>    wxBoxSizer* topSizer = new wxBoxSizer( wxVERTICAL );
<br>
<br>    wxBoxSizer* sizer = new wxBoxSizer( wxVERTICAL );
<br>    topSizer->Add( sizer, 0, wxALIGN_CENTER_HORIZONTAL | wxALL, 5 );
<br>
<br>    choices.push_back( new wxRadioButton( this, 0,  _("No, I don't want to hide it."),
<br>            wxDefaultPosition, wxDefaultSize, wxRB_GROUP ) );
<br>
<br>    choices.push_back( new wxRadioButton( this, 1, _("No, and permanently remove the option to hide it."),
<br>            wxDefaultPosition) );
<br>
<br>    choices.push_back( new wxRadioButton( this, 2, _("Yes, hide it."),
<br>            wxDefaultPosition) );
<br>
<br><mark>    wxStdDialogButtonSizer* buttonSizer = CreateStdDialogButtonSizer( wxOK | wxCANCEL );
</mark><br>
<br>
<br>    wxStaticText* textCtrl = new wxStaticText( this, wxID_ANY, _("The Man Over Board button could be an important safety feature.\nAre you sure you want to hide it?") );
<br>
<br>    sizer->Add( textCtrl, 0, wxEXPAND | wxALL, 5 );
<br>    sizer->Add( choices[0], 0, wxEXPAND | wxALL, 5 );
<br>    sizer->Add( choices[1], 0, wxEXPAND | wxALL, 5 );
<br>    sizer->Add( choices[2], 0, wxEXPAND | wxALL, 5 );
<br><mark>    sizer->Add( buttonSizer, 0, wxEXPAND | wxTOP, 5 );
</mark><br>
<br>    topSizer->SetSizeHints(this);
<br>    SetSizer( topSizer );
<br>}
<br>
<br>int ToolbarMOBDialog::GetSelection() {
<br>    for( unsigned int i=0; i<choices.size(); i++ ) {
<br>        if( choices[i]->GetValue() ) return choices[i]->GetId();
<br>    }
<br>    return 0;
<br>}
</p></body>
    </html><html>
    <head></head>
    <body><p><br>/***************************************************************************
<br> *
<br> * Project:  OpenCPN
<br> * Purpose:  OpenCPN Toolbar
<br> * Author:   David Register
<br> *
<br> ***************************************************************************
<br> *   Copyright (C) 2010 by David S. Register                               *
<br> *                                                                         *
<br> *   This program is free software; you can redistribute it and/or modify  *
<br> *   it under the terms of the GNU General Public License as published by  *
<br> *   the Free Software Foundation; either version 2 of the License, or     *
<br> *   (at your option) any later version.                                   *
<br> *                                                                         *
<br> *   This program is distributed in the hope that it will be useful,       *
<br> *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
<br> *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
<br> *   GNU General Public License for more details.                          *
<br> *                                                                         *
<br> *   You should have received a copy of the GNU General Public License     *
<br> *   along with this program; if not, write to the                         *
<br> *   Free Software Foundation, Inc.,                                       *
<br> *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,  USA.         *
<br> **************************************************************************/
<br>
<br>#include "wx/wxprec.h"
<br>
<br>#ifndef  WX_PRECOMP
<br>#include "wx/wx.h"
<br>#endif
<br>
<br>#include <vector>
<br>
<br>#include "ocpn_types.h"
<br>#include "navutil.h"
<br>#include "styles.h"
<br>#include "toolbar.h"
<br>#include "chart1.h"
<br>#include "pluginmanager.h"
<br>#include "FontMgr.h"
<br>
<br>extern ocpnFloatingToolbarDialog* g_FloatingToolbarDialog;
<br>extern bool                       g_bTransparentToolbar;
<br>extern bool                       g_bTransparentToolbarInOpenGLOK;
<br>extern ChartCanvas*               cc1;
<br>extern bool                       g_bopengl;
<br>extern ocpnToolBarSimple*         g_toolbar;
<br>extern ocpnStyle::StyleManager*   g_StyleManager;
<br>extern MyFrame*                   gFrame;
<br>extern PlugInManager*             g_pi_manager;
<br>extern wxMenu*                    g_FloatingToolbarConfigMenu;
<br>extern wxString                   g_toolbarConfig;
<br>extern bool                       g_bPermanentMOBIcon;
<br>extern bool                       g_btouch;
<br>extern bool                       g_bsmoothpanzoom;
<br>
<br>//----------------------------------------------------------------------------
<br>// GrabberWindow Implementation
<br>//----------------------------------------------------------------------------
<br>BEGIN_EVENT_TABLE(GrabberWin, wxPanel) EVT_MOUSE_EVENTS ( GrabberWin::MouseEvent )
<br>EVT_PAINT ( GrabberWin::OnPaint )
<br>END_EVENT_TABLE()
<br>
<br>GrabberWin::GrabberWin( wxWindow *parent, ocpnFloatingToolbarDialog *toolbar, float scale_factor, wxString icon_name, wxPoint position ):
<br>    wxPanel( parent, wxID_ANY, position, wxDefaultSize, wxNO_BORDER )
<br>{
<br>    m_icon_name = icon_name;
<br>    m_style = g_StyleManager->GetCurrentStyle();
<br>    wxBitmap bitmap = m_style->GetIcon( icon_name );
<br>    if(scale_factor > 1.0f){
<br>        int new_width = bitmap.GetWidth() * scale_factor;
<br>        int new_height = bitmap.GetHeight() * scale_factor;
<br>        wxImage scaled_image = bitmap.ConvertToImage();
<br>        m_bitmap = wxBitmap(scaled_image.Scale(new_width, new_height, wxIMAGE_QUALITY_HIGH));
<br>    }
<br>    else
<br>        m_bitmap = bitmap;
<br>
<br>    SetSize( wxSize( m_bitmap.GetWidth(), m_bitmap.GetHeight() ) );
<br>    SetMinSize( wxSize( m_bitmap.GetWidth(), m_bitmap.GetHeight() ) );
<br>
<br>    m_bLeftDown = false;
<br>    m_bRightDown = false;
<br>    m_scale_factor = scale_factor;
<br>    m_ptoolbar = toolbar;
<br>    m_dragging = false;
<br>    Hide();
<br>    
<br>}
<br>
<br>
<br>void GrabberWin::OnPaint( wxPaintEvent& event )
<br>{
<br>    wxPaintDC dc( this );
<br>    
<br>    wxColour back_color = GetGlobalColor( _T("GREY2") );
<br>    SetBackgroundColour( back_color );
<br>    ClearBackground();
<br>    
<br>    dc.DrawBitmap( m_bitmap, 0, 0, true );
<br>}
<br>
<br>void GrabberWin::SetColorScheme( ColorScheme cs )
<br>{
<br>    wxColour back_color = GetGlobalColor( _T("GREY2") );
<br>
<br>    SetBackgroundColour( back_color );
<br>    ClearBackground();
<br>
<br>    wxBitmap bitmap = m_style->GetIcon( m_icon_name) ;
<br>    if(m_scale_factor > 1.0f){
<br>        int new_width = bitmap.GetWidth() * m_scale_factor;
<br>        int new_height = bitmap.GetHeight() * m_scale_factor;
<br>        wxImage scaled_image = bitmap.ConvertToImage();
<br>        m_bitmap = wxBitmap(scaled_image.Scale(new_width, new_height, wxIMAGE_QUALITY_HIGH));
<br>    }
<br>    else
<br>        m_bitmap = bitmap;
<br>}
<br>
<br>void GrabberWin::MouseEvent( wxMouseEvent& event )
<br>{
<br>    static wxPoint s_gspt;
<br>    int x, y;
<br>
<br>    event.GetPosition( &x, &y );
<br>
<br>    wxPoint spt = ClientToScreen( wxPoint( x, y ) );
<br>    if( event.LeftDown() ) {
<br>        s_gspt = spt;
<br>    }
<br>    
<br>    
<br>#ifndef __WXQT__
<br>
<br>    if( event.LeftDown() ) {
<br>        CaptureMouse();
<br>    }
<br>
<br>    if( event.LeftUp() ) {
<br>        if( HasCapture() ) ReleaseMouse();
<br>    }
<br>
<br>#endif
<br>
<br>
<br>    if( event.RightDown() ){
<br>        if(m_ptoolbar){
<br>            m_dragging = true;
<br>            
<br>            if( !m_ptoolbar->m_bnavgrabber ){
<br>                m_ptoolbar->m_bnavgrabber = true;
<br>                m_ptoolbar->SetGrabber(_T("4WayMove") );
<br>            }
<br>            else{
<br>                m_ptoolbar->m_bnavgrabber = false;
<br>                m_ptoolbar->SetGrabber(_T("grabber_hi") );
<br>            }
<br>                
<br>        }
<br>    }
<br>    
<br>
<br>
<br>    if( event.Dragging() ) {
<br>        if(m_ptoolbar && m_ptoolbar->IsShown() /*&& m_ptoolbar->m_bnavgrabber*/){
<br>            wxPoint par_pos_old = m_ptoolbar->GetPosition();
<br>
<br>            wxPoint par_pos = par_pos_old;
<br>            par_pos.x += spt.x - s_gspt.x;
<br>            par_pos.y += spt.y - s_gspt.y;
<br>
<br>            m_ptoolbar->MoveDialogInScreenCoords( par_pos, par_pos_old );
<br>
<br>            s_gspt = spt;
<br>            m_dragging = true;
<br>        }
<br>
<br>    }
<br>
<br>    if( event.LeftUp() ) {
<br>        if(m_ptoolbar){
<br>            if(m_ptoolbar->m_bnavgrabber){
<br>                if(!m_dragging)
<br>                    m_ptoolbar->ToggleOrientation();
<br>            }
<br>            else if(!m_dragging){
<br>                if(m_ptoolbar->m_bsubmerged){
<br>                    m_ptoolbar->SurfaceFromGrabber();
<br>                }
<br>                else{
<br>                    m_ptoolbar->SubmergeToGrabber();
<br>                 }
<br>            }
<br>        }
<br>        m_dragging = false;
<br>    }
<br>    
<br>    
<br>#ifndef __OCPN__ANDROID__
<br>    gFrame->Raise();
<br>#endif
<br>    
<br>}
<br>
<br>class ocpnToolBarTool: public wxToolBarToolBase {
<br>public:
<br>    ocpnToolBarTool( ocpnToolBarSimple *tbar, int id, const wxString& label,
<br>            const wxBitmap& bmpNormal, const wxBitmap& bmpRollover, wxItemKind kind,
<br>            wxObject *clientData, const wxString& shortHelp, const wxString& longHelp ) :
<br>            wxToolBarToolBase( (wxToolBarBase*) tbar, id, label, bmpNormal, bmpRollover, kind,
<br>                    clientData, shortHelp, longHelp )
<br>    {
<br>        m_enabled = true;
<br>        m_toggled = false;
<br>        rollover = false;
<br>        bitmapOK = false;
<br>        m_btooltip_hiviz = false;
<br>
<br>        toolname = g_pi_manager->GetToolOwnerCommonName( id );
<br>        if( toolname == _T("") ) {
<br>            isPluginTool = false;
<br>            toolname = label;
<br>            iconName = label;
<br>        } else {
<br>            isPluginTool = true;
<br>            pluginNormalIcon = &bmpNormal;
<br>            pluginRolloverIcon = &bmpRollover;
<br>        }
<br>    }
<br>
<br>    void SetSize( const wxSize& size )
<br>    {
<br>        m_width = size.x;
<br>        m_height = size.y;
<br>    }
<br>
<br>    wxCoord GetWidth() const
<br>    {
<br>        return m_width;
<br>    }
<br>
<br>    wxCoord GetHeight() const
<br>    {
<br>        return m_height;
<br>    }
<br>
<br>    wxString GetToolname()
<br>    {
<br>        return toolname;
<br>    }
<br>
<br>    void SetIconName(wxString name)
<br>    {
<br>        iconName = name;
<br>    }
<br>    wxString GetIconName()
<br>    {
<br>        return iconName;
<br>    }
<br>
<br>    void SetTooltipHiviz( bool enable){ m_btooltip_hiviz = enable; }
<br>
<br>    wxCoord m_x;
<br>    wxCoord m_y;
<br>    wxCoord m_width;
<br>    wxCoord m_height;
<br>    wxRect trect;
<br>    wxString toolname;
<br>    wxString iconName;
<br>    const wxBitmap* pluginNormalIcon;
<br>    const wxBitmap* pluginRolloverIcon;
<br>    bool firstInLine;
<br>    bool lastInLine;
<br>    bool rollover;
<br>    bool bitmapOK;
<br>    bool isPluginTool;
<br>    bool b_hilite;
<br>    bool m_btooltip_hiviz;
<br>    wxRect last_rect;
<br>};
<br>
<br>//---------------------------------------------------------------------------------------
<br>//          ocpnFloatingToolbarDialog Implementation
<br>//---------------------------------------------------------------------------------------
<br>BEGIN_EVENT_TABLE(ocpnFloatingToolbarDialog, wxDialog)
<br>    EVT_MOUSE_EVENTS ( ocpnFloatingToolbarDialog::MouseEvent )
<br>    EVT_MENU(wxID_ANY, ocpnFloatingToolbarDialog::OnToolLeftClick)
<br>    EVT_TIMER ( FADE_TIMER, ocpnFloatingToolbarDialog::FadeTimerEvent )
<br>    EVT_TIMER ( DESTROY_TIMER, ocpnFloatingToolbarDialog::DestroyTimerEvent )
<br>    EVT_WINDOW_CREATE(ocpnFloatingToolbarDialog::OnWindowCreate)
<br>END_EVENT_TABLE()
<br>
<br>ocpnFloatingToolbarDialog::ocpnFloatingToolbarDialog( wxWindow *parent, wxPoint position,
<br>                                                      long orient, float size_factor )
<br>{
<br>    m_pparent = parent;
<br>    long wstyle = wxNO_BORDER | wxFRAME_NO_TASKBAR;
<br>#ifndef __WXMAC__
<br>    wstyle |= wxFRAME_SHAPED;
<br>#endif
<br>
<br>    m_ptoolbar = NULL;
<br>
<br>#ifdef __WXOSX__
<br>    wstyle |= wxSTAY_ON_TOP;
<br>#endif
<br>    wxDialog::Create( parent, -1, _T("ocpnToolbarDialog"), wxPoint( -1, -1 ), wxSize( -1, -1 ),
<br>            wstyle );
<br>
<br>    m_opacity = 255;
<br>
<br>    m_pGrabberwin = new GrabberWin( this, this, size_factor, _T("grabber_hi") );
<br>    m_pGrabberwin->Show();
<br>    
<br>    m_pRecoverwin = NULL;
<br>    m_position = position;
<br>    m_orient = orient;
<br>    m_sizefactor = size_factor;
<br>    
<br>    m_bAutoHideToolbar = false;
<br>    m_nAutoHideToolbar = 5;
<br>    
<br>
<br>    m_style = g_StyleManager->GetCurrentStyle();
<br>
<br>// A top-level sizer
<br>    m_topSizer = new wxBoxSizer( wxHORIZONTAL );
<br>    SetSizer( m_topSizer );
<br>
<br>    //    Set initial "Dock" parameters
<br>    m_dock_x = 0;
<br>    m_dock_y = 0;
<br>    m_block = false;
<br>
<br>    m_marginsInvisible = m_style->marginsInvisible;
<br>
<br>//    if(m_sizefactor > 1.0 )
<br> //       m_marginsInvisible = true;
<br>
<br>    m_bnavgrabber = false;    
<br>    
<br>    Hide();
<br>
<br>    m_bsubmerged = false;
<br>    
<br>    m_fade_timer.SetOwner( this, FADE_TIMER );
<br>    if( g_bTransparentToolbar )
<br>        m_fade_timer.Start( 5000 );
<br>    
<br>    if( m_bAutoHideToolbar && (m_nAutoHideToolbar > 0))
<br>        m_fade_timer.Start( m_nAutoHideToolbar * 1000 );
<br>    
<br>    m_destroyTimer.SetOwner( this, DESTROY_TIMER );
<br>}
<br>
<br>ocpnFloatingToolbarDialog::~ocpnFloatingToolbarDialog()
<br>{
<br>    DestroyToolBar();
<br>}
<br>
<br>void ocpnFloatingToolbarDialog::OnWindowCreate( wxWindowCreateEvent& event )
<br>{
<br>    Realize();
<br>}
<br>
<br>void ocpnFloatingToolbarDialog::SetGrabber( wxString icon_name )
<br>{
<br>//    m_pGrabberwin->Destroy();
<br>    m_pGrabberwin = new GrabberWin( this, this, m_sizefactor, icon_name );
<br>    m_pGrabberwin->Show();
<br>    
<br>    Realize();
<br>    
<br>#ifdef __WXOSX__    
<br>    m_pGrabberwin->Refresh();
<br>#endif    
<br>    
<br>}
<br>
<br>
<br>    
<br>void ocpnFloatingToolbarDialog::SetColorScheme( ColorScheme cs )
<br>{
<br>    m_cs = cs;
<br>
<br>    wxColour back_color = GetGlobalColor( _T("GREY2") );
<br>
<br>    //  Set background
<br>    SetBackgroundColour( back_color );
<br>    ClearBackground();
<br>
<br>    if( m_ptoolbar ) {
<br>        wxColour back_color = GetGlobalColor( _T("GREY2") );
<br>
<br>        //  Set background
<br>        m_ptoolbar->SetBackgroundColour( back_color );
<br>        m_ptoolbar->ClearBackground();
<br>
<br>        m_ptoolbar->SetToggledBackgroundColour( GetGlobalColor( _T("GREY1") ) );
<br>
<br>        m_ptoolbar->SetColorScheme( cs );
<br>        m_ptoolbar->Refresh( true );
<br>    }
<br>
<br>    if( m_pGrabberwin ) m_pGrabberwin->SetColorScheme( cs );
<br>
<br>}
<br>
<br>void ocpnFloatingToolbarDialog::SetGeometry(bool bAvoid, wxRect rectAvoid)
<br>{
<br>
<br>    if( m_ptoolbar ) {
<br>        wxSize style_tool_size = m_style->GetToolSize();
<br>
<br>        style_tool_size.x *= m_sizefactor;
<br>        style_tool_size.y *= m_sizefactor;
<br>
<br>        m_ptoolbar->SetToolBitmapSize( style_tool_size );
<br>
<br>        wxSize tool_size = m_ptoolbar->GetToolBitmapSize();
<br>        int grabber_width =  m_style->GetIcon( _T("grabber") ).GetWidth();
<br>        
<br>        int max_rows = 10;
<br>        int max_cols = 100;
<br>        if(cc1){
<br>
<br>            int avoid_start = cc1->GetClientSize().x - (tool_size.x + m_style->GetToolSeparation()) * 2;  // default
<br>            if(bAvoid && !rectAvoid.IsEmpty()){
<br>                avoid_start = cc1->GetClientSize().x - rectAvoid.width - 10;  // this is compass window, if shown
<br>            }
<br>            
<br>            
<br>            max_rows = (cc1->GetClientSize().y / ( tool_size.y + m_style->GetToolSeparation())) - 1;
<br>            
<br>            max_cols = (avoid_start - grabber_width) / ( tool_size.x + m_style->GetToolSeparation());
<br>            max_cols -= 1;
<br>            
<br>            if(m_orient == wxTB_VERTICAL)
<br>                max_rows = wxMax( max_rows, 2);             // at least two rows
<br>            else
<br>                max_cols = wxMax( max_cols, 2);             // at least two columns
<br>        }
<br>
<br>        if( m_orient == wxTB_VERTICAL )
<br>            m_ptoolbar->SetMaxRowsCols(max_rows, 100);
<br>        else
<br>            m_ptoolbar->SetMaxRowsCols( 100, max_cols);
<br>        m_ptoolbar->SetSizeFactor(m_sizefactor);
<br>        
<br>    }
<br> }
<br>
<br>void ocpnFloatingToolbarDialog::RePosition()
<br>{
<br>    if(m_block) return;
<br>
<br>    if( m_pparent && m_ptoolbar ) {
<br>        wxSize cs = m_pparent->GetClientSize();
<br>        if( -1 == m_dock_x ) m_position.x = 0;
<br>        else
<br>            if( 1 == m_dock_x ) m_position.x = cs.x - GetSize().x;
<br>
<br>        if( -1 == m_dock_y ) m_position.y = 0;
<br>        else
<br>            if( 1 == m_dock_y ) m_position.y = cs.y - GetSize().y;
<br>
<br>        m_position.x = wxMin(cs.x - GetSize().x, m_position.x);
<br>        m_position.y = wxMin(cs.y - GetSize().y, m_position.y);
<br>
<br>        m_position.x = wxMax(0, m_position.x);
<br>        m_position.y = wxMax(0, m_position.y);
<br>
<br>        wxPoint screen_pos = m_pparent->ClientToScreen( m_position );
<br>
<br>        Move( screen_pos );
<br>
<br>#ifdef __WXQT__
<br>        Raise();
<br>#endif
<br>
<br>    }
<br>}
<br>
<br>void ocpnFloatingToolbarDialog::Submerge()
<br>{
<br>    m_bsubmerged = true;
<br>    Hide();
<br>    if( m_ptoolbar ) m_ptoolbar->KillTooltip();
<br>}
<br>
<br>void ocpnFloatingToolbarDialog::SubmergeToGrabber()
<br>{
<br>//Submerge();
<br>    m_bsubmerged = true;
<br>    Hide();
<br>    if( m_ptoolbar ) m_ptoolbar->KillTooltip();
<br>
<br>    m_pRecoverwin = new GrabberWin( m_pparent, this, m_sizefactor, _T("grabber_ext" ), wxPoint(10,10) );
<br>   
<br>    m_pRecoverwin->Show();
<br>    m_pRecoverwin->Raise();
<br>#ifdef __WXQT__
<br>    wxSize s = gFrame->GetSize();
<br>    m_recoversize = s;
<br>    s.y--;
<br>    gFrame->TriggerResize(s);
<br>    Raise();
<br>#endif    
<br>
<br>    gFrame->Refresh();          // Needed for MSW OpenGL
<br>}
<br>
<br>void ocpnFloatingToolbarDialog::Surface()
<br>{
<br>    
<br>    if(m_pRecoverwin){
<br>        m_pRecoverwin->Show();
<br>        m_pRecoverwin->Raise();
<br>    }
<br>    else {
<br>        m_bsubmerged = false;
<br>        #ifndef __WXOSX__
<br>        Hide();
<br>        Move( 0, 0 );
<br>        #endif
<br>
<br>        RePosition();
<br>        Show();
<br>        if( m_ptoolbar )
<br>            m_ptoolbar->EnableTooltips();
<br>
<br>        #ifdef __WXQT__
<br>        Raise();
<br>        #endif
<br>    }
<br>    
<br>    if( m_bAutoHideToolbar && (m_nAutoHideToolbar > 0) ){
<br>        m_fade_timer.Start( m_nAutoHideToolbar * 1000 );
<br>    }
<br>}
<br>
<br>bool ocpnFloatingToolbarDialog::CheckSurfaceRequest( wxMouseEvent &event )
<br>{
<br>    if( m_bsubmerged ){
<br>        if( event.LeftUp() ){
<br>            int x,y;
<br>            event.GetPosition( &x, &y );
<br>            if( m_pRecoverwin ){
<br>                wxRect winRect = m_pRecoverwin->GetRect();
<br>                if( winRect.Contains( x, y ) ){
<br>                    SurfaceFromGrabber();
<br>                    return true;
<br>                }
<br>            }
<br>        }
<br>    }
<br>    
<br>    return false;
<br>}
<br>        
<br>void ocpnFloatingToolbarDialog::SurfaceFromGrabber()
<br>{
<br>    m_bsubmerged = false;
<br>    
<br>#ifndef __WXOSX__
<br>    Hide();
<br>    Move( 0, 0 );
<br>#endif
<br>
<br>    if( m_ptoolbar )
<br>        m_ptoolbar->InvalidateBitmaps();
<br>    
<br>    RePosition();
<br>    Show();
<br>    if( m_ptoolbar )
<br>        m_ptoolbar->EnableTooltips();
<br>    
<br>    if( m_bAutoHideToolbar && (m_nAutoHideToolbar > 0) ){
<br>        m_fade_timer.Start( m_nAutoHideToolbar * 1000 );
<br>    }
<br>    
<br>#ifdef __WXQT__
<br>    wxSize s = gFrame->GetSize();               // check for rotation
<br>    if(m_recoversize.x == s.x)
<br>        gFrame->TriggerResize(m_recoversize);
<br>    Raise();
<br>#endif
<br>    
<br>    m_destroyGrabber = m_pRecoverwin;
<br>    m_destroyTimer.Start( 5, wxTIMER_ONE_SHOT );           //  Destor the unneeded recovery grabber
<br>    
<br>}
<br>
<br>void ocpnFloatingToolbarDialog::DestroyTimerEvent( wxTimerEvent& event )
<br>{
<br>    delete m_destroyGrabber;
<br>    m_destroyGrabber = NULL;
<br>    m_pRecoverwin = NULL;
<br>}
<br>
<br>void ocpnFloatingToolbarDialog::HideTooltip()
<br>{
<br>    if( m_ptoolbar ) m_ptoolbar->HideTooltip();
<br>}
<br>
<br>void ocpnFloatingToolbarDialog::ShowTooltips()
<br>{
<br>    if( m_ptoolbar ) m_ptoolbar->EnableTooltips();
<br>}
<br>
<br>void ocpnFloatingToolbarDialog::ToggleOrientation()
<br>{
<br>    if( m_orient == wxTB_HORIZONTAL )
<br>        m_orient = wxTB_VERTICAL;
<br>    else
<br>        m_orient = wxTB_HORIZONTAL;
<br>
<br>    m_style->SetOrientation( m_orient );
<br>
<br>    wxPoint old_screen_pos = m_pparent->ClientToScreen( m_position );
<br>    wxPoint grabber_point_abs = ClientToScreen( m_pGrabberwin->GetPosition() );
<br>
<br>    gFrame->RequestNewToolbar();
<br>    wxPoint pos_abs = grabber_point_abs;
<br>    pos_abs.x -= m_pGrabberwin->GetPosition().x;
<br>    MoveDialogInScreenCoords( pos_abs, old_screen_pos );
<br>
<br>
<br>    Show();   // this seems to be necessary on GTK to kick the sizer into gear...(FS#553)
<br>    Refresh(true);
<br>    Raise();
<br>}
<br>
<br>void ocpnFloatingToolbarDialog::MouseEvent( wxMouseEvent& event )
<br>{
<br>    if( g_bTransparentToolbar ) {
<br>        if( event.Entering() && ( m_opacity < 255 ) ) {
<br>            SetTransparent( 255 );
<br>            m_opacity = 255;
<br>        }
<br>
<br>        m_fade_timer.Start( 5000 );           // retrigger the continuous timer
<br>    }
<br>    
<br>    if(m_bAutoHideToolbar && (m_nAutoHideToolbar > 0) ){
<br>        m_fade_timer.Start( m_nAutoHideToolbar * 1000 );
<br>    }
<br>}
<br>
<br>void ocpnFloatingToolbarDialog::FadeTimerEvent( wxTimerEvent& event )
<br>{
<br>    if(m_bnavgrabber){
<br>        m_fade_timer.Start( 5000 );           // do nothing if nav grabber is shown
<br>    }
<br>    else{
<br>        if( g_bTransparentToolbar && (!g_bopengl || g_bTransparentToolbarInOpenGLOK) ){
<br>            DoFade( 128 );
<br>            m_fade_timer.Start( 5000 );           // retrigger the continuous timer
<br>        }
<br>        
<br>        if(m_bAutoHideToolbar && (m_nAutoHideToolbar > 0) && !m_bsubmerged){
<br>            SubmergeToGrabber();
<br>//            m_fade_timer.Stop();
<br>        }
<br>    }
<br>}
<br>
<br>void ocpnFloatingToolbarDialog::SetAutoHideTimer(int time)
<br>{
<br>    m_nAutoHideToolbar = time;
<br>    if(m_bAutoHideToolbar){
<br>        m_fade_timer.Stop();
<br>        m_fade_timer.Start( m_nAutoHideToolbar * 1000 );
<br>    }
<br>}
<br>        
<br>void ocpnFloatingToolbarDialog::DoFade( int value )
<br>{
<br>    if( value != m_opacity ) SetTransparent( value );
<br>    m_opacity = value;
<br>}
<br>
<br>void ocpnFloatingToolbarDialog::RefreshFadeTimer()
<br>{
<br>    SetTransparent( 255 );
<br>    m_opacity = 255;
<br>    m_fade_timer.Start( 500 );           // retrigger the continuous timer
<br>    
<br>    if(m_bAutoHideToolbar && (m_nAutoHideToolbar > 0) ){
<br>        m_fade_timer.Start( m_nAutoHideToolbar * 1000 );
<br>    }
<br>    
<br>}
<br>
<br>void ocpnFloatingToolbarDialog::MoveDialogInScreenCoords( wxPoint posn, wxPoint posn_old )
<br>{
<br>    wxPoint pos_in_parent = m_pparent->ScreenToClient( posn );
<br>    wxPoint pos_in_parent_old = m_pparent->ScreenToClient( posn_old );
<br>
<br>    //    "Docking" support
<br>#define DOCK_MARGIN 40
<br>
<br>    // X
<br>    m_dock_x = 0;
<br>    if( pos_in_parent.x < pos_in_parent_old.x )            // moving left
<br>            {
<br>        if( pos_in_parent.x < DOCK_MARGIN ) {
<br>            pos_in_parent.x = 0;
<br>            m_dock_x = -1;
<br>        }
<br>    } else
<br>        if( pos_in_parent.x > pos_in_parent_old.x )            // moving right
<br>                {
<br>            int max_right = m_pparent->GetClientSize().x - GetSize().x;
<br>            if( pos_in_parent.x > ( max_right - DOCK_MARGIN ) ) {
<br>                pos_in_parent.x = max_right;
<br>                m_dock_x = 1;
<br>            }
<br>        }
<br>
<br>    // Y
<br>    m_dock_y = 0;
<br>    if( pos_in_parent.y < pos_in_parent_old.y )            // moving up
<br>            {
<br>        if( pos_in_parent.y < DOCK_MARGIN ) {
<br>            pos_in_parent.y = 0;
<br>            m_dock_y = -1;
<br>        }
<br>    } else
<br>        if( pos_in_parent.y > pos_in_parent_old.y )            // moving down
<br>                {
<br>            int max_down = m_pparent->GetClientSize().y - GetSize().y;
<br>            if( pos_in_parent.y > ( max_down - DOCK_MARGIN ) ) {
<br>                pos_in_parent.y = max_down;
<br>                m_dock_y = 1;
<br>            }
<br>        }
<br>
<br>    m_position = pos_in_parent;
<br>
<br>    wxPoint final_pos = m_pparent->ClientToScreen( pos_in_parent );
<br>
<br>    Move( final_pos );
<br>}
<br>
<br>void ocpnFloatingToolbarDialog::Realize()
<br>{
<br>    if( m_ptoolbar ) {
<br>        m_ptoolbar->Realize();
<br>
<br>        m_topSizer->Clear();
<br>        m_topSizer->Add( m_ptoolbar );
<br>        m_topSizer->Add( m_pGrabberwin, 0, wxTOP, m_style->GetTopMargin() );
<br>
<br>        m_topSizer->Layout();
<br>        Fit();
<br>
<br>        //    Update "Dock" parameters
<br>        if( m_position.x == 0 ) m_dock_x = -1;
<br>        else
<br>            if( m_position.x == m_pparent->GetClientSize().x - GetSize().x ) m_dock_x = 1;
<br>
<br>        if( m_position.y == 0 ) m_dock_y = -1;
<br>        else
<br>            if( m_position.y == m_pparent->GetClientSize().y - GetSize().y ) m_dock_y = 1;
<br>
<br>        // Now create a bitmap mask forthe frame shape.
<br>
<br>        if( m_marginsInvisible ) {
<br>
<br>            wxSize tool_size = m_ptoolbar->GetToolBitmapSize();
<br>
<br>            //  Determine whether the tool icons are meant (by style) to join without speces between
<br>            //  This will determine what type of region to draw.
<br>            bool b_overlap = false;
<br>
<br>            wxToolBarToolsList::compatibility_iterator node1 = m_ptoolbar->m_tools.GetFirst();
<br>            wxToolBarToolsList::compatibility_iterator node2 = node1->GetNext() ;
<br>
<br>            wxToolBarToolBase *tool1 = node1->GetData();
<br>            ocpnToolBarTool *tools1 = (ocpnToolBarTool *) tool1;
<br>
<br>            wxToolBarToolBase *tool2 = node2->GetData();
<br>            ocpnToolBarTool *tools2 = (ocpnToolBarTool *) tool2;
<br>
<br>            if( (tools1->m_x + tools1->m_width) >= tools2->m_x)
<br>                b_overlap = true;
<br>
<br>
<br>
<br>
<br>            int toolCount = m_ptoolbar->GetVisibleToolCount();
<br>
<br>            wxPoint upperLeft( m_style->GetLeftMargin(), m_style->GetTopMargin() );
<br>            wxSize visibleSize;
<br>            if( m_ptoolbar->IsVertical() ) {
<br>                int noTools = m_ptoolbar->GetMaxRows();
<br>                if( noTools > toolCount )
<br>                    noTools = toolCount;
<br>                visibleSize.x = m_ptoolbar->GetLineCount() * ( tool_size.x + m_style->GetTopMargin() );
<br>                visibleSize.y = noTools * ( tool_size.y + m_style->GetToolSeparation() );
<br>                visibleSize.x -= m_style->GetTopMargin();
<br>                visibleSize.y -= m_style->GetToolSeparation();
<br>            } else {
<br>                    int noTools = m_ptoolbar->GetMaxCols();
<br>                    if( noTools > toolCount )
<br>                        noTools = toolCount;
<br>                visibleSize.x = noTools * ( tool_size.x + m_style->GetToolSeparation() );
<br>                visibleSize.y = m_ptoolbar->GetLineCount() * ( tool_size.y + m_style->GetTopMargin() );
<br>                visibleSize.x -= m_style->GetToolSeparation();
<br>                visibleSize.y -= m_style->GetTopMargin();
<br>            }
<br>
<br>            wxBitmap shape( visibleSize.x + tool_size.x, visibleSize.y + tool_size.y);          // + fluff
<br>            wxMemoryDC sdc( shape );
<br>            sdc.SetBackground( *wxWHITE_BRUSH );
<br>            sdc.SetBrush( *wxBLACK_BRUSH );
<br>            sdc.SetPen( *wxBLACK_PEN );
<br>            sdc.Clear();
<br>
<br>            if(b_overlap) {
<br>                int lines = m_ptoolbar->GetLineCount();
<br>                for( int i = 1; i <= lines; i++ ) {
<br>                    if( m_ptoolbar->IsVertical() ) {
<br>                        wxSize barsize( tool_size.x, visibleSize.y );
<br>                        if( i == lines && i > 1 ) {
<br>                            int toolsInLastLine = toolCount % m_ptoolbar->GetMaxRows();
<br>                            if( toolsInLastLine == 0 ) toolsInLastLine = m_ptoolbar->GetMaxRows();
<br>                            int emptySpace = ( m_ptoolbar->GetMaxRows() - toolsInLastLine );
<br>                            barsize.y -= emptySpace
<br>                            * ( tool_size.y + m_style->GetToolSeparation() );
<br>                        }
<br>                        if( i == lines ) {
<br>                            // Also do grabber here, since it is to the right of the last line.
<br>                            wxRect grabMask( upperLeft, barsize );
<br>                            grabMask.width += m_style->GetIcon( _T("grabber") ).GetWidth();
<br>                            grabMask.height = m_style->GetIcon( _T("grabber") ).GetHeight();
<br>                            sdc.DrawRoundedRectangle( grabMask, m_style->GetToolbarCornerRadius() );
<br>                        }
<br>                        sdc.DrawRoundedRectangle( upperLeft, barsize,
<br>                                m_style->GetToolbarCornerRadius() );
<br>                        upperLeft.x += m_style->GetTopMargin() + tool_size.x;
<br>                    } else {
<br>                        wxSize barsize( visibleSize.x, tool_size.y );
<br>
<br>                        if( i == 1 ) {
<br>                            barsize.x += m_style->GetIcon( _T("grabber") ).GetWidth();
<br>                        }
<br>                        if( i == lines && i > 1 ) {
<br>                            int toolsInLastLine = toolCount % m_ptoolbar->GetMaxCols();
<br>                            if( toolsInLastLine == 0 ) toolsInLastLine = m_ptoolbar->GetMaxCols();
<br>                            int emptySpace = ( m_ptoolbar->GetMaxCols() - toolsInLastLine );
<br>                            barsize.x -= emptySpace * ( tool_size.x + m_style->GetToolSeparation() );
<br>                        }
<br>
<br>                        sdc.DrawRoundedRectangle( upperLeft, barsize,
<br>                                m_style->GetToolbarCornerRadius() );
<br>                        upperLeft.y += m_style->GetTopMargin() + tool_size.y;
<br>                    }
<br>                }
<br>            } //b_overlap
<br>            else {
<br>                for( wxToolBarToolsList::compatibility_iterator node = m_ptoolbar->m_tools.GetFirst(); node; node = node->GetNext() ) {
<br>                    wxToolBarToolBase *tool = node->GetData();
<br>                    ocpnToolBarTool *tools = (ocpnToolBarTool *) tool;
<br>                    wxRect toolRect = tools->trect;
<br>
<br>                    sdc.DrawRoundedRectangle( tools->m_x, tools->m_y, tool_size.x, tool_size.y,
<br>                                              m_style->GetToolbarCornerRadius() );
<br>                }
<br>            }
<br>
<br>#ifndef __OCPN__ANDROID__
<br>            if(shape.GetWidth() && shape.GetHeight())
<br>                SetShape( wxRegion( shape, *wxWHITE, 10 ) );
<br>#endif
<br>        }
<br>    }
<br>}
<br>
<br>void ocpnFloatingToolbarDialog::OnToolLeftClick( wxCommandEvent& event )
<br>{
<br>    // First see if it was actually the context menu that was clicked.
<br>
<br>    if( event.GetId() >= ID_PLUGIN_BASE + 100 ) {
<br>
<br>        int itemId = event.GetId() - ID_PLUGIN_BASE - 100;
<br>        wxMenuItem *item = g_FloatingToolbarConfigMenu->FindItem( event.GetId() );
<br>
<br>        if(item){
<br>            bool toolIsChecked = item->IsChecked();
<br>
<br>            if( toolIsChecked ) {
<br>                g_toolbarConfig.SetChar( itemId, _T('X') );
<br>            } else {
<br>
<br>                if( itemId + ID_ZOOMIN == ID_MOB ) {
<br>                    ToolbarMOBDialog mdlg( this );
<br>                    int dialog_ret = mdlg.ShowModal();
<br>                    int answer = mdlg.GetSelection();
<br>
<br>                    if( answer == 0 || answer == 1 || dialog_ret == wxID_CANCEL ) {
<br>                        g_FloatingToolbarConfigMenu->FindItem( event.GetId() )->Check( true );
<br>                        if( answer == 1 && dialog_ret == wxID_OK ) {
<br>                            g_bPermanentMOBIcon = true;
<br>                            delete g_FloatingToolbarConfigMenu;
<br>                            g_FloatingToolbarConfigMenu = new wxMenu();
<br>                            toolbarConfigChanged = true;
<br>                        }
<br>                        return;
<br>                    }
<br>                }
<br>
<br>                if( m_ptoolbar->GetVisibleToolCount() == 1 ) {
<br>                    OCPNMessageBox( this,
<br>                            _("You can't hide the last tool from the toolbar\nas this would make it inaccessible."),
<br>                            _("OpenCPN Alert"), wxOK );
<br>                    g_FloatingToolbarConfigMenu->FindItem( event.GetId() )->Check( true );
<br>                    return;
<br>                }
<br>
<br>                g_toolbarConfig.SetChar( itemId, _T('.') );
<br>            }
<br>        }
<br>
<br>        toolbarConfigChanged = true;
<br>        return;
<br>    }
<br>
<br>    // No it was a button that was clicked.
<br>    // Since Dialog events don't propagate automatically, we send it explicitly
<br>    // (instead of relying on event.Skip()). Send events up the window hierarchy
<br>
<br>    m_pparent->GetEventHandler()->AddPendingEvent( event );
<br>#ifndef __WXQT__
<br>    gFrame->Raise();
<br>#endif    
<br>}
<br>
<br>ocpnToolBarSimple *ocpnFloatingToolbarDialog::GetToolbar()
<br>{
<br>    if( !m_ptoolbar ) {
<br>        long winstyle = wxNO_BORDER | wxTB_FLAT;
<br>        winstyle |= m_orient;
<br>
<br>        m_ptoolbar = new ocpnToolBarSimple( this, -1, wxPoint( -1, -1 ), wxSize( -1, -1 ),
<br>                winstyle );
<br>
<br>        m_ptoolbar->SetBackgroundColour( GetGlobalColor( _T("GREY2") ) );
<br>        m_ptoolbar->ClearBackground();
<br>        m_ptoolbar->SetToggledBackgroundColour( GetGlobalColor( _T("GREY1") ) );
<br>        m_ptoolbar->SetColorScheme( m_cs );
<br>
<br>        SetGeometry(false, wxRect());
<br>    }
<br>
<br>    return m_ptoolbar;
<br>}
<br>
<br>void ocpnFloatingToolbarDialog::DestroyToolBar()
<br>{
<br>    if( m_ptoolbar ) {
<br>        m_ptoolbar->ClearTools();
<br>        delete m_ptoolbar;                  //->Destroy();
<br>        m_ptoolbar = NULL;
<br>    }
<br> 
<br>    m_destroyGrabber = m_pRecoverwin;
<br>    m_destroyTimer.Start( 5, wxTIMER_ONE_SHOT );           //  Destor the unneeded recovery grabber
<br>    
<br>}
<br>
<br>//----------------------------------------------------------------------------
<br>// Toolbar Tooltip Popup Window Definition
<br>//----------------------------------------------------------------------------
<br>class ToolTipWin: public wxDialog {
<br>public:
<br>    ToolTipWin( wxWindow *parent );
<br>    ~ToolTipWin();
<br>
<br>    void OnPaint( wxPaintEvent& event );
<br>
<br>    void SetColorScheme( ColorScheme cs );
<br>    void SetString( wxString &s )
<br>    {
<br>        m_string = s;
<br>    }
<br>    void SetPosition( wxPoint pt )
<br>    {
<br>        m_position = pt;
<br>    }
<br>    void SetBitmap( void );
<br>
<br>    void SetHiviz( bool hiviz){ m_hiviz = hiviz; }
<br>    
<br>    wxSize GetRenderedSize( void );
<br>    
<br>private:
<br>
<br>    wxString m_string;
<br>    wxSize m_size;
<br>    wxPoint m_position;
<br>    wxBitmap *m_pbm;
<br>    wxColour m_back_color;
<br>    wxColour m_text_color;
<br>    ColorScheme m_cs ;
<br>    bool m_hiviz;
<br>
<br>DECLARE_EVENT_TABLE()
<br>};
<br>//-----------------------------------------------------------------------
<br>//
<br>//    Toolbar Tooltip window implementation
<br>//
<br>//-----------------------------------------------------------------------
<br>BEGIN_EVENT_TABLE(ToolTipWin, wxDialog) EVT_PAINT(ToolTipWin::OnPaint)
<br>
<br>END_EVENT_TABLE()
<br>
<br>// Define a constructor
<br>ToolTipWin::ToolTipWin( wxWindow *parent ) :
<br>        wxDialog( parent, wxID_ANY, _T(""), wxPoint( 0, 0 ), wxSize( 1, 1 ),
<br>                wxNO_BORDER | wxSTAY_ON_TOP )
<br>{
<br>    m_pbm = NULL;
<br>
<br>    m_back_color = GetGlobalColor( _T ( "UIBCK" ) );
<br>    m_text_color = GetGlobalColor( _T ( "UITX1" ) );
<br>
<br>    SetBackgroundStyle( wxBG_STYLE_CUSTOM );
<br>    SetBackgroundColour( m_back_color );
<br>    m_cs = GLOBAL_COLOR_SCHEME_RGB;
<br>
<br>    Hide();
<br>}
<br>
<br>ToolTipWin::~ToolTipWin()
<br>{
<br>    delete m_pbm;
<br>}
<br>
<br>void ToolTipWin::SetColorScheme( ColorScheme cs )
<br>{
<br>    m_back_color = GetGlobalColor( _T ( "UIBCK" ) );
<br>    m_text_color = FontMgr::Get().GetFontColor( _("ToolTips") );
<br>
<br>    m_cs = cs;
<br>}
<br>
<br>wxSize ToolTipWin::GetRenderedSize( void )
<br>{
<br>    int h, w;
<br>    wxSize sz;
<br>
<br>    wxClientDC cdc( GetParent() );
<br>
<br>    wxFont *plabelFont = FontMgr::Get().GetFont( _("ToolTips") );
<br>    cdc.GetTextExtent( m_string, &w, &h, NULL, NULL, plabelFont );
<br>
<br>    sz.x = w + 8;
<br>    sz.y = h + 4;
<br>    
<br>    return sz;
<br>
<br>}
<br>
<br>void ToolTipWin::SetBitmap()
<br>{
<br>    int h, w;
<br>
<br>    wxClientDC cdc( GetParent() );
<br>
<br>    wxFont *plabelFont = FontMgr::Get().GetFont( _("ToolTips") );
<br>    cdc.GetTextExtent( m_string, &w, &h, NULL, NULL, plabelFont );
<br>
<br>    m_size.x = w + 8;
<br>    m_size.y = h + 4;
<br>
<br>    wxMemoryDC mdc;
<br>
<br>    delete m_pbm;
<br>    m_pbm = new wxBitmap( m_size.x, m_size.y, -1 );
<br>    mdc.SelectObject( *m_pbm );
<br>
<br>    wxPen pborder( m_text_color );
<br>    wxBrush bback( m_back_color );
<br>    mdc.SetPen( pborder );
<br>    mdc.SetBrush( bback );
<br>
<br>    if(m_hiviz){
<br>        if((m_cs == GLOBAL_COLOR_SCHEME_DUSK) || (m_cs == GLOBAL_COLOR_SCHEME_NIGHT)){
<br>            wxBrush hv_back( wxColour(200,200,200));
<br>            mdc.SetBrush( hv_back );
<br>        }
<br>    }
<br>    mdc.DrawRectangle( 0, 0, m_size.x, m_size.y );
<br>
<br>    //    Draw the text
<br>    mdc.SetFont( *plabelFont );
<br>    mdc.SetTextForeground( m_text_color );
<br>    mdc.SetTextBackground( m_back_color );
<br>
<br>    mdc.DrawText( m_string, 4, 2 );
<br>
<br>    SetSize( m_position.x, m_position.y, m_size.x, m_size.y );
<br>
<br>}
<br>
<br>void ToolTipWin::OnPaint( wxPaintEvent& event )
<br>{
<br>    int width, height;
<br>    GetClientSize( &width, &height );
<br>    wxPaintDC dc( this );
<br>
<br>    if( m_string.Len() ) {
<br>        wxMemoryDC mdc;
<br>        mdc.SelectObject( *m_pbm );
<br>        dc.Blit( 0, 0, width, height, &mdc, 0, 0 );
<br>    }
<br>}
<br>
<br>
<br>// ----------------------------------------------------------------------------
<br>BEGIN_EVENT_TABLE(ocpnToolBarSimple, wxControl) EVT_SIZE(ocpnToolBarSimple::OnSize)
<br>EVT_PAINT(ocpnToolBarSimple::OnPaint)
<br>EVT_KILL_FOCUS(ocpnToolBarSimple::OnKillFocus)
<br>EVT_MOUSE_EVENTS(ocpnToolBarSimple::OnMouseEvent)
<br>EVT_TIMER(TOOLTIPON_TIMER, ocpnToolBarSimple::OnToolTipTimerEvent)
<br>EVT_TIMER(TOOLTIPOFF_TIMER, ocpnToolBarSimple::OnToolTipOffTimerEvent)
<br>
<br>END_EVENT_TABLE()
<br>
<br>// ============================================================================
<br>// implementation
<br>// ============================================================================
<br>
<br>// ----------------------------------------------------------------------------
<br>// tool bar tools creation
<br>// ----------------------------------------------------------------------------
<br>
<br>wxToolBarToolBase *ocpnToolBarSimple::CreateTool( int id, const wxString& label,
<br>        const wxBitmap& bmpNormal, const wxBitmap& bmpDisabled, wxItemKind kind,
<br>        wxObject *clientData, const wxString& shortHelp, const wxString& longHelp )
<br>{
<br>    return new ocpnToolBarTool( this, id, label, bmpNormal, bmpDisabled, kind, clientData,
<br>            shortHelp, longHelp );
<br>}
<br>
<br>// ----------------------------------------------------------------------------
<br>// ocpnToolBarSimple creation
<br>// ----------------------------------------------------------------------------
<br>
<br>void ocpnToolBarSimple::Init()
<br>{
<br>    m_currentRowsOrColumns = 0;
<br>
<br>    m_lastX = m_lastY = 0;
<br>
<br>    m_maxWidth = m_maxHeight = 0;
<br>
<br>    m_pressedTool = m_currentTool = -1;
<br>
<br>    m_xPos = m_yPos = wxDefaultCoord;
<br>
<br>    m_style = g_StyleManager->GetCurrentStyle();
<br>
<br>    m_defaultWidth = 16;
<br>    m_defaultHeight = 15;
<br>
<br>    m_toggle_bg_color = wxSystemSettings::GetColour( wxSYS_COLOUR_3DFACE );
<br>    m_toolOutlineColour.Set( _T("BLACK") );
<br>    m_pToolTipWin = NULL;
<br>    m_last_ro_tool = NULL;
<br>
<br>    m_btoolbar_is_zooming = false;
<br>    m_sizefactor = 1.0f;
<br>
<br>    m_last_plugin_down_id = -1;
<br>    
<br>    EnableTooltips();
<br>}
<br>
<br>wxToolBarToolBase *ocpnToolBarSimple::DoAddTool( int id, const wxString& label,
<br>        const wxBitmap& bitmap, const wxBitmap& bmpDisabled, wxItemKind kind,
<br>        const wxString& shortHelp, const wxString& longHelp, wxObject *clientData, wxCoord xPos,
<br>        wxCoord yPos )
<br>{
<br>    // rememeber the position for DoInsertTool()
<br>    m_xPos = xPos;
<br>    m_yPos = yPos;
<br>
<br>    InvalidateBestSize();
<br>    return InsertTool( GetToolsCount(), id, label, bitmap, bmpDisabled, kind, shortHelp, longHelp,
<br>            clientData );
<br>
<br>}
<br>
<br>///
<br>
<br>wxToolBarToolBase *ocpnToolBarSimple::AddTool( int toolid, const wxString& label,
<br>        const wxBitmap& bitmap, const wxBitmap& bmpDisabled, wxItemKind kind,
<br>        const wxString& shortHelp, const wxString& longHelp, wxObject *data )
<br>{
<br>    InvalidateBestSize();
<br>    ocpnToolBarTool* tool = (ocpnToolBarTool*)InsertTool( GetToolsCount(), toolid, label, bitmap, bmpDisabled, kind,
<br>            shortHelp, longHelp, data );
<br>    return tool;
<br>}
<br>
<br>wxToolBarToolBase *ocpnToolBarSimple::InsertTool( size_t pos, int id, const wxString& label,
<br>        const wxBitmap& bitmap, const wxBitmap& bmpDisabled, wxItemKind kind,
<br>        const wxString& shortHelp, const wxString& longHelp, wxObject *clientData )
<br>{
<br>    wxCHECK_MSG( pos <= GetToolsCount(), (wxToolBarToolBase *)NULL,
<br>            _T("invalid position in wxToolBar::InsertTool()") );
<br>
<br>    wxToolBarToolBase *tool = CreateTool( id, label, bitmap, bmpDisabled, kind, clientData,
<br>            shortHelp, longHelp );
<br>
<br>    if( !InsertTool( pos, tool ) ) {
<br>        delete tool;
<br>
<br>        return NULL;
<br>    }
<br>
<br>    return tool;
<br>}
<br>
<br>wxToolBarToolBase *ocpnToolBarSimple::InsertTool( size_t pos, wxToolBarToolBase *tool )
<br>{
<br>    wxCHECK_MSG( pos <= GetToolsCount(), (wxToolBarToolBase *)NULL,
<br>            _T("invalid position in wxToolBar::InsertTool()") );
<br>
<br>    if( !tool || !DoInsertTool( pos, tool ) ) {
<br>        return NULL;
<br>    }
<br>
<br>    m_tools.Insert( pos, tool );
<br>
<br>    return tool;
<br>}
<br>
<br>bool ocpnToolBarSimple::DoInsertTool( size_t WXUNUSED(pos), wxToolBarToolBase *toolBase )
<br>{
<br>    ocpnToolBarTool *tool = (ocpnToolBarTool *) toolBase;
<br>
<br>    // Check if the plugin is inserting same-named tools. Make sure they have different names,
<br>    // otherwise the style manager cannot differentiate between them.
<br>    if( tool->isPluginTool ) {
<br>        for( unsigned int i=0; i<GetToolsCount(); i++ ) {
<br>            if( tool->GetToolname() == ((ocpnToolBarTool *)m_tools.Item(i)->GetData())->GetToolname()) {
<br>                tool->toolname << _T("1");
<br>            }
<br>        }
<br>    }
<br>
<br>    tool->m_x = m_xPos;
<br>    if( tool->m_x == wxDefaultCoord ) tool->m_x = m_style->GetLeftMargin();
<br>
<br>    tool->m_y = m_yPos;
<br>    if( tool->m_y == wxDefaultCoord ) tool->m_y = m_style->GetTopMargin();
<br>
<br>    if( tool->IsButton() ) {
<br>        tool->SetSize( GetToolSize() );
<br>
<br>        // Calculate reasonable max size in case Layout() not called
<br>        if( ( tool->m_x + tool->GetNormalBitmap().GetWidth() + m_style->GetLeftMargin() )
<br>                > m_maxWidth ) m_maxWidth = (wxCoord) ( ( tool->m_x + tool->GetWidth()
<br>                + m_style->GetLeftMargin() ) );
<br>
<br>        if( ( tool->m_y + tool->GetNormalBitmap().GetHeight() + m_style->GetTopMargin() )
<br>                > m_maxHeight ) m_maxHeight = (wxCoord) ( ( tool->m_y + tool->GetHeight()
<br>                + m_style->GetTopMargin() ) );
<br>    }
<br>
<br>    else
<br>        if( tool->IsControl() ) {
<br>            tool->SetSize( tool->GetControl()->GetSize() );
<br>        }
<br>
<br>    tool->b_hilite = false;
<br>
<br>    return true;
<br>}
<br>
<br>bool ocpnToolBarSimple::DoDeleteTool( size_t WXUNUSED(pos), wxToolBarToolBase *tool )
<br>{
<br>    // VZ: didn't test whether it works, but why not...
<br>    tool->Detach();
<br>
<br>    if( m_last_ro_tool == tool ) m_last_ro_tool = NULL;
<br>
<br>    Refresh( false );
<br>
<br>    return true;
<br>}
<br>
<br>bool ocpnToolBarSimple::Create( wxWindow *parent, wxWindowID id, const wxPoint& pos,
<br>        const wxSize& size, long style, const wxString& name )
<br>{
<br>    if( !wxWindow::Create( parent, id, pos, size, style, name ) ) return false;
<br>
<br>    // Set it to grey (or other 3D face colour)
<br>    SetBackgroundColour( wxSystemSettings::GetColour( wxSYS_COLOUR_3DFACE ) );
<br>
<br>    if( GetWindowStyleFlag() & wxTB_VERTICAL ) {
<br>        m_lastX = 7;
<br>        m_lastY = 3;
<br>
<br>        m_maxRows = 32000;      // a lot
<br>        m_maxCols = 1;
<br>    } else {
<br>        m_lastX = 3;
<br>        m_lastY = 7;
<br>
<br>        m_maxRows = 1;
<br>        m_maxCols = 32000;      // a lot
<br>    }
<br>
<br>    SetCursor( *wxSTANDARD_CURSOR );
<br>
<br>    m_tooltip_timer.SetOwner( this, TOOLTIPON_TIMER );
<br>    m_tooltipoff_timer.SetOwner( this, TOOLTIPOFF_TIMER );
<br>    m_tooltip_off = 3000;
<br>
<br>    return true;
<br>}
<br>
<br>ocpnToolBarSimple::~ocpnToolBarSimple()
<br>{
<br>    if( m_pToolTipWin ) {
<br>        m_pToolTipWin->Destroy();
<br>        m_pToolTipWin = NULL;
<br>    }
<br>
<br>}
<br>
<br>void ocpnToolBarSimple::KillTooltip()
<br>{
<br>    m_btooltip_show = false;
<br>
<br>    if( m_pToolTipWin ) {
<br>        m_pToolTipWin->Hide();
<br>        m_pToolTipWin->Destroy();
<br>        m_pToolTipWin = NULL;
<br>    }
<br>    m_tooltip_timer.Stop();
<br>
<br>    if( m_last_ro_tool ) {
<br>        if( m_last_ro_tool->IsEnabled() ) {
<br>            if( m_last_ro_tool->IsToggled() ) {
<br>                m_last_ro_tool->SetNormalBitmap( m_style->GetToolIcon( m_last_ro_tool->GetToolname(), TOOLICON_TOGGLED ) );
<br>            }
<br>            else {
<br>                m_last_ro_tool->SetNormalBitmap( m_style->GetToolIcon( m_last_ro_tool->GetToolname(), TOOLICON_NORMAL ) );
<br>            }
<br>        }
<br>    }
<br>}
<br>
<br>void ocpnToolBarSimple::HideTooltip()
<br>{
<br>    if( m_pToolTipWin ) {
<br>        m_pToolTipWin->Hide();
<br>    }
<br>}
<br>
<br>void ocpnToolBarSimple::SetColorScheme( ColorScheme cs )
<br>{
<br>    if( m_pToolTipWin ) {
<br>        m_pToolTipWin->Destroy();
<br>        m_pToolTipWin = NULL;
<br>    }
<br>
<br>    m_toolOutlineColour = GetGlobalColor( _T("UIBDR") );
<br>
<br>    m_currentColorScheme = cs;
<br>}
<br>
<br>bool ocpnToolBarSimple::Realize()
<br>{
<br>    m_currentRowsOrColumns = 0;
<br>    m_LineCount = 1;
<br>    m_lastX = m_style->GetLeftMargin();
<br>    m_lastY = m_style->GetTopMargin();
<br>    m_maxWidth = 0;
<br>    m_maxHeight = 0;
<br>
<br>    if( IsVertical() ) m_style->SetOrientation( wxTB_VERTICAL );
<br>    else
<br>        m_style->SetOrientation( wxTB_HORIZONTAL );
<br>
<br>    wxSize toolSize = wxSize(-1, -1);
<br>    int separatorSize = m_style->GetToolSeparation();
<br>
<br>    ocpnToolBarTool *lastTool = NULL;
<br>    bool firstNode = true;
<br>    wxToolBarToolsList::compatibility_iterator node = m_tools.GetFirst();
<br>
<br>    while( node ) {
<br>        ocpnToolBarTool *tool = (ocpnToolBarTool *) node->GetData();
<br>
<br>        // Set the tool size to be the size of the first non-separator tool, usually the first one
<br>        if(toolSize.x == -1){
<br>            if( !tool->IsSeparator() ){
<br>                toolSize.x = tool->m_width;
<br>                toolSize.y = tool->m_height;
<br>            }
<br>        }
<br>
<br>        tool->firstInLine = firstNode;
<br>        tool->lastInLine = false;
<br>        firstNode = false;
<br>
<br>        tool->last_rect.width = 0;              // mark it invalid
<br>        
<br>        if( tool->IsSeparator() ) {
<br>            if( GetWindowStyleFlag() & wxTB_HORIZONTAL ) {
<br>                if( m_currentRowsOrColumns >= m_maxCols ) m_lastY += separatorSize;
<br>                else
<br>                    m_lastX += separatorSize;
<br>            } else {
<br>                if( m_currentRowsOrColumns >= m_maxRows ) m_lastX += separatorSize;
<br>                else
<br>                    m_lastY += separatorSize;
<br>            }
<br>        } else
<br>            if( tool->IsButton() ) {
<br>                if( !IsVertical() ) {
<br>                    if( m_currentRowsOrColumns >= m_maxCols ) {
<br>                        tool->firstInLine = true;
<br>                        if( lastTool && m_LineCount > 1 ) lastTool->lastInLine = true;
<br>                        m_LineCount++;
<br>                        m_currentRowsOrColumns = 0;
<br>                        m_lastX = m_style->GetLeftMargin();
<br>                        m_lastY += toolSize.y + m_style->GetTopMargin();
<br>                    }
<br>                    tool->m_x = (wxCoord) m_lastX;
<br>                    tool->m_y = (wxCoord) m_lastY;
<br>
<br>                    tool->trect = wxRect( tool->m_x, tool->m_y, toolSize.x, toolSize.y );
<br>                    tool->trect.Inflate( m_style->GetToolSeparation() / 2,
<br>                            m_style->GetTopMargin() );
<br>
<br>                    m_lastX += toolSize.x + m_style->GetToolSeparation();
<br>                } else {
<br>                    if( m_currentRowsOrColumns >= m_maxRows ) {
<br>                        tool->firstInLine = true;
<br>                        if( lastTool ) lastTool->lastInLine = true;
<br>                        m_LineCount++;
<br>                        m_currentRowsOrColumns = 0;
<br>                        m_lastX += toolSize.x + m_style->GetTopMargin();
<br>                        m_lastY = m_style->GetTopMargin();
<br>                    }
<br>                    tool->m_x = (wxCoord) m_lastX;
<br>                    tool->m_y = (wxCoord) m_lastY;
<br>
<br>                    tool->trect = wxRect( tool->m_x, tool->m_y, toolSize.x, toolSize.y );
<br>                    tool->trect.Inflate( m_style->GetToolSeparation() / 2,
<br>                            m_style->GetTopMargin() );
<br>
<br>                    m_lastY += toolSize.y + m_style->GetToolSeparation();
<br>                }
<br>                m_currentRowsOrColumns++;
<br>            } else
<br>                if( tool->IsControl() ) {
<br>                    tool->m_x = (wxCoord) ( m_lastX );
<br>                    tool->m_y = (wxCoord) ( m_lastY - ( m_style->GetTopMargin() / 2 ) );
<br>
<br>                    tool->trect = wxRect( tool->m_x, tool->m_y, tool->GetWidth(),
<br>                            tool->GetHeight() );
<br>                    tool->trect.Inflate( m_style->GetToolSeparation() / 2,
<br>                            m_style->GetTopMargin() );
<br>                    ;
<br>
<br>                    wxSize s = tool->GetControl()->GetSize();
<br>                    m_lastX += s.x + m_style->GetToolSeparation();
<br>
<br>                }
<br>
<br>        if( m_lastX > m_maxWidth ) m_maxWidth = m_lastX;
<br>        if( m_lastY > m_maxHeight ) m_maxHeight = m_lastY;
<br>
<br>        lastTool = tool;
<br>        node = node->GetNext();
<br>    }
<br>    if( lastTool && (m_LineCount > 1 || IsVertical()) )
<br>        lastTool->lastInLine = true;
<br>
<br>    if( GetWindowStyleFlag() & wxTB_HORIZONTAL ) m_maxHeight += toolSize.y;
<br>    else
<br>        m_maxWidth += toolSize.x;
<br>
<br>    m_maxWidth += m_style->GetRightMargin();
<br>    m_maxHeight += m_style->GetBottomMargin();
<br>
<br>    SetSize( m_maxWidth, m_maxHeight );
<br>    SetMinSize( wxSize( m_maxWidth, m_maxHeight ) );
<br>
<br>    return true;
<br>}
<br>
<br>// ----------------------------------------------------------------------------
<br>// event handlers
<br>// ----------------------------------------------------------------------------
<br>
<br>void ocpnToolBarSimple::OnPaint( wxPaintEvent& WXUNUSED(event) )
<br>{
<br>    wxPaintDC dc( this );
<br>    PrepareDC( dc );
<br>
<br>    wxRegion ru = GetUpdateRegion();
<br>    wxRect upRect = ru.GetBox();
<br>
<br>    static int count = 0;
<br>    // Prevent reentry of OnPaint which would cause wxMemoryDC errors.
<br>    if( count > 0 ) return;
<br>    count++;
<br>
<br>    for( wxToolBarToolsList::compatibility_iterator node = m_tools.GetFirst(); node;
<br>            node = node->GetNext() ) {
<br>        wxToolBarToolBase *tool = node->GetData();
<br>        ocpnToolBarTool *tools = (ocpnToolBarTool *) tool;
<br>        wxRect toolRect = tools->trect;
<br>
<br>        if( toolRect.Intersects( upRect ) ) {
<br>
<br>            if( tool->IsButton() ) {
<br>                DrawTool( dc, tool );
<br>            } else
<br>                if( tool->IsControl() ) {
<br>                    if( tool->GetControl()->IsKindOf( CLASSINFO(wxStaticBitmap) ) ) {
<br>                        wxStaticBitmap *psbm = (wxStaticBitmap *) tool->GetControl();
<br>                        ocpnToolBarTool *toolsimp = (ocpnToolBarTool *) tool;
<br>                        dc.DrawBitmap( psbm->GetBitmap(), toolsimp->m_x, toolsimp->m_y, false );
<br>                    }
<br>                }
<br>        }
<br>    }
<br>
<br>    count--;
<br>}
<br>
<br>void ocpnToolBarSimple::OnSize( wxSizeEvent& WXUNUSED(event) )
<br>{
<br>    if( GetAutoLayout() ) Layout();
<br>}
<br>
<br>void ocpnToolBarSimple::OnKillFocus( wxFocusEvent& WXUNUSED(event) )
<br>{
<br>    OnMouseEnter( m_pressedTool = m_currentTool = -1 );
<br>}
<br>
<br>void ocpnToolBarSimple::OnToolTipTimerEvent( wxTimerEvent& event )
<br>{
<br>    if( !gFrame->IsActive() ) return;
<br>
<br>    if( m_btooltip_show && IsShown() && m_pToolTipWin && ( !m_pToolTipWin->IsShown() ) ) {
<br>        if( m_last_ro_tool ) {
<br>            wxString s = m_last_ro_tool->GetShortHelp();
<br>
<br>            if( s.Len() ) {
<br>                m_pToolTipWin->SetString( s );
<br>                m_pToolTipWin->SetHiviz(m_last_ro_tool->m_btooltip_hiviz);
<br>
<br>                wxPoint pos_in_toolbar( m_last_ro_tool->m_x, m_last_ro_tool->m_y );
<br>                pos_in_toolbar.x += m_last_ro_tool->m_width + 2;
<br>
<br>                m_pToolTipWin->Move(0,0);       // workaround for gtk autocentre dialog behavior
<br>
<br>                wxPoint screenPosition = ClientToScreen( pos_in_toolbar );
<br>                wxPoint framePosition = gFrame->ScreenToClient(screenPosition);
<br>                wxSize tipSize = m_pToolTipWin->GetRenderedSize();
<br>                
<br>                if( (framePosition.x + tipSize.x) > gFrame->GetSize().x)
<br>                    screenPosition.x -= (tipSize.x + m_last_ro_tool->m_width + 4);
<br>                
<br>                m_pToolTipWin->SetPosition( screenPosition );
<br>                m_pToolTipWin->SetBitmap();
<br>                m_pToolTipWin->Show();
<br>                gFrame->Raise();
<br>                if( g_btouch )
<br>                    m_tooltipoff_timer.Start(m_tooltip_off, wxTIMER_ONE_SHOT);
<br>            }
<br>        }
<br>    }
<br>}
<br>
<br>void ocpnToolBarSimple::OnToolTipOffTimerEvent( wxTimerEvent& event )
<br>{
<br>    HideTooltip();
<br>}
<br>
<br>
<br>int s_dragx, s_dragy;
<br>
<br>void ocpnToolBarSimple::OnMouseEvent( wxMouseEvent & event )
<br>{
<br>#ifdef __OCPN__ANDROID__
<br>    if(!event.IsButton())
<br>        return;
<br>#endif
<br>
<br>    wxCoord x, y;
<br>    event.GetPosition( &x, &y );
<br>    ocpnToolBarTool *tool = (ocpnToolBarTool *) FindToolForPosition( x, y );
<br>
<br>#ifndef __OCPN__ANDROID__
<br>    if( event.LeftDown() ) {
<br>        CaptureMouse();
<br>        s_dragx = x;
<br>        s_dragy = y;
<br>    }
<br>    if( event.LeftUp() ) {
<br>        if( HasCapture() ) ReleaseMouse();
<br>    }
<br>#endif
<br>
<br>    if( tool && tool->IsButton() && IsShown() ) {
<br>
<br>        //    ToolTips
<br>        if( NULL == m_pToolTipWin ) {
<br>            m_pToolTipWin = new ToolTipWin( GetParent() );
<br>            m_pToolTipWin->SetColorScheme( m_currentColorScheme );
<br>            m_pToolTipWin->Hide();
<br>        }
<br>
<br>        if( tool != m_last_ro_tool ) m_pToolTipWin->Hide();
<br>
<br>#ifndef __OCPN__ANDROID__
<br>        if( !m_pToolTipWin->IsShown() ) {
<br>            m_tooltip_timer.Start( m_one_shot, wxTIMER_ONE_SHOT );
<br>        }
<br>#endif
<br>
<br>        //    Tool Rollover highlighting
<br>        if(!g_btouch){
<br>            if( tool != m_last_ro_tool ) {
<br>                if( tool->IsEnabled() ) {
<br>                    tool->rollover = true;
<br>                    tool->bitmapOK = false;
<br>                }
<br>                if( m_last_ro_tool ) {
<br>                    if( m_last_ro_tool->IsEnabled() ) {
<br>                        m_last_ro_tool->rollover = false;
<br>                        m_last_ro_tool->bitmapOK = false;
<br>                    }
<br>                }
<br>                m_last_ro_tool = tool;
<br>                if(g_toolbar)
<br>                    g_toolbar->Refresh( false );
<br>            }
<br>        }
<br>    } else {
<br>        //    Tooltips
<br>        if( m_pToolTipWin && m_pToolTipWin->IsShown() ) m_pToolTipWin->Hide();
<br>
<br>        //    Remove Highlighting
<br>        if( m_last_ro_tool ) {
<br>            if( m_last_ro_tool->IsEnabled() ) {
<br>                m_last_ro_tool->rollover = false;
<br>                m_last_ro_tool->bitmapOK = false;
<br>            }
<br>            g_toolbar->Refresh( false );
<br>        }
<br>    }
<br>
<br>    m_last_ro_tool = tool;
<br>
<br>    // allow smooth zooming while toolbutton is held down
<br>    if(g_bsmoothpanzoom && !g_btouch) {
<br>        if(event.LeftUp() && m_btoolbar_is_zooming) {
<br>            cc1->StopMovement();
<br>            m_btoolbar_is_zooming = false;
<br>            return;
<br>        }
<br>
<br>        if( event.LeftDown() && tool &&
<br>            (tool->GetId() == ID_ZOOMIN || tool->GetId() == ID_ZOOMOUT) ) {
<br>            cc1->ZoomCanvas( tool->GetId() == ID_ZOOMIN ? 2.0 : .5, false, false );
<br>            m_btoolbar_is_zooming = true;
<br>            return;
<br>        }
<br>    }
<br>
<br>    if( !tool ) {
<br>        if( m_currentTool > -1 ) {
<br>            if( event.LeftIsDown() ) SpringUpButton( m_currentTool );
<br>            m_currentTool = -1;
<br>            OnMouseEnter( -1 );
<br>        }
<br>
<br>        wxMouseEvent *pev = (wxMouseEvent *) event.Clone();
<br>        GetParent()->GetEventHandler()->AddPendingEvent( *pev );
<br>        wxDELETE( pev );
<br>
<br>        return;
<br>    }
<br>
<br>    if( !event.IsButton() ) {
<br>        if( tool->GetId() != m_currentTool ) {
<br>            // If the left button is kept down and moved over buttons,
<br>            // press those buttons.
<br>            if( event.LeftIsDown() && tool->IsEnabled() ) {
<br>                SpringUpButton( m_currentTool );
<br>
<br>                if( tool->CanBeToggled() ) {
<br>                    tool->Toggle();
<br>                }
<br>
<br>                DrawTool( tool );
<br>            }
<br>
<br>            m_currentTool = tool->GetId();
<br>            OnMouseEnter( m_currentTool );
<br>        }
<br>
<br>        wxMouseEvent *pev = (wxMouseEvent *) event.Clone();
<br>        GetParent()->GetEventHandler()->AddPendingEvent( *pev );
<br>        wxDELETE( pev );
<br>
<br>        return;
<br>    }
<br>
<br>    // Left button pressed.
<br>    if( event.LeftDown() && tool->IsEnabled() ) {
<br>        if( tool->CanBeToggled() ) {
<br>            tool->Toggle();
<br>            tool->bitmapOK = false;
<br>            
<br>        }
<br>
<br>        DrawTool( tool );
<br>
<br>        //        Look for PlugIn tools
<br>        //        If found, make the callback.
<br>        if( g_pi_manager ) {
<br>            ArrayOfPlugInToolbarTools tool_array = g_pi_manager->GetPluginToolbarToolArray();
<br>            for( unsigned int i = 0; i < tool_array.GetCount(); i++ ) {
<br>                PlugInToolbarToolContainer *pttc = tool_array.Item( i );
<br>                if( tool->GetId() == pttc->id ) {
<br>                    opencpn_plugin_113 *ppi = dynamic_cast<opencpn_plugin_113 *>(pttc->m_pplugin);
<br>                    if( ppi ) {
<br>                        ppi->OnToolbarToolDownCallback( pttc->id );
<br>                        m_last_plugin_down_id = pttc->id;
<br>                    }
<br>                }
<br>            }
<br>        }
<br>    } else
<br>        if( event.RightDown() ) {
<br>            OnRightClick( tool->GetId(), x, y );
<br>        }
<br>
<br>    // Left Button Released.  Only this action confirms selection.
<br>    // If the button is enabled and it is not a toggle tool and it is
<br>    // in the pressed state, then raise the button and call OnLeftClick.
<br>    //
<br>    if( event.LeftUp() && tool->IsEnabled() ) {
<br>        // Pass the OnLeftClick event to tool
<br>        if( !OnLeftClick( tool->GetId(), tool->IsToggled() ) && tool->CanBeToggled() ) {
<br>            // If it was a toggle, and OnLeftClick says No Toggle allowed,
<br>            // then change it back
<br>            tool->Toggle();
<br>            tool->bitmapOK = false;
<br>        }
<br>
<br>        DoPluginToolUp();
<br>    }
<br>
<br>    wxMouseEvent *pev = (wxMouseEvent *) event.Clone();
<br>    GetParent()->GetEventHandler()->AddPendingEvent( *pev );
<br>    wxDELETE( pev );
<br>    event.Skip();
<br>}
<br>
<br>// ----------------------------------------------------------------------------
<br>// drawing
<br>// ----------------------------------------------------------------------------
<br>
<br>void ocpnToolBarSimple::DrawTool( wxToolBarToolBase *tool )
<br>{
<br>    wxClientDC dc( this );
<br>    DrawTool( dc, tool );
<br>}
<br>
<br>// NB! The current DrawTool code assumes that plugin tools are never disabled
<br>// when they are present on the toolbar, since disabled plugins are removed.
<br>
<br>void ocpnToolBarSimple::DrawTool( wxDC& dc, wxToolBarToolBase *toolBase )
<br>{
<br>    ocpnToolBarTool *tool = (ocpnToolBarTool *) toolBase;
<br>    PrepareDC( dc );
<br>
<br>    wxPoint drawAt( tool->m_x, tool->m_y );
<br>    wxBitmap bmp;
<br>
<br>    if( tool->bitmapOK ) {
<br>        if( tool->IsEnabled() ) {
<br>            bmp = tool->GetNormalBitmap();
<br>            if( !bmp.IsOk() ){
<br>                bmp = m_style->GetToolIcon( tool->GetToolname(), TOOLICON_NORMAL, tool->rollover );
<br>                if(m_sizefactor > 1.0 ){
<br>                    wxImage scaled_image = bmp.ConvertToImage();
<br>                    bmp = wxBitmap(scaled_image.Scale(tool->m_width, tool->m_height, wxIMAGE_QUALITY_HIGH));
<br>                }
<br>                tool->SetNormalBitmap( bmp );
<br>                tool->bitmapOK = true;
<br>            }
<br>        } else {
<br>            bmp = tool->GetDisabledBitmap();
<br>            if( !bmp.IsOk() ){
<br>                bmp = m_style->GetToolIcon( tool->GetToolname(), TOOLICON_DISABLED );
<br>                if(m_sizefactor > 1.0 ){
<br>                    wxImage scaled_image = bmp.ConvertToImage();
<br>                    bmp = wxBitmap(scaled_image.Scale(tool->m_width, tool->m_height, wxIMAGE_QUALITY_HIGH));
<br>                }
<br>                tool->SetDisabledBitmap( bmp );
<br>                tool->bitmapOK = true;
<br>            }
<br>        }
<br>    } else {
<br>        if ( tool->isPluginTool ) {
<br>
<br>            // First try getting the icon from the Style.
<br>            // If it is not in the style we build a new icon from the style BG and the plugin icon.
<br>
<br>            if( tool->IsToggled() ) {
<br>                bmp = m_style->GetToolIcon( tool->GetToolname(), TOOLICON_TOGGLED, tool->rollover );
<br>                if( bmp.GetDepth() == 1 ) {
<br>                    if( tool->rollover ) {
<br>                        bmp = m_style->BuildPluginIcon( tool->pluginRolloverIcon, TOOLICON_TOGGLED );
<br>                        if( ! bmp.IsOk() )
<br>                            bmp = m_style->BuildPluginIcon( tool->pluginNormalIcon, TOOLICON_TOGGLED );
<br>                    }
<br>                    else
<br>                        bmp = m_style->BuildPluginIcon( tool->pluginNormalIcon, TOOLICON_TOGGLED );
<br>                }
<br>            } else {
<br>                bmp = m_style->GetToolIcon( tool->GetToolname(), TOOLICON_NORMAL, tool->rollover );
<br>                if( bmp.GetDepth() == 1 ) {
<br>                    if( tool->rollover ) {
<br>                        bmp = m_style->BuildPluginIcon( tool->pluginRolloverIcon, TOOLICON_NORMAL );
<br>                        if( ! bmp.IsOk() )
<br>                            bmp = m_style->BuildPluginIcon( tool->pluginNormalIcon, TOOLICON_NORMAL );
<br>                    }
<br>                    else
<br>                        bmp = m_style->BuildPluginIcon( tool->pluginNormalIcon, TOOLICON_NORMAL );
<br>                }
<br>            }
<br>            if(m_sizefactor > 1.0 ){
<br>                wxImage scaled_image = bmp.ConvertToImage();
<br>                bmp = wxBitmap(scaled_image.Scale(tool->m_width, tool->m_height, wxIMAGE_QUALITY_HIGH));
<br>            }
<br>            tool->SetNormalBitmap( bmp );
<br>            tool->bitmapOK = true;
<br>        } else {
<br>            if( tool->IsEnabled() ) {
<br>                if( tool->IsToggled() )
<br>                    bmp = m_style->GetToolIcon( tool->GetToolname(), TOOLICON_TOGGLED, tool->rollover );
<br>                else
<br>                    bmp = m_style->GetToolIcon( tool->GetIconName(), TOOLICON_NORMAL, tool->rollover );
<br>
<br>                if(m_sizefactor > 1.0 ){
<br>                    wxImage scaled_image = bmp.ConvertToImage();
<br>                    bmp = wxBitmap(scaled_image.Scale(tool->m_width, tool->m_height, wxIMAGE_QUALITY_HIGH));
<br>                }
<br>                tool->SetNormalBitmap( bmp );
<br>                tool->bitmapOK = true;
<br>            } else {
<br>                bmp = m_style->GetToolIcon( tool->GetToolname(), TOOLICON_DISABLED );
<br>                if(m_sizefactor > 1.0 ){
<br>                    wxImage scaled_image = bmp.ConvertToImage();
<br>                    bmp = wxBitmap(scaled_image.Scale(tool->m_width, tool->m_height, wxIMAGE_QUALITY_HIGH));
<br>                }
<br>                tool->SetDisabledBitmap( bmp );
<br>                tool->bitmapOK = true;
<br>            }
<br>        }
<br>    }
<br>
<br>    if( tool->firstInLine ) {
<br>        m_style->DrawToolbarLineStart( bmp );
<br>    }
<br>    if( tool->lastInLine ) {
<br>        m_style->DrawToolbarLineEnd( bmp );
<br>    }
<br>
<br>    if( bmp.GetWidth() != m_style->GetToolSize().x
<br>            || bmp.GetHeight() != m_style->GetToolSize().y ) {
<br>//        drawAt.x -= ( bmp.GetWidth() - m_style->GetToolSize().x ) / 2;
<br>//        drawAt.y -= ( bmp.GetHeight() - m_style->GetToolSize().y ) / 2;
<br>    }
<br>
<br>    //      Clear the last drawn tool if necessary
<br>    if( tool->last_rect.width && ((tool->last_rect.x != drawAt.x) || (tool->last_rect.y != drawAt.y)) ){
<br>        wxBrush bb(GetGlobalColor( _T("GREY2") ));
<br>        dc.SetBrush(bb);
<br>        dc.SetPen( *wxTRANSPARENT_PEN );
<br>        dc.DrawRectangle(tool->last_rect.x, tool->last_rect.y, tool->last_rect.width, tool->last_rect.height);
<br>    }
<br>
<br>    //  could cache this in the tool...
<br>    //  A bit of a hack here.  We only scale tools if they are to be magnified globally
<br>    if(0/*m_sizefactor > 1.0*/ )
<br>    {
<br>        wxImage scaled_image = bmp.ConvertToImage();
<br>        wxBitmap sbmp = wxBitmap(scaled_image.Scale(tool->m_width, tool->m_height, wxIMAGE_QUALITY_HIGH));
<br>        dc.DrawBitmap( sbmp, drawAt );
<br>        tool->last_rect = wxRect(drawAt.x, drawAt.y, sbmp.GetWidth(), sbmp.GetHeight());
<br>
<br>    }
<br>    else
<br>    {
<br>        dc.DrawBitmap( bmp, drawAt );
<br>        tool->last_rect = wxRect(drawAt.x, drawAt.y, bmp.GetWidth(), bmp.GetHeight());
<br>    }
<br>
<br>}
<br>
<br>// ----------------------------------------------------------------------------
<br>// toolbar geometry
<br>// ----------------------------------------------------------------------------
<br>
<br>wxToolBarToolBase *ocpnToolBarSimple::FindToolForPosition( wxCoord x, wxCoord y )
<br>{
<br>    wxToolBarToolsList::compatibility_iterator node = m_tools.GetFirst();
<br>    while( node ) {
<br>        ocpnToolBarTool *tool = (ocpnToolBarTool *) node->GetData();
<br>        if( ( x >= tool->m_x ) && ( y >= tool->m_y ) && ( x < ( tool->m_x + tool->GetWidth() ) )
<br>                && ( y < ( tool->m_y + tool->GetHeight() ) ) ) {
<br>            return tool;
<br>        }
<br>
<br>        node = node->GetNext();
<br>    }
<br>
<br>    return (wxToolBarToolBase *) NULL;
<br>}
<br>
<br>void ocpnToolBarSimple::InvalidateBitmaps()
<br>{
<br>    wxToolBarToolsList::compatibility_iterator node = m_tools.GetFirst();
<br>    while( node ) {
<br>        ocpnToolBarTool *tool = (ocpnToolBarTool *) node->GetData();
<br>        tool->bitmapOK = false;
<br>        node = node->GetNext();
<br>    }
<br>}
<br>
<br>wxRect ocpnToolBarSimple::GetToolRect( int tool_id )
<br>{
<br>    wxRect rect;
<br>    wxToolBarToolBase *tool = FindById( tool_id );
<br>    if( tool ) {
<br>        ocpnToolBarTool *otool = (ocpnToolBarTool *) tool;
<br>        if( otool ) rect = otool->trect;
<br>    }
<br>
<br>    return rect;
<br>}
<br>
<br>// ----------------------------------------------------------------------------
<br>// tool state change handlers
<br>// ----------------------------------------------------------------------------
<br>
<br>void ocpnToolBarSimple::DoEnableTool( wxToolBarToolBase *tool, bool WXUNUSED(enable) )
<br>{
<br>    DrawTool( tool );
<br>}
<br>
<br>void ocpnToolBarSimple::DoToggleTool( wxToolBarToolBase *tool, bool WXUNUSED(toggle) )
<br>{
<br>    ocpnToolBarTool *t = (ocpnToolBarTool *) tool;
<br>    t->bitmapOK = false;
<br>    DrawTool( tool );
<br>}
<br>
<br>// Okay, so we've left the tool we're in ... we must check if the tool we're
<br>// leaving was a 'sprung push button' and if so, spring it back to the up
<br>// state.
<br>void ocpnToolBarSimple::SpringUpButton( int id )
<br>{
<br>    wxToolBarToolBase *tool = FindById( id );
<br>
<br>    if( tool && tool->CanBeToggled() ) {
<br>        if( tool->IsToggled() ) tool->Toggle();
<br>
<br>        DrawTool( tool );
<br>    }
<br>}
<br>
<br>// ----------------------------------------------------------------------------
<br>// scrolling implementation
<br>// ----------------------------------------------------------------------------
<br>
<br>wxString ocpnToolBarSimple::GetToolShortHelp( int id ) const
<br>{
<br>    wxToolBarToolBase *tool = FindById( id );
<br>    wxCHECK_MSG( tool, wxEmptyString, _T("no such tool") );
<br>
<br>    return tool->GetShortHelp();
<br>}
<br>
<br>wxString ocpnToolBarSimple::GetToolLongHelp( int id ) const
<br>{
<br>    wxToolBarToolBase *tool = FindById( id );
<br>    wxCHECK_MSG( tool, wxEmptyString, _T("no such tool") );
<br>
<br>    return tool->GetLongHelp();
<br>}
<br>
<br>void ocpnToolBarSimple::SetToolShortHelp( int id, const wxString& help )
<br>{
<br>    wxToolBarToolBase *tool = FindById( id );
<br>    if( tool ) {
<br>        (void) tool->SetShortHelp( help );
<br>    }
<br>}
<br>
<br>void ocpnToolBarSimple::SetToolLongHelp( int id, const wxString& help )
<br>{
<br>    wxToolBarToolBase *tool = FindById( id );
<br>    if( tool ) {
<br>        (void) tool->SetLongHelp( help );
<br>    }
<br>}
<br>
<br>int ocpnToolBarSimple::GetToolPos( int id ) const
<br>{
<br>    size_t pos = 0;
<br>    wxToolBarToolsList::compatibility_iterator node;
<br>
<br>    for( node = m_tools.GetFirst(); node; node = node->GetNext() ) {
<br>        if( node->GetData()->GetId() == id ) return pos;
<br>
<br>        pos++;
<br>    }
<br>
<br>    return wxNOT_FOUND;
<br>}
<br>bool ocpnToolBarSimple::GetToolState( int id ) const
<br>{
<br>    wxToolBarToolBase *tool = FindById( id );
<br>    wxCHECK_MSG( tool, false, _T("no such tool") );
<br>
<br>    return tool->IsToggled();
<br>}
<br>
<br>bool ocpnToolBarSimple::GetToolEnabled( int id ) const
<br>{
<br>    wxToolBarToolBase *tool = FindById( id );
<br>    wxCHECK_MSG( tool, false, _T("no such tool") );
<br>
<br>    return tool->IsEnabled();
<br>}
<br>
<br>void ocpnToolBarSimple::ToggleTool( int id, bool toggle )
<br>{
<br>    wxToolBarToolBase *tool = FindById( id );
<br>        
<br>    if( tool && tool->CanBeToggled() && tool->Toggle( toggle ) ) {
<br>        DoToggleTool( tool, toggle );
<br>        if( g_toolbar ) g_toolbar->Refresh();
<br>    }
<br>}
<br>
<br>wxObject *ocpnToolBarSimple::GetToolClientData( int id ) const
<br>{
<br>    wxToolBarToolBase *tool = FindById( id );
<br>    return tool ? tool->GetClientData() : (wxObject *) NULL;
<br>}
<br>
<br>void ocpnToolBarSimple::SetToolClientData( int id, wxObject *clientData )
<br>{
<br>    wxToolBarToolBase *tool = FindById( id );
<br>
<br>    wxCHECK_RET( tool, _T("no such tool in wxToolBar::SetToolClientData") );
<br>
<br>    tool->SetClientData( clientData );
<br>}
<br>
<br>void ocpnToolBarSimple::EnableTool( int id, bool enable )
<br>{
<br>    wxToolBarToolBase *tool = FindById( id );
<br>    if( tool ) {
<br>        if( tool->Enable( enable ) ) {
<br>            DoEnableTool( tool, enable );
<br>        }
<br>    }
<br>    wxMenuItem* configItem = g_FloatingToolbarConfigMenu->FindItem( id );
<br>    configItem->Check( true );
<br>}
<br>
<br>void ocpnToolBarSimple::SetToolBitmaps( int id, wxBitmap *bmp, wxBitmap *bmpRollover )
<br>{
<br>    ocpnToolBarTool *tool = (ocpnToolBarTool*)FindById( id );
<br>    if( tool ) {
<br>        tool->pluginNormalIcon = bmp;
<br>        tool->pluginRolloverIcon = bmpRollover;
<br>        tool->bitmapOK = false;
<br>    }
<br>}
<br>
<br>void ocpnToolBarSimple::SetToolTooltipHiViz( int id, bool b_hiviz )
<br>{
<br>    ocpnToolBarTool *tool = (ocpnToolBarTool*)FindById( id );
<br>    if( tool ) {
<br>        tool->SetTooltipHiviz( b_hiviz );
<br>    }
<br>}
<br>
<br>
<br>void ocpnToolBarSimple::ClearTools()
<br>{
<br>    while( GetToolsCount() ) {
<br>        DeleteToolByPos( 0 );
<br>    }
<br>}
<br>
<br>int ocpnToolBarSimple::GetVisibleToolCount()
<br>{
<br>    int counter = 0;
<br>    wxToolBarToolsList::compatibility_iterator node = m_tools.GetFirst();
<br>    while( node ) {
<br>        ocpnToolBarTool *tool = (ocpnToolBarTool *) node->GetData();
<br>        counter++;
<br>        node = node->GetNext();
<br>    }
<br>    return counter;
<br>}
<br>
<br>bool ocpnToolBarSimple::DeleteToolByPos( size_t pos )
<br>{
<br>    wxCHECK_MSG( pos < GetToolsCount(), false,
<br>            _T("invalid position in wxToolBar::DeleteToolByPos()") );
<br>
<br>    wxToolBarToolsList::compatibility_iterator node = m_tools.Item( pos );
<br>
<br>    if( !DoDeleteTool( pos, node->GetData() ) ) {
<br>        return false;
<br>    }
<br>
<br>    delete node->GetData();
<br>    m_tools.Erase( node );
<br>
<br>    return true;
<br>}
<br>
<br>bool ocpnToolBarSimple::DeleteTool( int id )
<br>{
<br>    size_t pos = 0;
<br>    wxToolBarToolsList::compatibility_iterator node;
<br>    for( node = m_tools.GetFirst(); node; node = node->GetNext() ) {
<br>        if( node->GetData()->GetId() == id ) break;
<br>
<br>        pos++;
<br>    }
<br>
<br>    if( !node || !DoDeleteTool( pos, node->GetData() ) ) {
<br>        return false;
<br>    }
<br>
<br>    delete node->GetData();
<br>    m_tools.Erase( node );
<br>
<br>    return true;
<br>}
<br>
<br>wxToolBarToolBase *ocpnToolBarSimple::AddSeparator()
<br>{
<br>    return InsertSeparator( GetToolsCount() );
<br>}
<br>
<br>wxToolBarToolBase *ocpnToolBarSimple::InsertSeparator( size_t pos )
<br>{
<br>    wxCHECK_MSG( pos <= GetToolsCount(), (wxToolBarToolBase *)NULL,
<br>            _T("invalid position in wxToolBar::InsertSeparator()") );
<br>
<br>    wxToolBarToolBase *tool = CreateTool( wxID_SEPARATOR, wxEmptyString, wxNullBitmap, wxNullBitmap,
<br>            wxITEM_SEPARATOR, (wxObject *) NULL, wxEmptyString, wxEmptyString );
<br>
<br>    if( !tool || !DoInsertTool( pos, tool ) ) {
<br>        delete tool;
<br>
<br>        return NULL;
<br>    }
<br>
<br>    m_tools.Insert( pos, tool );
<br>
<br>    return tool;
<br>}
<br>
<br>wxToolBarToolBase *ocpnToolBarSimple::RemoveTool( int id )
<br>{
<br>    size_t pos = 0;
<br>    wxToolBarToolsList::compatibility_iterator node;
<br>    for( node = m_tools.GetFirst(); node; node = node->GetNext() ) {
<br>        if( node->GetData()->GetId() == id ) break;
<br>
<br>        pos++;
<br>    }
<br>
<br>    if( !node ) {
<br>        // don't give any error messages - sometimes we might call RemoveTool()
<br>        // without knowing whether the tool is or not in the toolbar
<br>        return (wxToolBarToolBase *) NULL;
<br>    }
<br>
<br>    wxToolBarToolBase *tool = node->GetData();
<br>    if( !DoDeleteTool( pos, tool ) ) {
<br>        return (wxToolBarToolBase *) NULL;
<br>    }
<br>
<br>    m_tools.Erase( node );
<br>
<br>    return tool;
<br>}
<br>
<br>
<br>wxControl *ocpnToolBarSimple::FindControl( int id )
<br>{
<br>    for( wxToolBarToolsList::compatibility_iterator node = m_tools.GetFirst(); node;
<br>            node = node->GetNext() ) {
<br>        const wxToolBarToolBase * const tool = node->GetData();
<br>        if( tool->IsControl() ) {
<br>            wxControl * const control = tool->GetControl();
<br>
<br>            if( !control ) {
<br>                wxFAIL_MSG( _T("NULL control in toolbar?") );
<br>            } else
<br>                if( control->GetId() == id ) {
<br>                    // found
<br>                    return control;
<br>                }
<br>        }
<br>    }
<br>
<br>    return NULL;
<br>}
<br>
<br>wxToolBarToolBase *ocpnToolBarSimple::FindById( int id ) const
<br>{
<br>    wxToolBarToolBase *tool = (wxToolBarToolBase *) NULL;
<br>
<br>    for( wxToolBarToolsList::compatibility_iterator node = m_tools.GetFirst(); node;
<br>            node = node->GetNext() ) {
<br>        tool = node->GetData();
<br>        if( tool->GetId() == id ) {
<br>            // found
<br>            break;
<br>        }
<br>
<br>        tool = NULL;
<br>    }
<br>
<br>    return tool;
<br>}
<br>
<br>// ----------------------------------------------------------------------------
<br>// event processing
<br>// ----------------------------------------------------------------------------
<br>
<br>// Only allow toggle if returns true
<br>bool ocpnToolBarSimple::OnLeftClick( int id, bool toggleDown )
<br>{
<br>    wxCommandEvent event( wxEVT_COMMAND_TOOL_CLICKED, id );
<br>    event.SetEventObject( this );
<br>
<br>    // we use SetInt() to make wxCommandEvent::IsChecked() return toggleDown
<br>    event.SetInt( (int) toggleDown );
<br>
<br>    // and SetExtraLong() for backwards compatibility
<br>    event.SetExtraLong( (long) toggleDown );
<br>
<br>    // Send events to this toolbar instead (and thence up the window hierarchy)
<br>    GetEventHandler()->ProcessEvent( event );
<br>
<br>    return true;
<br>}
<br>
<br>// Call when right button down.
<br>void ocpnToolBarSimple::OnRightClick( int id, long WXUNUSED(x), long WXUNUSED(y) )
<br>{
<br>    wxCommandEvent event( wxEVT_COMMAND_TOOL_RCLICKED, id );
<br>    event.SetEventObject( this );
<br>    event.SetInt( id );
<br>
<br>    HideTooltip();
<br>    ((ocpnFloatingToolbarDialog*)GetParent())->toolbarConfigChanged = false;
<br>    wxMenu* contextMenu = new wxMenu();
<br>    wxMenuItem* submenu = contextMenu->AppendSubMenu( g_FloatingToolbarConfigMenu, _("Visible buttons") );
<br>
<br>    PopupMenu( contextMenu );
<br>
<br>    contextMenu->Remove( submenu );
<br>    delete contextMenu;
<br>
<br>    if( ((ocpnFloatingToolbarDialog*)GetParent())->toolbarConfigChanged )
<br>        gFrame->GetEventHandler()->AddPendingEvent( event );
<br>}
<br>
<br>// Called when the mouse cursor enters a tool bitmap (no button pressed).
<br>// Argument is wxID_ANY if mouse is exiting the toolbar.
<br>// Note that for this event, the id of the window is used,
<br>// and the integer parameter of wxCommandEvent is used to retrieve
<br>// the tool id.
<br>void ocpnToolBarSimple::OnMouseEnter( int id )
<br>{
<br>    wxCommandEvent event( wxEVT_COMMAND_TOOL_ENTER, GetId() );
<br>    event.SetEventObject( this );
<br>    event.SetInt( id );
<br>
<br>    wxFrame *frame = wxDynamicCast(GetParent(), wxFrame);
<br>    if( frame ) {
<br>        wxString help;
<br>        wxToolBarToolBase* tool = id == wxID_ANY ? (wxToolBarToolBase*) NULL : FindById( id );
<br>        if( tool ) help = tool->GetLongHelp();
<br>        frame->DoGiveHelp( help, id != wxID_ANY );
<br>    }
<br>
<br>    (void) GetEventHandler()->ProcessEvent( event );
<br>
<br>    DoPluginToolUp();
<br>}
<br>
<br>void ocpnToolBarSimple::DoPluginToolUp()
<br>{
<br>    //        Look for PlugIn tools
<br>    //        If found, make the callback.
<br>    if( !g_pi_manager)
<br>        return;
<br>
<br>    ArrayOfPlugInToolbarTools tool_array = g_pi_manager->GetPluginToolbarToolArray();
<br>    for( unsigned int i = 0; i < tool_array.GetCount(); i++ ) {
<br>        PlugInToolbarToolContainer *pttc = tool_array.Item( i );
<br>        if( m_last_plugin_down_id == pttc->id ) {
<br>            opencpn_plugin_113 *ppi = dynamic_cast<opencpn_plugin_113 *>(pttc->m_pplugin);
<br>            if( ppi )
<br>                ppi->OnToolbarToolUpCallback( pttc->id );
<br>        }
<br>    }
<br>
<br>    m_last_plugin_down_id = -1;
<br>}
<br>
<br>void ocpnToolBarSimple::SetToolNormalBitmapEx( wxToolBarToolBase *tool, const wxString &iconName)
<br>{
<br>    if( tool ) {
<br>        ocpnToolBarTool *otool = (ocpnToolBarTool *) tool;
<br>        if(otool){
<br>            ocpnStyle::Style *style = g_StyleManager->GetCurrentStyle();
<br>
<br>            wxBitmap bmp = style->GetToolIcon( iconName, TOOLICON_NORMAL );
<br>            if(m_sizefactor > 1.0 ){
<br>                wxImage scaled_image = bmp.ConvertToImage();
<br>                bmp = wxBitmap(scaled_image.Scale(otool->m_width, otool->m_height, wxIMAGE_QUALITY_HIGH));
<br>            }
<br>        
<br>            tool->SetNormalBitmap( bmp );
<br>            otool->SetIconName( iconName );
<br>        }
<br>    }
<br>}
<br>
<br>
<br>//-------------------------------------------------------------------------------------
<br>
<br>ToolbarMOBDialog::ToolbarMOBDialog( wxWindow* parent )
<br>       : wxDialog( parent, wxID_ANY, _("OpenCPN Alert"), wxDefaultPosition, wxSize(250, 230) )
<br>{
<br>    wxBoxSizer* topSizer = new wxBoxSizer( wxVERTICAL );
<br>
<br>    wxBoxSizer* sizer = new wxBoxSizer( wxVERTICAL );
<br>    topSizer->Add( sizer, 0, wxALIGN_CENTER_HORIZONTAL | wxALL, 5 );
<br>
<br>    choices.push_back( new wxRadioButton( this, 0,  _("No, I don't want to hide it."),
<br>            wxDefaultPosition, wxDefaultSize, wxRB_GROUP ) );
<br>
<br>    choices.push_back( new wxRadioButton( this, 1, _("No, and permanently remove the option to hide it."),
<br>            wxDefaultPosition) );
<br>
<br>    choices.push_back( new wxRadioButton( this, 2, _("Yes, hide it."),
<br>            wxDefaultPosition) );
<br>
<br><mark>    wxStdDialogButtonSizer* buttonSizer = CreateStdDialogButtonSizer( wxOK | wxCANCEL );
</mark><br>
<br>
<br>    wxStaticText* textCtrl = new wxStaticText( this, wxID_ANY, _("The Man Over Board button could be an important safety feature.\nAre you sure you want to hide it?") );
<br>
<br>    sizer->Add( textCtrl, 0, wxEXPAND | wxALL, 5 );
<br>    sizer->Add( choices[0], 0, wxEXPAND | wxALL, 5 );
<br>    sizer->Add( choices[1], 0, wxEXPAND | wxALL, 5 );
<br>    sizer->Add( choices[2], 0, wxEXPAND | wxALL, 5 );
<br><mark>    sizer->Add( buttonSizer, 0, wxEXPAND | wxTOP, 5 );
</mark><br>
<br>    topSizer->SetSizeHints(this);
<br>    SetSizer( topSizer );
<br>}
<br>
<br>int ToolbarMOBDialog::GetSelection() {
<br>    for( unsigned int i=0; i<choices.size(); i++ ) {
<br>        if( choices[i]->GetValue() ) return choices[i]->GetId();
<br>    }
<br>    return 0;
<br>}
</p></body>
    </html><html>
    <head></head>
    <body><p><br><mark>/***************************************************************************
</mark><br><mark> *
</mark><br><mark> * Project:  OpenCPN
</mark><br><mark> * Purpose:  OpenCPN Toolbar
</mark><br><mark> * Author:   David Register
</mark><br><mark> *
</mark><br><mark> ***************************************************************************
</mark><br><mark> *   Copyright (C) 2010 by David S. Register                               *
</mark><br><mark> *                                                                         *
</mark><br><mark> *   This program is free software; you can redistribute it and/or modify  *
</mark><br><mark> *   it under the terms of the GNU General Public License as published by  *
</mark><br><mark> *   the Free Software Foundation; either version 2 of the License, or     *
</mark><br><mark> *   (at your option) any later version.                                   *
</mark><br><mark> *                                                                         *
</mark><br><mark> *   This program is distributed in the hope that it will be useful,       *
</mark><br><mark> *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
</mark><br><mark> *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
</mark><br><mark> *   GNU General Public License for more details.                          *
</mark><br><mark> *                                                                         *
</mark><br><mark> *   You should have received a copy of the GNU General Public License     *
</mark><br><mark> *   along with this program; if not, write to the                         *
</mark><br><mark> *   Free Software Foundation, Inc.,                                       *
</mark><br><mark> *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,  USA.         *
</mark><br><mark> **************************************************************************/
</mark><br><mark>
</mark><br><mark>#include "wx/wxprec.h"
</mark><br><mark>
</mark><br><mark>#ifndef  WX_PRECOMP
</mark><br><mark>#include "wx/wx.h"
</mark><br><mark>#endif
</mark><br><mark>
</mark><br><mark>#include <vector>
</mark><br><mark>
</mark><br><mark>#include "ocpn_types.h"
</mark><br><mark>#include "navutil.h"
</mark><br><mark>#include "styles.h"
</mark><br><mark>#include "toolbar.h"
</mark><br><mark>#include "chart1.h"
</mark><br><mark>#include "pluginmanager.h"
</mark><br><mark>#include "FontMgr.h"
</mark><br><mark>
</mark><br><mark>extern ocpnFloatingToolbarDialog* g_FloatingToolbarDialog;
</mark><br><mark>extern bool                       g_bTransparentToolbar;
</mark><br><mark>extern bool                       g_bTransparentToolbarInOpenGLOK;
</mark><br><mark>extern ChartCanvas*               cc1;
</mark><br><mark>extern bool                       g_bopengl;
</mark><br><mark>extern ocpnToolBarSimple*         g_toolbar;
</mark><br><mark>extern ocpnStyle::StyleManager*   g_StyleManager;
</mark><br><mark>extern MyFrame*                   gFrame;
</mark><br><mark>extern PlugInManager*             g_pi_manager;
</mark><br><mark>extern wxMenu*                    g_FloatingToolbarConfigMenu;
</mark><br><mark>extern wxString                   g_toolbarConfig;
</mark><br><mark>extern bool                       g_bPermanentMOBIcon;
</mark><br><mark>extern bool                       g_btouch;
</mark><br><mark>extern bool                       g_bsmoothpanzoom;
</mark><br><mark>
</mark><br><mark>//----------------------------------------------------------------------------
</mark><br><mark>// GrabberWindow Implementation
</mark><br><mark>//----------------------------------------------------------------------------
</mark><br><mark>BEGIN_EVENT_TABLE(GrabberWin, wxPanel) EVT_MOUSE_EVENTS ( GrabberWin::MouseEvent )
</mark><br><mark>EVT_PAINT ( GrabberWin::OnPaint )
</mark><br><mark>END_EVENT_TABLE()
</mark><br><mark>
</mark><br><mark>GrabberWin::GrabberWin( wxWindow *parent, ocpnFloatingToolbarDialog *toolbar, float scale_factor, wxString icon_name, wxPoint position ):
</mark><br><mark>    wxPanel( parent, wxID_ANY, position, wxDefaultSize, wxNO_BORDER )
</mark><br><mark>{
</mark><br><mark>    m_icon_name = icon_name;
</mark><br><mark>    m_style = g_StyleManager->GetCurrentStyle();
</mark><br><mark>    wxBitmap bitmap = m_style->GetIcon( icon_name );
</mark><br><mark>    if(scale_factor > 1.0f){
</mark><br><mark>        int new_width = bitmap.GetWidth() * scale_factor;
</mark><br><mark>        int new_height = bitmap.GetHeight() * scale_factor;
</mark><br><mark>        wxImage scaled_image = bitmap.ConvertToImage();
</mark><br><mark>        m_bitmap = wxBitmap(scaled_image.Scale(new_width, new_height, wxIMAGE_QUALITY_HIGH));
</mark><br><mark>    }
</mark><br><mark>    else
</mark><br><mark>        m_bitmap = bitmap;
</mark><br><mark>
</mark><br><mark>    SetSize( wxSize( m_bitmap.GetWidth(), m_bitmap.GetHeight() ) );
</mark><br><mark>    SetMinSize( wxSize( m_bitmap.GetWidth(), m_bitmap.GetHeight() ) );
</mark><br><mark>
</mark><br><mark>    m_bLeftDown = false;
</mark><br><mark>    m_bRightDown = false;
</mark><br><mark>    m_scale_factor = scale_factor;
</mark><br><mark>    m_ptoolbar = toolbar;
</mark><br><mark>    m_dragging = false;
</mark><br><mark>    Hide();
</mark><br><mark>    
</mark><br><mark>}
</mark><br><mark>
</mark><br><mark>
</mark><br><mark>void GrabberWin::OnPaint( wxPaintEvent& event )
</mark><br><mark>{
</mark><br><mark>    wxPaintDC dc( this );
</mark><br><mark>    
</mark><br><mark>    wxColour back_color = GetGlobalColor( _T("GREY2") );
</mark><br><mark>    SetBackgroundColour( back_color );
</mark><br><mark>    ClearBackground();
</mark><br><mark>    
</mark><br><mark>    dc.DrawBitmap( m_bitmap, 0, 0, true );
</mark><br><mark>}
</mark><br><mark>
</mark><br><mark>void GrabberWin::SetColorScheme( ColorScheme cs )
</mark><br><mark>{
</mark><br><mark>    wxColour back_color = GetGlobalColor( _T("GREY2") );
</mark><br><mark>
</mark><br><mark>    SetBackgroundColour( back_color );
</mark><br><mark>    ClearBackground();
</mark><br><mark>
</mark><br><mark>    wxBitmap bitmap = m_style->GetIcon( m_icon_name) ;
</mark><br><mark>    if(m_scale_factor > 1.0f){
</mark><br><mark>        int new_width = bitmap.GetWidth() * m_scale_factor;
</mark><br><mark>        int new_height = bitmap.GetHeight() * m_scale_factor;
</mark><br><mark>        wxImage scaled_image = bitmap.ConvertToImage();
</mark><br><mark>        m_bitmap = wxBitmap(scaled_image.Scale(new_width, new_height, wxIMAGE_QUALITY_HIGH));
</mark><br><mark>    }
</mark><br><mark>    else
</mark><br><mark>        m_bitmap = bitmap;
</mark><br><mark>}
</mark><br><mark>
</mark><br><mark>void GrabberWin::MouseEvent( wxMouseEvent& event )
</mark><br><mark>{
</mark><br><mark>    static wxPoint s_gspt;
</mark><br><mark>    int x, y;
</mark><br><mark>
</mark><br><mark>    event.GetPosition( &x, &y );
</mark><br><mark>
</mark><br><mark>    wxPoint spt = ClientToScreen( wxPoint( x, y ) );
</mark><br><mark>    if( event.LeftDown() ) {
</mark><br><mark>        s_gspt = spt;
</mark><br><mark>    }
</mark><br><mark>    
</mark><br><mark>    
</mark><br><mark>#ifndef __WXQT__
</mark><br><mark>
</mark><br><mark>    if( event.LeftDown() ) {
</mark><br><mark>        CaptureMouse();
</mark><br><mark>    }
</mark><br><mark>
</mark><br><mark>    if( event.LeftUp() ) {
</mark><br><mark>        if( HasCapture() ) ReleaseMouse();
</mark><br><mark>    }
</mark><br><mark>
</mark><br><mark>#endif
</mark><br><mark>
</mark><br><mark>
</mark><br><mark>    if( event.RightDown() ){
</mark><br><mark>        if(m_ptoolbar){
</mark><br><mark>            m_dragging = true;
</mark><br><mark>            
</mark><br><mark>            if( !m_ptoolbar->m_bnavgrabber ){
</mark><br><mark>                m_ptoolbar->m_bnavgrabber = true;
</mark><br><mark>                m_ptoolbar->SetGrabber(_T("4WayMove") );
</mark><br><mark>            }
</mark><br><mark>            else{
</mark><br><mark>                m_ptoolbar->m_bnavgrabber = false;
</mark><br><mark>                m_ptoolbar->SetGrabber(_T("grabber_hi") );
</mark><br><mark>            }
</mark><br><mark>                
</mark><br><mark>        }
</mark><br><mark>    }
</mark><br><mark>    
</mark><br><mark>
</mark><br><mark>
</mark><br><mark>    if( event.Dragging() ) {
</mark><br><mark>        if(m_ptoolbar && m_ptoolbar->IsShown() /*&& m_ptoolbar->m_bnavgrabber*/){
</mark><br><mark>            wxPoint par_pos_old = m_ptoolbar->GetPosition();
</mark><br><mark>
</mark><br><mark>            wxPoint par_pos = par_pos_old;
</mark><br><mark>            par_pos.x += spt.x - s_gspt.x;
</mark><br><mark>            par_pos.y += spt.y - s_gspt.y;
</mark><br><mark>
</mark><br><mark>            m_ptoolbar->MoveDialogInScreenCoords( par_pos, par_pos_old );
</mark><br><mark>
</mark><br><mark>            s_gspt = spt;
</mark><br><mark>            m_dragging = true;
</mark><br><mark>        }
</mark><br><mark>
</mark><br><mark>    }
</mark><br><mark>
</mark><br><mark>    if( event.LeftUp() ) {
</mark><br><mark>        if(m_ptoolbar){
</mark><br><mark>            if(m_ptoolbar->m_bnavgrabber){
</mark><br><mark>                if(!m_dragging)
</mark><br><mark>                    m_ptoolbar->ToggleOrientation();
</mark><br><mark>            }
</mark><br><mark>            else if(!m_dragging){
</mark><br><mark>                if(m_ptoolbar->m_bsubmerged){
</mark><br><mark>                    m_ptoolbar->SurfaceFromGrabber();
</mark><br><mark>                }
</mark><br><mark>                else{
</mark><br><mark>                    m_ptoolbar->SubmergeToGrabber();
</mark><br><mark>                 }
</mark><br><mark>            }
</mark><br><mark>        }
</mark><br><mark>        m_dragging = false;
</mark><br><mark>    }
</mark><br><mark>    
</mark><br><mark>    
</mark><br><mark>#ifndef __OCPN__ANDROID__
</mark><br><mark>    gFrame->Raise();
</mark><br><mark>#endif
</mark><br><mark>    
</mark><br><mark>}
</mark><br><mark>
</mark><br><mark>class ocpnToolBarTool: public wxToolBarToolBase {
</mark><br><mark>public:
</mark><br><mark>    ocpnToolBarTool( ocpnToolBarSimple *tbar, int id, const wxString& label,
</mark><br><mark>            const wxBitmap& bmpNormal, const wxBitmap& bmpRollover, wxItemKind kind,
</mark><br><mark>            wxObject *clientData, const wxString& shortHelp, const wxString& longHelp ) :
</mark><br><mark>            wxToolBarToolBase( (wxToolBarBase*) tbar, id, label, bmpNormal, bmpRollover, kind,
</mark><br><mark>                    clientData, shortHelp, longHelp )
</mark><br><mark>    {
</mark><br><mark>        m_enabled = true;
</mark><br><mark>        m_toggled = false;
</mark><br><mark>        rollover = false;
</mark><br><mark>        bitmapOK = false;
</mark><br><mark>        m_btooltip_hiviz = false;
</mark><br><mark>
</mark><br><mark>        toolname = g_pi_manager->GetToolOwnerCommonName( id );
</mark><br><mark>        if( toolname == _T("") ) {
</mark><br><mark>            isPluginTool = false;
</mark><br><mark>            toolname = label;
</mark><br><mark>            iconName = label;
</mark><br><mark>        } else {
</mark><br><mark>            isPluginTool = true;
</mark><br><mark>            pluginNormalIcon = &bmpNormal;
</mark><br><mark>            pluginRolloverIcon = &bmpRollover;
</mark><br><mark>        }
</mark><br><mark>    }
</mark><br><mark>
</mark><br><mark>    void SetSize( const wxSize& size )
</mark><br><mark>    {
</mark><br><mark>        m_width = size.x;
</mark><br><mark>        m_height = size.y;
</mark><br><mark>    }
</mark><br><mark>
</mark><br><mark>    wxCoord GetWidth() const
</mark><br><mark>    {
</mark><br><mark>        return m_width;
</mark><br><mark>    }
</mark><br><mark>
</mark><br><mark>    wxCoord GetHeight() const
</mark><br><mark>    {
</mark><br><mark>        return m_height;
</mark><br><mark>    }
</mark><br><mark>
</mark><br><mark>    wxString GetToolname()
</mark><br><mark>    {
</mark><br><mark>        return toolname;
</mark><br><mark>    }
</mark><br><mark>
</mark><br><mark>    void SetIconName(wxString name)
</mark><br><mark>    {
</mark><br><mark>        iconName = name;
</mark><br><mark>    }
</mark><br><mark>    wxString GetIconName()
</mark><br><mark>    {
</mark><br><mark>        return iconName;
</mark><br><mark>    }
</mark><br><mark>
</mark><br><mark>    void SetTooltipHiviz( bool enable){ m_btooltip_hiviz = enable; }
</mark><br><mark>
</mark><br><mark>    wxCoord m_x;
</mark><br><mark>    wxCoord m_y;
</mark><br><mark>    wxCoord m_width;
</mark><br><mark>    wxCoord m_height;
</mark><br><mark>    wxRect trect;
</mark><br><mark>    wxString toolname;
</mark><br><mark>    wxString iconName;
</mark><br><mark>    const wxBitmap* pluginNormalIcon;
</mark><br><mark>    const wxBitmap* pluginRolloverIcon;
</mark><br><mark>    bool firstInLine;
</mark><br><mark>    bool lastInLine;
</mark><br><mark>    bool rollover;
</mark><br><mark>    bool bitmapOK;
</mark><br><mark>    bool isPluginTool;
</mark><br><mark>    bool b_hilite;
</mark><br><mark>    bool m_btooltip_hiviz;
</mark><br><mark>    wxRect last_rect;
</mark><br><mark>};
</mark><br><mark>
</mark><br><mark>//---------------------------------------------------------------------------------------
</mark><br><mark>//          ocpnFloatingToolbarDialog Implementation
</mark><br><mark>//---------------------------------------------------------------------------------------
</mark><br><mark>BEGIN_EVENT_TABLE(ocpnFloatingToolbarDialog, wxDialog)
</mark><br><mark>    EVT_MOUSE_EVENTS ( ocpnFloatingToolbarDialog::MouseEvent )
</mark><br><mark>    EVT_MENU(wxID_ANY, ocpnFloatingToolbarDialog::OnToolLeftClick)
</mark><br><mark>    EVT_TIMER ( FADE_TIMER, ocpnFloatingToolbarDialog::FadeTimerEvent )
</mark><br><mark>    EVT_TIMER ( DESTROY_TIMER, ocpnFloatingToolbarDialog::DestroyTimerEvent )
</mark><br><mark>    EVT_WINDOW_CREATE(ocpnFloatingToolbarDialog::OnWindowCreate)
</mark><br><mark>END_EVENT_TABLE()
</mark><br><mark>
</mark><br><mark>ocpnFloatingToolbarDialog::ocpnFloatingToolbarDialog( wxWindow *parent, wxPoint position,
</mark><br><mark>                                                      long orient, float size_factor )
</mark><br><mark>{
</mark><br><mark>    m_pparent = parent;
</mark><br><mark>    long wstyle = wxNO_BORDER | wxFRAME_NO_TASKBAR;
</mark><br><mark>#ifndef __WXMAC__
</mark><br><mark>    wstyle |= wxFRAME_SHAPED;
</mark><br><mark>#endif
</mark><br><mark>
</mark><br><mark>    m_ptoolbar = NULL;
</mark><br><mark>
</mark><br><mark>#ifdef __WXOSX__
</mark><br><mark>    wstyle |= wxSTAY_ON_TOP;
</mark><br><mark>#endif
</mark><br><mark>    wxDialog::Create( parent, -1, _T("ocpnToolbarDialog"), wxPoint( -1, -1 ), wxSize( -1, -1 ),
</mark><br><mark>            wstyle );
</mark><br><mark>
</mark><br><mark>    m_opacity = 255;
</mark><br><mark>
</mark><br><mark>    m_pGrabberwin = new GrabberWin( this, this, size_factor, _T("grabber_hi") );
</mark><br><mark>    m_pGrabberwin->Show();
</mark><br><mark>    
</mark><br><mark>    m_pRecoverwin = NULL;
</mark><br><mark>    m_position = position;
</mark><br><mark>    m_orient = orient;
</mark><br><mark>    m_sizefactor = size_factor;
</mark><br><mark>    
</mark><br><mark>    m_bAutoHideToolbar = false;
</mark><br><mark>    m_nAutoHideToolbar = 5;
</mark><br><mark>    
</mark><br><mark>
</mark><br><mark>    m_style = g_StyleManager->GetCurrentStyle();
</mark><br><mark>
</mark><br><mark>// A top-level sizer
</mark><br><mark>    m_topSizer = new wxBoxSizer( wxHORIZONTAL );
</mark><br><mark>    SetSizer( m_topSizer );
</mark><br><mark>
</mark><br><mark>    //    Set initial "Dock" parameters
</mark><br><mark>    m_dock_x = 0;
</mark><br><mark>    m_dock_y = 0;
</mark><br><mark>    m_block = false;
</mark><br><mark>
</mark><br><mark>    m_marginsInvisible = m_style->marginsInvisible;
</mark><br><mark>
</mark><br><mark>//    if(m_sizefactor > 1.0 )
</mark><br><mark> //       m_marginsInvisible = true;
</mark><br><mark>
</mark><br><mark>    m_bnavgrabber = false;    
</mark><br><mark>    
</mark><br><mark>    Hide();
</mark><br><mark>
</mark><br><mark>    m_bsubmerged = false;
</mark><br><mark>    
</mark><br><mark>    m_fade_timer.SetOwner( this, FADE_TIMER );
</mark><br><mark>    if( g_bTransparentToolbar )
</mark><br><mark>        m_fade_timer.Start( 5000 );
</mark><br><mark>    
</mark><br><mark>    if( m_bAutoHideToolbar && (m_nAutoHideToolbar > 0))
</mark><br><mark>        m_fade_timer.Start( m_nAutoHideToolbar * 1000 );
</mark><br><mark>    
</mark><br><mark>    m_destroyTimer.SetOwner( this, DESTROY_TIMER );
</mark><br><mark>}
</mark><br><mark>
</mark><br><mark>ocpnFloatingToolbarDialog::~ocpnFloatingToolbarDialog()
</mark><br><mark>{
</mark><br><mark>    DestroyToolBar();
</mark><br><mark>}
</mark><br><mark>
</mark><br><mark>void ocpnFloatingToolbarDialog::OnWindowCreate( wxWindowCreateEvent& event )
</mark><br><mark>{
</mark><br><mark>    Realize();
</mark><br><mark>}
</mark><br><mark>
</mark><br><mark>void ocpnFloatingToolbarDialog::SetGrabber( wxString icon_name )
</mark><br><mark>{
</mark><br><mark>//    m_pGrabberwin->Destroy();
</mark><br><mark>    m_pGrabberwin = new GrabberWin( this, this, m_sizefactor, icon_name );
</mark><br><mark>    m_pGrabberwin->Show();
</mark><br><mark>    
</mark><br><mark>    Realize();
</mark><br><mark>    
</mark><br><mark>#ifdef __WXOSX__    
</mark><br><mark>    m_pGrabberwin->Refresh();
</mark><br><mark>#endif    
</mark><br><mark>    
</mark><br><mark>}
</mark><br><mark>
</mark><br><mark>
</mark><br><mark>    
</mark><br><mark>void ocpnFloatingToolbarDialog::SetColorScheme( ColorScheme cs )
</mark><br><mark>{
</mark><br><mark>    m_cs = cs;
</mark><br><mark>
</mark><br><mark>    wxColour back_color = GetGlobalColor( _T("GREY2") );
</mark><br><mark>
</mark><br><mark>    //  Set background
</mark><br><mark>    SetBackgroundColour( back_color );
</mark><br><mark>    ClearBackground();
</mark><br><mark>
</mark><br><mark>    if( m_ptoolbar ) {
</mark><br><mark>        wxColour back_color = GetGlobalColor( _T("GREY2") );
</mark><br><mark>
</mark><br><mark>        //  Set background
</mark><br><mark>        m_ptoolbar->SetBackgroundColour( back_color );
</mark><br><mark>        m_ptoolbar->ClearBackground();
</mark><br><mark>
</mark><br><mark>        m_ptoolbar->SetToggledBackgroundColour( GetGlobalColor( _T("GREY1") ) );
</mark><br><mark>
</mark><br><mark>        m_ptoolbar->SetColorScheme( cs );
</mark><br><mark>        m_ptoolbar->Refresh( true );
</mark><br><mark>    }
</mark><br><mark>
</mark><br><mark>    if( m_pGrabberwin ) m_pGrabberwin->SetColorScheme( cs );
</mark><br><mark>
</mark><br><mark>}
</mark><br><mark>
</mark><br><mark>void ocpnFloatingToolbarDialog::SetGeometry(bool bAvoid, wxRect rectAvoid)
</mark><br><mark>{
</mark><br><mark>
</mark><br><mark>    if( m_ptoolbar ) {
</mark><br><mark>        wxSize style_tool_size = m_style->GetToolSize();
</mark><br><mark>
</mark><br><mark>        style_tool_size.x *= m_sizefactor;
</mark><br><mark>        style_tool_size.y *= m_sizefactor;
</mark><br><mark>
</mark><br><mark>        m_ptoolbar->SetToolBitmapSize( style_tool_size );
</mark><br><mark>
</mark><br><mark>        wxSize tool_size = m_ptoolbar->GetToolBitmapSize();
</mark><br><mark>        int grabber_width =  m_style->GetIcon( _T("grabber") ).GetWidth();
</mark><br><mark>        
</mark><br><mark>        int max_rows = 10;
</mark><br><mark>        int max_cols = 100;
</mark><br><mark>        if(cc1){
</mark><br><mark>
</mark><br><mark>            int avoid_start = cc1->GetClientSize().x - (tool_size.x + m_style->GetToolSeparation()) * 2;  // default
</mark><br><mark>            if(bAvoid && !rectAvoid.IsEmpty()){
</mark><br><mark>                avoid_start = cc1->GetClientSize().x - rectAvoid.width - 10;  // this is compass window, if shown
</mark><br><mark>            }
</mark><br><mark>            
</mark><br><mark>            
</mark><br><mark>            max_rows = (cc1->GetClientSize().y / ( tool_size.y + m_style->GetToolSeparation())) - 1;
</mark><br><mark>            
</mark><br><mark>            max_cols = (avoid_start - grabber_width) / ( tool_size.x + m_style->GetToolSeparation());
</mark><br><mark>            max_cols -= 1;
</mark><br><mark>            
</mark><br><mark>            if(m_orient == wxTB_VERTICAL)
</mark><br><mark>                max_rows = wxMax( max_rows, 2);             // at least two rows
</mark><br><mark>            else
</mark><br><mark>                max_cols = wxMax( max_cols, 2);             // at least two columns
</mark><br><mark>        }
</mark><br><mark>
</mark><br><mark>        if( m_orient == wxTB_VERTICAL )
</mark><br><mark>            m_ptoolbar->SetMaxRowsCols(max_rows, 100);
</mark><br><mark>        else
</mark><br><mark>            m_ptoolbar->SetMaxRowsCols( 100, max_cols);
</mark><br><mark>        m_ptoolbar->SetSizeFactor(m_sizefactor);
</mark><br><mark>        
</mark><br><mark>    }
</mark><br><mark> }
</mark><br><mark>
</mark><br><mark>void ocpnFloatingToolbarDialog::RePosition()
</mark><br><mark>{
</mark><br><mark>    if(m_block) return;
</mark><br><mark>
</mark><br><mark>    if( m_pparent && m_ptoolbar ) {
</mark><br><mark>        wxSize cs = m_pparent->GetClientSize();
</mark><br><mark>        if( -1 == m_dock_x ) m_position.x = 0;
</mark><br><mark>        else
</mark><br><mark>            if( 1 == m_dock_x ) m_position.x = cs.x - GetSize().x;
</mark><br><mark>
</mark><br><mark>        if( -1 == m_dock_y ) m_position.y = 0;
</mark><br><mark>        else
</mark><br><mark>            if( 1 == m_dock_y ) m_position.y = cs.y - GetSize().y;
</mark><br><mark>
</mark><br><mark>        m_position.x = wxMin(cs.x - GetSize().x, m_position.x);
</mark><br><mark>        m_position.y = wxMin(cs.y - GetSize().y, m_position.y);
</mark><br><mark>
</mark><br><mark>        m_position.x = wxMax(0, m_position.x);
</mark><br><mark>        m_position.y = wxMax(0, m_position.y);
</mark><br><mark>
</mark><br><mark>        wxPoint screen_pos = m_pparent->ClientToScreen( m_position );
</mark><br><mark>
</mark><br><mark>        Move( screen_pos );
</mark><br><mark>
</mark><br><mark>#ifdef __WXQT__
</mark><br><mark>        Raise();
</mark><br><mark>#endif
</mark><br><mark>
</mark><br><mark>    }
</mark><br><mark>}
</mark><br><mark>
</mark><br><mark>void ocpnFloatingToolbarDialog::Submerge()
</mark><br><mark>{
</mark><br><mark>    m_bsubmerged = true;
</mark><br><mark>    Hide();
</mark><br><mark>    if( m_ptoolbar ) m_ptoolbar->KillTooltip();
</mark><br><mark>}
</mark><br><mark>
</mark><br><mark>void ocpnFloatingToolbarDialog::SubmergeToGrabber()
</mark><br><mark>{
</mark><br><mark>//Submerge();
</mark><br><mark>    m_bsubmerged = true;
</mark><br><mark>    Hide();
</mark><br><mark>    if( m_ptoolbar ) m_ptoolbar->KillTooltip();
</mark><br><mark>
</mark><br><mark>    m_pRecoverwin = new GrabberWin( m_pparent, this, m_sizefactor, _T("grabber_ext" ), wxPoint(10,10) );
</mark><br><mark>   
</mark><br><mark>    m_pRecoverwin->Show();
</mark><br><mark>    m_pRecoverwin->Raise();
</mark><br><mark>#ifdef __WXQT__
</mark><br><mark>    wxSize s = gFrame->GetSize();
</mark><br><mark>    m_recoversize = s;
</mark><br><mark>    s.y--;
</mark><br><mark>    gFrame->TriggerResize(s);
</mark><br><mark>    Raise();
</mark><br><mark>#endif    
</mark><br><mark>
</mark><br><mark>    gFrame->Refresh();          // Needed for MSW OpenGL
</mark><br><mark>}
</mark><br><mark>
</mark><br><mark>void ocpnFloatingToolbarDialog::Surface()
</mark><br><mark>{
</mark><br><mark>    
</mark><br><mark>    if(m_pRecoverwin){
</mark><br><mark>        m_pRecoverwin->Show();
</mark><br><mark>        m_pRecoverwin->Raise();
</mark><br><mark>    }
</mark><br><mark>    else {
</mark><br><mark>        m_bsubmerged = false;
</mark><br><mark>        #ifndef __WXOSX__
</mark><br><mark>        Hide();
</mark><br><mark>        Move( 0, 0 );
</mark><br><mark>        #endif
</mark><br><mark>
</mark><br><mark>        RePosition();
</mark><br><mark>        Show();
</mark><br><mark>        if( m_ptoolbar )
</mark><br><mark>            m_ptoolbar->EnableTooltips();
</mark><br><mark>
</mark><br><mark>        #ifdef __WXQT__
</mark><br><mark>        Raise();
</mark><br><mark>        #endif
</mark><br><mark>    }
</mark><br><mark>    
</mark><br><mark>    if( m_bAutoHideToolbar && (m_nAutoHideToolbar > 0) ){
</mark><br><mark>        m_fade_timer.Start( m_nAutoHideToolbar * 1000 );
</mark><br><mark>    }
</mark><br><mark>}
</mark><br><mark>
</mark><br><mark>bool ocpnFloatingToolbarDialog::CheckSurfaceRequest( wxMouseEvent &event )
</mark><br><mark>{
</mark><br><mark>    if( m_bsubmerged ){
</mark><br><mark>        if( event.LeftUp() ){
</mark><br><mark>            int x,y;
</mark><br><mark>            event.GetPosition( &x, &y );
</mark><br><mark>            if( m_pRecoverwin ){
</mark><br><mark>                wxRect winRect = m_pRecoverwin->GetRect();
</mark><br><mark>                if( winRect.Contains( x, y ) ){
</mark><br><mark>                    SurfaceFromGrabber();
</mark><br><mark>                    return true;
</mark><br><mark>                }
</mark><br><mark>            }
</mark><br><mark>        }
</mark><br><mark>    }
</mark><br><mark>    
</mark><br><mark>    return false;
</mark><br><mark>}
</mark><br><mark>        
</mark><br><mark>void ocpnFloatingToolbarDialog::SurfaceFromGrabber()
</mark><br><mark>{
</mark><br><mark>    m_bsubmerged = false;
</mark><br><mark>    
</mark><br><mark>#ifndef __WXOSX__
</mark><br><mark>    Hide();
</mark><br><mark>    Move( 0, 0 );
</mark><br><mark>#endif
</mark><br><mark>
</mark><br><mark>    if( m_ptoolbar )
</mark><br><mark>        m_ptoolbar->InvalidateBitmaps();
</mark><br><mark>    
</mark><br><mark>    RePosition();
</mark><br><mark>    Show();
</mark><br><mark>    if( m_ptoolbar )
</mark><br><mark>        m_ptoolbar->EnableTooltips();
</mark><br><mark>    
</mark><br><mark>    if( m_bAutoHideToolbar && (m_nAutoHideToolbar > 0) ){
</mark><br><mark>        m_fade_timer.Start( m_nAutoHideToolbar * 1000 );
</mark><br><mark>    }
</mark><br><mark>    
</mark><br><mark>#ifdef __WXQT__
</mark><br><mark>    wxSize s = gFrame->GetSize();               // check for rotation
</mark><br><mark>    if(m_recoversize.x == s.x)
</mark><br><mark>        gFrame->TriggerResize(m_recoversize);
</mark><br><mark>    Raise();
</mark><br><mark>#endif
</mark><br><mark>    
</mark><br><mark>    m_destroyGrabber = m_pRecoverwin;
</mark><br><mark>    m_destroyTimer.Start( 5, wxTIMER_ONE_SHOT );           //  Destor the unneeded recovery grabber
</mark><br><mark>    
</mark><br><mark>}
</mark><br><mark>
</mark><br><mark>void ocpnFloatingToolbarDialog::DestroyTimerEvent( wxTimerEvent& event )
</mark><br><mark>{
</mark><br><mark>    delete m_destroyGrabber;
</mark><br><mark>    m_destroyGrabber = NULL;
</mark><br><mark>    m_pRecoverwin = NULL;
</mark><br><mark>}
</mark><br><mark>
</mark><br><mark>void ocpnFloatingToolbarDialog::HideTooltip()
</mark><br><mark>{
</mark><br><mark>    if( m_ptoolbar ) m_ptoolbar->HideTooltip();
</mark><br><mark>}
</mark><br><mark>
</mark><br><mark>void ocpnFloatingToolbarDialog::ShowTooltips()
</mark><br><mark>{
</mark><br><mark>    if( m_ptoolbar ) m_ptoolbar->EnableTooltips();
</mark><br><mark>}
</mark><br><mark>
</mark><br><mark>void ocpnFloatingToolbarDialog::ToggleOrientation()
</mark><br><mark>{
</mark><br><mark>    if( m_orient == wxTB_HORIZONTAL )
</mark><br><mark>        m_orient = wxTB_VERTICAL;
</mark><br><mark>    else
</mark><br><mark>        m_orient = wxTB_HORIZONTAL;
</mark><br><mark>
</mark><br><mark>    m_style->SetOrientation( m_orient );
</mark><br><mark>
</mark><br><mark>    wxPoint old_screen_pos = m_pparent->ClientToScreen( m_position );
</mark><br><mark>    wxPoint grabber_point_abs = ClientToScreen( m_pGrabberwin->GetPosition() );
</mark><br><mark>
</mark><br><mark>    gFrame->RequestNewToolbar();
</mark><br><mark>    wxPoint pos_abs = grabber_point_abs;
</mark><br><mark>    pos_abs.x -= m_pGrabberwin->GetPosition().x;
</mark><br><mark>    MoveDialogInScreenCoords( pos_abs, old_screen_pos );
</mark><br><mark>
</mark><br><mark>
</mark><br><mark>    Show();   // this seems to be necessary on GTK to kick the sizer into gear...(FS#553)
</mark><br><mark>    Refresh(true);
</mark><br><mark>    Raise();
</mark><br><mark>}
</mark><br><mark>
</mark><br><mark>void ocpnFloatingToolbarDialog::MouseEvent( wxMouseEvent& event )
</mark><br><mark>{
</mark><br><mark>    if( g_bTransparentToolbar ) {
</mark><br><mark>        if( event.Entering() && ( m_opacity < 255 ) ) {
</mark><br><mark>            SetTransparent( 255 );
</mark><br><mark>            m_opacity = 255;
</mark><br><mark>        }
</mark><br><mark>
</mark><br><mark>        m_fade_timer.Start( 5000 );           // retrigger the continuous timer
</mark><br><mark>    }
</mark><br><mark>    
</mark><br><mark>    if(m_bAutoHideToolbar && (m_nAutoHideToolbar > 0) ){
</mark><br><mark>        m_fade_timer.Start( m_nAutoHideToolbar * 1000 );
</mark><br><mark>    }
</mark><br><mark>}
</mark><br><mark>
</mark><br><mark>void ocpnFloatingToolbarDialog::FadeTimerEvent( wxTimerEvent& event )
</mark><br><mark>{
</mark><br><mark>    if(m_bnavgrabber){
</mark><br><mark>        m_fade_timer.Start( 5000 );           // do nothing if nav grabber is shown
</mark><br><mark>    }
</mark><br><mark>    else{
</mark><br><mark>        if( g_bTransparentToolbar && (!g_bopengl || g_bTransparentToolbarInOpenGLOK) ){
</mark><br><mark>            DoFade( 128 );
</mark><br><mark>            m_fade_timer.Start( 5000 );           // retrigger the continuous timer
</mark><br><mark>        }
</mark><br><mark>        
</mark><br><mark>        if(m_bAutoHideToolbar && (m_nAutoHideToolbar > 0) && !m_bsubmerged){
</mark><br><mark>            SubmergeToGrabber();
</mark><br><mark>//            m_fade_timer.Stop();
</mark><br><mark>        }
</mark><br><mark>    }
</mark><br><mark>}
</mark><br><mark>
</mark><br><mark>void ocpnFloatingToolbarDialog::SetAutoHideTimer(int time)
</mark><br><mark>{
</mark><br><mark>    m_nAutoHideToolbar = time;
</mark><br><mark>    if(m_bAutoHideToolbar){
</mark><br><mark>        m_fade_timer.Stop();
</mark><br><mark>        m_fade_timer.Start( m_nAutoHideToolbar * 1000 );
</mark><br><mark>    }
</mark><br><mark>}
</mark><br><mark>        
</mark><br><mark>void ocpnFloatingToolbarDialog::DoFade( int value )
</mark><br><mark>{
</mark><br><mark>    if( value != m_opacity ) SetTransparent( value );
</mark><br><mark>    m_opacity = value;
</mark><br><mark>}
</mark><br><mark>
</mark><br><mark>void ocpnFloatingToolbarDialog::RefreshFadeTimer()
</mark><br><mark>{
</mark><br><mark>    SetTransparent( 255 );
</mark><br><mark>    m_opacity = 255;
</mark><br><mark>    m_fade_timer.Start( 500 );           // retrigger the continuous timer
</mark><br><mark>    
</mark><br><mark>    if(m_bAutoHideToolbar && (m_nAutoHideToolbar > 0) ){
</mark><br><mark>        m_fade_timer.Start( m_nAutoHideToolbar * 1000 );
</mark><br><mark>    }
</mark><br><mark>    
</mark><br><mark>}
</mark><br><mark>
</mark><br><mark>void ocpnFloatingToolbarDialog::MoveDialogInScreenCoords( wxPoint posn, wxPoint posn_old )
</mark><br><mark>{
</mark><br><mark>    wxPoint pos_in_parent = m_pparent->ScreenToClient( posn );
</mark><br><mark>    wxPoint pos_in_parent_old = m_pparent->ScreenToClient( posn_old );
</mark><br><mark>
</mark><br><mark>    //    "Docking" support
</mark><br><mark>#define DOCK_MARGIN 40
</mark><br><mark>
</mark><br><mark>    // X
</mark><br><mark>    m_dock_x = 0;
</mark><br><mark>    if( pos_in_parent.x < pos_in_parent_old.x )            // moving left
</mark><br><mark>            {
</mark><br><mark>        if( pos_in_parent.x < DOCK_MARGIN ) {
</mark><br><mark>            pos_in_parent.x = 0;
</mark><br><mark>            m_dock_x = -1;
</mark><br><mark>        }
</mark><br><mark>    } else
</mark><br><mark>        if( pos_in_parent.x > pos_in_parent_old.x )            // moving right
</mark><br><mark>                {
</mark><br><mark>            int max_right = m_pparent->GetClientSize().x - GetSize().x;
</mark><br><mark>            if( pos_in_parent.x > ( max_right - DOCK_MARGIN ) ) {
</mark><br><mark>                pos_in_parent.x = max_right;
</mark><br><mark>                m_dock_x = 1;
</mark><br><mark>            }
</mark><br><mark>        }
</mark><br><mark>
</mark><br><mark>    // Y
</mark><br><mark>    m_dock_y = 0;
</mark><br><mark>    if( pos_in_parent.y < pos_in_parent_old.y )            // moving up
</mark><br><mark>            {
</mark><br><mark>        if( pos_in_parent.y < DOCK_MARGIN ) {
</mark><br><mark>            pos_in_parent.y = 0;
</mark><br><mark>            m_dock_y = -1;
</mark><br><mark>        }
</mark><br><mark>    } else
</mark><br><mark>        if( pos_in_parent.y > pos_in_parent_old.y )            // moving down
</mark><br><mark>                {
</mark><br><mark>            int max_down = m_pparent->GetClientSize().y - GetSize().y;
</mark><br><mark>            if( pos_in_parent.y > ( max_down - DOCK_MARGIN ) ) {
</mark><br><mark>                pos_in_parent.y = max_down;
</mark><br><mark>                m_dock_y = 1;
</mark><br><mark>            }
</mark><br><mark>        }
</mark><br><mark>
</mark><br><mark>    m_position = pos_in_parent;
</mark><br><mark>
</mark><br><mark>    wxPoint final_pos = m_pparent->ClientToScreen( pos_in_parent );
</mark><br><mark>
</mark><br><mark>    Move( final_pos );
</mark><br><mark>}
</mark><br><mark>
</mark><br><mark>void ocpnFloatingToolbarDialog::Realize()
</mark><br><mark>{
</mark><br><mark>    if( m_ptoolbar ) {
</mark><br><mark>        m_ptoolbar->Realize();
</mark><br><mark>
</mark><br><mark>        m_topSizer->Clear();
</mark><br><mark>        m_topSizer->Add( m_ptoolbar );
</mark><br><mark>        m_topSizer->Add( m_pGrabberwin, 0, wxTOP, m_style->GetTopMargin() );
</mark><br><mark>
</mark><br><mark>        m_topSizer->Layout();
</mark><br><mark>        Fit();
</mark><br><mark>
</mark><br><mark>        //    Update "Dock" parameters
</mark><br><mark>        if( m_position.x == 0 ) m_dock_x = -1;
</mark><br><mark>        else
</mark><br><mark>            if( m_position.x == m_pparent->GetClientSize().x - GetSize().x ) m_dock_x = 1;
</mark><br><mark>
</mark><br><mark>        if( m_position.y == 0 ) m_dock_y = -1;
</mark><br><mark>        else
</mark><br><mark>            if( m_position.y == m_pparent->GetClientSize().y - GetSize().y ) m_dock_y = 1;
</mark><br><mark>
</mark><br><mark>        // Now create a bitmap mask forthe frame shape.
</mark><br><mark>
</mark><br><mark>        if( m_marginsInvisible ) {
</mark><br><mark>
</mark><br><mark>            wxSize tool_size = m_ptoolbar->GetToolBitmapSize();
</mark><br><mark>
</mark><br><mark>            //  Determine whether the tool icons are meant (by style) to join without speces between
</mark><br><mark>            //  This will determine what type of region to draw.
</mark><br><mark>            bool b_overlap = false;
</mark><br><mark>
</mark><br><mark>            wxToolBarToolsList::compatibility_iterator node1 = m_ptoolbar->m_tools.GetFirst();
</mark><br><mark>            wxToolBarToolsList::compatibility_iterator node2 = node1->GetNext() ;
</mark><br><mark>
</mark><br><mark>            wxToolBarToolBase *tool1 = node1->GetData();
</mark><br><mark>            ocpnToolBarTool *tools1 = (ocpnToolBarTool *) tool1;
</mark><br><mark>
</mark><br><mark>            wxToolBarToolBase *tool2 = node2->GetData();
</mark><br><mark>            ocpnToolBarTool *tools2 = (ocpnToolBarTool *) tool2;
</mark><br><mark>
</mark><br><mark>            if( (tools1->m_x + tools1->m_width) >= tools2->m_x)
</mark><br><mark>                b_overlap = true;
</mark><br><mark>
</mark><br><mark>
</mark><br><mark>
</mark><br><mark>
</mark><br><mark>            int toolCount = m_ptoolbar->GetVisibleToolCount();
</mark><br><mark>
</mark><br><mark>            wxPoint upperLeft( m_style->GetLeftMargin(), m_style->GetTopMargin() );
</mark><br><mark>            wxSize visibleSize;
</mark><br><mark>            if( m_ptoolbar->IsVertical() ) {
</mark><br><mark>                int noTools = m_ptoolbar->GetMaxRows();
</mark><br><mark>                if( noTools > toolCount )
</mark><br><mark>                    noTools = toolCount;
</mark><br><mark>                visibleSize.x = m_ptoolbar->GetLineCount() * ( tool_size.x + m_style->GetTopMargin() );
</mark><br><mark>                visibleSize.y = noTools * ( tool_size.y + m_style->GetToolSeparation() );
</mark><br><mark>                visibleSize.x -= m_style->GetTopMargin();
</mark><br><mark>                visibleSize.y -= m_style->GetToolSeparation();
</mark><br><mark>            } else {
</mark><br><mark>                    int noTools = m_ptoolbar->GetMaxCols();
</mark><br><mark>                    if( noTools > toolCount )
</mark><br><mark>                        noTools = toolCount;
</mark><br><mark>                visibleSize.x = noTools * ( tool_size.x + m_style->GetToolSeparation() );
</mark><br><mark>                visibleSize.y = m_ptoolbar->GetLineCount() * ( tool_size.y + m_style->GetTopMargin() );
</mark><br><mark>                visibleSize.x -= m_style->GetToolSeparation();
</mark><br><mark>                visibleSize.y -= m_style->GetTopMargin();
</mark><br><mark>            }
</mark><br><mark>
</mark><br><mark>            wxBitmap shape( visibleSize.x + tool_size.x, visibleSize.y + tool_size.y);          // + fluff
</mark><br><mark>            wxMemoryDC sdc( shape );
</mark><br><mark>            sdc.SetBackground( *wxWHITE_BRUSH );
</mark><br><mark>            sdc.SetBrush( *wxBLACK_BRUSH );
</mark><br><mark>            sdc.SetPen( *wxBLACK_PEN );
</mark><br><mark>            sdc.Clear();
</mark><br><mark>
</mark><br><mark>            if(b_overlap) {
</mark><br><mark>                int lines = m_ptoolbar->GetLineCount();
</mark><br><mark>                for( int i = 1; i <= lines; i++ ) {
</mark><br><mark>                    if( m_ptoolbar->IsVertical() ) {
</mark><br><mark>                        wxSize barsize( tool_size.x, visibleSize.y );
</mark><br><mark>                        if( i == lines && i > 1 ) {
</mark><br><mark>                            int toolsInLastLine = toolCount % m_ptoolbar->GetMaxRows();
</mark><br><mark>                            if( toolsInLastLine == 0 ) toolsInLastLine = m_ptoolbar->GetMaxRows();
</mark><br><mark>                            int emptySpace = ( m_ptoolbar->GetMaxRows() - toolsInLastLine );
</mark><br><mark>                            barsize.y -= emptySpace
</mark><br><mark>                            * ( tool_size.y + m_style->GetToolSeparation() );
</mark><br><mark>                        }
</mark><br><mark>                        if( i == lines ) {
</mark><br><mark>                            // Also do grabber here, since it is to the right of the last line.
</mark><br><mark>                            wxRect grabMask( upperLeft, barsize );
</mark><br><mark>                            grabMask.width += m_style->GetIcon( _T("grabber") ).GetWidth();
</mark><br><mark>                            grabMask.height = m_style->GetIcon( _T("grabber") ).GetHeight();
</mark><br><mark>                            sdc.DrawRoundedRectangle( grabMask, m_style->GetToolbarCornerRadius() );
</mark><br><mark>                        }
</mark><br><mark>                        sdc.DrawRoundedRectangle( upperLeft, barsize,
</mark><br><mark>                                m_style->GetToolbarCornerRadius() );
</mark><br><mark>                        upperLeft.x += m_style->GetTopMargin() + tool_size.x;
</mark><br><mark>                    } else {
</mark><br><mark>                        wxSize barsize( visibleSize.x, tool_size.y );
</mark><br><mark>
</mark><br><mark>                        if( i == 1 ) {
</mark><br><mark>                            barsize.x += m_style->GetIcon( _T("grabber") ).GetWidth();
</mark><br><mark>                        }
</mark><br><mark>                        if( i == lines && i > 1 ) {
</mark><br><mark>                            int toolsInLastLine = toolCount % m_ptoolbar->GetMaxCols();
</mark><br><mark>                            if( toolsInLastLine == 0 ) toolsInLastLine = m_ptoolbar->GetMaxCols();
</mark><br><mark>                            int emptySpace = ( m_ptoolbar->GetMaxCols() - toolsInLastLine );
</mark><br><mark>                            barsize.x -= emptySpace * ( tool_size.x + m_style->GetToolSeparation() );
</mark><br><mark>                        }
</mark><br><mark>
</mark><br><mark>                        sdc.DrawRoundedRectangle( upperLeft, barsize,
</mark><br><mark>                                m_style->GetToolbarCornerRadius() );
</mark><br><mark>                        upperLeft.y += m_style->GetTopMargin() + tool_size.y;
</mark><br><mark>                    }
</mark><br><mark>                }
</mark><br><mark>            } //b_overlap
</mark><br><mark>            else {
</mark><br><mark>                for( wxToolBarToolsList::compatibility_iterator node = m_ptoolbar->m_tools.GetFirst(); node; node = node->GetNext() ) {
</mark><br><mark>                    wxToolBarToolBase *tool = node->GetData();
</mark><br><mark>                    ocpnToolBarTool *tools = (ocpnToolBarTool *) tool;
</mark><br><mark>                    wxRect toolRect = tools->trect;
</mark><br><mark>
</mark><br><mark>                    sdc.DrawRoundedRectangle( tools->m_x, tools->m_y, tool_size.x, tool_size.y,
</mark><br><mark>                                              m_style->GetToolbarCornerRadius() );
</mark><br><mark>                }
</mark><br><mark>            }
</mark><br><mark>
</mark><br><mark>#ifndef __OCPN__ANDROID__
</mark><br><mark>            if(shape.GetWidth() && shape.GetHeight())
</mark><br><mark>                SetShape( wxRegion( shape, *wxWHITE, 10 ) );
</mark><br><mark>#endif
</mark><br><mark>        }
</mark><br><mark>    }
</mark><br><mark>}
</mark><br><mark>
</mark><br><mark>void ocpnFloatingToolbarDialog::OnToolLeftClick( wxCommandEvent& event )
</mark><br><mark>{
</mark><br><mark>    // First see if it was actually the context menu that was clicked.
</mark><br><mark>
</mark><br><mark>    if( event.GetId() >= ID_PLUGIN_BASE + 100 ) {
</mark><br><mark>
</mark><br><mark>        int itemId = event.GetId() - ID_PLUGIN_BASE - 100;
</mark><br><mark>        wxMenuItem *item = g_FloatingToolbarConfigMenu->FindItem( event.GetId() );
</mark><br><mark>
</mark><br><mark>        if(item){
</mark><br><mark>            bool toolIsChecked = item->IsChecked();
</mark><br><mark>
</mark><br><mark>            if( toolIsChecked ) {
</mark><br><mark>                g_toolbarConfig.SetChar( itemId, _T('X') );
</mark><br><mark>            } else {
</mark><br><mark>
</mark><br><mark>                if( itemId + ID_ZOOMIN == ID_MOB ) {
</mark><br><mark>                    ToolbarMOBDialog mdlg( this );
</mark><br><mark>                    int dialog_ret = mdlg.ShowModal();
</mark><br><mark>                    int answer = mdlg.GetSelection();
</mark><br><mark>
</mark><br><mark>                    if( answer == 0 || answer == 1 || dialog_ret == wxID_CANCEL ) {
</mark><br><mark>                        g_FloatingToolbarConfigMenu->FindItem( event.GetId() )->Check( true );
</mark><br><mark>                        if( answer == 1 && dialog_ret == wxID_OK ) {
</mark><br><mark>                            g_bPermanentMOBIcon = true;
</mark><br><mark>                            delete g_FloatingToolbarConfigMenu;
</mark><br><mark>                            g_FloatingToolbarConfigMenu = new wxMenu();
</mark><br><mark>                            toolbarConfigChanged = true;
</mark><br><mark>                        }
</mark><br><mark>                        return;
</mark><br><mark>                    }
</mark><br><mark>                }
</mark><br><mark>
</mark><br><mark>                if( m_ptoolbar->GetVisibleToolCount() == 1 ) {
</mark><br><mark>                    OCPNMessageBox( this,
</mark><br><mark>                            _("You can't hide the last tool from the toolbar\nas this would make it inaccessible."),
</mark><br><mark>                            _("OpenCPN Alert"), wxOK );
</mark><br><mark>                    g_FloatingToolbarConfigMenu->FindItem( event.GetId() )->Check( true );
</mark><br><mark>                    return;
</mark><br><mark>                }
</mark><br><mark>
</mark><br><mark>                g_toolbarConfig.SetChar( itemId, _T('.') );
</mark><br><mark>            }
</mark><br><mark>        }
</mark><br><mark>
</mark><br><mark>        toolbarConfigChanged = true;
</mark><br><mark>        return;
</mark><br><mark>    }
</mark><br><mark>
</mark><br><mark>    // No it was a button that was clicked.
</mark><br><mark>    // Since Dialog events don't propagate automatically, we send it explicitly
</mark><br><mark>    // (instead of relying on event.Skip()). Send events up the window hierarchy
</mark><br><mark>
</mark><br><mark>    m_pparent->GetEventHandler()->AddPendingEvent( event );
</mark><br><mark>#ifndef __WXQT__
</mark><br><mark>    gFrame->Raise();
</mark><br><mark>#endif    
</mark><br><mark>}
</mark><br><mark>
</mark><br><mark>ocpnToolBarSimple *ocpnFloatingToolbarDialog::GetToolbar()
</mark><br><mark>{
</mark><br><mark>    if( !m_ptoolbar ) {
</mark><br><mark>        long winstyle = wxNO_BORDER | wxTB_FLAT;
</mark><br><mark>        winstyle |= m_orient;
</mark><br><mark>
</mark><br><mark>        m_ptoolbar = new ocpnToolBarSimple( this, -1, wxPoint( -1, -1 ), wxSize( -1, -1 ),
</mark><br><mark>                winstyle );
</mark><br><mark>
</mark><br><mark>        m_ptoolbar->SetBackgroundColour( GetGlobalColor( _T("GREY2") ) );
</mark><br><mark>        m_ptoolbar->ClearBackground();
</mark><br><mark>        m_ptoolbar->SetToggledBackgroundColour( GetGlobalColor( _T("GREY1") ) );
</mark><br><mark>        m_ptoolbar->SetColorScheme( m_cs );
</mark><br><mark>
</mark><br><mark>        SetGeometry(false, wxRect());
</mark><br><mark>    }
</mark><br><mark>
</mark><br><mark>    return m_ptoolbar;
</mark><br><mark>}
</mark><br><mark>
</mark><br><mark>void ocpnFloatingToolbarDialog::DestroyToolBar()
</mark><br><mark>{
</mark><br><mark>    if( m_ptoolbar ) {
</mark><br><mark>        m_ptoolbar->ClearTools();
</mark><br><mark>        delete m_ptoolbar;                  //->Destroy();
</mark><br><mark>        m_ptoolbar = NULL;
</mark><br><mark>    }
</mark><br><mark> 
</mark><br><mark>    m_destroyGrabber = m_pRecoverwin;
</mark><br><mark>    m_destroyTimer.Start( 5, wxTIMER_ONE_SHOT );           //  Destor the unneeded recovery grabber
</mark><br><mark>    
</mark><br><mark>}
</mark><br><mark>
</mark><br><mark>//----------------------------------------------------------------------------
</mark><br><mark>// Toolbar Tooltip Popup Window Definition
</mark><br><mark>//----------------------------------------------------------------------------
</mark><br><mark>class ToolTipWin: public wxDialog {
</mark><br><mark>public:
</mark><br><mark>    ToolTipWin( wxWindow *parent );
</mark><br><mark>    ~ToolTipWin();
</mark><br><mark>
</mark><br><mark>    void OnPaint( wxPaintEvent& event );
</mark><br><mark>
</mark><br><mark>    void SetColorScheme( ColorScheme cs );
</mark><br><mark>    void SetString( wxString &s )
</mark><br><mark>    {
</mark><br><mark>        m_string = s;
</mark><br><mark>    }
</mark><br><mark>    void SetPosition( wxPoint pt )
</mark><br><mark>    {
</mark><br><mark>        m_position = pt;
</mark><br><mark>    }
</mark><br><mark>    void SetBitmap( void );
</mark><br><mark>
</mark><br><mark>    void SetHiviz( bool hiviz){ m_hiviz = hiviz; }
</mark><br><mark>    
</mark><br><mark>    wxSize GetRenderedSize( void );
</mark><br><mark>    
</mark><br><mark>private:
</mark><br><mark>
</mark><br><mark>    wxString m_string;
</mark><br><mark>    wxSize m_size;
</mark><br><mark>    wxPoint m_position;
</mark><br><mark>    wxBitmap *m_pbm;
</mark><br><mark>    wxColour m_back_color;
</mark><br><mark>    wxColour m_text_color;
</mark><br><mark>    ColorScheme m_cs ;
</mark><br><mark>    bool m_hiviz;
</mark><br><mark>
</mark><br><mark>DECLARE_EVENT_TABLE()
</mark><br><mark>};
</mark><br><mark>//-----------------------------------------------------------------------
</mark><br><mark>//
</mark><br><mark>//    Toolbar Tooltip window implementation
</mark><br><mark>//
</mark><br><mark>//-----------------------------------------------------------------------
</mark><br><mark>BEGIN_EVENT_TABLE(ToolTipWin, wxDialog) EVT_PAINT(ToolTipWin::OnPaint)
</mark><br><mark>
</mark><br><mark>END_EVENT_TABLE()
</mark><br><mark>
</mark><br><mark>// Define a constructor
</mark><br><mark>ToolTipWin::ToolTipWin( wxWindow *parent ) :
</mark><br><mark>        wxDialog( parent, wxID_ANY, _T(""), wxPoint( 0, 0 ), wxSize( 1, 1 ),
</mark><br><mark>                wxNO_BORDER | wxSTAY_ON_TOP )
</mark><br><mark>{
</mark><br><mark>    m_pbm = NULL;
</mark><br><mark>
</mark><br><mark>    m_back_color = GetGlobalColor( _T ( "UIBCK" ) );
</mark><br><mark>    m_text_color = GetGlobalColor( _T ( "UITX1" ) );
</mark><br><mark>
</mark><br><mark>    SetBackgroundStyle( wxBG_STYLE_CUSTOM );
</mark><br><mark>    SetBackgroundColour( m_back_color );
</mark><br><mark>    m_cs = GLOBAL_COLOR_SCHEME_RGB;
</mark><br><mark>
</mark><br><mark>    Hide();
</mark><br><mark>}
</mark><br><mark>
</mark><br><mark>ToolTipWin::~ToolTipWin()
</mark><br><mark>{
</mark><br><mark>    delete m_pbm;
</mark><br><mark>}
</mark><br><mark>
</mark><br><mark>void ToolTipWin::SetColorScheme( ColorScheme cs )
</mark><br><mark>{
</mark><br><mark>    m_back_color = GetGlobalColor( _T ( "UIBCK" ) );
</mark><br><mark>    m_text_color = FontMgr::Get().GetFontColor( _("ToolTips") );
</mark><br><mark>
</mark><br><mark>    m_cs = cs;
</mark><br><mark>}
</mark><br><mark>
</mark><br><mark>wxSize ToolTipWin::GetRenderedSize( void )
</mark><br><mark>{
</mark><br><mark>    int h, w;
</mark><br><mark>    wxSize sz;
</mark><br><mark>
</mark><br><mark>    wxClientDC cdc( GetParent() );
</mark><br><mark>
</mark><br><mark>    wxFont *plabelFont = FontMgr::Get().GetFont( _("ToolTips") );
</mark><br><mark>    cdc.GetTextExtent( m_string, &w, &h, NULL, NULL, plabelFont );
</mark><br><mark>
</mark><br><mark>    sz.x = w + 8;
</mark><br><mark>    sz.y = h + 4;
</mark><br><mark>    
</mark><br><mark>    return sz;
</mark><br><mark>
</mark><br><mark>}
</mark><br><mark>
</mark><br><mark>void ToolTipWin::SetBitmap()
</mark><br><mark>{
</mark><br><mark>    int h, w;
</mark><br><mark>
</mark><br><mark>    wxClientDC cdc( GetParent() );
</mark><br><mark>
</mark><br><mark>    wxFont *plabelFont = FontMgr::Get().GetFont( _("ToolTips") );
</mark><br><mark>    cdc.GetTextExtent( m_string, &w, &h, NULL, NULL, plabelFont );
</mark><br><mark>
</mark><br><mark>    m_size.x = w + 8;
</mark><br><mark>    m_size.y = h + 4;
</mark><br><mark>
</mark><br><mark>    wxMemoryDC mdc;
</mark><br><mark>
</mark><br><mark>    delete m_pbm;
</mark><br><mark>    m_pbm = new wxBitmap( m_size.x, m_size.y, -1 );
</mark><br><mark>    mdc.SelectObject( *m_pbm );
</mark><br><mark>
</mark><br><mark>    wxPen pborder( m_text_color );
</mark><br><mark>    wxBrush bback( m_back_color );
</mark><br><mark>    mdc.SetPen( pborder );
</mark><br><mark>    mdc.SetBrush( bback );
</mark><br><mark>
</mark><br><mark>    if(m_hiviz){
</mark><br><mark>        if((m_cs == GLOBAL_COLOR_SCHEME_DUSK) || (m_cs == GLOBAL_COLOR_SCHEME_NIGHT)){
</mark><br><mark>            wxBrush hv_back( wxColour(200,200,200));
</mark><br><mark>            mdc.SetBrush( hv_back );
</mark><br><mark>        }
</mark><br><mark>    }
</mark><br><mark>    mdc.DrawRectangle( 0, 0, m_size.x, m_size.y );
</mark><br><mark>
</mark><br><mark>    //    Draw the text
</mark><br><mark>    mdc.SetFont( *plabelFont );
</mark><br><mark>    mdc.SetTextForeground( m_text_color );
</mark><br><mark>    mdc.SetTextBackground( m_back_color );
</mark><br><mark>
</mark><br><mark>    mdc.DrawText( m_string, 4, 2 );
</mark><br><mark>
</mark><br><mark>    SetSize( m_position.x, m_position.y, m_size.x, m_size.y );
</mark><br><mark>
</mark><br><mark>}
</mark><br><mark>
</mark><br><mark>void ToolTipWin::OnPaint( wxPaintEvent& event )
</mark><br><mark>{
</mark><br><mark>    int width, height;
</mark><br><mark>    GetClientSize( &width, &height );
</mark><br><mark>    wxPaintDC dc( this );
</mark><br><mark>
</mark><br><mark>    if( m_string.Len() ) {
</mark><br><mark>        wxMemoryDC mdc;
</mark><br><mark>        mdc.SelectObject( *m_pbm );
</mark><br><mark>        dc.Blit( 0, 0, width, height, &mdc, 0, 0 );
</mark><br><mark>    }
</mark><br><mark>}
</mark><br><mark>
</mark><br><mark>
</mark><br><mark>// ----------------------------------------------------------------------------
</mark><br><mark>BEGIN_EVENT_TABLE(ocpnToolBarSimple, wxControl) EVT_SIZE(ocpnToolBarSimple::OnSize)
</mark><br><mark>EVT_PAINT(ocpnToolBarSimple::OnPaint)
</mark><br><mark>EVT_KILL_FOCUS(ocpnToolBarSimple::OnKillFocus)
</mark><br><mark>EVT_MOUSE_EVENTS(ocpnToolBarSimple::OnMouseEvent)
</mark><br><mark>EVT_TIMER(TOOLTIPON_TIMER, ocpnToolBarSimple::OnToolTipTimerEvent)
</mark><br><mark>EVT_TIMER(TOOLTIPOFF_TIMER, ocpnToolBarSimple::OnToolTipOffTimerEvent)
</mark><br><mark>
</mark><br><mark>END_EVENT_TABLE()
</mark><br><mark>
</mark><br><mark>// ============================================================================
</mark><br><mark>// implementation
</mark><br><mark>// ============================================================================
</mark><br><mark>
</mark><br><mark>// ----------------------------------------------------------------------------
</mark><br><mark>// tool bar tools creation
</mark><br><mark>// ----------------------------------------------------------------------------
</mark><br><mark>
</mark><br><mark>wxToolBarToolBase *ocpnToolBarSimple::CreateTool( int id, const wxString& label,
</mark><br><mark>        const wxBitmap& bmpNormal, const wxBitmap& bmpDisabled, wxItemKind kind,
</mark><br><mark>        wxObject *clientData, const wxString& shortHelp, const wxString& longHelp )
</mark><br><mark>{
</mark><br><mark>    return new ocpnToolBarTool( this, id, label, bmpNormal, bmpDisabled, kind, clientData,
</mark><br><mark>            shortHelp, longHelp );
</mark><br><mark>}
</mark><br><mark>
</mark><br><mark>// ----------------------------------------------------------------------------
</mark><br><mark>// ocpnToolBarSimple creation
</mark><br><mark>// ----------------------------------------------------------------------------
</mark><br><mark>
</mark><br><mark>void ocpnToolBarSimple::Init()
</mark><br><mark>{
</mark><br><mark>    m_currentRowsOrColumns = 0;
</mark><br><mark>
</mark><br><mark>    m_lastX = m_lastY = 0;
</mark><br><mark>
</mark><br><mark>    m_maxWidth = m_maxHeight = 0;
</mark><br><mark>
</mark><br><mark>    m_pressedTool = m_currentTool = -1;
</mark><br><mark>
</mark><br><mark>    m_xPos = m_yPos = wxDefaultCoord;
</mark><br><mark>
</mark><br><mark>    m_style = g_StyleManager->GetCurrentStyle();
</mark><br><mark>
</mark><br><mark>    m_defaultWidth = 16;
</mark><br><mark>    m_defaultHeight = 15;
</mark><br><mark>
</mark><br><mark>    m_toggle_bg_color = wxSystemSettings::GetColour( wxSYS_COLOUR_3DFACE );
</mark><br><mark>    m_toolOutlineColour.Set( _T("BLACK") );
</mark><br><mark>    m_pToolTipWin = NULL;
</mark><br><mark>    m_last_ro_tool = NULL;
</mark><br><mark>
</mark><br><mark>    m_btoolbar_is_zooming = false;
</mark><br><mark>    m_sizefactor = 1.0f;
</mark><br><mark>
</mark><br><mark>    m_last_plugin_down_id = -1;
</mark><br><mark>    
</mark><br><mark>    EnableTooltips();
</mark><br><mark>}
</mark><br><mark>
</mark><br><mark>wxToolBarToolBase *ocpnToolBarSimple::DoAddTool( int id, const wxString& label,
</mark><br><mark>        const wxBitmap& bitmap, const wxBitmap& bmpDisabled, wxItemKind kind,
</mark><br><mark>        const wxString& shortHelp, const wxString& longHelp, wxObject *clientData, wxCoord xPos,
</mark><br><mark>        wxCoord yPos )
</mark><br><mark>{
</mark><br><mark>    // rememeber the position for DoInsertTool()
</mark><br><mark>    m_xPos = xPos;
</mark><br><mark>    m_yPos = yPos;
</mark><br><mark>
</mark><br><mark>    InvalidateBestSize();
</mark><br><mark>    return InsertTool( GetToolsCount(), id, label, bitmap, bmpDisabled, kind, shortHelp, longHelp,
</mark><br><mark>            clientData );
</mark><br><mark>
</mark><br><mark>}
</mark><br><mark>
</mark><br><mark>///
</mark><br><mark>
</mark><br><mark>wxToolBarToolBase *ocpnToolBarSimple::AddTool( int toolid, const wxString& label,
</mark><br><mark>        const wxBitmap& bitmap, const wxBitmap& bmpDisabled, wxItemKind kind,
</mark><br><mark>        const wxString& shortHelp, const wxString& longHelp, wxObject *data )
</mark><br><mark>{
</mark><br><mark>    InvalidateBestSize();
</mark><br><mark>    ocpnToolBarTool* tool = (ocpnToolBarTool*)InsertTool( GetToolsCount(), toolid, label, bitmap, bmpDisabled, kind,
</mark><br><mark>            shortHelp, longHelp, data );
</mark><br><mark>    return tool;
</mark><br><mark>}
</mark><br><mark>
</mark><br><mark>wxToolBarToolBase *ocpnToolBarSimple::InsertTool( size_t pos, int id, const wxString& label,
</mark><br><mark>        const wxBitmap& bitmap, const wxBitmap& bmpDisabled, wxItemKind kind,
</mark><br><mark>        const wxString& shortHelp, const wxString& longHelp, wxObject *clientData )
</mark><br><mark>{
</mark><br><mark>    wxCHECK_MSG( pos <= GetToolsCount(), (wxToolBarToolBase *)NULL,
</mark><br><mark>            _T("invalid position in wxToolBar::InsertTool()") );
</mark><br><mark>
</mark><br><mark>    wxToolBarToolBase *tool = CreateTool( id, label, bitmap, bmpDisabled, kind, clientData,
</mark><br><mark>            shortHelp, longHelp );
</mark><br><mark>
</mark><br><mark>    if( !InsertTool( pos, tool ) ) {
</mark><br><mark>        delete tool;
</mark><br><mark>
</mark><br><mark>        return NULL;
</mark><br><mark>    }
</mark><br><mark>
</mark><br><mark>    return tool;
</mark><br><mark>}
</mark><br><mark>
</mark><br><mark>wxToolBarToolBase *ocpnToolBarSimple::InsertTool( size_t pos, wxToolBarToolBase *tool )
</mark><br><mark>{
</mark><br><mark>    wxCHECK_MSG( pos <= GetToolsCount(), (wxToolBarToolBase *)NULL,
</mark><br><mark>            _T("invalid position in wxToolBar::InsertTool()") );
</mark><br><mark>
</mark><br><mark>    if( !tool || !DoInsertTool( pos, tool ) ) {
</mark><br><mark>        return NULL;
</mark><br><mark>    }
</mark><br><mark>
</mark><br><mark>    m_tools.Insert( pos, tool );
</mark><br><mark>
</mark><br><mark>    return tool;
</mark><br><mark>}
</mark><br><mark>
</mark><br><mark>bool ocpnToolBarSimple::DoInsertTool( size_t WXUNUSED(pos), wxToolBarToolBase *toolBase )
</mark><br><mark>{
</mark><br><mark>    ocpnToolBarTool *tool = (ocpnToolBarTool *) toolBase;
</mark><br><mark>
</mark><br><mark>    // Check if the plugin is inserting same-named tools. Make sure they have different names,
</mark><br><mark>    // otherwise the style manager cannot differentiate between them.
</mark><br><mark>    if( tool->isPluginTool ) {
</mark><br><mark>        for( unsigned int i=0; i<GetToolsCount(); i++ ) {
</mark><br><mark>            if( tool->GetToolname() == ((ocpnToolBarTool *)m_tools.Item(i)->GetData())->GetToolname()) {
</mark><br><mark>                tool->toolname << _T("1");
</mark><br><mark>            }
</mark><br><mark>        }
</mark><br><mark>    }
</mark><br><mark>
</mark><br><mark>    tool->m_x = m_xPos;
</mark><br><mark>    if( tool->m_x == wxDefaultCoord ) tool->m_x = m_style->GetLeftMargin();
</mark><br><mark>
</mark><br><mark>    tool->m_y = m_yPos;
</mark><br><mark>    if( tool->m_y == wxDefaultCoord ) tool->m_y = m_style->GetTopMargin();
</mark><br><mark>
</mark><br><mark>    if( tool->IsButton() ) {
</mark><br><mark>        tool->SetSize( GetToolSize() );
</mark><br><mark>
</mark><br><mark>        // Calculate reasonable max size in case Layout() not called
</mark><br><mark>        if( ( tool->m_x + tool->GetNormalBitmap().GetWidth() + m_style->GetLeftMargin() )
</mark><br><mark>                > m_maxWidth ) m_maxWidth = (wxCoord) ( ( tool->m_x + tool->GetWidth()
</mark><br><mark>                + m_style->GetLeftMargin() ) );
</mark><br><mark>
</mark><br><mark>        if( ( tool->m_y + tool->GetNormalBitmap().GetHeight() + m_style->GetTopMargin() )
</mark><br><mark>                > m_maxHeight ) m_maxHeight = (wxCoord) ( ( tool->m_y + tool->GetHeight()
</mark><br><mark>                + m_style->GetTopMargin() ) );
</mark><br><mark>    }
</mark><br><mark>
</mark><br><mark>    else
</mark><br><mark>        if( tool->IsControl() ) {
</mark><br><mark>            tool->SetSize( tool->GetControl()->GetSize() );
</mark><br><mark>        }
</mark><br><mark>
</mark><br><mark>    tool->b_hilite = false;
</mark><br><mark>
</mark><br><mark>    return true;
</mark><br><mark>}
</mark><br><mark>
</mark><br><mark>bool ocpnToolBarSimple::DoDeleteTool( size_t WXUNUSED(pos), wxToolBarToolBase *tool )
</mark><br><mark>{
</mark><br><mark>    // VZ: didn't test whether it works, but why not...
</mark><br><mark>    tool->Detach();
</mark><br><mark>
</mark><br><mark>    if( m_last_ro_tool == tool ) m_last_ro_tool = NULL;
</mark><br><mark>
</mark><br><mark>    Refresh( false );
</mark><br><mark>
</mark><br><mark>    return true;
</mark><br><mark>}
</mark><br><mark>
</mark><br><mark>bool ocpnToolBarSimple::Create( wxWindow *parent, wxWindowID id, const wxPoint& pos,
</mark><br><mark>        const wxSize& size, long style, const wxString& name )
</mark><br><mark>{
</mark><br><mark>    if( !wxWindow::Create( parent, id, pos, size, style, name ) ) return false;
</mark><br><mark>
</mark><br><mark>    // Set it to grey (or other 3D face colour)
</mark><br><mark>    SetBackgroundColour( wxSystemSettings::GetColour( wxSYS_COLOUR_3DFACE ) );
</mark><br><mark>
</mark><br><mark>    if( GetWindowStyleFlag() & wxTB_VERTICAL ) {
</mark><br><mark>        m_lastX = 7;
</mark><br><mark>        m_lastY = 3;
</mark><br><mark>
</mark><br><mark>        m_maxRows = 32000;      // a lot
</mark><br><mark>        m_maxCols = 1;
</mark><br><mark>    } else {
</mark><br><mark>        m_lastX = 3;
</mark><br><mark>        m_lastY = 7;
</mark><br><mark>
</mark><br><mark>        m_maxRows = 1;
</mark><br><mark>        m_maxCols = 32000;      // a lot
</mark><br><mark>    }
</mark><br><mark>
</mark><br><mark>    SetCursor( *wxSTANDARD_CURSOR );
</mark><br><mark>
</mark><br><mark>    m_tooltip_timer.SetOwner( this, TOOLTIPON_TIMER );
</mark><br><mark>    m_tooltipoff_timer.SetOwner( this, TOOLTIPOFF_TIMER );
</mark><br><mark>    m_tooltip_off = 3000;
</mark><br><mark>
</mark><br><mark>    return true;
</mark><br><mark>}
</mark><br><mark>
</mark><br><mark>ocpnToolBarSimple::~ocpnToolBarSimple()
</mark><br><mark>{
</mark><br><mark>    if( m_pToolTipWin ) {
</mark><br><mark>        m_pToolTipWin->Destroy();
</mark><br><mark>        m_pToolTipWin = NULL;
</mark><br><mark>    }
</mark><br><mark>
</mark><br><mark>}
</mark><br><mark>
</mark><br><mark>void ocpnToolBarSimple::KillTooltip()
</mark><br><mark>{
</mark><br><mark>    m_btooltip_show = false;
</mark><br><mark>
</mark><br><mark>    if( m_pToolTipWin ) {
</mark><br><mark>        m_pToolTipWin->Hide();
</mark><br><mark>        m_pToolTipWin->Destroy();
</mark><br><mark>        m_pToolTipWin = NULL;
</mark><br><mark>    }
</mark><br><mark>    m_tooltip_timer.Stop();
</mark><br><mark>
</mark><br><mark>    if( m_last_ro_tool ) {
</mark><br><mark>        if( m_last_ro_tool->IsEnabled() ) {
</mark><br><mark>            if( m_last_ro_tool->IsToggled() ) {
</mark><br><mark>                m_last_ro_tool->SetNormalBitmap( m_style->GetToolIcon( m_last_ro_tool->GetToolname(), TOOLICON_TOGGLED ) );
</mark><br><mark>            }
</mark><br><mark>            else {
</mark><br><mark>                m_last_ro_tool->SetNormalBitmap( m_style->GetToolIcon( m_last_ro_tool->GetToolname(), TOOLICON_NORMAL ) );
</mark><br><mark>            }
</mark><br><mark>        }
</mark><br><mark>    }
</mark><br><mark>}
</mark><br><mark>
</mark><br><mark>void ocpnToolBarSimple::HideTooltip()
</mark><br><mark>{
</mark><br><mark>    if( m_pToolTipWin ) {
</mark><br><mark>        m_pToolTipWin->Hide();
</mark><br><mark>    }
</mark><br><mark>}
</mark><br><mark>
</mark><br><mark>void ocpnToolBarSimple::SetColorScheme( ColorScheme cs )
</mark><br><mark>{
</mark><br><mark>    if( m_pToolTipWin ) {
</mark><br><mark>        m_pToolTipWin->Destroy();
</mark><br><mark>        m_pToolTipWin = NULL;
</mark><br><mark>    }
</mark><br><mark>
</mark><br><mark>    m_toolOutlineColour = GetGlobalColor( _T("UIBDR") );
</mark><br><mark>
</mark><br><mark>    m_currentColorScheme = cs;
</mark><br><mark>}
</mark><br><mark>
</mark><br><mark>bool ocpnToolBarSimple::Realize()
</mark><br><mark>{
</mark><br><mark>    m_currentRowsOrColumns = 0;
</mark><br><mark>    m_LineCount = 1;
</mark><br><mark>    m_lastX = m_style->GetLeftMargin();
</mark><br><mark>    m_lastY = m_style->GetTopMargin();
</mark><br><mark>    m_maxWidth = 0;
</mark><br><mark>    m_maxHeight = 0;
</mark><br><mark>
</mark><br><mark>    if( IsVertical() ) m_style->SetOrientation( wxTB_VERTICAL );
</mark><br><mark>    else
</mark><br><mark>        m_style->SetOrientation( wxTB_HORIZONTAL );
</mark><br><mark>
</mark><br><mark>    wxSize toolSize = wxSize(-1, -1);
</mark><br><mark>    int separatorSize = m_style->GetToolSeparation();
</mark><br><mark>
</mark><br><mark>    ocpnToolBarTool *lastTool = NULL;
</mark><br><mark>    bool firstNode = true;
</mark><br><mark>    wxToolBarToolsList::compatibility_iterator node = m_tools.GetFirst();
</mark><br><mark>
</mark><br><mark>    while( node ) {
</mark><br><mark>        ocpnToolBarTool *tool = (ocpnToolBarTool *) node->GetData();
</mark><br><mark>
</mark><br><mark>        // Set the tool size to be the size of the first non-separator tool, usually the first one
</mark><br><mark>        if(toolSize.x == -1){
</mark><br><mark>            if( !tool->IsSeparator() ){
</mark><br><mark>                toolSize.x = tool->m_width;
</mark><br><mark>                toolSize.y = tool->m_height;
</mark><br><mark>            }
</mark><br><mark>        }
</mark><br><mark>
</mark><br><mark>        tool->firstInLine = firstNode;
</mark><br><mark>        tool->lastInLine = false;
</mark><br><mark>        firstNode = false;
</mark><br><mark>
</mark><br><mark>        tool->last_rect.width = 0;              // mark it invalid
</mark><br><mark>        
</mark><br><mark>        if( tool->IsSeparator() ) {
</mark><br><mark>            if( GetWindowStyleFlag() & wxTB_HORIZONTAL ) {
</mark><br><mark>                if( m_currentRowsOrColumns >= m_maxCols ) m_lastY += separatorSize;
</mark><br><mark>                else
</mark><br><mark>                    m_lastX += separatorSize;
</mark><br><mark>            } else {
</mark><br><mark>                if( m_currentRowsOrColumns >= m_maxRows ) m_lastX += separatorSize;
</mark><br><mark>                else
</mark><br><mark>                    m_lastY += separatorSize;
</mark><br><mark>            }
</mark><br><mark>        } else
</mark><br><mark>            if( tool->IsButton() ) {
</mark><br><mark>                if( !IsVertical() ) {
</mark><br><mark>                    if( m_currentRowsOrColumns >= m_maxCols ) {
</mark><br><mark>                        tool->firstInLine = true;
</mark><br><mark>                        if( lastTool && m_LineCount > 1 ) lastTool->lastInLine = true;
</mark><br><mark>                        m_LineCount++;
</mark><br><mark>                        m_currentRowsOrColumns = 0;
</mark><br><mark>                        m_lastX = m_style->GetLeftMargin();
</mark><br><mark>                        m_lastY += toolSize.y + m_style->GetTopMargin();
</mark><br><mark>                    }
</mark><br><mark>                    tool->m_x = (wxCoord) m_lastX;
</mark><br><mark>                    tool->m_y = (wxCoord) m_lastY;
</mark><br><mark>
</mark><br><mark>                    tool->trect = wxRect( tool->m_x, tool->m_y, toolSize.x, toolSize.y );
</mark><br><mark>                    tool->trect.Inflate( m_style->GetToolSeparation() / 2,
</mark><br><mark>                            m_style->GetTopMargin() );
</mark><br><mark>
</mark><br><mark>                    m_lastX += toolSize.x + m_style->GetToolSeparation();
</mark><br><mark>                } else {
</mark><br><mark>                    if( m_currentRowsOrColumns >= m_maxRows ) {
</mark><br><mark>                        tool->firstInLine = true;
</mark><br><mark>                        if( lastTool ) lastTool->lastInLine = true;
</mark><br><mark>                        m_LineCount++;
</mark><br><mark>                        m_currentRowsOrColumns = 0;
</mark><br><mark>                        m_lastX += toolSize.x + m_style->GetTopMargin();
</mark><br><mark>                        m_lastY = m_style->GetTopMargin();
</mark><br><mark>                    }
</mark><br><mark>                    tool->m_x = (wxCoord) m_lastX;
</mark><br><mark>                    tool->m_y = (wxCoord) m_lastY;
</mark><br><mark>
</mark><br><mark>                    tool->trect = wxRect( tool->m_x, tool->m_y, toolSize.x, toolSize.y );
</mark><br><mark>                    tool->trect.Inflate( m_style->GetToolSeparation() / 2,
</mark><br><mark>                            m_style->GetTopMargin() );
</mark><br><mark>
</mark><br><mark>                    m_lastY += toolSize.y + m_style->GetToolSeparation();
</mark><br><mark>                }
</mark><br><mark>                m_currentRowsOrColumns++;
</mark><br><mark>            } else
</mark><br><mark>                if( tool->IsControl() ) {
</mark><br><mark>                    tool->m_x = (wxCoord) ( m_lastX );
</mark><br><mark>                    tool->m_y = (wxCoord) ( m_lastY - ( m_style->GetTopMargin() / 2 ) );
</mark><br><mark>
</mark><br><mark>                    tool->trect = wxRect( tool->m_x, tool->m_y, tool->GetWidth(),
</mark><br><mark>                            tool->GetHeight() );
</mark><br><mark>                    tool->trect.Inflate( m_style->GetToolSeparation() / 2,
</mark><br><mark>                            m_style->GetTopMargin() );
</mark><br><mark>                    ;
</mark><br><mark>
</mark><br><mark>                    wxSize s = tool->GetControl()->GetSize();
</mark><br><mark>                    m_lastX += s.x + m_style->GetToolSeparation();
</mark><br><mark>
</mark><br><mark>                }
</mark><br><mark>
</mark><br><mark>        if( m_lastX > m_maxWidth ) m_maxWidth = m_lastX;
</mark><br><mark>        if( m_lastY > m_maxHeight ) m_maxHeight = m_lastY;
</mark><br><mark>
</mark><br><mark>        lastTool = tool;
</mark><br><mark>        node = node->GetNext();
</mark><br><mark>    }
</mark><br><mark>    if( lastTool && (m_LineCount > 1 || IsVertical()) )
</mark><br><mark>        lastTool->lastInLine = true;
</mark><br><mark>
</mark><br><mark>    if( GetWindowStyleFlag() & wxTB_HORIZONTAL ) m_maxHeight += toolSize.y;
</mark><br><mark>    else
</mark><br><mark>        m_maxWidth += toolSize.x;
</mark><br><mark>
</mark><br><mark>    m_maxWidth += m_style->GetRightMargin();
</mark><br><mark>    m_maxHeight += m_style->GetBottomMargin();
</mark><br><mark>
</mark><br><mark>    SetSize( m_maxWidth, m_maxHeight );
</mark><br><mark>    SetMinSize( wxSize( m_maxWidth, m_maxHeight ) );
</mark><br><mark>
</mark><br><mark>    return true;
</mark><br><mark>}
</mark><br><mark>
</mark><br><mark>// ----------------------------------------------------------------------------
</mark><br><mark>// event handlers
</mark><br><mark>// ----------------------------------------------------------------------------
</mark><br><mark>
</mark><br><mark>void ocpnToolBarSimple::OnPaint( wxPaintEvent& WXUNUSED(event) )
</mark><br><mark>{
</mark><br><mark>    wxPaintDC dc( this );
</mark><br><mark>    PrepareDC( dc );
</mark><br><mark>
</mark><br><mark>    wxRegion ru = GetUpdateRegion();
</mark><br><mark>    wxRect upRect = ru.GetBox();
</mark><br><mark>
</mark><br><mark>    static int count = 0;
</mark><br><mark>    // Prevent reentry of OnPaint which would cause wxMemoryDC errors.
</mark><br><mark>    if( count > 0 ) return;
</mark><br><mark>    count++;
</mark><br><mark>
</mark><br><mark>    for( wxToolBarToolsList::compatibility_iterator node = m_tools.GetFirst(); node;
</mark><br><mark>            node = node->GetNext() ) {
</mark><br><mark>        wxToolBarToolBase *tool = node->GetData();
</mark><br><mark>        ocpnToolBarTool *tools = (ocpnToolBarTool *) tool;
</mark><br><mark>        wxRect toolRect = tools->trect;
</mark><br><mark>
</mark><br><mark>        if( toolRect.Intersects( upRect ) ) {
</mark><br><mark>
</mark><br><mark>            if( tool->IsButton() ) {
</mark><br><mark>                DrawTool( dc, tool );
</mark><br><mark>            } else
</mark><br><mark>                if( tool->IsControl() ) {
</mark><br><mark>                    if( tool->GetControl()->IsKindOf( CLASSINFO(wxStaticBitmap) ) ) {
</mark><br><mark>                        wxStaticBitmap *psbm = (wxStaticBitmap *) tool->GetControl();
</mark><br><mark>                        ocpnToolBarTool *toolsimp = (ocpnToolBarTool *) tool;
</mark><br><mark>                        dc.DrawBitmap( psbm->GetBitmap(), toolsimp->m_x, toolsimp->m_y, false );
</mark><br><mark>                    }
</mark><br><mark>                }
</mark><br><mark>        }
</mark><br><mark>    }
</mark><br><mark>
</mark><br><mark>    count--;
</mark><br><mark>}
</mark><br><mark>
</mark><br><mark>void ocpnToolBarSimple::OnSize( wxSizeEvent& WXUNUSED(event) )
</mark><br><mark>{
</mark><br><mark>    if( GetAutoLayout() ) Layout();
</mark><br><mark>}
</mark><br><mark>
</mark><br><mark>void ocpnToolBarSimple::OnKillFocus( wxFocusEvent& WXUNUSED(event) )
</mark><br><mark>{
</mark><br><mark>    OnMouseEnter( m_pressedTool = m_currentTool = -1 );
</mark><br><mark>}
</mark><br><mark>
</mark><br><mark>void ocpnToolBarSimple::OnToolTipTimerEvent( wxTimerEvent& event )
</mark><br><mark>{
</mark><br><mark>    if( !gFrame->IsActive() ) return;
</mark><br><mark>
</mark><br><mark>    if( m_btooltip_show && IsShown() && m_pToolTipWin && ( !m_pToolTipWin->IsShown() ) ) {
</mark><br><mark>        if( m_last_ro_tool ) {
</mark><br><mark>            wxString s = m_last_ro_tool->GetShortHelp();
</mark><br><mark>
</mark><br><mark>            if( s.Len() ) {
</mark><br><mark>                m_pToolTipWin->SetString( s );
</mark><br><mark>                m_pToolTipWin->SetHiviz(m_last_ro_tool->m_btooltip_hiviz);
</mark><br><mark>
</mark><br><mark>                wxPoint pos_in_toolbar( m_last_ro_tool->m_x, m_last_ro_tool->m_y );
</mark><br><mark>                pos_in_toolbar.x += m_last_ro_tool->m_width + 2;
</mark><br><mark>
</mark><br><mark>                m_pToolTipWin->Move(0,0);       // workaround for gtk autocentre dialog behavior
</mark><br><mark>
</mark><br><mark>                wxPoint screenPosition = ClientToScreen( pos_in_toolbar );
</mark><br><mark>                wxPoint framePosition = gFrame->ScreenToClient(screenPosition);
</mark><br><mark>                wxSize tipSize = m_pToolTipWin->GetRenderedSize();
</mark><br><mark>                
</mark><br><mark>                if( (framePosition.x + tipSize.x) > gFrame->GetSize().x)
</mark><br><mark>                    screenPosition.x -= (tipSize.x + m_last_ro_tool->m_width + 4);
</mark><br><mark>                
</mark><br><mark>                m_pToolTipWin->SetPosition( screenPosition );
</mark><br><mark>                m_pToolTipWin->SetBitmap();
</mark><br><mark>                m_pToolTipWin->Show();
</mark><br><mark>                gFrame->Raise();
</mark><br><mark>                if( g_btouch )
</mark><br><mark>                    m_tooltipoff_timer.Start(m_tooltip_off, wxTIMER_ONE_SHOT);
</mark><br><mark>            }
</mark><br><mark>        }
</mark><br><mark>    }
</mark><br><mark>}
</mark><br><mark>
</mark><br><mark>void ocpnToolBarSimple::OnToolTipOffTimerEvent( wxTimerEvent& event )
</mark><br><mark>{
</mark><br><mark>    HideTooltip();
</mark><br><mark>}
</mark><br><mark>
</mark><br><mark>
</mark><br><mark>int s_dragx, s_dragy;
</mark><br><mark>
</mark><br><mark>void ocpnToolBarSimple::OnMouseEvent( wxMouseEvent & event )
</mark><br><mark>{
</mark><br><mark>#ifdef __OCPN__ANDROID__
</mark><br><mark>    if(!event.IsButton())
</mark><br><mark>        return;
</mark><br><mark>#endif
</mark><br><mark>
</mark><br><mark>    wxCoord x, y;
</mark><br><mark>    event.GetPosition( &x, &y );
</mark><br><mark>    ocpnToolBarTool *tool = (ocpnToolBarTool *) FindToolForPosition( x, y );
</mark><br><mark>
</mark><br><mark>#ifndef __OCPN__ANDROID__
</mark><br><mark>    if( event.LeftDown() ) {
</mark><br><mark>        CaptureMouse();
</mark><br><mark>        s_dragx = x;
</mark><br><mark>        s_dragy = y;
</mark><br><mark>    }
</mark><br><mark>    if( event.LeftUp() ) {
</mark><br><mark>        if( HasCapture() ) ReleaseMouse();
</mark><br><mark>    }
</mark><br><mark>#endif
</mark><br><mark>
</mark><br><mark>    if( tool && tool->IsButton() && IsShown() ) {
</mark><br><mark>
</mark><br><mark>        //    ToolTips
</mark><br><mark>        if( NULL == m_pToolTipWin ) {
</mark><br><mark>            m_pToolTipWin = new ToolTipWin( GetParent() );
</mark><br><mark>            m_pToolTipWin->SetColorScheme( m_currentColorScheme );
</mark><br><mark>            m_pToolTipWin->Hide();
</mark><br><mark>        }
</mark><br><mark>
</mark><br><mark>        if( tool != m_last_ro_tool ) m_pToolTipWin->Hide();
</mark><br><mark>
</mark><br><mark>#ifndef __OCPN__ANDROID__
</mark><br><mark>        if( !m_pToolTipWin->IsShown() ) {
</mark><br><mark>            m_tooltip_timer.Start( m_one_shot, wxTIMER_ONE_SHOT );
</mark><br><mark>        }
</mark><br><mark>#endif
</mark><br><mark>
</mark><br><mark>        //    Tool Rollover highlighting
</mark><br><mark>        if(!g_btouch){
</mark><br><mark>            if( tool != m_last_ro_tool ) {
</mark><br><mark>                if( tool->IsEnabled() ) {
</mark><br><mark>                    tool->rollover = true;
</mark><br><mark>                    tool->bitmapOK = false;
</mark><br><mark>                }
</mark><br><mark>                if( m_last_ro_tool ) {
</mark><br><mark>                    if( m_last_ro_tool->IsEnabled() ) {
</mark><br><mark>                        m_last_ro_tool->rollover = false;
</mark><br><mark>                        m_last_ro_tool->bitmapOK = false;
</mark><br><mark>                    }
</mark><br><mark>                }
</mark><br><mark>                m_last_ro_tool = tool;
</mark><br><mark>                if(g_toolbar)
</mark><br><mark>                    g_toolbar->Refresh( false );
</mark><br><mark>            }
</mark><br><mark>        }
</mark><br><mark>    } else {
</mark><br><mark>        //    Tooltips
</mark><br><mark>        if( m_pToolTipWin && m_pToolTipWin->IsShown() ) m_pToolTipWin->Hide();
</mark><br><mark>
</mark><br><mark>        //    Remove Highlighting
</mark><br><mark>        if( m_last_ro_tool ) {
</mark><br><mark>            if( m_last_ro_tool->IsEnabled() ) {
</mark><br><mark>                m_last_ro_tool->rollover = false;
</mark><br><mark>                m_last_ro_tool->bitmapOK = false;
</mark><br><mark>            }
</mark><br><mark>            g_toolbar->Refresh( false );
</mark><br><mark>        }
</mark><br><mark>    }
</mark><br><mark>
</mark><br><mark>    m_last_ro_tool = tool;
</mark><br><mark>
</mark><br><mark>    // allow smooth zooming while toolbutton is held down
</mark><br><mark>    if(g_bsmoothpanzoom && !g_btouch) {
</mark><br><mark>        if(event.LeftUp() && m_btoolbar_is_zooming) {
</mark><br><mark>            cc1->StopMovement();
</mark><br><mark>            m_btoolbar_is_zooming = false;
</mark><br><mark>            return;
</mark><br><mark>        }
</mark><br><mark>
</mark><br><mark>        if( event.LeftDown() && tool &&
</mark><br><mark>            (tool->GetId() == ID_ZOOMIN || tool->GetId() == ID_ZOOMOUT) ) {
</mark><br><mark>            cc1->ZoomCanvas( tool->GetId() == ID_ZOOMIN ? 2.0 : .5, false, false );
</mark><br><mark>            m_btoolbar_is_zooming = true;
</mark><br><mark>            return;
</mark><br><mark>        }
</mark><br><mark>    }
</mark><br><mark>
</mark><br><mark>    if( !tool ) {
</mark><br><mark>        if( m_currentTool > -1 ) {
</mark><br><mark>            if( event.LeftIsDown() ) SpringUpButton( m_currentTool );
</mark><br><mark>            m_currentTool = -1;
</mark><br><mark>            OnMouseEnter( -1 );
</mark><br><mark>        }
</mark><br><mark>
</mark><br><mark>        wxMouseEvent *pev = (wxMouseEvent *) event.Clone();
</mark><br><mark>        GetParent()->GetEventHandler()->AddPendingEvent( *pev );
</mark><br><mark>        wxDELETE( pev );
</mark><br><mark>
</mark><br><mark>        return;
</mark><br><mark>    }
</mark><br><mark>
</mark><br><mark>    if( !event.IsButton() ) {
</mark><br><mark>        if( tool->GetId() != m_currentTool ) {
</mark><br><mark>            // If the left button is kept down and moved over buttons,
</mark><br><mark>            // press those buttons.
</mark><br><mark>            if( event.LeftIsDown() && tool->IsEnabled() ) {
</mark><br><mark>                SpringUpButton( m_currentTool );
</mark><br><mark>
</mark><br><mark>                if( tool->CanBeToggled() ) {
</mark><br><mark>                    tool->Toggle();
</mark><br><mark>                }
</mark><br><mark>
</mark><br><mark>                DrawTool( tool );
</mark><br><mark>            }
</mark><br><mark>
</mark><br><mark>            m_currentTool = tool->GetId();
</mark><br><mark>            OnMouseEnter( m_currentTool );
</mark><br><mark>        }
</mark><br><mark>
</mark><br><mark>        wxMouseEvent *pev = (wxMouseEvent *) event.Clone();
</mark><br><mark>        GetParent()->GetEventHandler()->AddPendingEvent( *pev );
</mark><br><mark>        wxDELETE( pev );
</mark><br><mark>
</mark><br><mark>        return;
</mark><br><mark>    }
</mark><br><mark>
</mark><br><mark>    // Left button pressed.
</mark><br><mark>    if( event.LeftDown() && tool->IsEnabled() ) {
</mark><br><mark>        if( tool->CanBeToggled() ) {
</mark><br><mark>            tool->Toggle();
</mark><br><mark>            tool->bitmapOK = false;
</mark><br><mark>            
</mark><br><mark>        }
</mark><br><mark>
</mark><br><mark>        DrawTool( tool );
</mark><br><mark>
</mark><br><mark>        //        Look for PlugIn tools
</mark><br><mark>        //        If found, make the callback.
</mark><br><mark>        if( g_pi_manager ) {
</mark><br><mark>            ArrayOfPlugInToolbarTools tool_array = g_pi_manager->GetPluginToolbarToolArray();
</mark><br><mark>            for( unsigned int i = 0; i < tool_array.GetCount(); i++ ) {
</mark><br><mark>                PlugInToolbarToolContainer *pttc = tool_array.Item( i );
</mark><br><mark>                if( tool->GetId() == pttc->id ) {
</mark><br><mark>                    opencpn_plugin_113 *ppi = dynamic_cast<opencpn_plugin_113 *>(pttc->m_pplugin);
</mark><br><mark>                    if( ppi ) {
</mark><br><mark>                        ppi->OnToolbarToolDownCallback( pttc->id );
</mark><br><mark>                        m_last_plugin_down_id = pttc->id;
</mark><br><mark>                    }
</mark><br><mark>                }
</mark><br><mark>            }
</mark><br><mark>        }
</mark><br><mark>    } else
</mark><br><mark>        if( event.RightDown() ) {
</mark><br><mark>            OnRightClick( tool->GetId(), x, y );
</mark><br><mark>        }
</mark><br><mark>
</mark><br><mark>    // Left Button Released.  Only this action confirms selection.
</mark><br><mark>    // If the button is enabled and it is not a toggle tool and it is
</mark><br><mark>    // in the pressed state, then raise the button and call OnLeftClick.
</mark><br><mark>    //
</mark><br><mark>    if( event.LeftUp() && tool->IsEnabled() ) {
</mark><br><mark>        // Pass the OnLeftClick event to tool
</mark><br><mark>        if( !OnLeftClick( tool->GetId(), tool->IsToggled() ) && tool->CanBeToggled() ) {
</mark><br><mark>            // If it was a toggle, and OnLeftClick says No Toggle allowed,
</mark><br><mark>            // then change it back
</mark><br><mark>            tool->Toggle();
</mark><br><mark>            tool->bitmapOK = false;
</mark><br><mark>        }
</mark><br><mark>
</mark><br><mark>        DoPluginToolUp();
</mark><br><mark>    }
</mark><br><mark>
</mark><br><mark>    wxMouseEvent *pev = (wxMouseEvent *) event.Clone();
</mark><br><mark>    GetParent()->GetEventHandler()->AddPendingEvent( *pev );
</mark><br><mark>    wxDELETE( pev );
</mark><br><mark>    event.Skip();
</mark><br><mark>}
</mark><br><mark>
</mark><br><mark>// ----------------------------------------------------------------------------
</mark><br><mark>// drawing
</mark><br><mark>// ----------------------------------------------------------------------------
</mark><br><mark>
</mark><br><mark>void ocpnToolBarSimple::DrawTool( wxToolBarToolBase *tool )
</mark><br><mark>{
</mark><br><mark>    wxClientDC dc( this );
</mark><br><mark>    DrawTool( dc, tool );
</mark><br><mark>}
</mark><br><mark>
</mark><br><mark>// NB! The current DrawTool code assumes that plugin tools are never disabled
</mark><br><mark>// when they are present on the toolbar, since disabled plugins are removed.
</mark><br><mark>
</mark><br><mark>void ocpnToolBarSimple::DrawTool( wxDC& dc, wxToolBarToolBase *toolBase )
</mark><br><mark>{
</mark><br><mark>    ocpnToolBarTool *tool = (ocpnToolBarTool *) toolBase;
</mark><br><mark>    PrepareDC( dc );
</mark><br><mark>
</mark><br><mark>    wxPoint drawAt( tool->m_x, tool->m_y );
</mark><br><mark>    wxBitmap bmp;
</mark><br><mark>
</mark><br><mark>    if( tool->bitmapOK ) {
</mark><br><mark>        if( tool->IsEnabled() ) {
</mark><br><mark>            bmp = tool->GetNormalBitmap();
</mark><br><mark>            if( !bmp.IsOk() ){
</mark><br><mark>                bmp = m_style->GetToolIcon( tool->GetToolname(), TOOLICON_NORMAL, tool->rollover );
</mark><br><mark>                if(m_sizefactor > 1.0 ){
</mark><br><mark>                    wxImage scaled_image = bmp.ConvertToImage();
</mark><br><mark>                    bmp = wxBitmap(scaled_image.Scale(tool->m_width, tool->m_height, wxIMAGE_QUALITY_HIGH));
</mark><br><mark>                }
</mark><br><mark>                tool->SetNormalBitmap( bmp );
</mark><br><mark>                tool->bitmapOK = true;
</mark><br><mark>            }
</mark><br><mark>        } else {
</mark><br><mark>            bmp = tool->GetDisabledBitmap();
</mark><br><mark>            if( !bmp.IsOk() ){
</mark><br><mark>                bmp = m_style->GetToolIcon( tool->GetToolname(), TOOLICON_DISABLED );
</mark><br><mark>                if(m_sizefactor > 1.0 ){
</mark><br><mark>                    wxImage scaled_image = bmp.ConvertToImage();
</mark><br><mark>                    bmp = wxBitmap(scaled_image.Scale(tool->m_width, tool->m_height, wxIMAGE_QUALITY_HIGH));
</mark><br><mark>                }
</mark><br><mark>                tool->SetDisabledBitmap( bmp );
</mark><br><mark>                tool->bitmapOK = true;
</mark><br><mark>            }
</mark><br><mark>        }
</mark><br><mark>    } else {
</mark><br><mark>        if ( tool->isPluginTool ) {
</mark><br><mark>
</mark><br><mark>            // First try getting the icon from the Style.
</mark><br><mark>            // If it is not in the style we build a new icon from the style BG and the plugin icon.
</mark><br><mark>
</mark><br><mark>            if( tool->IsToggled() ) {
</mark><br><mark>                bmp = m_style->GetToolIcon( tool->GetToolname(), TOOLICON_TOGGLED, tool->rollover );
</mark><br><mark>                if( bmp.GetDepth() == 1 ) {
</mark><br><mark>                    if( tool->rollover ) {
</mark><br><mark>                        bmp = m_style->BuildPluginIcon( tool->pluginRolloverIcon, TOOLICON_TOGGLED );
</mark><br><mark>                        if( ! bmp.IsOk() )
</mark><br><mark>                            bmp = m_style->BuildPluginIcon( tool->pluginNormalIcon, TOOLICON_TOGGLED );
</mark><br><mark>                    }
</mark><br><mark>                    else
</mark><br><mark>                        bmp = m_style->BuildPluginIcon( tool->pluginNormalIcon, TOOLICON_TOGGLED );
</mark><br><mark>                }
</mark><br><mark>            } else {
</mark><br><mark>                bmp = m_style->GetToolIcon( tool->GetToolname(), TOOLICON_NORMAL, tool->rollover );
</mark><br><mark>                if( bmp.GetDepth() == 1 ) {
</mark><br><mark>                    if( tool->rollover ) {
</mark><br><mark>                        bmp = m_style->BuildPluginIcon( tool->pluginRolloverIcon, TOOLICON_NORMAL );
</mark><br><mark>                        if( ! bmp.IsOk() )
</mark><br><mark>                            bmp = m_style->BuildPluginIcon( tool->pluginNormalIcon, TOOLICON_NORMAL );
</mark><br><mark>                    }
</mark><br><mark>                    else
</mark><br><mark>                        bmp = m_style->BuildPluginIcon( tool->pluginNormalIcon, TOOLICON_NORMAL );
</mark><br><mark>                }
</mark><br><mark>            }
</mark><br><mark>            if(m_sizefactor > 1.0 ){
</mark><br><mark>                wxImage scaled_image = bmp.ConvertToImage();
</mark><br><mark>                bmp = wxBitmap(scaled_image.Scale(tool->m_width, tool->m_height, wxIMAGE_QUALITY_HIGH));
</mark><br><mark>            }
</mark><br><mark>            tool->SetNormalBitmap( bmp );
</mark><br><mark>            tool->bitmapOK = true;
</mark><br><mark>        } else {
</mark><br><mark>            if( tool->IsEnabled() ) {
</mark><br><mark>                if( tool->IsToggled() )
</mark><br><mark>                    bmp = m_style->GetToolIcon( tool->GetToolname(), TOOLICON_TOGGLED, tool->rollover );
</mark><br><mark>                else
</mark><br><mark>                    bmp = m_style->GetToolIcon( tool->GetIconName(), TOOLICON_NORMAL, tool->rollover );
</mark><br><mark>
</mark><br><mark>                if(m_sizefactor > 1.0 ){
</mark><br><mark>                    wxImage scaled_image = bmp.ConvertToImage();
</mark><br><mark>                    bmp = wxBitmap(scaled_image.Scale(tool->m_width, tool->m_height, wxIMAGE_QUALITY_HIGH));
</mark><br><mark>                }
</mark><br><mark>                tool->SetNormalBitmap( bmp );
</mark><br><mark>                tool->bitmapOK = true;
</mark><br><mark>            } else {
</mark><br><mark>                bmp = m_style->GetToolIcon( tool->GetToolname(), TOOLICON_DISABLED );
</mark><br><mark>                if(m_sizefactor > 1.0 ){
</mark><br><mark>                    wxImage scaled_image = bmp.ConvertToImage();
</mark><br><mark>                    bmp = wxBitmap(scaled_image.Scale(tool->m_width, tool->m_height, wxIMAGE_QUALITY_HIGH));
</mark><br><mark>                }
</mark><br><mark>                tool->SetDisabledBitmap( bmp );
</mark><br><mark>                tool->bitmapOK = true;
</mark><br><mark>            }
</mark><br><mark>        }
</mark><br><mark>    }
</mark><br><mark>
</mark><br><mark>    if( tool->firstInLine ) {
</mark><br><mark>        m_style->DrawToolbarLineStart( bmp );
</mark><br><mark>    }
</mark><br><mark>    if( tool->lastInLine ) {
</mark><br><mark>        m_style->DrawToolbarLineEnd( bmp );
</mark><br><mark>    }
</mark><br><mark>
</mark><br><mark>    if( bmp.GetWidth() != m_style->GetToolSize().x
</mark><br><mark>            || bmp.GetHeight() != m_style->GetToolSize().y ) {
</mark><br><mark>//        drawAt.x -= ( bmp.GetWidth() - m_style->GetToolSize().x ) / 2;
</mark><br><mark>//        drawAt.y -= ( bmp.GetHeight() - m_style->GetToolSize().y ) / 2;
</mark><br><mark>    }
</mark><br><mark>
</mark><br><mark>    //      Clear the last drawn tool if necessary
</mark><br><mark>    if( tool->last_rect.width && ((tool->last_rect.x != drawAt.x) || (tool->last_rect.y != drawAt.y)) ){
</mark><br><mark>        wxBrush bb(GetGlobalColor( _T("GREY2") ));
</mark><br><mark>        dc.SetBrush(bb);
</mark><br><mark>        dc.SetPen( *wxTRANSPARENT_PEN );
</mark><br><mark>        dc.DrawRectangle(tool->last_rect.x, tool->last_rect.y, tool->last_rect.width, tool->last_rect.height);
</mark><br><mark>    }
</mark><br><mark>
</mark><br><mark>    //  could cache this in the tool...
</mark><br><mark>    //  A bit of a hack here.  We only scale tools if they are to be magnified globally
</mark><br><mark>    if(0/*m_sizefactor > 1.0*/ )
</mark><br><mark>    {
</mark><br><mark>        wxImage scaled_image = bmp.ConvertToImage();
</mark><br><mark>        wxBitmap sbmp = wxBitmap(scaled_image.Scale(tool->m_width, tool->m_height, wxIMAGE_QUALITY_HIGH));
</mark><br><mark>        dc.DrawBitmap( sbmp, drawAt );
</mark><br><mark>        tool->last_rect = wxRect(drawAt.x, drawAt.y, sbmp.GetWidth(), sbmp.GetHeight());
</mark><br><mark>
</mark><br><mark>    }
</mark><br><mark>    else
</mark><br><mark>    {
</mark><br><mark>        dc.DrawBitmap( bmp, drawAt );
</mark><br><mark>        tool->last_rect = wxRect(drawAt.x, drawAt.y, bmp.GetWidth(), bmp.GetHeight());
</mark><br><mark>    }
</mark><br><mark>
</mark><br><mark>}
</mark><br><mark>
</mark><br><mark>// ----------------------------------------------------------------------------
</mark><br><mark>// toolbar geometry
</mark><br><mark>// ----------------------------------------------------------------------------
</mark><br><mark>
</mark><br><mark>wxToolBarToolBase *ocpnToolBarSimple::FindToolForPosition( wxCoord x, wxCoord y )
</mark><br><mark>{
</mark><br><mark>    wxToolBarToolsList::compatibility_iterator node = m_tools.GetFirst();
</mark><br><mark>    while( node ) {
</mark><br><mark>        ocpnToolBarTool *tool = (ocpnToolBarTool *) node->GetData();
</mark><br><mark>        if( ( x >= tool->m_x ) && ( y >= tool->m_y ) && ( x < ( tool->m_x + tool->GetWidth() ) )
</mark><br><mark>                && ( y < ( tool->m_y + tool->GetHeight() ) ) ) {
</mark><br><mark>            return tool;
</mark><br><mark>        }
</mark><br><mark>
</mark><br><mark>        node = node->GetNext();
</mark><br><mark>    }
</mark><br><mark>
</mark><br><mark>    return (wxToolBarToolBase *) NULL;
</mark><br><mark>}
</mark><br><mark>
</mark><br><mark>void ocpnToolBarSimple::InvalidateBitmaps()
</mark><br><mark>{
</mark><br><mark>    wxToolBarToolsList::compatibility_iterator node = m_tools.GetFirst();
</mark><br><mark>    while( node ) {
</mark><br><mark>        ocpnToolBarTool *tool = (ocpnToolBarTool *) node->GetData();
</mark><br><mark>        tool->bitmapOK = false;
</mark><br><mark>        node = node->GetNext();
</mark><br><mark>    }
</mark><br><mark>}
</mark><br><mark>
</mark><br><mark>wxRect ocpnToolBarSimple::GetToolRect( int tool_id )
</mark><br><mark>{
</mark><br><mark>    wxRect rect;
</mark><br><mark>    wxToolBarToolBase *tool = FindById( tool_id );
</mark><br><mark>    if( tool ) {
</mark><br><mark>        ocpnToolBarTool *otool = (ocpnToolBarTool *) tool;
</mark><br><mark>        if( otool ) rect = otool->trect;
</mark><br><mark>    }
</mark><br><mark>
</mark><br><mark>    return rect;
</mark><br><mark>}
</mark><br><mark>
</mark><br><mark>// ----------------------------------------------------------------------------
</mark><br><mark>// tool state change handlers
</mark><br><mark>// ----------------------------------------------------------------------------
</mark><br><mark>
</mark><br><mark>void ocpnToolBarSimple::DoEnableTool( wxToolBarToolBase *tool, bool WXUNUSED(enable) )
</mark><br><mark>{
</mark><br><mark>    DrawTool( tool );
</mark><br><mark>}
</mark><br><mark>
</mark><br><mark>void ocpnToolBarSimple::DoToggleTool( wxToolBarToolBase *tool, bool WXUNUSED(toggle) )
</mark><br><mark>{
</mark><br><mark>    ocpnToolBarTool *t = (ocpnToolBarTool *) tool;
</mark><br><mark>    t->bitmapOK = false;
</mark><br><mark>    DrawTool( tool );
</mark><br><mark>}
</mark><br><mark>
</mark><br><mark>// Okay, so we've left the tool we're in ... we must check if the tool we're
</mark><br><mark>// leaving was a 'sprung push button' and if so, spring it back to the up
</mark><br><mark>// state.
</mark><br><mark>void ocpnToolBarSimple::SpringUpButton( int id )
</mark><br><mark>{
</mark><br><mark>    wxToolBarToolBase *tool = FindById( id );
</mark><br><mark>
</mark><br><mark>    if( tool && tool->CanBeToggled() ) {
</mark><br><mark>        if( tool->IsToggled() ) tool->Toggle();
</mark><br><mark>
</mark><br><mark>        DrawTool( tool );
</mark><br><mark>    }
</mark><br><mark>}
</mark><br><mark>
</mark><br><mark>// ----------------------------------------------------------------------------
</mark><br><mark>// scrolling implementation
</mark><br><mark>// ----------------------------------------------------------------------------
</mark><br><mark>
</mark><br><mark>wxString ocpnToolBarSimple::GetToolShortHelp( int id ) const
</mark><br><mark>{
</mark><br><mark>    wxToolBarToolBase *tool = FindById( id );
</mark><br><mark>    wxCHECK_MSG( tool, wxEmptyString, _T("no such tool") );
</mark><br><mark>
</mark><br><mark>    return tool->GetShortHelp();
</mark><br><mark>}
</mark><br><mark>
</mark><br><mark>wxString ocpnToolBarSimple::GetToolLongHelp( int id ) const
</mark><br><mark>{
</mark><br><mark>    wxToolBarToolBase *tool = FindById( id );
</mark><br><mark>    wxCHECK_MSG( tool, wxEmptyString, _T("no such tool") );
</mark><br><mark>
</mark><br><mark>    return tool->GetLongHelp();
</mark><br><mark>}
</mark><br><mark>
</mark><br><mark>void ocpnToolBarSimple::SetToolShortHelp( int id, const wxString& help )
</mark><br><mark>{
</mark><br><mark>    wxToolBarToolBase *tool = FindById( id );
</mark><br><mark>    if( tool ) {
</mark><br><mark>        (void) tool->SetShortHelp( help );
</mark><br><mark>    }
</mark><br><mark>}
</mark><br><mark>
</mark><br><mark>void ocpnToolBarSimple::SetToolLongHelp( int id, const wxString& help )
</mark><br><mark>{
</mark><br><mark>    wxToolBarToolBase *tool = FindById( id );
</mark><br><mark>    if( tool ) {
</mark><br><mark>        (void) tool->SetLongHelp( help );
</mark><br><mark>    }
</mark><br><mark>}
</mark><br><mark>
</mark><br><mark>int ocpnToolBarSimple::GetToolPos( int id ) const
</mark><br><mark>{
</mark><br><mark>    size_t pos = 0;
</mark><br><mark>    wxToolBarToolsList::compatibility_iterator node;
</mark><br><mark>
</mark><br><mark>    for( node = m_tools.GetFirst(); node; node = node->GetNext() ) {
</mark><br><mark>        if( node->GetData()->GetId() == id ) return pos;
</mark><br><mark>
</mark><br><mark>        pos++;
</mark><br><mark>    }
</mark><br><mark>
</mark><br><mark>    return wxNOT_FOUND;
</mark><br><mark>}
</mark><br><mark>bool ocpnToolBarSimple::GetToolState( int id ) const
</mark><br><mark>{
</mark><br><mark>    wxToolBarToolBase *tool = FindById( id );
</mark><br><mark>    wxCHECK_MSG( tool, false, _T("no such tool") );
</mark><br><mark>
</mark><br><mark>    return tool->IsToggled();
</mark><br><mark>}
</mark><br><mark>
</mark><br><mark>bool ocpnToolBarSimple::GetToolEnabled( int id ) const
</mark><br><mark>{
</mark><br><mark>    wxToolBarToolBase *tool = FindById( id );
</mark><br><mark>    wxCHECK_MSG( tool, false, _T("no such tool") );
</mark><br><mark>
</mark><br><mark>    return tool->IsEnabled();
</mark><br><mark>}
</mark><br><mark>
</mark><br><mark>void ocpnToolBarSimple::ToggleTool( int id, bool toggle )
</mark><br><mark>{
</mark><br><mark>    wxToolBarToolBase *tool = FindById( id );
</mark><br><mark>        
</mark><br><mark>    if( tool && tool->CanBeToggled() && tool->Toggle( toggle ) ) {
</mark><br><mark>        DoToggleTool( tool, toggle );
</mark><br><mark>        if( g_toolbar ) g_toolbar->Refresh();
</mark><br><mark>    }
</mark><br><mark>}
</mark><br><mark>
</mark><br><mark>wxObject *ocpnToolBarSimple::GetToolClientData( int id ) const
</mark><br><mark>{
</mark><br><mark>    wxToolBarToolBase *tool = FindById( id );
</mark><br><mark>    return tool ? tool->GetClientData() : (wxObject *) NULL;
</mark><br><mark>}
</mark><br><mark>
</mark><br><mark>void ocpnToolBarSimple::SetToolClientData( int id, wxObject *clientData )
</mark><br><mark>{
</mark><br><mark>    wxToolBarToolBase *tool = FindById( id );
</mark><br><mark>
</mark><br><mark>    wxCHECK_RET( tool, _T("no such tool in wxToolBar::SetToolClientData") );
</mark><br><mark>
</mark><br><mark>    tool->SetClientData( clientData );
</mark><br><mark>}
</mark><br><mark>
</mark><br><mark>void ocpnToolBarSimple::EnableTool( int id, bool enable )
</mark><br><mark>{
</mark><br><mark>    wxToolBarToolBase *tool = FindById( id );
</mark><br><mark>    if( tool ) {
</mark><br><mark>        if( tool->Enable( enable ) ) {
</mark><br><mark>            DoEnableTool( tool, enable );
</mark><br><mark>        }
</mark><br><mark>    }
</mark><br><mark>    wxMenuItem* configItem = g_FloatingToolbarConfigMenu->FindItem( id );
</mark><br><mark>    configItem->Check( true );
</mark><br><mark>}
</mark><br><mark>
</mark><br><mark>void ocpnToolBarSimple::SetToolBitmaps( int id, wxBitmap *bmp, wxBitmap *bmpRollover )
</mark><br><mark>{
</mark><br><mark>    ocpnToolBarTool *tool = (ocpnToolBarTool*)FindById( id );
</mark><br><mark>    if( tool ) {
</mark><br><mark>        tool->pluginNormalIcon = bmp;
</mark><br><mark>        tool->pluginRolloverIcon = bmpRollover;
</mark><br><mark>        tool->bitmapOK = false;
</mark><br><mark>    }
</mark><br><mark>}
</mark><br><mark>
</mark><br><mark>void ocpnToolBarSimple::SetToolTooltipHiViz( int id, bool b_hiviz )
</mark><br><mark>{
</mark><br><mark>    ocpnToolBarTool *tool = (ocpnToolBarTool*)FindById( id );
</mark><br><mark>    if( tool ) {
</mark><br><mark>        tool->SetTooltipHiviz( b_hiviz );
</mark><br><mark>    }
</mark><br><mark>}
</mark><br><mark>
</mark><br><mark>
</mark><br><mark>void ocpnToolBarSimple::ClearTools()
</mark><br><mark>{
</mark><br><mark>    while( GetToolsCount() ) {
</mark><br><mark>        DeleteToolByPos( 0 );
</mark><br><mark>    }
</mark><br><mark>}
</mark><br><mark>
</mark><br><mark>int ocpnToolBarSimple::GetVisibleToolCount()
</mark><br><mark>{
</mark><br><mark>    int counter = 0;
</mark><br><mark>    wxToolBarToolsList::compatibility_iterator node = m_tools.GetFirst();
</mark><br><mark>    while( node ) {
</mark><br><mark>        ocpnToolBarTool *tool = (ocpnToolBarTool *) node->GetData();
</mark><br><mark>        counter++;
</mark><br><mark>        node = node->GetNext();
</mark><br><mark>    }
</mark><br><mark>    return counter;
</mark><br><mark>}
</mark><br><mark>
</mark><br><mark>bool ocpnToolBarSimple::DeleteToolByPos( size_t pos )
</mark><br><mark>{
</mark><br><mark>    wxCHECK_MSG( pos < GetToolsCount(), false,
</mark><br><mark>            _T("invalid position in wxToolBar::DeleteToolByPos()") );
</mark><br><mark>
</mark><br><mark>    wxToolBarToolsList::compatibility_iterator node = m_tools.Item( pos );
</mark><br><mark>
</mark><br><mark>    if( !DoDeleteTool( pos, node->GetData() ) ) {
</mark><br><mark>        return false;
</mark><br><mark>    }
</mark><br><mark>
</mark><br><mark>    delete node->GetData();
</mark><br><mark>    m_tools.Erase( node );
</mark><br><mark>
</mark><br><mark>    return true;
</mark><br><mark>}
</mark><br><mark>
</mark><br><mark>bool ocpnToolBarSimple::DeleteTool( int id )
</mark><br><mark>{
</mark><br><mark>    size_t pos = 0;
</mark><br><mark>    wxToolBarToolsList::compatibility_iterator node;
</mark><br><mark>    for( node = m_tools.GetFirst(); node; node = node->GetNext() ) {
</mark><br><mark>        if( node->GetData()->GetId() == id ) break;
</mark><br><mark>
</mark><br><mark>        pos++;
</mark><br><mark>    }
</mark><br><mark>
</mark><br><mark>    if( !node || !DoDeleteTool( pos, node->GetData() ) ) {
</mark><br><mark>        return false;
</mark><br><mark>    }
</mark><br><mark>
</mark><br><mark>    delete node->GetData();
</mark><br><mark>    m_tools.Erase( node );
</mark><br><mark>
</mark><br><mark>    return true;
</mark><br><mark>}
</mark><br><mark>
</mark><br><mark>wxToolBarToolBase *ocpnToolBarSimple::AddSeparator()
</mark><br><mark>{
</mark><br><mark>    return InsertSeparator( GetToolsCount() );
</mark><br><mark>}
</mark><br><mark>
</mark><br><mark>wxToolBarToolBase *ocpnToolBarSimple::InsertSeparator( size_t pos )
</mark><br><mark>{
</mark><br><mark>    wxCHECK_MSG( pos <= GetToolsCount(), (wxToolBarToolBase *)NULL,
</mark><br><mark>            _T("invalid position in wxToolBar::InsertSeparator()") );
</mark><br><mark>
</mark><br><mark>    wxToolBarToolBase *tool = CreateTool( wxID_SEPARATOR, wxEmptyString, wxNullBitmap, wxNullBitmap,
</mark><br><mark>            wxITEM_SEPARATOR, (wxObject *) NULL, wxEmptyString, wxEmptyString );
</mark><br><mark>
</mark><br><mark>    if( !tool || !DoInsertTool( pos, tool ) ) {
</mark><br><mark>        delete tool;
</mark><br><mark>
</mark><br><mark>        return NULL;
</mark><br><mark>    }
</mark><br><mark>
</mark><br><mark>    m_tools.Insert( pos, tool );
</mark><br><mark>
</mark><br><mark>    return tool;
</mark><br><mark>}
</mark><br><mark>
</mark><br><mark>wxToolBarToolBase *ocpnToolBarSimple::RemoveTool( int id )
</mark><br><mark>{
</mark><br><mark>    size_t pos = 0;
</mark><br><mark>    wxToolBarToolsList::compatibility_iterator node;
</mark><br><mark>    for( node = m_tools.GetFirst(); node; node = node->GetNext() ) {
</mark><br><mark>        if( node->GetData()->GetId() == id ) break;
</mark><br><mark>
</mark><br><mark>        pos++;
</mark><br><mark>    }
</mark><br><mark>
</mark><br><mark>    if( !node ) {
</mark><br><mark>        // don't give any error messages - sometimes we might call RemoveTool()
</mark><br><mark>        // without knowing whether the tool is or not in the toolbar
</mark><br><mark>        return (wxToolBarToolBase *) NULL;
</mark><br><mark>    }
</mark><br><mark>
</mark><br><mark>    wxToolBarToolBase *tool = node->GetData();
</mark><br><mark>    if( !DoDeleteTool( pos, tool ) ) {
</mark><br><mark>        return (wxToolBarToolBase *) NULL;
</mark><br><mark>    }
</mark><br><mark>
</mark><br><mark>    m_tools.Erase( node );
</mark><br><mark>
</mark><br><mark>    return tool;
</mark><br><mark>}
</mark><br><mark>
</mark><br><mark>
</mark><br><mark>wxControl *ocpnToolBarSimple::FindControl( int id )
</mark><br><mark>{
</mark><br><mark>    for( wxToolBarToolsList::compatibility_iterator node = m_tools.GetFirst(); node;
</mark><br><mark>            node = node->GetNext() ) {
</mark><br><mark>        const wxToolBarToolBase * const tool = node->GetData();
</mark><br><mark>        if( tool->IsControl() ) {
</mark><br><mark>            wxControl * const control = tool->GetControl();
</mark><br><mark>
</mark><br><mark>            if( !control ) {
</mark><br><mark>                wxFAIL_MSG( _T("NULL control in toolbar?") );
</mark><br><mark>            } else
</mark><br><mark>                if( control->GetId() == id ) {
</mark><br><mark>                    // found
</mark><br><mark>                    return control;
</mark><br><mark>                }
</mark><br><mark>        }
</mark><br><mark>    }
</mark><br><mark>
</mark><br><mark>    return NULL;
</mark><br><mark>}
</mark><br><mark>
</mark><br><mark>wxToolBarToolBase *ocpnToolBarSimple::FindById( int id ) const
</mark><br><mark>{
</mark><br><mark>    wxToolBarToolBase *tool = (wxToolBarToolBase *) NULL;
</mark><br><mark>
</mark><br><mark>    for( wxToolBarToolsList::compatibility_iterator node = m_tools.GetFirst(); node;
</mark><br><mark>            node = node->GetNext() ) {
</mark><br><mark>        tool = node->GetData();
</mark><br><mark>        if( tool->GetId() == id ) {
</mark><br><mark>            // found
</mark><br><mark>            break;
</mark><br><mark>        }
</mark><br><mark>
</mark><br><mark>        tool = NULL;
</mark><br><mark>    }
</mark><br><mark>
</mark><br><mark>    return tool;
</mark><br><mark>}
</mark><br><mark>
</mark><br><mark>// ----------------------------------------------------------------------------
</mark><br><mark>// event processing
</mark><br><mark>// ----------------------------------------------------------------------------
</mark><br><mark>
</mark><br><mark>// Only allow toggle if returns true
</mark><br><mark>bool ocpnToolBarSimple::OnLeftClick( int id, bool toggleDown )
</mark><br><mark>{
</mark><br><mark>    wxCommandEvent event( wxEVT_COMMAND_TOOL_CLICKED, id );
</mark><br><mark>    event.SetEventObject( this );
</mark><br><mark>
</mark><br><mark>    // we use SetInt() to make wxCommandEvent::IsChecked() return toggleDown
</mark><br><mark>    event.SetInt( (int) toggleDown );
</mark><br><mark>
</mark><br><mark>    // and SetExtraLong() for backwards compatibility
</mark><br><mark>    event.SetExtraLong( (long) toggleDown );
</mark><br><mark>
</mark><br><mark>    // Send events to this toolbar instead (and thence up the window hierarchy)
</mark><br><mark>    GetEventHandler()->ProcessEvent( event );
</mark><br><mark>
</mark><br><mark>    return true;
</mark><br><mark>}
</mark><br><mark>
</mark><br><mark>// Call when right button down.
</mark><br><mark>void ocpnToolBarSimple::OnRightClick( int id, long WXUNUSED(x), long WXUNUSED(y) )
</mark><br><mark>{
</mark><br><mark>    wxCommandEvent event( wxEVT_COMMAND_TOOL_RCLICKED, id );
</mark><br><mark>    event.SetEventObject( this );
</mark><br><mark>    event.SetInt( id );
</mark><br><mark>
</mark><br><mark>    HideTooltip();
</mark><br><mark>    ((ocpnFloatingToolbarDialog*)GetParent())->toolbarConfigChanged = false;
</mark><br><mark>    wxMenu* contextMenu = new wxMenu();
</mark><br><mark>    wxMenuItem* submenu = contextMenu->AppendSubMenu( g_FloatingToolbarConfigMenu, _("Visible buttons") );
</mark><br><mark>
</mark><br><mark>    PopupMenu( contextMenu );
</mark><br><mark>
</mark><br><mark>    contextMenu->Remove( submenu );
</mark><br><mark>    delete contextMenu;
</mark><br><mark>
</mark><br><mark>    if( ((ocpnFloatingToolbarDialog*)GetParent())->toolbarConfigChanged )
</mark><br><mark>        gFrame->GetEventHandler()->AddPendingEvent( event );
</mark><br><mark>}
</mark><br><mark>
</mark><br><mark>// Called when the mouse cursor enters a tool bitmap (no button pressed).
</mark><br><mark>// Argument is wxID_ANY if mouse is exiting the toolbar.
</mark><br><mark>// Note that for this event, the id of the window is used,
</mark><br><mark>// and the integer parameter of wxCommandEvent is used to retrieve
</mark><br><mark>// the tool id.
</mark><br><mark>void ocpnToolBarSimple::OnMouseEnter( int id )
</mark><br><mark>{
</mark><br><mark>    wxCommandEvent event( wxEVT_COMMAND_TOOL_ENTER, GetId() );
</mark><br><mark>    event.SetEventObject( this );
</mark><br><mark>    event.SetInt( id );
</mark><br><mark>
</mark><br><mark>    wxFrame *frame = wxDynamicCast(GetParent(), wxFrame);
</mark><br><mark>    if( frame ) {
</mark><br><mark>        wxString help;
</mark><br><mark>        wxToolBarToolBase* tool = id == wxID_ANY ? (wxToolBarToolBase*) NULL : FindById( id );
</mark><br><mark>        if( tool ) help = tool->GetLongHelp();
</mark><br><mark>        frame->DoGiveHelp( help, id != wxID_ANY );
</mark><br><mark>    }
</mark><br><mark>
</mark><br><mark>    (void) GetEventHandler()->ProcessEvent( event );
</mark><br><mark>
</mark><br><mark>    DoPluginToolUp();
</mark><br><mark>}
</mark><br><mark>
</mark><br><mark>void ocpnToolBarSimple::DoPluginToolUp()
</mark><br><mark>{
</mark><br><mark>    //        Look for PlugIn tools
</mark><br><mark>    //        If found, make the callback.
</mark><br><mark>    if( !g_pi_manager)
</mark><br><mark>        return;
</mark><br><mark>
</mark><br><mark>    ArrayOfPlugInToolbarTools tool_array = g_pi_manager->GetPluginToolbarToolArray();
</mark><br><mark>    for( unsigned int i = 0; i < tool_array.GetCount(); i++ ) {
</mark><br><mark>        PlugInToolbarToolContainer *pttc = tool_array.Item( i );
</mark><br><mark>        if( m_last_plugin_down_id == pttc->id ) {
</mark><br><mark>            opencpn_plugin_113 *ppi = dynamic_cast<opencpn_plugin_113 *>(pttc->m_pplugin);
</mark><br><mark>            if( ppi )
</mark><br><mark>                ppi->OnToolbarToolUpCallback( pttc->id );
</mark><br><mark>        }
</mark><br><mark>    }
</mark><br><mark>
</mark><br><mark>    m_last_plugin_down_id = -1;
</mark><br><mark>}
</mark><br><mark>
</mark><br><mark>void ocpnToolBarSimple::SetToolNormalBitmapEx( wxToolBarToolBase *tool, const wxString &iconName)
</mark><br><mark>{
</mark><br><mark>    if( tool ) {
</mark><br><mark>        ocpnToolBarTool *otool = (ocpnToolBarTool *) tool;
</mark><br><mark>        if(otool){
</mark><br><mark>            ocpnStyle::Style *style = g_StyleManager->GetCurrentStyle();
</mark><br><mark>
</mark><br><mark>            wxBitmap bmp = style->GetToolIcon( iconName, TOOLICON_NORMAL );
</mark><br><mark>            if(m_sizefactor > 1.0 ){
</mark><br><mark>                wxImage scaled_image = bmp.ConvertToImage();
</mark><br><mark>                bmp = wxBitmap(scaled_image.Scale(otool->m_width, otool->m_height, wxIMAGE_QUALITY_HIGH));
</mark><br><mark>            }
</mark><br><mark>        
</mark><br><mark>            tool->SetNormalBitmap( bmp );
</mark><br><mark>            otool->SetIconName( iconName );
</mark><br><mark>        }
</mark><br><mark>    }
</mark><br><mark>}
</mark><br><mark>
</mark><br><mark>
</mark><br><mark>//-------------------------------------------------------------------------------------
</mark><br><mark>
</mark><br><mark>ToolbarMOBDialog::ToolbarMOBDialog( wxWindow* parent )
</mark><br><mark>       : wxDialog( parent, wxID_ANY, _("OpenCPN Alert"), wxDefaultPosition, wxSize(250, 230) )
</mark><br><mark>{
</mark><br><mark>    wxBoxSizer* topSizer = new wxBoxSizer( wxVERTICAL );
</mark><br><mark>
</mark><br><mark>    wxBoxSizer* sizer = new wxBoxSizer( wxVERTICAL );
</mark><br><mark>    topSizer->Add( sizer, 0, wxALIGN_CENTER_HORIZONTAL | wxALL, 5 );
</mark><br><mark>
</mark><br><mark>    choices.push_back( new wxRadioButton( this, 0,  _("No, I don't want to hide it."),
</mark><br><mark>            wxDefaultPosition, wxDefaultSize, wxRB_GROUP ) );
</mark><br><mark>
</mark><br><mark>    choices.push_back( new wxRadioButton( this, 1, _("No, and permanently remove the option to hide it."),
</mark><br><mark>            wxDefaultPosition) );
</mark><br><mark>
</mark><br><mark>    choices.push_back( new wxRadioButton( this, 2, _("Yes, hide it."),
</mark><br><mark>            wxDefaultPosition) );
</mark><br><mark>
</mark><br><mark>    wxStdDialogButtonSizer* buttonSizer = CreateStdDialogButtonSizer( wxOK | wxCANCEL );
</mark><br><mark>
</mark><br><mark>
</mark><br><mark>    wxStaticText* textCtrl = new wxStaticText( this, wxID_ANY, _("The Man Over Board button could be an important safety feature.\nAre you sure you want to hide it?") );
</mark><br><mark>
</mark><br><mark>    sizer->Add( textCtrl, 0, wxEXPAND | wxALL, 5 );
</mark><br><mark>    sizer->Add( choices[0], 0, wxEXPAND | wxALL, 5 );
</mark><br><mark>    sizer->Add( choices[1], 0, wxEXPAND | wxALL, 5 );
</mark><br><mark>    sizer->Add( choices[2], 0, wxEXPAND | wxALL, 5 );
</mark><br><mark>    sizer->Add( buttonSizer, 0, wxEXPAND | wxTOP, 5 );
</mark><br><mark>
</mark><br><mark>    topSizer->SetSizeHints(this);
</mark><br><mark>    SetSizer( topSizer );
</mark><br><mark>}
</mark><br><mark>
</mark><br><mark>int ToolbarMOBDialog::GetSelection() {
</mark><br><mark>    for( unsigned int i=0; i<choices.size(); i++ ) {
</mark><br><mark>        if( choices[i]->GetValue() ) return choices[i]->GetId();
</mark><br><mark>    }
</mark><br><mark>    return 0;
</mark><br><mark>}
</mark></p></body>
    </html><html>
    <head></head>
    <body><p>1<br><mark>/***************************************************************************
</mark>1<br><mark> *
</mark>1<br><mark> * Project:  OpenCPN
</mark>1<br><mark> * Purpose:  OpenCPN Toolbar
</mark>1<br><mark> * Author:   David Register
</mark>1<br><mark> *
</mark>1<br><mark> ***************************************************************************
</mark>1<br><mark> *   Copyright (C) 2010 by David S. Register                               *
</mark>1<br><mark> *                                                                         *
</mark>1<br><mark> *   This program is free software; you can redistribute it and/or modify  *
</mark>1<br><mark> *   it under the terms of the GNU General Public License as published by  *
</mark>1<br><mark> *   the Free Software Foundation; either version 2 of the License, or     *
</mark>1<br><mark> *   (at your option) any later version.                                   *
</mark>1<br><mark> *                                                                         *
</mark>1<br><mark> *   This program is distributed in the hope that it will be useful,       *
</mark>1<br><mark> *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
</mark>1<br><mark> *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
</mark>1<br><mark> *   GNU General Public License for more details.                          *
</mark>1<br><mark> *                                                                         *
</mark>1<br><mark> *   You should have received a copy of the GNU General Public License     *
</mark>1<br><mark> *   along with this program; if not, write to the                         *
</mark>1<br><mark> *   Free Software Foundation, Inc.,                                       *
</mark>1<br><mark> *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,  USA.         *
</mark>1<br><mark> **************************************************************************/
</mark>1<br><mark>
</mark>1<br><mark>#include "wx/wxprec.h"
</mark>1<br><mark>
</mark>1<br><mark>#ifndef  WX_PRECOMP
</mark>1<br><mark>#include "wx/wx.h"
</mark>1<br><mark>#endif
</mark>1<br><mark>
</mark>1<br><mark>#include <vector>
</mark>1<br><mark>
</mark>1<br><mark>#include "ocpn_types.h"
</mark>1<br><mark>#include "navutil.h"
</mark>1<br><mark>#include "styles.h"
</mark>1<br><mark>#include "toolbar.h"
</mark>1<br><mark>#include "chart1.h"
</mark>1<br><mark>#include "pluginmanager.h"
</mark>1<br><mark>#include "FontMgr.h"
</mark>1<br><mark>
</mark>1<br><mark>extern ocpnFloatingToolbarDialog* g_FloatingToolbarDialog;
</mark>1<br><mark>extern bool                       g_bTransparentToolbar;
</mark>1<br><mark>extern bool                       g_bTransparentToolbarInOpenGLOK;
</mark>1<br><mark>extern ChartCanvas*               cc1;
</mark>1<br><mark>extern bool                       g_bopengl;
</mark>1<br><mark>extern ocpnToolBarSimple*         g_toolbar;
</mark>1<br><mark>extern ocpnStyle::StyleManager*   g_StyleManager;
</mark>1<br><mark>extern MyFrame*                   gFrame;
</mark>1<br><mark>extern PlugInManager*             g_pi_manager;
</mark>1<br><mark>extern wxMenu*                    g_FloatingToolbarConfigMenu;
</mark>1<br><mark>extern wxString                   g_toolbarConfig;
</mark>1<br><mark>extern bool                       g_bPermanentMOBIcon;
</mark>1<br><mark>extern bool                       g_btouch;
</mark>1<br><mark>extern bool                       g_bsmoothpanzoom;
</mark>1<br><mark>
</mark>1<br><mark>//----------------------------------------------------------------------------
</mark>1<br><mark>// GrabberWindow Implementation
</mark>1<br><mark>//----------------------------------------------------------------------------
</mark>1<br><mark>BEGIN_EVENT_TABLE(GrabberWin, wxPanel) EVT_MOUSE_EVENTS ( GrabberWin::MouseEvent )
</mark>1<br><mark>EVT_PAINT ( GrabberWin::OnPaint )
</mark>1<br><mark>END_EVENT_TABLE()
</mark>1<br><mark>
</mark>1<br><mark>GrabberWin::GrabberWin( wxWindow *parent, ocpnFloatingToolbarDialog *toolbar, float scale_factor, wxString icon_name, wxPoint position ):
</mark>1<br><mark>    wxPanel( parent, wxID_ANY, position, wxDefaultSize, wxNO_BORDER )
</mark>1<br><mark>{
</mark>1<br><mark>    m_icon_name = icon_name;
</mark>1<br><mark>    m_style = g_StyleManager->GetCurrentStyle();
</mark>1<br><mark>    wxBitmap bitmap = m_style->GetIcon( icon_name );
</mark>1<br><mark>    if(scale_factor > 1.0f){
</mark>1<br><mark>        int new_width = bitmap.GetWidth() * scale_factor;
</mark>1<br><mark>        int new_height = bitmap.GetHeight() * scale_factor;
</mark>1<br><mark>        wxImage scaled_image = bitmap.ConvertToImage();
</mark>1<br><mark>        m_bitmap = wxBitmap(scaled_image.Scale(new_width, new_height, wxIMAGE_QUALITY_HIGH));
</mark>1<br><mark>    }
</mark>1<br><mark>    else
</mark>1<br><mark>        m_bitmap = bitmap;
</mark>1<br><mark>
</mark>1<br><mark>    SetSize( wxSize( m_bitmap.GetWidth(), m_bitmap.GetHeight() ) );
</mark>1<br><mark>    SetMinSize( wxSize( m_bitmap.GetWidth(), m_bitmap.GetHeight() ) );
</mark>1<br><mark>
</mark>1<br><mark>    m_bLeftDown = false;
</mark>1<br><mark>    m_bRightDown = false;
</mark>1<br><mark>    m_scale_factor = scale_factor;
</mark>1<br><mark>    m_ptoolbar = toolbar;
</mark>1<br><mark>    m_dragging = false;
</mark>1<br><mark>    Hide();
</mark>1<br><mark>    
</mark>1<br><mark>}
</mark>1<br><mark>
</mark>1<br><mark>
</mark>1<br><mark>void GrabberWin::OnPaint( wxPaintEvent& event )
</mark>1<br><mark>{
</mark>1<br><mark>    wxPaintDC dc( this );
</mark>1<br><mark>    
</mark>1<br><mark>    wxColour back_color = GetGlobalColor( _T("GREY2") );
</mark>1<br><mark>    SetBackgroundColour( back_color );
</mark>1<br><mark>    ClearBackground();
</mark>1<br><mark>    
</mark>1<br><mark>    dc.DrawBitmap( m_bitmap, 0, 0, true );
</mark>1<br><mark>}
</mark>1<br><mark>
</mark>1<br><mark>void GrabberWin::SetColorScheme( ColorScheme cs )
</mark>1<br><mark>{
</mark>1<br><mark>    wxColour back_color = GetGlobalColor( _T("GREY2") );
</mark>1<br><mark>
</mark>1<br><mark>    SetBackgroundColour( back_color );
</mark>1<br><mark>    ClearBackground();
</mark>1<br><mark>
</mark>1<br><mark>    wxBitmap bitmap = m_style->GetIcon( m_icon_name) ;
</mark>1<br><mark>    if(m_scale_factor > 1.0f){
</mark>1<br><mark>        int new_width = bitmap.GetWidth() * m_scale_factor;
</mark>1<br><mark>        int new_height = bitmap.GetHeight() * m_scale_factor;
</mark>1<br><mark>        wxImage scaled_image = bitmap.ConvertToImage();
</mark>1<br><mark>        m_bitmap = wxBitmap(scaled_image.Scale(new_width, new_height, wxIMAGE_QUALITY_HIGH));
</mark>1<br><mark>    }
</mark>1<br><mark>    else
</mark>1<br><mark>        m_bitmap = bitmap;
</mark>1<br><mark>}
</mark>1<br><mark>
</mark>1<br><mark>void GrabberWin::MouseEvent( wxMouseEvent& event )
</mark>1<br><mark>{
</mark>1<br><mark>    static wxPoint s_gspt;
</mark>1<br><mark>    int x, y;
</mark>1<br><mark>
</mark>1<br><mark>    event.GetPosition( &x, &y );
</mark>1<br><mark>
</mark>1<br><mark>    wxPoint spt = ClientToScreen( wxPoint( x, y ) );
</mark>1<br><mark>    if( event.LeftDown() ) {
</mark>1<br><mark>        s_gspt = spt;
</mark>1<br><mark>    }
</mark>1<br><mark>    
</mark>1<br><mark>    
</mark>1<br><mark>#ifndef __WXQT__
</mark>1<br><mark>
</mark>1<br><mark>    if( event.LeftDown() ) {
</mark>1<br><mark>        CaptureMouse();
</mark>1<br><mark>    }
</mark>1<br><mark>
</mark>1<br><mark>    if( event.LeftUp() ) {
</mark>1<br><mark>        if( HasCapture() ) ReleaseMouse();
</mark>1<br><mark>    }
</mark>1<br><mark>
</mark>1<br><mark>#endif
</mark>1<br><mark>
</mark>1<br><mark>
</mark>1<br><mark>    if( event.RightDown() ){
</mark>1<br><mark>        if(m_ptoolbar){
</mark>1<br><mark>            m_dragging = true;
</mark>1<br><mark>            
</mark>1<br><mark>            if( !m_ptoolbar->m_bnavgrabber ){
</mark>1<br><mark>                m_ptoolbar->m_bnavgrabber = true;
</mark>1<br><mark>                m_ptoolbar->SetGrabber(_T("4WayMove") );
</mark>1<br><mark>            }
</mark>1<br><mark>            else{
</mark>1<br><mark>                m_ptoolbar->m_bnavgrabber = false;
</mark>1<br><mark>                m_ptoolbar->SetGrabber(_T("grabber_hi") );
</mark>1<br><mark>            }
</mark>1<br><mark>                
</mark>1<br><mark>        }
</mark>1<br><mark>    }
</mark>1<br><mark>    
</mark>1<br><mark>
</mark>1<br><mark>
</mark>1<br><mark>    if( event.Dragging() ) {
</mark>1<br><mark>        if(m_ptoolbar && m_ptoolbar->IsShown() /*&& m_ptoolbar->m_bnavgrabber*/){
</mark>1<br><mark>            wxPoint par_pos_old = m_ptoolbar->GetPosition();
</mark>1<br><mark>
</mark>1<br><mark>            wxPoint par_pos = par_pos_old;
</mark>1<br><mark>            par_pos.x += spt.x - s_gspt.x;
</mark>1<br><mark>            par_pos.y += spt.y - s_gspt.y;
</mark>1<br><mark>
</mark>1<br><mark>            m_ptoolbar->MoveDialogInScreenCoords( par_pos, par_pos_old );
</mark>1<br><mark>
</mark>1<br><mark>            s_gspt = spt;
</mark>1<br><mark>            m_dragging = true;
</mark>1<br><mark>        }
</mark>1<br><mark>
</mark>1<br><mark>    }
</mark>1<br><mark>
</mark>1<br><mark>    if( event.LeftUp() ) {
</mark>1<br><mark>        if(m_ptoolbar){
</mark>1<br><mark>            if(m_ptoolbar->m_bnavgrabber){
</mark>1<br><mark>                if(!m_dragging)
</mark>1<br><mark>                    m_ptoolbar->ToggleOrientation();
</mark>1<br><mark>            }
</mark>1<br><mark>            else if(!m_dragging){
</mark>1<br><mark>                if(m_ptoolbar->m_bsubmerged){
</mark>1<br><mark>                    m_ptoolbar->SurfaceFromGrabber();
</mark>1<br><mark>                }
</mark>1<br><mark>                else{
</mark>1<br><mark>                    m_ptoolbar->SubmergeToGrabber();
</mark>1<br><mark>                 }
</mark>1<br><mark>            }
</mark>1<br><mark>        }
</mark>1<br><mark>        m_dragging = false;
</mark>1<br><mark>    }
</mark>1<br><mark>    
</mark>1<br><mark>    
</mark>1<br><mark>#ifndef __OCPN__ANDROID__
</mark>1<br><mark>    gFrame->Raise();
</mark>1<br><mark>#endif
</mark>1<br><mark>    
</mark>1<br><mark>}
</mark>1<br><mark>
</mark>1<br><mark>class ocpnToolBarTool: public wxToolBarToolBase {
</mark>1<br><mark>public:
</mark>1<br><mark>    ocpnToolBarTool( ocpnToolBarSimple *tbar, int id, const wxString& label,
</mark>1<br><mark>            const wxBitmap& bmpNormal, const wxBitmap& bmpRollover, wxItemKind kind,
</mark>1<br><mark>            wxObject *clientData, const wxString& shortHelp, const wxString& longHelp ) :
</mark>1<br><mark>            wxToolBarToolBase( (wxToolBarBase*) tbar, id, label, bmpNormal, bmpRollover, kind,
</mark>1<br><mark>                    clientData, shortHelp, longHelp )
</mark>1<br><mark>    {
</mark>1<br><mark>        m_enabled = true;
</mark>1<br><mark>        m_toggled = false;
</mark>1<br><mark>        rollover = false;
</mark>1<br><mark>        bitmapOK = false;
</mark>1<br><mark>        m_btooltip_hiviz = false;
</mark>1<br><mark>
</mark>1<br><mark>        toolname = g_pi_manager->GetToolOwnerCommonName( id );
</mark>1<br><mark>        if( toolname == _T("") ) {
</mark>1<br><mark>            isPluginTool = false;
</mark>1<br><mark>            toolname = label;
</mark>1<br><mark>            iconName = label;
</mark>1<br><mark>        } else {
</mark>1<br><mark>            isPluginTool = true;
</mark>1<br><mark>            pluginNormalIcon = &bmpNormal;
</mark>1<br><mark>            pluginRolloverIcon = &bmpRollover;
</mark>1<br><mark>        }
</mark>1<br><mark>    }
</mark>1<br><mark>
</mark>1<br><mark>    void SetSize( const wxSize& size )
</mark>1<br><mark>    {
</mark>1<br><mark>        m_width = size.x;
</mark>1<br><mark>        m_height = size.y;
</mark>1<br><mark>    }
</mark>1<br><mark>
</mark>1<br><mark>    wxCoord GetWidth() const
</mark>1<br><mark>    {
</mark>1<br><mark>        return m_width;
</mark>1<br><mark>    }
</mark>1<br><mark>
</mark>1<br><mark>    wxCoord GetHeight() const
</mark>1<br><mark>    {
</mark>1<br><mark>        return m_height;
</mark>1<br><mark>    }
</mark>1<br><mark>
</mark>1<br><mark>    wxString GetToolname()
</mark>1<br><mark>    {
</mark>1<br><mark>        return toolname;
</mark>1<br><mark>    }
</mark>1<br><mark>
</mark>1<br><mark>    void SetIconName(wxString name)
</mark>1<br><mark>    {
</mark>1<br><mark>        iconName = name;
</mark>1<br><mark>    }
</mark>1<br><mark>    wxString GetIconName()
</mark>1<br><mark>    {
</mark>1<br><mark>        return iconName;
</mark>1<br><mark>    }
</mark>1<br><mark>
</mark>1<br><mark>    void SetTooltipHiviz( bool enable){ m_btooltip_hiviz = enable; }
</mark>1<br><mark>
</mark>1<br><mark>    wxCoord m_x;
</mark>1<br><mark>    wxCoord m_y;
</mark>1<br><mark>    wxCoord m_width;
</mark>1<br><mark>    wxCoord m_height;
</mark>1<br><mark>    wxRect trect;
</mark>1<br><mark>    wxString toolname;
</mark>1<br><mark>    wxString iconName;
</mark>1<br><mark>    const wxBitmap* pluginNormalIcon;
</mark>1<br><mark>    const wxBitmap* pluginRolloverIcon;
</mark>1<br><mark>    bool firstInLine;
</mark>1<br><mark>    bool lastInLine;
</mark>1<br><mark>    bool rollover;
</mark>1<br><mark>    bool bitmapOK;
</mark>1<br><mark>    bool isPluginTool;
</mark>1<br><mark>    bool b_hilite;
</mark>1<br><mark>    bool m_btooltip_hiviz;
</mark>1<br><mark>    wxRect last_rect;
</mark>1<br><mark>};
</mark>1<br><mark>
</mark>1<br><mark>//---------------------------------------------------------------------------------------
</mark>1<br><mark>//          ocpnFloatingToolbarDialog Implementation
</mark>1<br><mark>//---------------------------------------------------------------------------------------
</mark>1<br><mark>BEGIN_EVENT_TABLE(ocpnFloatingToolbarDialog, wxDialog)
</mark>1<br><mark>    EVT_MOUSE_EVENTS ( ocpnFloatingToolbarDialog::MouseEvent )
</mark>1<br><mark>    EVT_MENU(wxID_ANY, ocpnFloatingToolbarDialog::OnToolLeftClick)
</mark>1<br><mark>    EVT_TIMER ( FADE_TIMER, ocpnFloatingToolbarDialog::FadeTimerEvent )
</mark>1<br><mark>    EVT_TIMER ( DESTROY_TIMER, ocpnFloatingToolbarDialog::DestroyTimerEvent )
</mark>1<br><mark>    EVT_WINDOW_CREATE(ocpnFloatingToolbarDialog::OnWindowCreate)
</mark>1<br><mark>END_EVENT_TABLE()
</mark>1<br><mark>
</mark>1<br><mark>ocpnFloatingToolbarDialog::ocpnFloatingToolbarDialog( wxWindow *parent, wxPoint position,
</mark>1<br><mark>                                                      long orient, float size_factor )
</mark>1<br><mark>{
</mark>1<br><mark>    m_pparent = parent;
</mark>1<br><mark>    long wstyle = wxNO_BORDER | wxFRAME_NO_TASKBAR;
</mark>1<br><mark>#ifndef __WXMAC__
</mark>1<br><mark>    wstyle |= wxFRAME_SHAPED;
</mark>1<br><mark>#endif
</mark>1<br><mark>
</mark>1<br><mark>    m_ptoolbar = NULL;
</mark>1<br><mark>
</mark>1<br><mark>#ifdef __WXOSX__
</mark>1<br><mark>    wstyle |= wxSTAY_ON_TOP;
</mark>1<br><mark>#endif
</mark>1<br><mark>    wxDialog::Create( parent, -1, _T("ocpnToolbarDialog"), wxPoint( -1, -1 ), wxSize( -1, -1 ),
</mark>1<br><mark>            wstyle );
</mark>1<br><mark>
</mark>1<br><mark>    m_opacity = 255;
</mark>1<br><mark>
</mark>1<br><mark>    m_pGrabberwin = new GrabberWin( this, this, size_factor, _T("grabber_hi") );
</mark>1<br><mark>    m_pGrabberwin->Show();
</mark>1<br><mark>    
</mark>1<br><mark>    m_pRecoverwin = NULL;
</mark>1<br><mark>    m_position = position;
</mark>1<br><mark>    m_orient = orient;
</mark>1<br><mark>    m_sizefactor = size_factor;
</mark>1<br><mark>    
</mark>1<br><mark>    m_bAutoHideToolbar = false;
</mark>1<br><mark>    m_nAutoHideToolbar = 5;
</mark>1<br><mark>    
</mark>1<br><mark>
</mark>1<br><mark>    m_style = g_StyleManager->GetCurrentStyle();
</mark>1<br><mark>
</mark>1<br><mark>// A top-level sizer
</mark>1<br><mark>    m_topSizer = new wxBoxSizer( wxHORIZONTAL );
</mark>1<br><mark>    SetSizer( m_topSizer );
</mark>1<br><mark>
</mark>1<br><mark>    //    Set initial "Dock" parameters
</mark>1<br><mark>    m_dock_x = 0;
</mark>1<br><mark>    m_dock_y = 0;
</mark>1<br><mark>    m_block = false;
</mark>1<br><mark>
</mark>1<br><mark>    m_marginsInvisible = m_style->marginsInvisible;
</mark>1<br><mark>
</mark>1<br><mark>//    if(m_sizefactor > 1.0 )
</mark>1<br><mark> //       m_marginsInvisible = true;
</mark>1<br><mark>
</mark>1<br><mark>    m_bnavgrabber = false;    
</mark>1<br><mark>    
</mark>1<br><mark>    Hide();
</mark>1<br><mark>
</mark>1<br><mark>    m_bsubmerged = false;
</mark>1<br><mark>    
</mark>1<br><mark>    m_fade_timer.SetOwner( this, FADE_TIMER );
</mark>1<br><mark>    if( g_bTransparentToolbar )
</mark>1<br><mark>        m_fade_timer.Start( 5000 );
</mark>1<br><mark>    
</mark>1<br><mark>    if( m_bAutoHideToolbar && (m_nAutoHideToolbar > 0))
</mark>1<br><mark>        m_fade_timer.Start( m_nAutoHideToolbar * 1000 );
</mark>1<br><mark>    
</mark>1<br><mark>    m_destroyTimer.SetOwner( this, DESTROY_TIMER );
</mark>1<br><mark>}
</mark>1<br><mark>
</mark>1<br><mark>ocpnFloatingToolbarDialog::~ocpnFloatingToolbarDialog()
</mark>1<br><mark>{
</mark>1<br><mark>    DestroyToolBar();
</mark>1<br><mark>}
</mark>1<br><mark>
</mark>1<br><mark>void ocpnFloatingToolbarDialog::OnWindowCreate( wxWindowCreateEvent& event )
</mark>1<br><mark>{
</mark>1<br><mark>    Realize();
</mark>1<br><mark>}
</mark>1<br><mark>
</mark>1<br><mark>void ocpnFloatingToolbarDialog::SetGrabber( wxString icon_name )
</mark>1<br><mark>{
</mark>1<br><mark>//    m_pGrabberwin->Destroy();
</mark>1<br><mark>    m_pGrabberwin = new GrabberWin( this, this, m_sizefactor, icon_name );
</mark>1<br><mark>    m_pGrabberwin->Show();
</mark>1<br><mark>    
</mark>1<br><mark>    Realize();
</mark>1<br><mark>    
</mark>1<br><mark>#ifdef __WXOSX__    
</mark>1<br><mark>    m_pGrabberwin->Refresh();
</mark>1<br><mark>#endif    
</mark>1<br><mark>    
</mark>1<br><mark>}
</mark>1<br><mark>
</mark>1<br><mark>
</mark>1<br><mark>    
</mark>1<br><mark>void ocpnFloatingToolbarDialog::SetColorScheme( ColorScheme cs )
</mark>1<br><mark>{
</mark>1<br><mark>    m_cs = cs;
</mark>1<br><mark>
</mark>1<br><mark>    wxColour back_color = GetGlobalColor( _T("GREY2") );
</mark>1<br><mark>
</mark>1<br><mark>    //  Set background
</mark>1<br><mark>    SetBackgroundColour( back_color );
</mark>1<br><mark>    ClearBackground();
</mark>1<br><mark>
</mark>1<br><mark>    if( m_ptoolbar ) {
</mark>1<br><mark>        wxColour back_color = GetGlobalColor( _T("GREY2") );
</mark>1<br><mark>
</mark>1<br><mark>        //  Set background
</mark>1<br><mark>        m_ptoolbar->SetBackgroundColour( back_color );
</mark>1<br><mark>        m_ptoolbar->ClearBackground();
</mark>1<br><mark>
</mark>1<br><mark>        m_ptoolbar->SetToggledBackgroundColour( GetGlobalColor( _T("GREY1") ) );
</mark>1<br><mark>
</mark>1<br><mark>        m_ptoolbar->SetColorScheme( cs );
</mark>1<br><mark>        m_ptoolbar->Refresh( true );
</mark>1<br><mark>    }
</mark>1<br><mark>
</mark>1<br><mark>    if( m_pGrabberwin ) m_pGrabberwin->SetColorScheme( cs );
</mark>1<br><mark>
</mark>1<br><mark>}
</mark>1<br><mark>
</mark>1<br><mark>void ocpnFloatingToolbarDialog::SetGeometry(bool bAvoid, wxRect rectAvoid)
</mark>1<br><mark>{
</mark>1<br><mark>
</mark>1<br><mark>    if( m_ptoolbar ) {
</mark>1<br><mark>        wxSize style_tool_size = m_style->GetToolSize();
</mark>1<br><mark>
</mark>1<br><mark>        style_tool_size.x *= m_sizefactor;
</mark>1<br><mark>        style_tool_size.y *= m_sizefactor;
</mark>1<br><mark>
</mark>1<br><mark>        m_ptoolbar->SetToolBitmapSize( style_tool_size );
</mark>1<br><mark>
</mark>1<br><mark>        wxSize tool_size = m_ptoolbar->GetToolBitmapSize();
</mark>1<br><mark>        int grabber_width =  m_style->GetIcon( _T("grabber") ).GetWidth();
</mark>1<br><mark>        
</mark>1<br><mark>        int max_rows = 10;
</mark>1<br><mark>        int max_cols = 100;
</mark>1<br><mark>        if(cc1){
</mark>1<br><mark>
</mark>1<br><mark>            int avoid_start = cc1->GetClientSize().x - (tool_size.x + m_style->GetToolSeparation()) * 2;  // default
</mark>1<br><mark>            if(bAvoid && !rectAvoid.IsEmpty()){
</mark>1<br><mark>                avoid_start = cc1->GetClientSize().x - rectAvoid.width - 10;  // this is compass window, if shown
</mark>1<br><mark>            }
</mark>1<br><mark>            
</mark>1<br><mark>            
</mark>1<br><mark>            max_rows = (cc1->GetClientSize().y / ( tool_size.y + m_style->GetToolSeparation())) - 1;
</mark>1<br><mark>            
</mark>1<br><mark>            max_cols = (avoid_start - grabber_width) / ( tool_size.x + m_style->GetToolSeparation());
</mark>1<br><mark>            max_cols -= 1;
</mark>1<br><mark>            
</mark>1<br><mark>            if(m_orient == wxTB_VERTICAL)
</mark>1<br><mark>                max_rows = wxMax( max_rows, 2);             // at least two rows
</mark>1<br><mark>            else
</mark>1<br><mark>                max_cols = wxMax( max_cols, 2);             // at least two columns
</mark>1<br><mark>        }
</mark>1<br><mark>
</mark>1<br><mark>        if( m_orient == wxTB_VERTICAL )
</mark>1<br><mark>            m_ptoolbar->SetMaxRowsCols(max_rows, 100);
</mark>1<br><mark>        else
</mark>1<br><mark>            m_ptoolbar->SetMaxRowsCols( 100, max_cols);
</mark>1<br><mark>        m_ptoolbar->SetSizeFactor(m_sizefactor);
</mark>1<br><mark>        
</mark>1<br><mark>    }
</mark>1<br><mark> }
</mark>1<br><mark>
</mark>1<br><mark>void ocpnFloatingToolbarDialog::RePosition()
</mark>1<br><mark>{
</mark>1<br><mark>    if(m_block) return;
</mark>1<br><mark>
</mark>1<br><mark>    if( m_pparent && m_ptoolbar ) {
</mark>1<br><mark>        wxSize cs = m_pparent->GetClientSize();
</mark>1<br><mark>        if( -1 == m_dock_x ) m_position.x = 0;
</mark>1<br><mark>        else
</mark>1<br><mark>            if( 1 == m_dock_x ) m_position.x = cs.x - GetSize().x;
</mark>1<br><mark>
</mark>1<br><mark>        if( -1 == m_dock_y ) m_position.y = 0;
</mark>1<br><mark>        else
</mark>1<br><mark>            if( 1 == m_dock_y ) m_position.y = cs.y - GetSize().y;
</mark>1<br><mark>
</mark>1<br><mark>        m_position.x = wxMin(cs.x - GetSize().x, m_position.x);
</mark>1<br><mark>        m_position.y = wxMin(cs.y - GetSize().y, m_position.y);
</mark>1<br><mark>
</mark>1<br><mark>        m_position.x = wxMax(0, m_position.x);
</mark>1<br><mark>        m_position.y = wxMax(0, m_position.y);
</mark>1<br><mark>
</mark>1<br><mark>        wxPoint screen_pos = m_pparent->ClientToScreen( m_position );
</mark>1<br><mark>
</mark>1<br><mark>        Move( screen_pos );
</mark>1<br><mark>
</mark>1<br><mark>#ifdef __WXQT__
</mark>1<br><mark>        Raise();
</mark>1<br><mark>#endif
</mark>1<br><mark>
</mark>1<br><mark>    }
</mark>1<br><mark>}
</mark>1<br><mark>
</mark>1<br><mark>void ocpnFloatingToolbarDialog::Submerge()
</mark>1<br><mark>{
</mark>1<br><mark>    m_bsubmerged = true;
</mark>1<br><mark>    Hide();
</mark>1<br><mark>    if( m_ptoolbar ) m_ptoolbar->KillTooltip();
</mark>1<br><mark>}
</mark>1<br><mark>
</mark>1<br><mark>void ocpnFloatingToolbarDialog::SubmergeToGrabber()
</mark>1<br><mark>{
</mark>1<br><mark>//Submerge();
</mark>1<br><mark>    m_bsubmerged = true;
</mark>1<br><mark>    Hide();
</mark>1<br><mark>    if( m_ptoolbar ) m_ptoolbar->KillTooltip();
</mark>1<br><mark>
</mark>1<br><mark>    m_pRecoverwin = new GrabberWin( m_pparent, this, m_sizefactor, _T("grabber_ext" ), wxPoint(10,10) );
</mark>1<br><mark>   
</mark>1<br><mark>    m_pRecoverwin->Show();
</mark>1<br><mark>    m_pRecoverwin->Raise();
</mark>1<br><mark>#ifdef __WXQT__
</mark>1<br><mark>    wxSize s = gFrame->GetSize();
</mark>1<br><mark>    m_recoversize = s;
</mark>1<br><mark>    s.y--;
</mark>1<br><mark>    gFrame->TriggerResize(s);
</mark>1<br><mark>    Raise();
</mark>1<br><mark>#endif    
</mark>1<br><mark>
</mark>1<br><mark>    gFrame->Refresh();          // Needed for MSW OpenGL
</mark>1<br><mark>}
</mark>1<br><mark>
</mark>1<br><mark>void ocpnFloatingToolbarDialog::Surface()
</mark>1<br><mark>{
</mark>1<br><mark>    
</mark>1<br><mark>    if(m_pRecoverwin){
</mark>1<br><mark>        m_pRecoverwin->Show();
</mark>1<br><mark>        m_pRecoverwin->Raise();
</mark>1<br><mark>    }
</mark>1<br><mark>    else {
</mark>1<br><mark>        m_bsubmerged = false;
</mark>1<br><mark>        #ifndef __WXOSX__
</mark>1<br><mark>        Hide();
</mark>1<br><mark>        Move( 0, 0 );
</mark>1<br><mark>        #endif
</mark>1<br><mark>
</mark>1<br><mark>        RePosition();
</mark>1<br><mark>        Show();
</mark>1<br><mark>        if( m_ptoolbar )
</mark>1<br><mark>            m_ptoolbar->EnableTooltips();
</mark>1<br><mark>
</mark>1<br><mark>        #ifdef __WXQT__
</mark>1<br><mark>        Raise();
</mark>1<br><mark>        #endif
</mark>1<br><mark>    }
</mark>1<br><mark>    
</mark>1<br><mark>    if( m_bAutoHideToolbar && (m_nAutoHideToolbar > 0) ){
</mark>1<br><mark>        m_fade_timer.Start( m_nAutoHideToolbar * 1000 );
</mark>1<br><mark>    }
</mark>1<br><mark>}
</mark>1<br><mark>
</mark>1<br><mark>bool ocpnFloatingToolbarDialog::CheckSurfaceRequest( wxMouseEvent &event )
</mark>1<br><mark>{
</mark>1<br><mark>    if( m_bsubmerged ){
</mark>1<br><mark>        if( event.LeftUp() ){
</mark>1<br><mark>            int x,y;
</mark>1<br><mark>            event.GetPosition( &x, &y );
</mark>1<br><mark>            if( m_pRecoverwin ){
</mark>1<br><mark>                wxRect winRect = m_pRecoverwin->GetRect();
</mark>1<br><mark>                if( winRect.Contains( x, y ) ){
</mark>1<br><mark>                    SurfaceFromGrabber();
</mark>1<br><mark>                    return true;
</mark>1<br><mark>                }
</mark>1<br><mark>            }
</mark>1<br><mark>        }
</mark>1<br><mark>    }
</mark>1<br><mark>    
</mark>1<br><mark>    return false;
</mark>1<br><mark>}
</mark>1<br><mark>        
</mark>1<br><mark>void ocpnFloatingToolbarDialog::SurfaceFromGrabber()
</mark>1<br><mark>{
</mark>1<br><mark>    m_bsubmerged = false;
</mark>1<br><mark>    
</mark>1<br><mark>#ifndef __WXOSX__
</mark>1<br><mark>    Hide();
</mark>1<br><mark>    Move( 0, 0 );
</mark>1<br><mark>#endif
</mark>1<br><mark>
</mark>1<br><mark>    if( m_ptoolbar )
</mark>1<br><mark>        m_ptoolbar->InvalidateBitmaps();
</mark>1<br><mark>    
</mark>1<br><mark>    RePosition();
</mark>1<br><mark>    Show();
</mark>1<br><mark>    if( m_ptoolbar )
</mark>1<br><mark>        m_ptoolbar->EnableTooltips();
</mark>1<br><mark>    
</mark>1<br><mark>    if( m_bAutoHideToolbar && (m_nAutoHideToolbar > 0) ){
</mark>1<br><mark>        m_fade_timer.Start( m_nAutoHideToolbar * 1000 );
</mark>1<br><mark>    }
</mark>1<br><mark>    
</mark>1<br><mark>#ifdef __WXQT__
</mark>1<br><mark>    wxSize s = gFrame->GetSize();               // check for rotation
</mark>1<br><mark>    if(m_recoversize.x == s.x)
</mark>1<br><mark>        gFrame->TriggerResize(m_recoversize);
</mark>1<br><mark>    Raise();
</mark>1<br><mark>#endif
</mark>1<br><mark>    
</mark>1<br><mark>    m_destroyGrabber = m_pRecoverwin;
</mark>1<br><mark>    m_destroyTimer.Start( 5, wxTIMER_ONE_SHOT );           //  Destor the unneeded recovery grabber
</mark>1<br><mark>    
</mark>1<br><mark>}
</mark>1<br><mark>
</mark>1<br><mark>void ocpnFloatingToolbarDialog::DestroyTimerEvent( wxTimerEvent& event )
</mark>1<br><mark>{
</mark>1<br><mark>    delete m_destroyGrabber;
</mark>1<br><mark>    m_destroyGrabber = NULL;
</mark>1<br><mark>    m_pRecoverwin = NULL;
</mark>1<br><mark>}
</mark>1<br><mark>
</mark>1<br><mark>void ocpnFloatingToolbarDialog::HideTooltip()
</mark>1<br><mark>{
</mark>1<br><mark>    if( m_ptoolbar ) m_ptoolbar->HideTooltip();
</mark>1<br><mark>}
</mark>1<br><mark>
</mark>1<br><mark>void ocpnFloatingToolbarDialog::ShowTooltips()
</mark>1<br><mark>{
</mark>1<br><mark>    if( m_ptoolbar ) m_ptoolbar->EnableTooltips();
</mark>1<br><mark>}
</mark>1<br><mark>
</mark>1<br><mark>void ocpnFloatingToolbarDialog::ToggleOrientation()
</mark>1<br><mark>{
</mark>1<br><mark>    if( m_orient == wxTB_HORIZONTAL )
</mark>1<br><mark>        m_orient = wxTB_VERTICAL;
</mark>1<br><mark>    else
</mark>1<br><mark>        m_orient = wxTB_HORIZONTAL;
</mark>1<br><mark>
</mark>1<br><mark>    m_style->SetOrientation( m_orient );
</mark>1<br><mark>
</mark>1<br><mark>    wxPoint old_screen_pos = m_pparent->ClientToScreen( m_position );
</mark>1<br><mark>    wxPoint grabber_point_abs = ClientToScreen( m_pGrabberwin->GetPosition() );
</mark>1<br><mark>
</mark>1<br><mark>    gFrame->RequestNewToolbar();
</mark>1<br><mark>    wxPoint pos_abs = grabber_point_abs;
</mark>1<br><mark>    pos_abs.x -= m_pGrabberwin->GetPosition().x;
</mark>1<br><mark>    MoveDialogInScreenCoords( pos_abs, old_screen_pos );
</mark>1<br><mark>
</mark>1<br><mark>
</mark>1<br><mark>    Show();   // this seems to be necessary on GTK to kick the sizer into gear...(FS#553)
</mark>1<br><mark>    Refresh(true);
</mark>1<br><mark>    Raise();
</mark>1<br><mark>}
</mark>1<br><mark>
</mark>1<br><mark>void ocpnFloatingToolbarDialog::MouseEvent( wxMouseEvent& event )
</mark>1<br><mark>{
</mark>1<br><mark>    if( g_bTransparentToolbar ) {
</mark>1<br><mark>        if( event.Entering() && ( m_opacity < 255 ) ) {
</mark>1<br><mark>            SetTransparent( 255 );
</mark>1<br><mark>            m_opacity = 255;
</mark>1<br><mark>        }
</mark>1<br><mark>
</mark>1<br><mark>        m_fade_timer.Start( 5000 );           // retrigger the continuous timer
</mark>1<br><mark>    }
</mark>1<br><mark>    
</mark>1<br><mark>    if(m_bAutoHideToolbar && (m_nAutoHideToolbar > 0) ){
</mark>1<br><mark>        m_fade_timer.Start( m_nAutoHideToolbar * 1000 );
</mark>1<br><mark>    }
</mark>1<br><mark>}
</mark>1<br><mark>
</mark>1<br><mark>void ocpnFloatingToolbarDialog::FadeTimerEvent( wxTimerEvent& event )
</mark>1<br><mark>{
</mark>1<br><mark>    if(m_bnavgrabber){
</mark>1<br><mark>        m_fade_timer.Start( 5000 );           // do nothing if nav grabber is shown
</mark>1<br><mark>    }
</mark>1<br><mark>    else{
</mark>1<br><mark>        if( g_bTransparentToolbar && (!g_bopengl || g_bTransparentToolbarInOpenGLOK) ){
</mark>1<br><mark>            DoFade( 128 );
</mark>1<br><mark>            m_fade_timer.Start( 5000 );           // retrigger the continuous timer
</mark>1<br><mark>        }
</mark>1<br><mark>        
</mark>1<br><mark>        if(m_bAutoHideToolbar && (m_nAutoHideToolbar > 0) && !m_bsubmerged){
</mark>1<br><mark>            SubmergeToGrabber();
</mark>1<br><mark>//            m_fade_timer.Stop();
</mark>1<br><mark>        }
</mark>1<br><mark>    }
</mark>1<br><mark>}
</mark>1<br><mark>
</mark>1<br><mark>void ocpnFloatingToolbarDialog::SetAutoHideTimer(int time)
</mark>1<br><mark>{
</mark>1<br><mark>    m_nAutoHideToolbar = time;
</mark>1<br><mark>    if(m_bAutoHideToolbar){
</mark>1<br><mark>        m_fade_timer.Stop();
</mark>1<br><mark>        m_fade_timer.Start( m_nAutoHideToolbar * 1000 );
</mark>1<br><mark>    }
</mark>1<br><mark>}
</mark>1<br><mark>        
</mark>1<br><mark>void ocpnFloatingToolbarDialog::DoFade( int value )
</mark>1<br><mark>{
</mark>1<br><mark>    if( value != m_opacity ) SetTransparent( value );
</mark>1<br><mark>    m_opacity = value;
</mark>1<br><mark>}
</mark>1<br><mark>
</mark>1<br><mark>void ocpnFloatingToolbarDialog::RefreshFadeTimer()
</mark>1<br><mark>{
</mark>1<br><mark>    SetTransparent( 255 );
</mark>1<br><mark>    m_opacity = 255;
</mark>1<br><mark>    m_fade_timer.Start( 500 );           // retrigger the continuous timer
</mark>1<br><mark>    
</mark>1<br><mark>    if(m_bAutoHideToolbar && (m_nAutoHideToolbar > 0) ){
</mark>1<br><mark>        m_fade_timer.Start( m_nAutoHideToolbar * 1000 );
</mark>1<br><mark>    }
</mark>1<br><mark>    
</mark>1<br><mark>}
</mark>1<br><mark>
</mark>1<br><mark>void ocpnFloatingToolbarDialog::MoveDialogInScreenCoords( wxPoint posn, wxPoint posn_old )
</mark>1<br><mark>{
</mark>1<br><mark>    wxPoint pos_in_parent = m_pparent->ScreenToClient( posn );
</mark>1<br><mark>    wxPoint pos_in_parent_old = m_pparent->ScreenToClient( posn_old );
</mark>1<br><mark>
</mark>1<br><mark>    //    "Docking" support
</mark>1<br><mark>#define DOCK_MARGIN 40
</mark>1<br><mark>
</mark>1<br><mark>    // X
</mark>1<br><mark>    m_dock_x = 0;
</mark>1<br><mark>    if( pos_in_parent.x < pos_in_parent_old.x )            // moving left
</mark>1<br><mark>            {
</mark>1<br><mark>        if( pos_in_parent.x < DOCK_MARGIN ) {
</mark>1<br><mark>            pos_in_parent.x = 0;
</mark>1<br><mark>            m_dock_x = -1;
</mark>1<br><mark>        }
</mark>1<br><mark>    } else
</mark>1<br><mark>        if( pos_in_parent.x > pos_in_parent_old.x )            // moving right
</mark>1<br><mark>                {
</mark>1<br><mark>            int max_right = m_pparent->GetClientSize().x - GetSize().x;
</mark>1<br><mark>            if( pos_in_parent.x > ( max_right - DOCK_MARGIN ) ) {
</mark>1<br><mark>                pos_in_parent.x = max_right;
</mark>1<br><mark>                m_dock_x = 1;
</mark>1<br><mark>            }
</mark>1<br><mark>        }
</mark>1<br><mark>
</mark>1<br><mark>    // Y
</mark>1<br><mark>    m_dock_y = 0;
</mark>1<br><mark>    if( pos_in_parent.y < pos_in_parent_old.y )            // moving up
</mark>1<br><mark>            {
</mark>1<br><mark>        if( pos_in_parent.y < DOCK_MARGIN ) {
</mark>1<br><mark>            pos_in_parent.y = 0;
</mark>1<br><mark>            m_dock_y = -1;
</mark>1<br><mark>        }
</mark>1<br><mark>    } else
</mark>1<br><mark>        if( pos_in_parent.y > pos_in_parent_old.y )            // moving down
</mark>1<br><mark>                {
</mark>1<br><mark>            int max_down = m_pparent->GetClientSize().y - GetSize().y;
</mark>1<br><mark>            if( pos_in_parent.y > ( max_down - DOCK_MARGIN ) ) {
</mark>1<br><mark>                pos_in_parent.y = max_down;
</mark>1<br><mark>                m_dock_y = 1;
</mark>1<br><mark>            }
</mark>1<br><mark>        }
</mark>1<br><mark>
</mark>1<br><mark>    m_position = pos_in_parent;
</mark>1<br><mark>
</mark>1<br><mark>    wxPoint final_pos = m_pparent->ClientToScreen( pos_in_parent );
</mark>1<br><mark>
</mark>1<br><mark>    Move( final_pos );
</mark>1<br><mark>}
</mark>1<br><mark>
</mark>1<br><mark>void ocpnFloatingToolbarDialog::Realize()
</mark>1<br><mark>{
</mark>1<br><mark>    if( m_ptoolbar ) {
</mark>1<br><mark>        m_ptoolbar->Realize();
</mark>1<br><mark>
</mark>1<br><mark>        m_topSizer->Clear();
</mark>1<br><mark>        m_topSizer->Add( m_ptoolbar );
</mark>1<br><mark>        m_topSizer->Add( m_pGrabberwin, 0, wxTOP, m_style->GetTopMargin() );
</mark>1<br><mark>
</mark>1<br><mark>        m_topSizer->Layout();
</mark>1<br><mark>        Fit();
</mark>1<br><mark>
</mark>1<br><mark>        //    Update "Dock" parameters
</mark>1<br><mark>        if( m_position.x == 0 ) m_dock_x = -1;
</mark>1<br><mark>        else
</mark>1<br><mark>            if( m_position.x == m_pparent->GetClientSize().x - GetSize().x ) m_dock_x = 1;
</mark>1<br><mark>
</mark>1<br><mark>        if( m_position.y == 0 ) m_dock_y = -1;
</mark>1<br><mark>        else
</mark>1<br><mark>            if( m_position.y == m_pparent->GetClientSize().y - GetSize().y ) m_dock_y = 1;
</mark>1<br><mark>
</mark>1<br><mark>        // Now create a bitmap mask forthe frame shape.
</mark>1<br><mark>
</mark>1<br><mark>        if( m_marginsInvisible ) {
</mark>1<br><mark>
</mark>1<br><mark>            wxSize tool_size = m_ptoolbar->GetToolBitmapSize();
</mark>1<br><mark>
</mark>1<br><mark>            //  Determine whether the tool icons are meant (by style) to join without speces between
</mark>1<br><mark>            //  This will determine what type of region to draw.
</mark>1<br><mark>            bool b_overlap = false;
</mark>1<br><mark>
</mark>1<br><mark>            wxToolBarToolsList::compatibility_iterator node1 = m_ptoolbar->m_tools.GetFirst();
</mark>1<br><mark>            wxToolBarToolsList::compatibility_iterator node2 = node1->GetNext() ;
</mark>1<br><mark>
</mark>1<br><mark>            wxToolBarToolBase *tool1 = node1->GetData();
</mark>1<br><mark>            ocpnToolBarTool *tools1 = (ocpnToolBarTool *) tool1;
</mark>1<br><mark>
</mark>1<br><mark>            wxToolBarToolBase *tool2 = node2->GetData();
</mark>1<br><mark>            ocpnToolBarTool *tools2 = (ocpnToolBarTool *) tool2;
</mark>1<br><mark>
</mark>1<br><mark>            if( (tools1->m_x + tools1->m_width) >= tools2->m_x)
</mark>1<br><mark>                b_overlap = true;
</mark>1<br><mark>
</mark>1<br><mark>
</mark>1<br><mark>
</mark>1<br><mark>
</mark>1<br><mark>            int toolCount = m_ptoolbar->GetVisibleToolCount();
</mark>1<br><mark>
</mark>1<br><mark>            wxPoint upperLeft( m_style->GetLeftMargin(), m_style->GetTopMargin() );
</mark>1<br><mark>            wxSize visibleSize;
</mark>1<br><mark>            if( m_ptoolbar->IsVertical() ) {
</mark>1<br><mark>                int noTools = m_ptoolbar->GetMaxRows();
</mark>1<br><mark>                if( noTools > toolCount )
</mark>1<br><mark>                    noTools = toolCount;
</mark>1<br><mark>                visibleSize.x = m_ptoolbar->GetLineCount() * ( tool_size.x + m_style->GetTopMargin() );
</mark>1<br><mark>                visibleSize.y = noTools * ( tool_size.y + m_style->GetToolSeparation() );
</mark>1<br><mark>                visibleSize.x -= m_style->GetTopMargin();
</mark>1<br><mark>                visibleSize.y -= m_style->GetToolSeparation();
</mark>1<br><mark>            } else {
</mark>1<br><mark>                    int noTools = m_ptoolbar->GetMaxCols();
</mark>1<br><mark>                    if( noTools > toolCount )
</mark>1<br><mark>                        noTools = toolCount;
</mark>1<br><mark>                visibleSize.x = noTools * ( tool_size.x + m_style->GetToolSeparation() );
</mark>1<br><mark>                visibleSize.y = m_ptoolbar->GetLineCount() * ( tool_size.y + m_style->GetTopMargin() );
</mark>1<br><mark>                visibleSize.x -= m_style->GetToolSeparation();
</mark>1<br><mark>                visibleSize.y -= m_style->GetTopMargin();
</mark>1<br><mark>            }
</mark>1<br><mark>
</mark>1<br><mark>            wxBitmap shape( visibleSize.x + tool_size.x, visibleSize.y + tool_size.y);          // + fluff
</mark>1<br><mark>            wxMemoryDC sdc( shape );
</mark>1<br><mark>            sdc.SetBackground( *wxWHITE_BRUSH );
</mark>1<br><mark>            sdc.SetBrush( *wxBLACK_BRUSH );
</mark>1<br><mark>            sdc.SetPen( *wxBLACK_PEN );
</mark>1<br><mark>            sdc.Clear();
</mark>1<br><mark>
</mark>1<br><mark>            if(b_overlap) {
</mark>1<br><mark>                int lines = m_ptoolbar->GetLineCount();
</mark>1<br><mark>                for( int i = 1; i <= lines; i++ ) {
</mark>1<br><mark>                    if( m_ptoolbar->IsVertical() ) {
</mark>1<br><mark>                        wxSize barsize( tool_size.x, visibleSize.y );
</mark>1<br><mark>                        if( i == lines && i > 1 ) {
</mark>1<br><mark>                            int toolsInLastLine = toolCount % m_ptoolbar->GetMaxRows();
</mark>1<br><mark>                            if( toolsInLastLine == 0 ) toolsInLastLine = m_ptoolbar->GetMaxRows();
</mark>1<br><mark>                            int emptySpace = ( m_ptoolbar->GetMaxRows() - toolsInLastLine );
</mark>1<br><mark>                            barsize.y -= emptySpace
</mark>1<br><mark>                            * ( tool_size.y + m_style->GetToolSeparation() );
</mark>1<br><mark>                        }
</mark>1<br><mark>                        if( i == lines ) {
</mark>1<br><mark>                            // Also do grabber here, since it is to the right of the last line.
</mark>1<br><mark>                            wxRect grabMask( upperLeft, barsize );
</mark>1<br><mark>                            grabMask.width += m_style->GetIcon( _T("grabber") ).GetWidth();
</mark>1<br><mark>                            grabMask.height = m_style->GetIcon( _T("grabber") ).GetHeight();
</mark>1<br><mark>                            sdc.DrawRoundedRectangle( grabMask, m_style->GetToolbarCornerRadius() );
</mark>1<br><mark>                        }
</mark>1<br><mark>                        sdc.DrawRoundedRectangle( upperLeft, barsize,
</mark>1<br><mark>                                m_style->GetToolbarCornerRadius() );
</mark>1<br><mark>                        upperLeft.x += m_style->GetTopMargin() + tool_size.x;
</mark>1<br><mark>                    } else {
</mark>1<br><mark>                        wxSize barsize( visibleSize.x, tool_size.y );
</mark>1<br><mark>
</mark>1<br><mark>                        if( i == 1 ) {
</mark>1<br><mark>                            barsize.x += m_style->GetIcon( _T("grabber") ).GetWidth();
</mark>1<br><mark>                        }
</mark>1<br><mark>                        if( i == lines && i > 1 ) {
</mark>1<br><mark>                            int toolsInLastLine = toolCount % m_ptoolbar->GetMaxCols();
</mark>1<br><mark>                            if( toolsInLastLine == 0 ) toolsInLastLine = m_ptoolbar->GetMaxCols();
</mark>1<br><mark>                            int emptySpace = ( m_ptoolbar->GetMaxCols() - toolsInLastLine );
</mark>1<br><mark>                            barsize.x -= emptySpace * ( tool_size.x + m_style->GetToolSeparation() );
</mark>1<br><mark>                        }
</mark>1<br><mark>
</mark>1<br><mark>                        sdc.DrawRoundedRectangle( upperLeft, barsize,
</mark>1<br><mark>                                m_style->GetToolbarCornerRadius() );
</mark>1<br><mark>                        upperLeft.y += m_style->GetTopMargin() + tool_size.y;
</mark>1<br><mark>                    }
</mark>1<br><mark>                }
</mark>1<br><mark>            } //b_overlap
</mark>1<br><mark>            else {
</mark>1<br><mark>                for( wxToolBarToolsList::compatibility_iterator node = m_ptoolbar->m_tools.GetFirst(); node; node = node->GetNext() ) {
</mark>1<br><mark>                    wxToolBarToolBase *tool = node->GetData();
</mark>1<br><mark>                    ocpnToolBarTool *tools = (ocpnToolBarTool *) tool;
</mark>1<br><mark>                    wxRect toolRect = tools->trect;
</mark>1<br><mark>
</mark>1<br><mark>                    sdc.DrawRoundedRectangle( tools->m_x, tools->m_y, tool_size.x, tool_size.y,
</mark>1<br><mark>                                              m_style->GetToolbarCornerRadius() );
</mark>1<br><mark>                }
</mark>1<br><mark>            }
</mark>1<br><mark>
</mark>1<br><mark>#ifndef __OCPN__ANDROID__
</mark>1<br><mark>            if(shape.GetWidth() && shape.GetHeight())
</mark>1<br><mark>                SetShape( wxRegion( shape, *wxWHITE, 10 ) );
</mark>1<br><mark>#endif
</mark>1<br><mark>        }
</mark>1<br><mark>    }
</mark>1<br><mark>}
</mark>1<br><mark>
</mark>1<br><mark>void ocpnFloatingToolbarDialog::OnToolLeftClick( wxCommandEvent& event )
</mark>1<br><mark>{
</mark>1<br><mark>    // First see if it was actually the context menu that was clicked.
</mark>1<br><mark>
</mark>1<br><mark>    if( event.GetId() >= ID_PLUGIN_BASE + 100 ) {
</mark>1<br><mark>
</mark>1<br><mark>        int itemId = event.GetId() - ID_PLUGIN_BASE - 100;
</mark>1<br><mark>        wxMenuItem *item = g_FloatingToolbarConfigMenu->FindItem( event.GetId() );
</mark>1<br><mark>
</mark>1<br><mark>        if(item){
</mark>1<br><mark>            bool toolIsChecked = item->IsChecked();
</mark>1<br><mark>
</mark>1<br><mark>            if( toolIsChecked ) {
</mark>1<br><mark>                g_toolbarConfig.SetChar( itemId, _T('X') );
</mark>1<br><mark>            } else {
</mark>1<br><mark>
</mark>1<br><mark>                if( itemId + ID_ZOOMIN == ID_MOB ) {
</mark>1<br><mark>                    ToolbarMOBDialog mdlg( this );
</mark>1<br><mark>                    int dialog_ret = mdlg.ShowModal();
</mark>1<br><mark>                    int answer = mdlg.GetSelection();
</mark>1<br><mark>
</mark>1<br><mark>                    if( answer == 0 || answer == 1 || dialog_ret == wxID_CANCEL ) {
</mark>1<br><mark>                        g_FloatingToolbarConfigMenu->FindItem( event.GetId() )->Check( true );
</mark>1<br><mark>                        if( answer == 1 && dialog_ret == wxID_OK ) {
</mark>1<br><mark>                            g_bPermanentMOBIcon = true;
</mark>1<br><mark>                            delete g_FloatingToolbarConfigMenu;
</mark>1<br><mark>                            g_FloatingToolbarConfigMenu = new wxMenu();
</mark>1<br><mark>                            toolbarConfigChanged = true;
</mark>1<br><mark>                        }
</mark>1<br><mark>                        return;
</mark>1<br><mark>                    }
</mark>1<br><mark>                }
</mark>1<br><mark>
</mark>1<br><mark>                if( m_ptoolbar->GetVisibleToolCount() == 1 ) {
</mark>1<br><mark>                    OCPNMessageBox( this,
</mark>1<br><mark>                            _("You can't hide the last tool from the toolbar\nas this would make it inaccessible."),
</mark>1<br><mark>                            _("OpenCPN Alert"), wxOK );
</mark>1<br><mark>                    g_FloatingToolbarConfigMenu->FindItem( event.GetId() )->Check( true );
</mark>1<br><mark>                    return;
</mark>1<br><mark>                }
</mark>1<br><mark>
</mark>1<br><mark>                g_toolbarConfig.SetChar( itemId, _T('.') );
</mark>1<br><mark>            }
</mark>1<br><mark>        }
</mark>1<br><mark>
</mark>1<br><mark>        toolbarConfigChanged = true;
</mark>1<br><mark>        return;
</mark>1<br><mark>    }
</mark>1<br><mark>
</mark>1<br><mark>    // No it was a button that was clicked.
</mark>1<br><mark>    // Since Dialog events don't propagate automatically, we send it explicitly
</mark>1<br><mark>    // (instead of relying on event.Skip()). Send events up the window hierarchy
</mark>1<br><mark>
</mark>1<br><mark>    m_pparent->GetEventHandler()->AddPendingEvent( event );
</mark>1<br><mark>#ifndef __WXQT__
</mark>1<br><mark>    gFrame->Raise();
</mark>1<br><mark>#endif    
</mark>1<br><mark>}
</mark>1<br><mark>
</mark>1<br><mark>ocpnToolBarSimple *ocpnFloatingToolbarDialog::GetToolbar()
</mark>1<br><mark>{
</mark>1<br><mark>    if( !m_ptoolbar ) {
</mark>1<br><mark>        long winstyle = wxNO_BORDER | wxTB_FLAT;
</mark>1<br><mark>        winstyle |= m_orient;
</mark>1<br><mark>
</mark>1<br><mark>        m_ptoolbar = new ocpnToolBarSimple( this, -1, wxPoint( -1, -1 ), wxSize( -1, -1 ),
</mark>1<br><mark>                winstyle );
</mark>1<br><mark>
</mark>1<br><mark>        m_ptoolbar->SetBackgroundColour( GetGlobalColor( _T("GREY2") ) );
</mark>1<br><mark>        m_ptoolbar->ClearBackground();
</mark>1<br><mark>        m_ptoolbar->SetToggledBackgroundColour( GetGlobalColor( _T("GREY1") ) );
</mark>1<br><mark>        m_ptoolbar->SetColorScheme( m_cs );
</mark>1<br><mark>
</mark>1<br><mark>        SetGeometry(false, wxRect());
</mark>1<br><mark>    }
</mark>1<br><mark>
</mark>1<br><mark>    return m_ptoolbar;
</mark>1<br><mark>}
</mark>1<br><mark>
</mark>1<br><mark>void ocpnFloatingToolbarDialog::DestroyToolBar()
</mark>1<br><mark>{
</mark>1<br><mark>    if( m_ptoolbar ) {
</mark>1<br><mark>        m_ptoolbar->ClearTools();
</mark>1<br><mark>        delete m_ptoolbar;                  //->Destroy();
</mark>1<br><mark>        m_ptoolbar = NULL;
</mark>1<br><mark>    }
</mark>1<br><mark> 
</mark>1<br><mark>    m_destroyGrabber = m_pRecoverwin;
</mark>1<br><mark>    m_destroyTimer.Start( 5, wxTIMER_ONE_SHOT );           //  Destor the unneeded recovery grabber
</mark>1<br><mark>    
</mark>1<br><mark>}
</mark>1<br><mark>
</mark>1<br><mark>//----------------------------------------------------------------------------
</mark>1<br><mark>// Toolbar Tooltip Popup Window Definition
</mark>1<br><mark>//----------------------------------------------------------------------------
</mark>1<br><mark>class ToolTipWin: public wxDialog {
</mark>1<br><mark>public:
</mark>1<br><mark>    ToolTipWin( wxWindow *parent );
</mark>1<br><mark>    ~ToolTipWin();
</mark>1<br><mark>
</mark>1<br><mark>    void OnPaint( wxPaintEvent& event );
</mark>1<br><mark>
</mark>1<br><mark>    void SetColorScheme( ColorScheme cs );
</mark>1<br><mark>    void SetString( wxString &s )
</mark>1<br><mark>    {
</mark>1<br><mark>        m_string = s;
</mark>1<br><mark>    }
</mark>1<br><mark>    void SetPosition( wxPoint pt )
</mark>1<br><mark>    {
</mark>1<br><mark>        m_position = pt;
</mark>1<br><mark>    }
</mark>1<br><mark>    void SetBitmap( void );
</mark>1<br><mark>
</mark>1<br><mark>    void SetHiviz( bool hiviz){ m_hiviz = hiviz; }
</mark>1<br><mark>    
</mark>1<br><mark>    wxSize GetRenderedSize( void );
</mark>1<br><mark>    
</mark>1<br><mark>private:
</mark>1<br><mark>
</mark>1<br><mark>    wxString m_string;
</mark>1<br><mark>    wxSize m_size;
</mark>1<br><mark>    wxPoint m_position;
</mark>1<br><mark>    wxBitmap *m_pbm;
</mark>1<br><mark>    wxColour m_back_color;
</mark>1<br><mark>    wxColour m_text_color;
</mark>1<br><mark>    ColorScheme m_cs ;
</mark>1<br><mark>    bool m_hiviz;
</mark>1<br><mark>
</mark>1<br><mark>DECLARE_EVENT_TABLE()
</mark>1<br><mark>};
</mark>1<br><mark>//-----------------------------------------------------------------------
</mark>1<br><mark>//
</mark>1<br><mark>//    Toolbar Tooltip window implementation
</mark>1<br><mark>//
</mark>1<br><mark>//-----------------------------------------------------------------------
</mark>1<br><mark>BEGIN_EVENT_TABLE(ToolTipWin, wxDialog) EVT_PAINT(ToolTipWin::OnPaint)
</mark>1<br><mark>
</mark>1<br><mark>END_EVENT_TABLE()
</mark>1<br><mark>
</mark>1<br><mark>// Define a constructor
</mark>1<br><mark>ToolTipWin::ToolTipWin( wxWindow *parent ) :
</mark>1<br><mark>        wxDialog( parent, wxID_ANY, _T(""), wxPoint( 0, 0 ), wxSize( 1, 1 ),
</mark>1<br><mark>                wxNO_BORDER | wxSTAY_ON_TOP )
</mark>1<br><mark>{
</mark>1<br><mark>    m_pbm = NULL;
</mark>1<br><mark>
</mark>1<br><mark>    m_back_color = GetGlobalColor( _T ( "UIBCK" ) );
</mark>1<br><mark>    m_text_color = GetGlobalColor( _T ( "UITX1" ) );
</mark>1<br><mark>
</mark>1<br><mark>    SetBackgroundStyle( wxBG_STYLE_CUSTOM );
</mark>1<br><mark>    SetBackgroundColour( m_back_color );
</mark>1<br><mark>    m_cs = GLOBAL_COLOR_SCHEME_RGB;
</mark>1<br><mark>
</mark>1<br><mark>    Hide();
</mark>1<br><mark>}
</mark>1<br><mark>
</mark>1<br><mark>ToolTipWin::~ToolTipWin()
</mark>1<br><mark>{
</mark>1<br><mark>    delete m_pbm;
</mark>1<br><mark>}
</mark>1<br><mark>
</mark>1<br><mark>void ToolTipWin::SetColorScheme( ColorScheme cs )
</mark>1<br><mark>{
</mark>1<br><mark>    m_back_color = GetGlobalColor( _T ( "UIBCK" ) );
</mark>1<br><mark>    m_text_color = FontMgr::Get().GetFontColor( _("ToolTips") );
</mark>1<br><mark>
</mark>1<br><mark>    m_cs = cs;
</mark>1<br><mark>}
</mark>1<br><mark>
</mark>1<br><mark>wxSize ToolTipWin::GetRenderedSize( void )
</mark>1<br><mark>{
</mark>1<br><mark>    int h, w;
</mark>1<br><mark>    wxSize sz;
</mark>1<br><mark>
</mark>1<br><mark>    wxClientDC cdc( GetParent() );
</mark>1<br><mark>
</mark>1<br><mark>    wxFont *plabelFont = FontMgr::Get().GetFont( _("ToolTips") );
</mark>1<br><mark>    cdc.GetTextExtent( m_string, &w, &h, NULL, NULL, plabelFont );
</mark>1<br><mark>
</mark>1<br><mark>    sz.x = w + 8;
</mark>1<br><mark>    sz.y = h + 4;
</mark>1<br><mark>    
</mark>1<br><mark>    return sz;
</mark>1<br><mark>
</mark>1<br><mark>}
</mark>1<br><mark>
</mark>1<br><mark>void ToolTipWin::SetBitmap()
</mark>1<br><mark>{
</mark>1<br><mark>    int h, w;
</mark>1<br><mark>
</mark>1<br><mark>    wxClientDC cdc( GetParent() );
</mark>1<br><mark>
</mark>1<br><mark>    wxFont *plabelFont = FontMgr::Get().GetFont( _("ToolTips") );
</mark>1<br><mark>    cdc.GetTextExtent( m_string, &w, &h, NULL, NULL, plabelFont );
</mark>1<br><mark>
</mark>1<br><mark>    m_size.x = w + 8;
</mark>1<br><mark>    m_size.y = h + 4;
</mark>1<br><mark>
</mark>1<br><mark>    wxMemoryDC mdc;
</mark>1<br><mark>
</mark>1<br><mark>    delete m_pbm;
</mark>1<br><mark>    m_pbm = new wxBitmap( m_size.x, m_size.y, -1 );
</mark>1<br><mark>    mdc.SelectObject( *m_pbm );
</mark>1<br><mark>
</mark>1<br><mark>    wxPen pborder( m_text_color );
</mark>1<br><mark>    wxBrush bback( m_back_color );
</mark>1<br><mark>    mdc.SetPen( pborder );
</mark>1<br><mark>    mdc.SetBrush( bback );
</mark>1<br><mark>
</mark>1<br><mark>    if(m_hiviz){
</mark>1<br><mark>        if((m_cs == GLOBAL_COLOR_SCHEME_DUSK) || (m_cs == GLOBAL_COLOR_SCHEME_NIGHT)){
</mark>1<br><mark>            wxBrush hv_back( wxColour(200,200,200));
</mark>1<br><mark>            mdc.SetBrush( hv_back );
</mark>1<br><mark>        }
</mark>1<br><mark>    }
</mark>1<br><mark>    mdc.DrawRectangle( 0, 0, m_size.x, m_size.y );
</mark>1<br><mark>
</mark>1<br><mark>    //    Draw the text
</mark>1<br><mark>    mdc.SetFont( *plabelFont );
</mark>1<br><mark>    mdc.SetTextForeground( m_text_color );
</mark>1<br><mark>    mdc.SetTextBackground( m_back_color );
</mark>1<br><mark>
</mark>1<br><mark>    mdc.DrawText( m_string, 4, 2 );
</mark>1<br><mark>
</mark>1<br><mark>    SetSize( m_position.x, m_position.y, m_size.x, m_size.y );
</mark>1<br><mark>
</mark>1<br><mark>}
</mark>1<br><mark>
</mark>1<br><mark>void ToolTipWin::OnPaint( wxPaintEvent& event )
</mark>1<br><mark>{
</mark>1<br><mark>    int width, height;
</mark>1<br><mark>    GetClientSize( &width, &height );
</mark>1<br><mark>    wxPaintDC dc( this );
</mark>1<br><mark>
</mark>1<br><mark>    if( m_string.Len() ) {
</mark>1<br><mark>        wxMemoryDC mdc;
</mark>1<br><mark>        mdc.SelectObject( *m_pbm );
</mark>1<br><mark>        dc.Blit( 0, 0, width, height, &mdc, 0, 0 );
</mark>1<br><mark>    }
</mark>1<br><mark>}
</mark>1<br><mark>
</mark>1<br><mark>
</mark>1<br><mark>// ----------------------------------------------------------------------------
</mark>1<br><mark>BEGIN_EVENT_TABLE(ocpnToolBarSimple, wxControl) EVT_SIZE(ocpnToolBarSimple::OnSize)
</mark>1<br><mark>EVT_PAINT(ocpnToolBarSimple::OnPaint)
</mark>1<br><mark>EVT_KILL_FOCUS(ocpnToolBarSimple::OnKillFocus)
</mark>1<br><mark>EVT_MOUSE_EVENTS(ocpnToolBarSimple::OnMouseEvent)
</mark>1<br><mark>EVT_TIMER(TOOLTIPON_TIMER, ocpnToolBarSimple::OnToolTipTimerEvent)
</mark>1<br><mark>EVT_TIMER(TOOLTIPOFF_TIMER, ocpnToolBarSimple::OnToolTipOffTimerEvent)
</mark>1<br><mark>
</mark>1<br><mark>END_EVENT_TABLE()
</mark>1<br><mark>
</mark>1<br><mark>// ============================================================================
</mark>1<br><mark>// implementation
</mark>1<br><mark>// ============================================================================
</mark>1<br><mark>
</mark>1<br><mark>// ----------------------------------------------------------------------------
</mark>1<br><mark>// tool bar tools creation
</mark>1<br><mark>// ----------------------------------------------------------------------------
</mark>1<br><mark>
</mark>1<br><mark>wxToolBarToolBase *ocpnToolBarSimple::CreateTool( int id, const wxString& label,
</mark>1<br><mark>        const wxBitmap& bmpNormal, const wxBitmap& bmpDisabled, wxItemKind kind,
</mark>1<br><mark>        wxObject *clientData, const wxString& shortHelp, const wxString& longHelp )
</mark>1<br><mark>{
</mark>1<br><mark>    return new ocpnToolBarTool( this, id, label, bmpNormal, bmpDisabled, kind, clientData,
</mark>1<br><mark>            shortHelp, longHelp );
</mark>1<br><mark>}
</mark>1<br><mark>
</mark>1<br><mark>// ----------------------------------------------------------------------------
</mark>1<br><mark>// ocpnToolBarSimple creation
</mark>1<br><mark>// ----------------------------------------------------------------------------
</mark>1<br><mark>
</mark>1<br><mark>void ocpnToolBarSimple::Init()
</mark>1<br><mark>{
</mark>1<br><mark>    m_currentRowsOrColumns = 0;
</mark>1<br><mark>
</mark>1<br><mark>    m_lastX = m_lastY = 0;
</mark>1<br><mark>
</mark>1<br><mark>    m_maxWidth = m_maxHeight = 0;
</mark>1<br><mark>
</mark>1<br><mark>    m_pressedTool = m_currentTool = -1;
</mark>1<br><mark>
</mark>1<br><mark>    m_xPos = m_yPos = wxDefaultCoord;
</mark>1<br><mark>
</mark>1<br><mark>    m_style = g_StyleManager->GetCurrentStyle();
</mark>1<br><mark>
</mark>1<br><mark>    m_defaultWidth = 16;
</mark>1<br><mark>    m_defaultHeight = 15;
</mark>1<br><mark>
</mark>1<br><mark>    m_toggle_bg_color = wxSystemSettings::GetColour( wxSYS_COLOUR_3DFACE );
</mark>1<br><mark>    m_toolOutlineColour.Set( _T("BLACK") );
</mark>1<br><mark>    m_pToolTipWin = NULL;
</mark>1<br><mark>    m_last_ro_tool = NULL;
</mark>1<br><mark>
</mark>1<br><mark>    m_btoolbar_is_zooming = false;
</mark>1<br><mark>    m_sizefactor = 1.0f;
</mark>1<br><mark>
</mark>1<br><mark>    m_last_plugin_down_id = -1;
</mark>1<br><mark>    
</mark>1<br><mark>    EnableTooltips();
</mark>1<br><mark>}
</mark>1<br><mark>
</mark>1<br><mark>wxToolBarToolBase *ocpnToolBarSimple::DoAddTool( int id, const wxString& label,
</mark>1<br><mark>        const wxBitmap& bitmap, const wxBitmap& bmpDisabled, wxItemKind kind,
</mark>1<br><mark>        const wxString& shortHelp, const wxString& longHelp, wxObject *clientData, wxCoord xPos,
</mark>1<br><mark>        wxCoord yPos )
</mark>1<br><mark>{
</mark>1<br><mark>    // rememeber the position for DoInsertTool()
</mark>1<br><mark>    m_xPos = xPos;
</mark>1<br><mark>    m_yPos = yPos;
</mark>1<br><mark>
</mark>1<br><mark>    InvalidateBestSize();
</mark>1<br><mark>    return InsertTool( GetToolsCount(), id, label, bitmap, bmpDisabled, kind, shortHelp, longHelp,
</mark>1<br><mark>            clientData );
</mark>1<br><mark>
</mark>1<br><mark>}
</mark>1<br><mark>
</mark>1<br><mark>///
</mark>1<br><mark>
</mark>1<br><mark>wxToolBarToolBase *ocpnToolBarSimple::AddTool( int toolid, const wxString& label,
</mark>1<br><mark>        const wxBitmap& bitmap, const wxBitmap& bmpDisabled, wxItemKind kind,
</mark>1<br><mark>        const wxString& shortHelp, const wxString& longHelp, wxObject *data )
</mark>1<br><mark>{
</mark>1<br><mark>    InvalidateBestSize();
</mark>1<br><mark>    ocpnToolBarTool* tool = (ocpnToolBarTool*)InsertTool( GetToolsCount(), toolid, label, bitmap, bmpDisabled, kind,
</mark>1<br><mark>            shortHelp, longHelp, data );
</mark>1<br><mark>    return tool;
</mark>1<br><mark>}
</mark>1<br><mark>
</mark>1<br><mark>wxToolBarToolBase *ocpnToolBarSimple::InsertTool( size_t pos, int id, const wxString& label,
</mark>1<br><mark>        const wxBitmap& bitmap, const wxBitmap& bmpDisabled, wxItemKind kind,
</mark>1<br><mark>        const wxString& shortHelp, const wxString& longHelp, wxObject *clientData )
</mark>1<br><mark>{
</mark>1<br><mark>    wxCHECK_MSG( pos <= GetToolsCount(), (wxToolBarToolBase *)NULL,
</mark>1<br><mark>            _T("invalid position in wxToolBar::InsertTool()") );
</mark>1<br><mark>
</mark>1<br><mark>    wxToolBarToolBase *tool = CreateTool( id, label, bitmap, bmpDisabled, kind, clientData,
</mark>1<br><mark>            shortHelp, longHelp );
</mark>1<br><mark>
</mark>1<br><mark>    if( !InsertTool( pos, tool ) ) {
</mark>1<br><mark>        delete tool;
</mark>1<br><mark>
</mark>1<br><mark>        return NULL;
</mark>1<br><mark>    }
</mark>1<br><mark>
</mark>1<br><mark>    return tool;
</mark>1<br><mark>}
</mark>1<br><mark>
</mark>1<br><mark>wxToolBarToolBase *ocpnToolBarSimple::InsertTool( size_t pos, wxToolBarToolBase *tool )
</mark>1<br><mark>{
</mark>1<br><mark>    wxCHECK_MSG( pos <= GetToolsCount(), (wxToolBarToolBase *)NULL,
</mark>1<br><mark>            _T("invalid position in wxToolBar::InsertTool()") );
</mark>1<br><mark>
</mark>1<br><mark>    if( !tool || !DoInsertTool( pos, tool ) ) {
</mark>1<br><mark>        return NULL;
</mark>1<br><mark>    }
</mark>1<br><mark>
</mark>1<br><mark>    m_tools.Insert( pos, tool );
</mark>1<br><mark>
</mark>1<br><mark>    return tool;
</mark>1<br><mark>}
</mark>1<br><mark>
</mark>1<br><mark>bool ocpnToolBarSimple::DoInsertTool( size_t WXUNUSED(pos), wxToolBarToolBase *toolBase )
</mark>1<br><mark>{
</mark>1<br><mark>    ocpnToolBarTool *tool = (ocpnToolBarTool *) toolBase;
</mark>1<br><mark>
</mark>1<br><mark>    // Check if the plugin is inserting same-named tools. Make sure they have different names,
</mark>1<br><mark>    // otherwise the style manager cannot differentiate between them.
</mark>1<br><mark>    if( tool->isPluginTool ) {
</mark>1<br><mark>        for( unsigned int i=0; i<GetToolsCount(); i++ ) {
</mark>1<br><mark>            if( tool->GetToolname() == ((ocpnToolBarTool *)m_tools.Item(i)->GetData())->GetToolname()) {
</mark>1<br><mark>                tool->toolname << _T("1");
</mark>1<br><mark>            }
</mark>1<br><mark>        }
</mark>1<br><mark>    }
</mark>1<br><mark>
</mark>1<br><mark>    tool->m_x = m_xPos;
</mark>1<br><mark>    if( tool->m_x == wxDefaultCoord ) tool->m_x = m_style->GetLeftMargin();
</mark>1<br><mark>
</mark>1<br><mark>    tool->m_y = m_yPos;
</mark>1<br><mark>    if( tool->m_y == wxDefaultCoord ) tool->m_y = m_style->GetTopMargin();
</mark>1<br><mark>
</mark>1<br><mark>    if( tool->IsButton() ) {
</mark>1<br><mark>        tool->SetSize( GetToolSize() );
</mark>1<br><mark>
</mark>1<br><mark>        // Calculate reasonable max size in case Layout() not called
</mark>1<br><mark>        if( ( tool->m_x + tool->GetNormalBitmap().GetWidth() + m_style->GetLeftMargin() )
</mark>1<br><mark>                > m_maxWidth ) m_maxWidth = (wxCoord) ( ( tool->m_x + tool->GetWidth()
</mark>1<br><mark>                + m_style->GetLeftMargin() ) );
</mark>1<br><mark>
</mark>1<br><mark>        if( ( tool->m_y + tool->GetNormalBitmap().GetHeight() + m_style->GetTopMargin() )
</mark>1<br><mark>                > m_maxHeight ) m_maxHeight = (wxCoord) ( ( tool->m_y + tool->GetHeight()
</mark>1<br><mark>                + m_style->GetTopMargin() ) );
</mark>1<br><mark>    }
</mark>1<br><mark>
</mark>1<br><mark>    else
</mark>1<br><mark>        if( tool->IsControl() ) {
</mark>1<br><mark>            tool->SetSize( tool->GetControl()->GetSize() );
</mark>1<br><mark>        }
</mark>1<br><mark>
</mark>1<br><mark>    tool->b_hilite = false;
</mark>1<br><mark>
</mark>1<br><mark>    return true;
</mark>1<br><mark>}
</mark>1<br><mark>
</mark>1<br><mark>bool ocpnToolBarSimple::DoDeleteTool( size_t WXUNUSED(pos), wxToolBarToolBase *tool )
</mark>1<br><mark>{
</mark>1<br><mark>    // VZ: didn't test whether it works, but why not...
</mark>1<br><mark>    tool->Detach();
</mark>1<br><mark>
</mark>1<br><mark>    if( m_last_ro_tool == tool ) m_last_ro_tool = NULL;
</mark>1<br><mark>
</mark>1<br><mark>    Refresh( false );
</mark>1<br><mark>
</mark>1<br><mark>    return true;
</mark>1<br><mark>}
</mark>1<br><mark>
</mark>1<br><mark>bool ocpnToolBarSimple::Create( wxWindow *parent, wxWindowID id, const wxPoint& pos,
</mark>1<br><mark>        const wxSize& size, long style, const wxString& name )
</mark>1<br><mark>{
</mark>1<br><mark>    if( !wxWindow::Create( parent, id, pos, size, style, name ) ) return false;
</mark>1<br><mark>
</mark>1<br><mark>    // Set it to grey (or other 3D face colour)
</mark>1<br><mark>    SetBackgroundColour( wxSystemSettings::GetColour( wxSYS_COLOUR_3DFACE ) );
</mark>1<br><mark>
</mark>1<br><mark>    if( GetWindowStyleFlag() & wxTB_VERTICAL ) {
</mark>1<br><mark>        m_lastX = 7;
</mark>1<br><mark>        m_lastY = 3;
</mark>1<br><mark>
</mark>1<br><mark>        m_maxRows = 32000;      // a lot
</mark>1<br><mark>        m_maxCols = 1;
</mark>1<br><mark>    } else {
</mark>1<br><mark>        m_lastX = 3;
</mark>1<br><mark>        m_lastY = 7;
</mark>1<br><mark>
</mark>1<br><mark>        m_maxRows = 1;
</mark>1<br><mark>        m_maxCols = 32000;      // a lot
</mark>1<br><mark>    }
</mark>1<br><mark>
</mark>1<br><mark>    SetCursor( *wxSTANDARD_CURSOR );
</mark>1<br><mark>
</mark>1<br><mark>    m_tooltip_timer.SetOwner( this, TOOLTIPON_TIMER );
</mark>1<br><mark>    m_tooltipoff_timer.SetOwner( this, TOOLTIPOFF_TIMER );
</mark>1<br><mark>    m_tooltip_off = 3000;
</mark>1<br><mark>
</mark>1<br><mark>    return true;
</mark>1<br><mark>}
</mark>1<br><mark>
</mark>1<br><mark>ocpnToolBarSimple::~ocpnToolBarSimple()
</mark>1<br><mark>{
</mark>1<br><mark>    if( m_pToolTipWin ) {
</mark>1<br><mark>        m_pToolTipWin->Destroy();
</mark>1<br><mark>        m_pToolTipWin = NULL;
</mark>1<br><mark>    }
</mark>1<br><mark>
</mark>1<br><mark>}
</mark>1<br><mark>
</mark>1<br><mark>void ocpnToolBarSimple::KillTooltip()
</mark>1<br><mark>{
</mark>1<br><mark>    m_btooltip_show = false;
</mark>1<br><mark>
</mark>1<br><mark>    if( m_pToolTipWin ) {
</mark>1<br><mark>        m_pToolTipWin->Hide();
</mark>1<br><mark>        m_pToolTipWin->Destroy();
</mark>1<br><mark>        m_pToolTipWin = NULL;
</mark>1<br><mark>    }
</mark>1<br><mark>    m_tooltip_timer.Stop();
</mark>1<br><mark>
</mark>1<br><mark>    if( m_last_ro_tool ) {
</mark>1<br><mark>        if( m_last_ro_tool->IsEnabled() ) {
</mark>1<br><mark>            if( m_last_ro_tool->IsToggled() ) {
</mark>1<br><mark>                m_last_ro_tool->SetNormalBitmap( m_style->GetToolIcon( m_last_ro_tool->GetToolname(), TOOLICON_TOGGLED ) );
</mark>1<br><mark>            }
</mark>1<br><mark>            else {
</mark>1<br><mark>                m_last_ro_tool->SetNormalBitmap( m_style->GetToolIcon( m_last_ro_tool->GetToolname(), TOOLICON_NORMAL ) );
</mark>1<br><mark>            }
</mark>1<br><mark>        }
</mark>1<br><mark>    }
</mark>1<br><mark>}
</mark>1<br><mark>
</mark>1<br><mark>void ocpnToolBarSimple::HideTooltip()
</mark>1<br><mark>{
</mark>1<br><mark>    if( m_pToolTipWin ) {
</mark>1<br><mark>        m_pToolTipWin->Hide();
</mark>1<br><mark>    }
</mark>1<br><mark>}
</mark>1<br><mark>
</mark>1<br><mark>void ocpnToolBarSimple::SetColorScheme( ColorScheme cs )
</mark>1<br><mark>{
</mark>1<br><mark>    if( m_pToolTipWin ) {
</mark>1<br><mark>        m_pToolTipWin->Destroy();
</mark>1<br><mark>        m_pToolTipWin = NULL;
</mark>1<br><mark>    }
</mark>1<br><mark>
</mark>1<br><mark>    m_toolOutlineColour = GetGlobalColor( _T("UIBDR") );
</mark>1<br><mark>
</mark>1<br><mark>    m_currentColorScheme = cs;
</mark>1<br><mark>}
</mark>1<br><mark>
</mark>1<br><mark>bool ocpnToolBarSimple::Realize()
</mark>1<br><mark>{
</mark>1<br><mark>    m_currentRowsOrColumns = 0;
</mark>1<br><mark>    m_LineCount = 1;
</mark>1<br><mark>    m_lastX = m_style->GetLeftMargin();
</mark>1<br><mark>    m_lastY = m_style->GetTopMargin();
</mark>1<br><mark>    m_maxWidth = 0;
</mark>1<br><mark>    m_maxHeight = 0;
</mark>1<br><mark>
</mark>1<br><mark>    if( IsVertical() ) m_style->SetOrientation( wxTB_VERTICAL );
</mark>1<br><mark>    else
</mark>1<br><mark>        m_style->SetOrientation( wxTB_HORIZONTAL );
</mark>1<br><mark>
</mark>1<br><mark>    wxSize toolSize = wxSize(-1, -1);
</mark>1<br><mark>    int separatorSize = m_style->GetToolSeparation();
</mark>1<br><mark>
</mark>1<br><mark>    ocpnToolBarTool *lastTool = NULL;
</mark>1<br><mark>    bool firstNode = true;
</mark>1<br><mark>    wxToolBarToolsList::compatibility_iterator node = m_tools.GetFirst();
</mark>1<br><mark>
</mark>1<br><mark>    while( node ) {
</mark>1<br><mark>        ocpnToolBarTool *tool = (ocpnToolBarTool *) node->GetData();
</mark>1<br><mark>
</mark>1<br><mark>        // Set the tool size to be the size of the first non-separator tool, usually the first one
</mark>1<br><mark>        if(toolSize.x == -1){
</mark>1<br><mark>            if( !tool->IsSeparator() ){
</mark>1<br><mark>                toolSize.x = tool->m_width;
</mark>1<br><mark>                toolSize.y = tool->m_height;
</mark>1<br><mark>            }
</mark>1<br><mark>        }
</mark>1<br><mark>
</mark>1<br><mark>        tool->firstInLine = firstNode;
</mark>1<br><mark>        tool->lastInLine = false;
</mark>1<br><mark>        firstNode = false;
</mark>1<br><mark>
</mark>1<br><mark>        tool->last_rect.width = 0;              // mark it invalid
</mark>1<br><mark>        
</mark>1<br><mark>        if( tool->IsSeparator() ) {
</mark>1<br><mark>            if( GetWindowStyleFlag() & wxTB_HORIZONTAL ) {
</mark>1<br><mark>                if( m_currentRowsOrColumns >= m_maxCols ) m_lastY += separatorSize;
</mark>1<br><mark>                else
</mark>1<br><mark>                    m_lastX += separatorSize;
</mark>1<br><mark>            } else {
</mark>1<br><mark>                if( m_currentRowsOrColumns >= m_maxRows ) m_lastX += separatorSize;
</mark>1<br><mark>                else
</mark>1<br><mark>                    m_lastY += separatorSize;
</mark>1<br><mark>            }
</mark>1<br><mark>        } else
</mark>1<br><mark>            if( tool->IsButton() ) {
</mark>1<br><mark>                if( !IsVertical() ) {
</mark>1<br><mark>                    if( m_currentRowsOrColumns >= m_maxCols ) {
</mark>1<br><mark>                        tool->firstInLine = true;
</mark>1<br><mark>                        if( lastTool && m_LineCount > 1 ) lastTool->lastInLine = true;
</mark>1<br><mark>                        m_LineCount++;
</mark>1<br><mark>                        m_currentRowsOrColumns = 0;
</mark>1<br><mark>                        m_lastX = m_style->GetLeftMargin();
</mark>1<br><mark>                        m_lastY += toolSize.y + m_style->GetTopMargin();
</mark>1<br><mark>                    }
</mark>1<br><mark>                    tool->m_x = (wxCoord) m_lastX;
</mark>1<br><mark>                    tool->m_y = (wxCoord) m_lastY;
</mark>1<br><mark>
</mark>1<br><mark>                    tool->trect = wxRect( tool->m_x, tool->m_y, toolSize.x, toolSize.y );
</mark>1<br><mark>                    tool->trect.Inflate( m_style->GetToolSeparation() / 2,
</mark>1<br><mark>                            m_style->GetTopMargin() );
</mark>1<br><mark>
</mark>1<br><mark>                    m_lastX += toolSize.x + m_style->GetToolSeparation();
</mark>1<br><mark>                } else {
</mark>1<br><mark>                    if( m_currentRowsOrColumns >= m_maxRows ) {
</mark>1<br><mark>                        tool->firstInLine = true;
</mark>1<br><mark>                        if( lastTool ) lastTool->lastInLine = true;
</mark>1<br><mark>                        m_LineCount++;
</mark>1<br><mark>                        m_currentRowsOrColumns = 0;
</mark>1<br><mark>                        m_lastX += toolSize.x + m_style->GetTopMargin();
</mark>1<br><mark>                        m_lastY = m_style->GetTopMargin();
</mark>1<br><mark>                    }
</mark>1<br><mark>                    tool->m_x = (wxCoord) m_lastX;
</mark>1<br><mark>                    tool->m_y = (wxCoord) m_lastY;
</mark>1<br><mark>
</mark>1<br><mark>                    tool->trect = wxRect( tool->m_x, tool->m_y, toolSize.x, toolSize.y );
</mark>1<br><mark>                    tool->trect.Inflate( m_style->GetToolSeparation() / 2,
</mark>1<br><mark>                            m_style->GetTopMargin() );
</mark>1<br><mark>
</mark>1<br><mark>                    m_lastY += toolSize.y + m_style->GetToolSeparation();
</mark>1<br><mark>                }
</mark>1<br><mark>                m_currentRowsOrColumns++;
</mark>1<br><mark>            } else
</mark>1<br><mark>                if( tool->IsControl() ) {
</mark>1<br><mark>                    tool->m_x = (wxCoord) ( m_lastX );
</mark>1<br><mark>                    tool->m_y = (wxCoord) ( m_lastY - ( m_style->GetTopMargin() / 2 ) );
</mark>1<br><mark>
</mark>1<br><mark>                    tool->trect = wxRect( tool->m_x, tool->m_y, tool->GetWidth(),
</mark>1<br><mark>                            tool->GetHeight() );
</mark>1<br><mark>                    tool->trect.Inflate( m_style->GetToolSeparation() / 2,
</mark>1<br><mark>                            m_style->GetTopMargin() );
</mark>1<br><mark>                    ;
</mark>1<br><mark>
</mark>1<br><mark>                    wxSize s = tool->GetControl()->GetSize();
</mark>1<br><mark>                    m_lastX += s.x + m_style->GetToolSeparation();
</mark>1<br><mark>
</mark>1<br><mark>                }
</mark>1<br><mark>
</mark>1<br><mark>        if( m_lastX > m_maxWidth ) m_maxWidth = m_lastX;
</mark>1<br><mark>        if( m_lastY > m_maxHeight ) m_maxHeight = m_lastY;
</mark>1<br><mark>
</mark>1<br><mark>        lastTool = tool;
</mark>1<br><mark>        node = node->GetNext();
</mark>1<br><mark>    }
</mark>1<br><mark>    if( lastTool && (m_LineCount > 1 || IsVertical()) )
</mark>1<br><mark>        lastTool->lastInLine = true;
</mark>1<br><mark>
</mark>1<br><mark>    if( GetWindowStyleFlag() & wxTB_HORIZONTAL ) m_maxHeight += toolSize.y;
</mark>1<br><mark>    else
</mark>1<br><mark>        m_maxWidth += toolSize.x;
</mark>1<br><mark>
</mark>1<br><mark>    m_maxWidth += m_style->GetRightMargin();
</mark>1<br><mark>    m_maxHeight += m_style->GetBottomMargin();
</mark>1<br><mark>
</mark>1<br><mark>    SetSize( m_maxWidth, m_maxHeight );
</mark>1<br><mark>    SetMinSize( wxSize( m_maxWidth, m_maxHeight ) );
</mark>1<br><mark>
</mark>1<br><mark>    return true;
</mark>1<br><mark>}
</mark>1<br><mark>
</mark>1<br><mark>// ----------------------------------------------------------------------------
</mark>1<br><mark>// event handlers
</mark>1<br><mark>// ----------------------------------------------------------------------------
</mark>1<br><mark>
</mark>1<br><mark>void ocpnToolBarSimple::OnPaint( wxPaintEvent& WXUNUSED(event) )
</mark>1<br><mark>{
</mark>1<br><mark>    wxPaintDC dc( this );
</mark>1<br><mark>    PrepareDC( dc );
</mark>1<br><mark>
</mark>1<br><mark>    wxRegion ru = GetUpdateRegion();
</mark>1<br><mark>    wxRect upRect = ru.GetBox();
</mark>1<br><mark>
</mark>1<br><mark>    static int count = 0;
</mark>1<br><mark>    // Prevent reentry of OnPaint which would cause wxMemoryDC errors.
</mark>1<br><mark>    if( count > 0 ) return;
</mark>1<br><mark>    count++;
</mark>1<br><mark>
</mark>1<br><mark>    for( wxToolBarToolsList::compatibility_iterator node = m_tools.GetFirst(); node;
</mark>1<br><mark>            node = node->GetNext() ) {
</mark>1<br><mark>        wxToolBarToolBase *tool = node->GetData();
</mark>1<br><mark>        ocpnToolBarTool *tools = (ocpnToolBarTool *) tool;
</mark>1<br><mark>        wxRect toolRect = tools->trect;
</mark>1<br><mark>
</mark>1<br><mark>        if( toolRect.Intersects( upRect ) ) {
</mark>1<br><mark>
</mark>1<br><mark>            if( tool->IsButton() ) {
</mark>1<br><mark>                DrawTool( dc, tool );
</mark>1<br><mark>            } else
</mark>1<br><mark>                if( tool->IsControl() ) {
</mark>1<br><mark>                    if( tool->GetControl()->IsKindOf( CLASSINFO(wxStaticBitmap) ) ) {
</mark>1<br><mark>                        wxStaticBitmap *psbm = (wxStaticBitmap *) tool->GetControl();
</mark>1<br><mark>                        ocpnToolBarTool *toolsimp = (ocpnToolBarTool *) tool;
</mark>1<br><mark>                        dc.DrawBitmap( psbm->GetBitmap(), toolsimp->m_x, toolsimp->m_y, false );
</mark>1<br><mark>                    }
</mark>1<br><mark>                }
</mark>1<br><mark>        }
</mark>1<br><mark>    }
</mark>1<br><mark>
</mark>1<br><mark>    count--;
</mark>1<br><mark>}
</mark>1<br><mark>
</mark>1<br><mark>void ocpnToolBarSimple::OnSize( wxSizeEvent& WXUNUSED(event) )
</mark>1<br><mark>{
</mark>1<br><mark>    if( GetAutoLayout() ) Layout();
</mark>1<br><mark>}
</mark>1<br><mark>
</mark>1<br><mark>void ocpnToolBarSimple::OnKillFocus( wxFocusEvent& WXUNUSED(event) )
</mark>1<br><mark>{
</mark>1<br><mark>    OnMouseEnter( m_pressedTool = m_currentTool = -1 );
</mark>1<br><mark>}
</mark>1<br><mark>
</mark>1<br><mark>void ocpnToolBarSimple::OnToolTipTimerEvent( wxTimerEvent& event )
</mark>1<br><mark>{
</mark>1<br><mark>    if( !gFrame->IsActive() ) return;
</mark>1<br><mark>
</mark>1<br><mark>    if( m_btooltip_show && IsShown() && m_pToolTipWin && ( !m_pToolTipWin->IsShown() ) ) {
</mark>1<br><mark>        if( m_last_ro_tool ) {
</mark>1<br><mark>            wxString s = m_last_ro_tool->GetShortHelp();
</mark>1<br><mark>
</mark>1<br><mark>            if( s.Len() ) {
</mark>1<br><mark>                m_pToolTipWin->SetString( s );
</mark>1<br><mark>                m_pToolTipWin->SetHiviz(m_last_ro_tool->m_btooltip_hiviz);
</mark>1<br><mark>
</mark>1<br><mark>                wxPoint pos_in_toolbar( m_last_ro_tool->m_x, m_last_ro_tool->m_y );
</mark>1<br><mark>                pos_in_toolbar.x += m_last_ro_tool->m_width + 2;
</mark>1<br><mark>
</mark>1<br><mark>                m_pToolTipWin->Move(0,0);       // workaround for gtk autocentre dialog behavior
</mark>1<br><mark>
</mark>1<br><mark>                wxPoint screenPosition = ClientToScreen( pos_in_toolbar );
</mark>1<br><mark>                wxPoint framePosition = gFrame->ScreenToClient(screenPosition);
</mark>1<br><mark>                wxSize tipSize = m_pToolTipWin->GetRenderedSize();
</mark>1<br><mark>                
</mark>1<br><mark>                if( (framePosition.x + tipSize.x) > gFrame->GetSize().x)
</mark>1<br><mark>                    screenPosition.x -= (tipSize.x + m_last_ro_tool->m_width + 4);
</mark>1<br><mark>                
</mark>1<br><mark>                m_pToolTipWin->SetPosition( screenPosition );
</mark>1<br><mark>                m_pToolTipWin->SetBitmap();
</mark>1<br><mark>                m_pToolTipWin->Show();
</mark>1<br><mark>                gFrame->Raise();
</mark>1<br><mark>                if( g_btouch )
</mark>1<br><mark>                    m_tooltipoff_timer.Start(m_tooltip_off, wxTIMER_ONE_SHOT);
</mark>1<br><mark>            }
</mark>1<br><mark>        }
</mark>1<br><mark>    }
</mark>1<br><mark>}
</mark>1<br><mark>
</mark>1<br><mark>void ocpnToolBarSimple::OnToolTipOffTimerEvent( wxTimerEvent& event )
</mark>1<br><mark>{
</mark>1<br><mark>    HideTooltip();
</mark>1<br><mark>}
</mark>1<br><mark>
</mark>1<br><mark>
</mark>1<br><mark>int s_dragx, s_dragy;
</mark>1<br><mark>
</mark>1<br><mark>void ocpnToolBarSimple::OnMouseEvent( wxMouseEvent & event )
</mark>1<br><mark>{
</mark>1<br><mark>#ifdef __OCPN__ANDROID__
</mark>1<br><mark>    if(!event.IsButton())
</mark>1<br><mark>        return;
</mark>1<br><mark>#endif
</mark>1<br><mark>
</mark>1<br><mark>    wxCoord x, y;
</mark>1<br><mark>    event.GetPosition( &x, &y );
</mark>1<br><mark>    ocpnToolBarTool *tool = (ocpnToolBarTool *) FindToolForPosition( x, y );
</mark>1<br><mark>
</mark>1<br><mark>#ifndef __OCPN__ANDROID__
</mark>1<br><mark>    if( event.LeftDown() ) {
</mark>1<br><mark>        CaptureMouse();
</mark>1<br><mark>        s_dragx = x;
</mark>1<br><mark>        s_dragy = y;
</mark>1<br><mark>    }
</mark>1<br><mark>    if( event.LeftUp() ) {
</mark>1<br><mark>        if( HasCapture() ) ReleaseMouse();
</mark>1<br><mark>    }
</mark>1<br><mark>#endif
</mark>1<br><mark>
</mark>1<br><mark>    if( tool && tool->IsButton() && IsShown() ) {
</mark>1<br><mark>
</mark>1<br><mark>        //    ToolTips
</mark>1<br><mark>        if( NULL == m_pToolTipWin ) {
</mark>1<br><mark>            m_pToolTipWin = new ToolTipWin( GetParent() );
</mark>1<br><mark>            m_pToolTipWin->SetColorScheme( m_currentColorScheme );
</mark>1<br><mark>            m_pToolTipWin->Hide();
</mark>1<br><mark>        }
</mark>1<br><mark>
</mark>1<br><mark>        if( tool != m_last_ro_tool ) m_pToolTipWin->Hide();
</mark>1<br><mark>
</mark>1<br><mark>#ifndef __OCPN__ANDROID__
</mark>1<br><mark>        if( !m_pToolTipWin->IsShown() ) {
</mark>1<br><mark>            m_tooltip_timer.Start( m_one_shot, wxTIMER_ONE_SHOT );
</mark>1<br><mark>        }
</mark>1<br><mark>#endif
</mark>1<br><mark>
</mark>1<br><mark>        //    Tool Rollover highlighting
</mark>1<br><mark>        if(!g_btouch){
</mark>1<br><mark>            if( tool != m_last_ro_tool ) {
</mark>1<br><mark>                if( tool->IsEnabled() ) {
</mark>1<br><mark>                    tool->rollover = true;
</mark>1<br><mark>                    tool->bitmapOK = false;
</mark>1<br><mark>                }
</mark>1<br><mark>                if( m_last_ro_tool ) {
</mark>1<br><mark>                    if( m_last_ro_tool->IsEnabled() ) {
</mark>1<br><mark>                        m_last_ro_tool->rollover = false;
</mark>1<br><mark>                        m_last_ro_tool->bitmapOK = false;
</mark>1<br><mark>                    }
</mark>1<br><mark>                }
</mark>1<br><mark>                m_last_ro_tool = tool;
</mark>1<br><mark>                if(g_toolbar)
</mark>1<br><mark>                    g_toolbar->Refresh( false );
</mark>1<br><mark>            }
</mark>1<br><mark>        }
</mark>1<br><mark>    } else {
</mark>1<br><mark>        //    Tooltips
</mark>1<br><mark>        if( m_pToolTipWin && m_pToolTipWin->IsShown() ) m_pToolTipWin->Hide();
</mark>1<br><mark>
</mark>1<br><mark>        //    Remove Highlighting
</mark>1<br><mark>        if( m_last_ro_tool ) {
</mark>1<br><mark>            if( m_last_ro_tool->IsEnabled() ) {
</mark>1<br><mark>                m_last_ro_tool->rollover = false;
</mark>1<br><mark>                m_last_ro_tool->bitmapOK = false;
</mark>1<br><mark>            }
</mark>1<br><mark>            g_toolbar->Refresh( false );
</mark>1<br><mark>        }
</mark>1<br><mark>    }
</mark>1<br><mark>
</mark>1<br><mark>    m_last_ro_tool = tool;
</mark>1<br><mark>
</mark>1<br><mark>    // allow smooth zooming while toolbutton is held down
</mark>1<br><mark>    if(g_bsmoothpanzoom && !g_btouch) {
</mark>1<br><mark>        if(event.LeftUp() && m_btoolbar_is_zooming) {
</mark>1<br><mark>            cc1->StopMovement();
</mark>1<br><mark>            m_btoolbar_is_zooming = false;
</mark>1<br><mark>            return;
</mark>1<br><mark>        }
</mark>1<br><mark>
</mark>1<br><mark>        if( event.LeftDown() && tool &&
</mark>1<br><mark>            (tool->GetId() == ID_ZOOMIN || tool->GetId() == ID_ZOOMOUT) ) {
</mark>1<br><mark>            cc1->ZoomCanvas( tool->GetId() == ID_ZOOMIN ? 2.0 : .5, false, false );
</mark>1<br><mark>            m_btoolbar_is_zooming = true;
</mark>1<br><mark>            return;
</mark>1<br><mark>        }
</mark>1<br><mark>    }
</mark>1<br><mark>
</mark>1<br><mark>    if( !tool ) {
</mark>1<br><mark>        if( m_currentTool > -1 ) {
</mark>1<br><mark>            if( event.LeftIsDown() ) SpringUpButton( m_currentTool );
</mark>1<br><mark>            m_currentTool = -1;
</mark>1<br><mark>            OnMouseEnter( -1 );
</mark>1<br><mark>        }
</mark>1<br><mark>
</mark>1<br><mark>        wxMouseEvent *pev = (wxMouseEvent *) event.Clone();
</mark>1<br><mark>        GetParent()->GetEventHandler()->AddPendingEvent( *pev );
</mark>1<br><mark>        wxDELETE( pev );
</mark>1<br><mark>
</mark>1<br><mark>        return;
</mark>1<br><mark>    }
</mark>1<br><mark>
</mark>1<br><mark>    if( !event.IsButton() ) {
</mark>1<br><mark>        if( tool->GetId() != m_currentTool ) {
</mark>1<br><mark>            // If the left button is kept down and moved over buttons,
</mark>1<br><mark>            // press those buttons.
</mark>1<br><mark>            if( event.LeftIsDown() && tool->IsEnabled() ) {
</mark>1<br><mark>                SpringUpButton( m_currentTool );
</mark>1<br><mark>
</mark>1<br><mark>                if( tool->CanBeToggled() ) {
</mark>1<br><mark>                    tool->Toggle();
</mark>1<br><mark>                }
</mark>1<br><mark>
</mark>1<br><mark>                DrawTool( tool );
</mark>1<br><mark>            }
</mark>1<br><mark>
</mark>1<br><mark>            m_currentTool = tool->GetId();
</mark>1<br><mark>            OnMouseEnter( m_currentTool );
</mark>1<br><mark>        }
</mark>1<br><mark>
</mark>1<br><mark>        wxMouseEvent *pev = (wxMouseEvent *) event.Clone();
</mark>1<br><mark>        GetParent()->GetEventHandler()->AddPendingEvent( *pev );
</mark>1<br><mark>        wxDELETE( pev );
</mark>1<br><mark>
</mark>1<br><mark>        return;
</mark>1<br><mark>    }
</mark>1<br><mark>
</mark>1<br><mark>    // Left button pressed.
</mark>1<br><mark>    if( event.LeftDown() && tool->IsEnabled() ) {
</mark>1<br><mark>        if( tool->CanBeToggled() ) {
</mark>1<br><mark>            tool->Toggle();
</mark>1<br><mark>            tool->bitmapOK = false;
</mark>1<br><mark>            
</mark>1<br><mark>        }
</mark>1<br><mark>
</mark>1<br><mark>        DrawTool( tool );
</mark>1<br><mark>
</mark>1<br><mark>        //        Look for PlugIn tools
</mark>1<br><mark>        //        If found, make the callback.
</mark>1<br><mark>        if( g_pi_manager ) {
</mark>1<br><mark>            ArrayOfPlugInToolbarTools tool_array = g_pi_manager->GetPluginToolbarToolArray();
</mark>1<br><mark>            for( unsigned int i = 0; i < tool_array.GetCount(); i++ ) {
</mark>1<br><mark>                PlugInToolbarToolContainer *pttc = tool_array.Item( i );
</mark>1<br><mark>                if( tool->GetId() == pttc->id ) {
</mark>1<br><mark>                    opencpn_plugin_113 *ppi = dynamic_cast<opencpn_plugin_113 *>(pttc->m_pplugin);
</mark>1<br><mark>                    if( ppi ) {
</mark>1<br><mark>                        ppi->OnToolbarToolDownCallback( pttc->id );
</mark>1<br><mark>                        m_last_plugin_down_id = pttc->id;
</mark>1<br><mark>                    }
</mark>1<br><mark>                }
</mark>1<br><mark>            }
</mark>1<br><mark>        }
</mark>1<br><mark>    } else
</mark>1<br><mark>        if( event.RightDown() ) {
</mark>1<br><mark>            OnRightClick( tool->GetId(), x, y );
</mark>1<br><mark>        }
</mark>1<br><mark>
</mark>1<br><mark>    // Left Button Released.  Only this action confirms selection.
</mark>1<br><mark>    // If the button is enabled and it is not a toggle tool and it is
</mark>1<br><mark>    // in the pressed state, then raise the button and call OnLeftClick.
</mark>1<br><mark>    //
</mark>1<br><mark>    if( event.LeftUp() && tool->IsEnabled() ) {
</mark>1<br><mark>        // Pass the OnLeftClick event to tool
</mark>1<br><mark>        if( !OnLeftClick( tool->GetId(), tool->IsToggled() ) && tool->CanBeToggled() ) {
</mark>1<br><mark>            // If it was a toggle, and OnLeftClick says No Toggle allowed,
</mark>1<br><mark>            // then change it back
</mark>1<br><mark>            tool->Toggle();
</mark>1<br><mark>            tool->bitmapOK = false;
</mark>1<br><mark>        }
</mark>1<br><mark>
</mark>1<br><mark>        DoPluginToolUp();
</mark>1<br><mark>    }
</mark>1<br><mark>
</mark>1<br><mark>    wxMouseEvent *pev = (wxMouseEvent *) event.Clone();
</mark>1<br><mark>    GetParent()->GetEventHandler()->AddPendingEvent( *pev );
</mark>1<br><mark>    wxDELETE( pev );
</mark>1<br><mark>    event.Skip();
</mark>1<br><mark>}
</mark>1<br><mark>
</mark>1<br><mark>// ----------------------------------------------------------------------------
</mark>1<br><mark>// drawing
</mark>1<br><mark>// ----------------------------------------------------------------------------
</mark>1<br><mark>
</mark>1<br><mark>void ocpnToolBarSimple::DrawTool( wxToolBarToolBase *tool )
</mark>1<br><mark>{
</mark>1<br><mark>    wxClientDC dc( this );
</mark>1<br><mark>    DrawTool( dc, tool );
</mark>1<br><mark>}
</mark>1<br><mark>
</mark>1<br><mark>// NB! The current DrawTool code assumes that plugin tools are never disabled
</mark>1<br><mark>// when they are present on the toolbar, since disabled plugins are removed.
</mark>1<br><mark>
</mark>1<br><mark>void ocpnToolBarSimple::DrawTool( wxDC& dc, wxToolBarToolBase *toolBase )
</mark>1<br><mark>{
</mark>1<br><mark>    ocpnToolBarTool *tool = (ocpnToolBarTool *) toolBase;
</mark>1<br><mark>    PrepareDC( dc );
</mark>1<br><mark>
</mark>1<br><mark>    wxPoint drawAt( tool->m_x, tool->m_y );
</mark>1<br><mark>    wxBitmap bmp;
</mark>1<br><mark>
</mark>1<br><mark>    if( tool->bitmapOK ) {
</mark>1<br><mark>        if( tool->IsEnabled() ) {
</mark>1<br><mark>            bmp = tool->GetNormalBitmap();
</mark>1<br><mark>            if( !bmp.IsOk() ){
</mark>1<br><mark>                bmp = m_style->GetToolIcon( tool->GetToolname(), TOOLICON_NORMAL, tool->rollover );
</mark>1<br><mark>                if(m_sizefactor > 1.0 ){
</mark>1<br><mark>                    wxImage scaled_image = bmp.ConvertToImage();
</mark>1<br><mark>                    bmp = wxBitmap(scaled_image.Scale(tool->m_width, tool->m_height, wxIMAGE_QUALITY_HIGH));
</mark>1<br><mark>                }
</mark>1<br><mark>                tool->SetNormalBitmap( bmp );
</mark>1<br><mark>                tool->bitmapOK = true;
</mark>1<br><mark>            }
</mark>1<br><mark>        } else {
</mark>1<br><mark>            bmp = tool->GetDisabledBitmap();
</mark>1<br><mark>            if( !bmp.IsOk() ){
</mark>1<br><mark>                bmp = m_style->GetToolIcon( tool->GetToolname(), TOOLICON_DISABLED );
</mark>1<br><mark>                if(m_sizefactor > 1.0 ){
</mark>1<br><mark>                    wxImage scaled_image = bmp.ConvertToImage();
</mark>1<br><mark>                    bmp = wxBitmap(scaled_image.Scale(tool->m_width, tool->m_height, wxIMAGE_QUALITY_HIGH));
</mark>1<br><mark>                }
</mark>1<br><mark>                tool->SetDisabledBitmap( bmp );
</mark>1<br><mark>                tool->bitmapOK = true;
</mark>1<br><mark>            }
</mark>1<br><mark>        }
</mark>1<br><mark>    } else {
</mark>1<br><mark>        if ( tool->isPluginTool ) {
</mark>1<br><mark>
</mark>1<br><mark>            // First try getting the icon from the Style.
</mark>1<br><mark>            // If it is not in the style we build a new icon from the style BG and the plugin icon.
</mark>1<br><mark>
</mark>1<br><mark>            if( tool->IsToggled() ) {
</mark>1<br><mark>                bmp = m_style->GetToolIcon( tool->GetToolname(), TOOLICON_TOGGLED, tool->rollover );
</mark>1<br><mark>                if( bmp.GetDepth() == 1 ) {
</mark>1<br><mark>                    if( tool->rollover ) {
</mark>1<br><mark>                        bmp = m_style->BuildPluginIcon( tool->pluginRolloverIcon, TOOLICON_TOGGLED );
</mark>1<br><mark>                        if( ! bmp.IsOk() )
</mark>1<br><mark>                            bmp = m_style->BuildPluginIcon( tool->pluginNormalIcon, TOOLICON_TOGGLED );
</mark>1<br><mark>                    }
</mark>1<br><mark>                    else
</mark>1<br><mark>                        bmp = m_style->BuildPluginIcon( tool->pluginNormalIcon, TOOLICON_TOGGLED );
</mark>1<br><mark>                }
</mark>1<br><mark>            } else {
</mark>1<br><mark>                bmp = m_style->GetToolIcon( tool->GetToolname(), TOOLICON_NORMAL, tool->rollover );
</mark>1<br><mark>                if( bmp.GetDepth() == 1 ) {
</mark>1<br><mark>                    if( tool->rollover ) {
</mark>1<br><mark>                        bmp = m_style->BuildPluginIcon( tool->pluginRolloverIcon, TOOLICON_NORMAL );
</mark>1<br><mark>                        if( ! bmp.IsOk() )
</mark>1<br><mark>                            bmp = m_style->BuildPluginIcon( tool->pluginNormalIcon, TOOLICON_NORMAL );
</mark>1<br><mark>                    }
</mark>1<br><mark>                    else
</mark>1<br><mark>                        bmp = m_style->BuildPluginIcon( tool->pluginNormalIcon, TOOLICON_NORMAL );
</mark>1<br><mark>                }
</mark>1<br><mark>            }
</mark>1<br><mark>            if(m_sizefactor > 1.0 ){
</mark>1<br><mark>                wxImage scaled_image = bmp.ConvertToImage();
</mark>1<br><mark>                bmp = wxBitmap(scaled_image.Scale(tool->m_width, tool->m_height, wxIMAGE_QUALITY_HIGH));
</mark>1<br><mark>            }
</mark>1<br><mark>            tool->SetNormalBitmap( bmp );
</mark>1<br><mark>            tool->bitmapOK = true;
</mark>1<br><mark>        } else {
</mark>1<br><mark>            if( tool->IsEnabled() ) {
</mark>1<br><mark>                if( tool->IsToggled() )
</mark>1<br><mark>                    bmp = m_style->GetToolIcon( tool->GetToolname(), TOOLICON_TOGGLED, tool->rollover );
</mark>1<br><mark>                else
</mark>1<br><mark>                    bmp = m_style->GetToolIcon( tool->GetIconName(), TOOLICON_NORMAL, tool->rollover );
</mark>1<br><mark>
</mark>1<br><mark>                if(m_sizefactor > 1.0 ){
</mark>1<br><mark>                    wxImage scaled_image = bmp.ConvertToImage();
</mark>1<br><mark>                    bmp = wxBitmap(scaled_image.Scale(tool->m_width, tool->m_height, wxIMAGE_QUALITY_HIGH));
</mark>1<br><mark>                }
</mark>1<br><mark>                tool->SetNormalBitmap( bmp );
</mark>1<br><mark>                tool->bitmapOK = true;
</mark>1<br><mark>            } else {
</mark>1<br><mark>                bmp = m_style->GetToolIcon( tool->GetToolname(), TOOLICON_DISABLED );
</mark>1<br><mark>                if(m_sizefactor > 1.0 ){
</mark>1<br><mark>                    wxImage scaled_image = bmp.ConvertToImage();
</mark>1<br><mark>                    bmp = wxBitmap(scaled_image.Scale(tool->m_width, tool->m_height, wxIMAGE_QUALITY_HIGH));
</mark>1<br><mark>                }
</mark>1<br><mark>                tool->SetDisabledBitmap( bmp );
</mark>1<br><mark>                tool->bitmapOK = true;
</mark>1<br><mark>            }
</mark>1<br><mark>        }
</mark>1<br><mark>    }
</mark>1<br><mark>
</mark>1<br><mark>    if( tool->firstInLine ) {
</mark>1<br><mark>        m_style->DrawToolbarLineStart( bmp );
</mark>1<br><mark>    }
</mark>1<br><mark>    if( tool->lastInLine ) {
</mark>1<br><mark>        m_style->DrawToolbarLineEnd( bmp );
</mark>1<br><mark>    }
</mark>1<br><mark>
</mark>1<br><mark>    if( bmp.GetWidth() != m_style->GetToolSize().x
</mark>1<br><mark>            || bmp.GetHeight() != m_style->GetToolSize().y ) {
</mark>1<br><mark>//        drawAt.x -= ( bmp.GetWidth() - m_style->GetToolSize().x ) / 2;
</mark>1<br><mark>//        drawAt.y -= ( bmp.GetHeight() - m_style->GetToolSize().y ) / 2;
</mark>1<br><mark>    }
</mark>1<br><mark>
</mark>1<br><mark>    //      Clear the last drawn tool if necessary
</mark>1<br><mark>    if( tool->last_rect.width && ((tool->last_rect.x != drawAt.x) || (tool->last_rect.y != drawAt.y)) ){
</mark>1<br><mark>        wxBrush bb(GetGlobalColor( _T("GREY2") ));
</mark>1<br><mark>        dc.SetBrush(bb);
</mark>1<br><mark>        dc.SetPen( *wxTRANSPARENT_PEN );
</mark>1<br><mark>        dc.DrawRectangle(tool->last_rect.x, tool->last_rect.y, tool->last_rect.width, tool->last_rect.height);
</mark>1<br><mark>    }
</mark>1<br><mark>
</mark>1<br><mark>    //  could cache this in the tool...
</mark>1<br><mark>    //  A bit of a hack here.  We only scale tools if they are to be magnified globally
</mark>1<br><mark>    if(0/*m_sizefactor > 1.0*/ )
</mark>1<br><mark>    {
</mark>1<br><mark>        wxImage scaled_image = bmp.ConvertToImage();
</mark>1<br><mark>        wxBitmap sbmp = wxBitmap(scaled_image.Scale(tool->m_width, tool->m_height, wxIMAGE_QUALITY_HIGH));
</mark>1<br><mark>        dc.DrawBitmap( sbmp, drawAt );
</mark>1<br><mark>        tool->last_rect = wxRect(drawAt.x, drawAt.y, sbmp.GetWidth(), sbmp.GetHeight());
</mark>1<br><mark>
</mark>1<br><mark>    }
</mark>1<br><mark>    else
</mark>1<br><mark>    {
</mark>1<br><mark>        dc.DrawBitmap( bmp, drawAt );
</mark>1<br><mark>        tool->last_rect = wxRect(drawAt.x, drawAt.y, bmp.GetWidth(), bmp.GetHeight());
</mark>1<br><mark>    }
</mark>1<br><mark>
</mark>1<br><mark>}
</mark>1<br><mark>
</mark>1<br><mark>// ----------------------------------------------------------------------------
</mark>1<br><mark>// toolbar geometry
</mark>1<br><mark>// ----------------------------------------------------------------------------
</mark>1<br><mark>
</mark>1<br><mark>wxToolBarToolBase *ocpnToolBarSimple::FindToolForPosition( wxCoord x, wxCoord y )
</mark>1<br><mark>{
</mark>1<br><mark>    wxToolBarToolsList::compatibility_iterator node = m_tools.GetFirst();
</mark>1<br><mark>    while( node ) {
</mark>1<br><mark>        ocpnToolBarTool *tool = (ocpnToolBarTool *) node->GetData();
</mark>1<br><mark>        if( ( x >= tool->m_x ) && ( y >= tool->m_y ) && ( x < ( tool->m_x + tool->GetWidth() ) )
</mark>1<br><mark>                && ( y < ( tool->m_y + tool->GetHeight() ) ) ) {
</mark>1<br><mark>            return tool;
</mark>1<br><mark>        }
</mark>1<br><mark>
</mark>1<br><mark>        node = node->GetNext();
</mark>1<br><mark>    }
</mark>1<br><mark>
</mark>1<br><mark>    return (wxToolBarToolBase *) NULL;
</mark>1<br><mark>}
</mark>1<br><mark>
</mark>1<br><mark>void ocpnToolBarSimple::InvalidateBitmaps()
</mark>1<br><mark>{
</mark>1<br><mark>    wxToolBarToolsList::compatibility_iterator node = m_tools.GetFirst();
</mark>1<br><mark>    while( node ) {
</mark>1<br><mark>        ocpnToolBarTool *tool = (ocpnToolBarTool *) node->GetData();
</mark>1<br><mark>        tool->bitmapOK = false;
</mark>1<br><mark>        node = node->GetNext();
</mark>1<br><mark>    }
</mark>1<br><mark>}
</mark>1<br><mark>
</mark>1<br><mark>wxRect ocpnToolBarSimple::GetToolRect( int tool_id )
</mark>1<br><mark>{
</mark>1<br><mark>    wxRect rect;
</mark>1<br><mark>    wxToolBarToolBase *tool = FindById( tool_id );
</mark>1<br><mark>    if( tool ) {
</mark>1<br><mark>        ocpnToolBarTool *otool = (ocpnToolBarTool *) tool;
</mark>1<br><mark>        if( otool ) rect = otool->trect;
</mark>1<br><mark>    }
</mark>1<br><mark>
</mark>1<br><mark>    return rect;
</mark>1<br><mark>}
</mark>1<br><mark>
</mark>1<br><mark>// ----------------------------------------------------------------------------
</mark>1<br><mark>// tool state change handlers
</mark>1<br><mark>// ----------------------------------------------------------------------------
</mark>1<br><mark>
</mark>1<br><mark>void ocpnToolBarSimple::DoEnableTool( wxToolBarToolBase *tool, bool WXUNUSED(enable) )
</mark>1<br><mark>{
</mark>1<br><mark>    DrawTool( tool );
</mark>1<br><mark>}
</mark>1<br><mark>
</mark>1<br><mark>void ocpnToolBarSimple::DoToggleTool( wxToolBarToolBase *tool, bool WXUNUSED(toggle) )
</mark>1<br><mark>{
</mark>1<br><mark>    ocpnToolBarTool *t = (ocpnToolBarTool *) tool;
</mark>1<br><mark>    t->bitmapOK = false;
</mark>1<br><mark>    DrawTool( tool );
</mark>1<br><mark>}
</mark>1<br><mark>
</mark>1<br><mark>// Okay, so we've left the tool we're in ... we must check if the tool we're
</mark>1<br><mark>// leaving was a 'sprung push button' and if so, spring it back to the up
</mark>1<br><mark>// state.
</mark>1<br><mark>void ocpnToolBarSimple::SpringUpButton( int id )
</mark>1<br><mark>{
</mark>1<br><mark>    wxToolBarToolBase *tool = FindById( id );
</mark>1<br><mark>
</mark>1<br><mark>    if( tool && tool->CanBeToggled() ) {
</mark>1<br><mark>        if( tool->IsToggled() ) tool->Toggle();
</mark>1<br><mark>
</mark>1<br><mark>        DrawTool( tool );
</mark>1<br><mark>    }
</mark>1<br><mark>}
</mark>1<br><mark>
</mark>1<br><mark>// ----------------------------------------------------------------------------
</mark>1<br><mark>// scrolling implementation
</mark>1<br><mark>// ----------------------------------------------------------------------------
</mark>1<br><mark>
</mark>1<br><mark>wxString ocpnToolBarSimple::GetToolShortHelp( int id ) const
</mark>1<br><mark>{
</mark>1<br><mark>    wxToolBarToolBase *tool = FindById( id );
</mark>1<br><mark>    wxCHECK_MSG( tool, wxEmptyString, _T("no such tool") );
</mark>1<br><mark>
</mark>1<br><mark>    return tool->GetShortHelp();
</mark>1<br><mark>}
</mark>1<br><mark>
</mark>1<br><mark>wxString ocpnToolBarSimple::GetToolLongHelp( int id ) const
</mark>1<br><mark>{
</mark>1<br><mark>    wxToolBarToolBase *tool = FindById( id );
</mark>1<br><mark>    wxCHECK_MSG( tool, wxEmptyString, _T("no such tool") );
</mark>1<br><mark>
</mark>1<br><mark>    return tool->GetLongHelp();
</mark>1<br><mark>}
</mark>1<br><mark>
</mark>1<br><mark>void ocpnToolBarSimple::SetToolShortHelp( int id, const wxString& help )
</mark>1<br><mark>{
</mark>1<br><mark>    wxToolBarToolBase *tool = FindById( id );
</mark>1<br><mark>    if( tool ) {
</mark>1<br><mark>        (void) tool->SetShortHelp( help );
</mark>1<br><mark>    }
</mark>1<br><mark>}
</mark>1<br><mark>
</mark>1<br><mark>void ocpnToolBarSimple::SetToolLongHelp( int id, const wxString& help )
</mark>1<br><mark>{
</mark>1<br><mark>    wxToolBarToolBase *tool = FindById( id );
</mark>1<br><mark>    if( tool ) {
</mark>1<br><mark>        (void) tool->SetLongHelp( help );
</mark>1<br><mark>    }
</mark>1<br><mark>}
</mark>1<br><mark>
</mark>1<br><mark>int ocpnToolBarSimple::GetToolPos( int id ) const
</mark>1<br><mark>{
</mark>1<br><mark>    size_t pos = 0;
</mark>1<br><mark>    wxToolBarToolsList::compatibility_iterator node;
</mark>1<br><mark>
</mark>1<br><mark>    for( node = m_tools.GetFirst(); node; node = node->GetNext() ) {
</mark>1<br><mark>        if( node->GetData()->GetId() == id ) return pos;
</mark>1<br><mark>
</mark>1<br><mark>        pos++;
</mark>1<br><mark>    }
</mark>1<br><mark>
</mark>1<br><mark>    return wxNOT_FOUND;
</mark>1<br><mark>}
</mark>1<br><mark>bool ocpnToolBarSimple::GetToolState( int id ) const
</mark>1<br><mark>{
</mark>1<br><mark>    wxToolBarToolBase *tool = FindById( id );
</mark>1<br><mark>    wxCHECK_MSG( tool, false, _T("no such tool") );
</mark>1<br><mark>
</mark>1<br><mark>    return tool->IsToggled();
</mark>1<br><mark>}
</mark>1<br><mark>
</mark>1<br><mark>bool ocpnToolBarSimple::GetToolEnabled( int id ) const
</mark>1<br><mark>{
</mark>1<br><mark>    wxToolBarToolBase *tool = FindById( id );
</mark>1<br><mark>    wxCHECK_MSG( tool, false, _T("no such tool") );
</mark>1<br><mark>
</mark>1<br><mark>    return tool->IsEnabled();
</mark>1<br><mark>}
</mark>1<br><mark>
</mark>1<br><mark>void ocpnToolBarSimple::ToggleTool( int id, bool toggle )
</mark>1<br><mark>{
</mark>1<br><mark>    wxToolBarToolBase *tool = FindById( id );
</mark>1<br><mark>        
</mark>1<br><mark>    if( tool && tool->CanBeToggled() && tool->Toggle( toggle ) ) {
</mark>1<br><mark>        DoToggleTool( tool, toggle );
</mark>1<br><mark>        if( g_toolbar ) g_toolbar->Refresh();
</mark>1<br><mark>    }
</mark>1<br><mark>}
</mark>1<br><mark>
</mark>1<br><mark>wxObject *ocpnToolBarSimple::GetToolClientData( int id ) const
</mark>1<br><mark>{
</mark>1<br><mark>    wxToolBarToolBase *tool = FindById( id );
</mark>1<br><mark>    return tool ? tool->GetClientData() : (wxObject *) NULL;
</mark>1<br><mark>}
</mark>1<br><mark>
</mark>1<br><mark>void ocpnToolBarSimple::SetToolClientData( int id, wxObject *clientData )
</mark>1<br><mark>{
</mark>1<br><mark>    wxToolBarToolBase *tool = FindById( id );
</mark>1<br><mark>
</mark>1<br><mark>    wxCHECK_RET( tool, _T("no such tool in wxToolBar::SetToolClientData") );
</mark>1<br><mark>
</mark>1<br><mark>    tool->SetClientData( clientData );
</mark>1<br><mark>}
</mark>1<br><mark>
</mark>1<br><mark>void ocpnToolBarSimple::EnableTool( int id, bool enable )
</mark>1<br><mark>{
</mark>1<br><mark>    wxToolBarToolBase *tool = FindById( id );
</mark>1<br><mark>    if( tool ) {
</mark>1<br><mark>        if( tool->Enable( enable ) ) {
</mark>1<br><mark>            DoEnableTool( tool, enable );
</mark>1<br><mark>        }
</mark>1<br><mark>    }
</mark>1<br><mark>    wxMenuItem* configItem = g_FloatingToolbarConfigMenu->FindItem( id );
</mark>1<br><mark>    configItem->Check( true );
</mark>1<br><mark>}
</mark>1<br><mark>
</mark>1<br><mark>void ocpnToolBarSimple::SetToolBitmaps( int id, wxBitmap *bmp, wxBitmap *bmpRollover )
</mark>1<br><mark>{
</mark>1<br><mark>    ocpnToolBarTool *tool = (ocpnToolBarTool*)FindById( id );
</mark>1<br><mark>    if( tool ) {
</mark>1<br><mark>        tool->pluginNormalIcon = bmp;
</mark>1<br><mark>        tool->pluginRolloverIcon = bmpRollover;
</mark>1<br><mark>        tool->bitmapOK = false;
</mark>1<br><mark>    }
</mark>1<br><mark>}
</mark>1<br><mark>
</mark>1<br><mark>void ocpnToolBarSimple::SetToolTooltipHiViz( int id, bool b_hiviz )
</mark>1<br><mark>{
</mark>1<br><mark>    ocpnToolBarTool *tool = (ocpnToolBarTool*)FindById( id );
</mark>1<br><mark>    if( tool ) {
</mark>1<br><mark>        tool->SetTooltipHiviz( b_hiviz );
</mark>1<br><mark>    }
</mark>1<br><mark>}
</mark>1<br><mark>
</mark>1<br><mark>
</mark>1<br><mark>void ocpnToolBarSimple::ClearTools()
</mark>1<br><mark>{
</mark>1<br><mark>    while( GetToolsCount() ) {
</mark>1<br><mark>        DeleteToolByPos( 0 );
</mark>1<br><mark>    }
</mark>1<br><mark>}
</mark>1<br><mark>
</mark>1<br><mark>int ocpnToolBarSimple::GetVisibleToolCount()
</mark>1<br><mark>{
</mark>1<br><mark>    int counter = 0;
</mark>1<br><mark>    wxToolBarToolsList::compatibility_iterator node = m_tools.GetFirst();
</mark>1<br><mark>    while( node ) {
</mark>1<br><mark>        ocpnToolBarTool *tool = (ocpnToolBarTool *) node->GetData();
</mark>1<br><mark>        counter++;
</mark>1<br><mark>        node = node->GetNext();
</mark>1<br><mark>    }
</mark>1<br><mark>    return counter;
</mark>1<br><mark>}
</mark>1<br><mark>
</mark>1<br><mark>bool ocpnToolBarSimple::DeleteToolByPos( size_t pos )
</mark>1<br><mark>{
</mark>1<br><mark>    wxCHECK_MSG( pos < GetToolsCount(), false,
</mark>1<br><mark>            _T("invalid position in wxToolBar::DeleteToolByPos()") );
</mark>1<br><mark>
</mark>1<br><mark>    wxToolBarToolsList::compatibility_iterator node = m_tools.Item( pos );
</mark>1<br><mark>
</mark>1<br><mark>    if( !DoDeleteTool( pos, node->GetData() ) ) {
</mark>1<br><mark>        return false;
</mark>1<br><mark>    }
</mark>1<br><mark>
</mark>1<br><mark>    delete node->GetData();
</mark>1<br><mark>    m_tools.Erase( node );
</mark>1<br><mark>
</mark>1<br><mark>    return true;
</mark>1<br><mark>}
</mark>1<br><mark>
</mark>1<br><mark>bool ocpnToolBarSimple::DeleteTool( int id )
</mark>1<br><mark>{
</mark>1<br><mark>    size_t pos = 0;
</mark>1<br><mark>    wxToolBarToolsList::compatibility_iterator node;
</mark>1<br><mark>    for( node = m_tools.GetFirst(); node; node = node->GetNext() ) {
</mark>1<br><mark>        if( node->GetData()->GetId() == id ) break;
</mark>1<br><mark>
</mark>1<br><mark>        pos++;
</mark>1<br><mark>    }
</mark>1<br><mark>
</mark>1<br><mark>    if( !node || !DoDeleteTool( pos, node->GetData() ) ) {
</mark>1<br><mark>        return false;
</mark>1<br><mark>    }
</mark>1<br><mark>
</mark>1<br><mark>    delete node->GetData();
</mark>1<br><mark>    m_tools.Erase( node );
</mark>1<br><mark>
</mark>1<br><mark>    return true;
</mark>1<br><mark>}
</mark>1<br><mark>
</mark>1<br><mark>wxToolBarToolBase *ocpnToolBarSimple::AddSeparator()
</mark>1<br><mark>{
</mark>1<br><mark>    return InsertSeparator( GetToolsCount() );
</mark>1<br><mark>}
</mark>1<br><mark>
</mark>1<br><mark>wxToolBarToolBase *ocpnToolBarSimple::InsertSeparator( size_t pos )
</mark>1<br><mark>{
</mark>1<br><mark>    wxCHECK_MSG( pos <= GetToolsCount(), (wxToolBarToolBase *)NULL,
</mark>1<br><mark>            _T("invalid position in wxToolBar::InsertSeparator()") );
</mark>1<br><mark>
</mark>1<br><mark>    wxToolBarToolBase *tool = CreateTool( wxID_SEPARATOR, wxEmptyString, wxNullBitmap, wxNullBitmap,
</mark>1<br><mark>            wxITEM_SEPARATOR, (wxObject *) NULL, wxEmptyString, wxEmptyString );
</mark>1<br><mark>
</mark>1<br><mark>    if( !tool || !DoInsertTool( pos, tool ) ) {
</mark>1<br><mark>        delete tool;
</mark>1<br><mark>
</mark>1<br><mark>        return NULL;
</mark>1<br><mark>    }
</mark>1<br><mark>
</mark>1<br><mark>    m_tools.Insert( pos, tool );
</mark>1<br><mark>
</mark>1<br><mark>    return tool;
</mark>1<br><mark>}
</mark>1<br><mark>
</mark>1<br><mark>wxToolBarToolBase *ocpnToolBarSimple::RemoveTool( int id )
</mark>1<br><mark>{
</mark>1<br><mark>    size_t pos = 0;
</mark>1<br><mark>    wxToolBarToolsList::compatibility_iterator node;
</mark>1<br><mark>    for( node = m_tools.GetFirst(); node; node = node->GetNext() ) {
</mark>1<br><mark>        if( node->GetData()->GetId() == id ) break;
</mark>1<br><mark>
</mark>1<br><mark>        pos++;
</mark>1<br><mark>    }
</mark>1<br><mark>
</mark>1<br><mark>    if( !node ) {
</mark>1<br><mark>        // don't give any error messages - sometimes we might call RemoveTool()
</mark>1<br><mark>        // without knowing whether the tool is or not in the toolbar
</mark>1<br><mark>        return (wxToolBarToolBase *) NULL;
</mark>1<br><mark>    }
</mark>1<br><mark>
</mark>1<br><mark>    wxToolBarToolBase *tool = node->GetData();
</mark>1<br><mark>    if( !DoDeleteTool( pos, tool ) ) {
</mark>1<br><mark>        return (wxToolBarToolBase *) NULL;
</mark>1<br><mark>    }
</mark>1<br><mark>
</mark>1<br><mark>    m_tools.Erase( node );
</mark>1<br><mark>
</mark>1<br><mark>    return tool;
</mark>1<br><mark>}
</mark>1<br><mark>
</mark>1<br><mark>
</mark>1<br><mark>wxControl *ocpnToolBarSimple::FindControl( int id )
</mark>1<br><mark>{
</mark>1<br><mark>    for( wxToolBarToolsList::compatibility_iterator node = m_tools.GetFirst(); node;
</mark>1<br><mark>            node = node->GetNext() ) {
</mark>1<br><mark>        const wxToolBarToolBase * const tool = node->GetData();
</mark>1<br><mark>        if( tool->IsControl() ) {
</mark>1<br><mark>            wxControl * const control = tool->GetControl();
</mark>1<br><mark>
</mark>1<br><mark>            if( !control ) {
</mark>1<br><mark>                wxFAIL_MSG( _T("NULL control in toolbar?") );
</mark>1<br><mark>            } else
</mark>1<br><mark>                if( control->GetId() == id ) {
</mark>1<br><mark>                    // found
</mark>1<br><mark>                    return control;
</mark>1<br><mark>                }
</mark>1<br><mark>        }
</mark>1<br><mark>    }
</mark>1<br><mark>
</mark>1<br><mark>    return NULL;
</mark>1<br><mark>}
</mark>1<br><mark>
</mark>1<br><mark>wxToolBarToolBase *ocpnToolBarSimple::FindById( int id ) const
</mark>1<br><mark>{
</mark>1<br><mark>    wxToolBarToolBase *tool = (wxToolBarToolBase *) NULL;
</mark>1<br><mark>
</mark>1<br><mark>    for( wxToolBarToolsList::compatibility_iterator node = m_tools.GetFirst(); node;
</mark>1<br><mark>            node = node->GetNext() ) {
</mark>1<br><mark>        tool = node->GetData();
</mark>1<br><mark>        if( tool->GetId() == id ) {
</mark>1<br><mark>            // found
</mark>1<br><mark>            break;
</mark>1<br><mark>        }
</mark>1<br><mark>
</mark>1<br><mark>        tool = NULL;
</mark>1<br><mark>    }
</mark>1<br><mark>
</mark>1<br><mark>    return tool;
</mark>1<br><mark>}
</mark>1<br><mark>
</mark>1<br><mark>// ----------------------------------------------------------------------------
</mark>1<br><mark>// event processing
</mark>1<br><mark>// ----------------------------------------------------------------------------
</mark>1<br><mark>
</mark>1<br><mark>// Only allow toggle if returns true
</mark>1<br><mark>bool ocpnToolBarSimple::OnLeftClick( int id, bool toggleDown )
</mark>1<br><mark>{
</mark>1<br><mark>    wxCommandEvent event( wxEVT_COMMAND_TOOL_CLICKED, id );
</mark>1<br><mark>    event.SetEventObject( this );
</mark>1<br><mark>
</mark>1<br><mark>    // we use SetInt() to make wxCommandEvent::IsChecked() return toggleDown
</mark>1<br><mark>    event.SetInt( (int) toggleDown );
</mark>1<br><mark>
</mark>1<br><mark>    // and SetExtraLong() for backwards compatibility
</mark>1<br><mark>    event.SetExtraLong( (long) toggleDown );
</mark>1<br><mark>
</mark>1<br><mark>    // Send events to this toolbar instead (and thence up the window hierarchy)
</mark>1<br><mark>    GetEventHandler()->ProcessEvent( event );
</mark>1<br><mark>
</mark>1<br><mark>    return true;
</mark>1<br><mark>}
</mark>1<br><mark>
</mark>1<br><mark>// Call when right button down.
</mark>1<br><mark>void ocpnToolBarSimple::OnRightClick( int id, long WXUNUSED(x), long WXUNUSED(y) )
</mark>1<br><mark>{
</mark>1<br><mark>    wxCommandEvent event( wxEVT_COMMAND_TOOL_RCLICKED, id );
</mark>1<br><mark>    event.SetEventObject( this );
</mark>1<br><mark>    event.SetInt( id );
</mark>1<br><mark>
</mark>1<br><mark>    HideTooltip();
</mark>1<br><mark>    ((ocpnFloatingToolbarDialog*)GetParent())->toolbarConfigChanged = false;
</mark>1<br><mark>    wxMenu* contextMenu = new wxMenu();
</mark>1<br><mark>    wxMenuItem* submenu = contextMenu->AppendSubMenu( g_FloatingToolbarConfigMenu, _("Visible buttons") );
</mark>1<br><mark>
</mark>1<br><mark>    PopupMenu( contextMenu );
</mark>1<br><mark>
</mark>1<br><mark>    contextMenu->Remove( submenu );
</mark>1<br><mark>    delete contextMenu;
</mark>1<br><mark>
</mark>1<br><mark>    if( ((ocpnFloatingToolbarDialog*)GetParent())->toolbarConfigChanged )
</mark>1<br><mark>        gFrame->GetEventHandler()->AddPendingEvent( event );
</mark>1<br><mark>}
</mark>1<br><mark>
</mark>1<br><mark>// Called when the mouse cursor enters a tool bitmap (no button pressed).
</mark>1<br><mark>// Argument is wxID_ANY if mouse is exiting the toolbar.
</mark>1<br><mark>// Note that for this event, the id of the window is used,
</mark>1<br><mark>// and the integer parameter of wxCommandEvent is used to retrieve
</mark>1<br><mark>// the tool id.
</mark>1<br><mark>void ocpnToolBarSimple::OnMouseEnter( int id )
</mark>1<br><mark>{
</mark>1<br><mark>    wxCommandEvent event( wxEVT_COMMAND_TOOL_ENTER, GetId() );
</mark>1<br><mark>    event.SetEventObject( this );
</mark>1<br><mark>    event.SetInt( id );
</mark>1<br><mark>
</mark>1<br><mark>    wxFrame *frame = wxDynamicCast(GetParent(), wxFrame);
</mark>1<br><mark>    if( frame ) {
</mark>1<br><mark>        wxString help;
</mark>1<br><mark>        wxToolBarToolBase* tool = id == wxID_ANY ? (wxToolBarToolBase*) NULL : FindById( id );
</mark>1<br><mark>        if( tool ) help = tool->GetLongHelp();
</mark>1<br><mark>        frame->DoGiveHelp( help, id != wxID_ANY );
</mark>1<br><mark>    }
</mark>1<br><mark>
</mark>1<br><mark>    (void) GetEventHandler()->ProcessEvent( event );
</mark>1<br><mark>
</mark>1<br><mark>    DoPluginToolUp();
</mark>1<br><mark>}
</mark>1<br><mark>
</mark>1<br><mark>void ocpnToolBarSimple::DoPluginToolUp()
</mark>1<br><mark>{
</mark>1<br><mark>    //        Look for PlugIn tools
</mark>1<br><mark>    //        If found, make the callback.
</mark>1<br><mark>    if( !g_pi_manager)
</mark>1<br><mark>        return;
</mark>1<br><mark>
</mark>1<br><mark>    ArrayOfPlugInToolbarTools tool_array = g_pi_manager->GetPluginToolbarToolArray();
</mark>1<br><mark>    for( unsigned int i = 0; i < tool_array.GetCount(); i++ ) {
</mark>1<br><mark>        PlugInToolbarToolContainer *pttc = tool_array.Item( i );
</mark>1<br><mark>        if( m_last_plugin_down_id == pttc->id ) {
</mark>1<br><mark>            opencpn_plugin_113 *ppi = dynamic_cast<opencpn_plugin_113 *>(pttc->m_pplugin);
</mark>1<br><mark>            if( ppi )
</mark>1<br><mark>                ppi->OnToolbarToolUpCallback( pttc->id );
</mark>1<br><mark>        }
</mark>1<br><mark>    }
</mark>1<br><mark>
</mark>1<br><mark>    m_last_plugin_down_id = -1;
</mark>1<br><mark>}
</mark>1<br><mark>
</mark>1<br><mark>void ocpnToolBarSimple::SetToolNormalBitmapEx( wxToolBarToolBase *tool, const wxString &iconName)
</mark>1<br><mark>{
</mark>1<br><mark>    if( tool ) {
</mark>1<br><mark>        ocpnToolBarTool *otool = (ocpnToolBarTool *) tool;
</mark>1<br><mark>        if(otool){
</mark>1<br><mark>            ocpnStyle::Style *style = g_StyleManager->GetCurrentStyle();
</mark>1<br><mark>
</mark>1<br><mark>            wxBitmap bmp = style->GetToolIcon( iconName, TOOLICON_NORMAL );
</mark>1<br><mark>            if(m_sizefactor > 1.0 ){
</mark>1<br><mark>                wxImage scaled_image = bmp.ConvertToImage();
</mark>1<br><mark>                bmp = wxBitmap(scaled_image.Scale(otool->m_width, otool->m_height, wxIMAGE_QUALITY_HIGH));
</mark>1<br><mark>            }
</mark>1<br><mark>        
</mark>1<br><mark>            tool->SetNormalBitmap( bmp );
</mark>1<br><mark>            otool->SetIconName( iconName );
</mark>1<br><mark>        }
</mark>1<br><mark>    }
</mark>1<br><mark>}
</mark>1<br><mark>
</mark>1<br><mark>
</mark>1<br><mark>//-------------------------------------------------------------------------------------
</mark>1<br><mark>
</mark>1<br><mark>ToolbarMOBDialog::ToolbarMOBDialog( wxWindow* parent )
</mark>1<br><mark>       : wxDialog( parent, wxID_ANY, _("OpenCPN Alert"), wxDefaultPosition, wxSize(250, 230) )
</mark>1<br><mark>{
</mark>1<br><mark>    wxBoxSizer* topSizer = new wxBoxSizer( wxVERTICAL );
</mark>1<br><mark>
</mark>1<br><mark>    wxBoxSizer* sizer = new wxBoxSizer( wxVERTICAL );
</mark>1<br><mark>    topSizer->Add( sizer, 0, wxALIGN_CENTER_HORIZONTAL | wxALL, 5 );
</mark>1<br><mark>
</mark>1<br><mark>    choices.push_back( new wxRadioButton( this, 0,  _("No, I don't want to hide it."),
</mark>1<br><mark>            wxDefaultPosition, wxDefaultSize, wxRB_GROUP ) );
</mark>1<br><mark>
</mark>1<br><mark>    choices.push_back( new wxRadioButton( this, 1, _("No, and permanently remove the option to hide it."),
</mark>1<br><mark>            wxDefaultPosition) );
</mark>1<br><mark>
</mark>1<br><mark>    choices.push_back( new wxRadioButton( this, 2, _("Yes, hide it."),
</mark>1<br><mark>            wxDefaultPosition) );
</mark>1<br><mark>
</mark>1<br><mark>    wxStdDialogButtonSizer* buttonSizer = CreateStdDialogButtonSizer( wxOK | wxCANCEL );
</mark>1<br><mark>
</mark>1<br><mark>
</mark>1<br><mark>    wxStaticText* textCtrl = new wxStaticText( this, wxID_ANY, _("The Man Over Board button could be an important safety feature.\nAre you sure you want to hide it?") );
</mark>1<br><mark>
</mark>1<br><mark>    sizer->Add( textCtrl, 0, wxEXPAND | wxALL, 5 );
</mark>1<br><mark>    sizer->Add( choices[0], 0, wxEXPAND | wxALL, 5 );
</mark>1<br><mark>    sizer->Add( choices[1], 0, wxEXPAND | wxALL, 5 );
</mark>1<br><mark>    sizer->Add( choices[2], 0, wxEXPAND | wxALL, 5 );
</mark>1<br><mark>    sizer->Add( buttonSizer, 0, wxEXPAND | wxTOP, 5 );
</mark>1<br><mark>
</mark>1<br><mark>    topSizer->SetSizeHints(this);
</mark>1<br><mark>    SetSizer( topSizer );
</mark>1<br><mark>}
</mark>1<br><mark>
</mark>1<br><mark>int ToolbarMOBDialog::GetSelection() {
</mark>1<br><mark>    for( unsigned int i=0; i<choices.size(); i++ ) {
</mark>1<br><mark>        if( choices[i]->GetValue() ) return choices[i]->GetId();
</mark>1<br><mark>    }
</mark>1<br><mark>    return 0;
</mark>1<br><mark>}
</mark></p></body>
    </html><html>
    <head></head>
    <body><p>1<br><mark>/***************************************************************************
</mark>2<br><mark> *
</mark>3<br><mark> * Project:  OpenCPN
</mark>4<br><mark> * Purpose:  OpenCPN Toolbar
</mark>5<br><mark> * Author:   David Register
</mark>6<br><mark> *
</mark>7<br><mark> ***************************************************************************
</mark>8<br><mark> *   Copyright (C) 2010 by David S. Register                               *
</mark>9<br><mark> *                                                                         *
</mark>10<br><mark> *   This program is free software; you can redistribute it and/or modify  *
</mark>11<br><mark> *   it under the terms of the GNU General Public License as published by  *
</mark>12<br><mark> *   the Free Software Foundation; either version 2 of the License, or     *
</mark>13<br><mark> *   (at your option) any later version.                                   *
</mark>14<br><mark> *                                                                         *
</mark>15<br><mark> *   This program is distributed in the hope that it will be useful,       *
</mark>16<br><mark> *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
</mark>17<br><mark> *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
</mark>18<br><mark> *   GNU General Public License for more details.                          *
</mark>19<br><mark> *                                                                         *
</mark>20<br><mark> *   You should have received a copy of the GNU General Public License     *
</mark>21<br><mark> *   along with this program; if not, write to the                         *
</mark>22<br><mark> *   Free Software Foundation, Inc.,                                       *
</mark>23<br><mark> *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,  USA.         *
</mark>24<br><mark> **************************************************************************/
</mark>25<br><mark>
</mark>26<br><mark>#include "wx/wxprec.h"
</mark>27<br><mark>
</mark>28<br><mark>#ifndef  WX_PRECOMP
</mark>29<br><mark>#include "wx/wx.h"
</mark>30<br><mark>#endif
</mark>31<br><mark>
</mark>32<br><mark>#include <vector>
</mark>33<br><mark>
</mark>34<br><mark>#include "ocpn_types.h"
</mark>35<br><mark>#include "navutil.h"
</mark>36<br><mark>#include "styles.h"
</mark>37<br><mark>#include "toolbar.h"
</mark>38<br><mark>#include "chart1.h"
</mark>39<br><mark>#include "pluginmanager.h"
</mark>40<br><mark>#include "FontMgr.h"
</mark>41<br><mark>
</mark>42<br><mark>extern ocpnFloatingToolbarDialog* g_FloatingToolbarDialog;
</mark>43<br><mark>extern bool                       g_bTransparentToolbar;
</mark>44<br><mark>extern bool                       g_bTransparentToolbarInOpenGLOK;
</mark>45<br><mark>extern ChartCanvas*               cc1;
</mark>46<br><mark>extern bool                       g_bopengl;
</mark>47<br><mark>extern ocpnToolBarSimple*         g_toolbar;
</mark>48<br><mark>extern ocpnStyle::StyleManager*   g_StyleManager;
</mark>49<br><mark>extern MyFrame*                   gFrame;
</mark>50<br><mark>extern PlugInManager*             g_pi_manager;
</mark>51<br><mark>extern wxMenu*                    g_FloatingToolbarConfigMenu;
</mark>52<br><mark>extern wxString                   g_toolbarConfig;
</mark>53<br><mark>extern bool                       g_bPermanentMOBIcon;
</mark>54<br><mark>extern bool                       g_btouch;
</mark>55<br><mark>extern bool                       g_bsmoothpanzoom;
</mark>56<br><mark>
</mark>57<br><mark>//----------------------------------------------------------------------------
</mark>58<br><mark>// GrabberWindow Implementation
</mark>59<br><mark>//----------------------------------------------------------------------------
</mark>60<br><mark>BEGIN_EVENT_TABLE(GrabberWin, wxPanel) EVT_MOUSE_EVENTS ( GrabberWin::MouseEvent )
</mark>61<br><mark>EVT_PAINT ( GrabberWin::OnPaint )
</mark>62<br><mark>END_EVENT_TABLE()
</mark>63<br><mark>
</mark>64<br><mark>GrabberWin::GrabberWin( wxWindow *parent, ocpnFloatingToolbarDialog *toolbar, float scale_factor, wxString icon_name, wxPoint position ):
</mark>65<br><mark>    wxPanel( parent, wxID_ANY, position, wxDefaultSize, wxNO_BORDER )
</mark>66<br><mark>{
</mark>67<br><mark>    m_icon_name = icon_name;
</mark>68<br><mark>    m_style = g_StyleManager->GetCurrentStyle();
</mark>69<br><mark>    wxBitmap bitmap = m_style->GetIcon( icon_name );
</mark>70<br><mark>    if(scale_factor > 1.0f){
</mark>71<br><mark>        int new_width = bitmap.GetWidth() * scale_factor;
</mark>72<br><mark>        int new_height = bitmap.GetHeight() * scale_factor;
</mark>73<br><mark>        wxImage scaled_image = bitmap.ConvertToImage();
</mark>74<br><mark>        m_bitmap = wxBitmap(scaled_image.Scale(new_width, new_height, wxIMAGE_QUALITY_HIGH));
</mark>75<br><mark>    }
</mark>76<br><mark>    else
</mark>77<br><mark>        m_bitmap = bitmap;
</mark>78<br><mark>
</mark>79<br><mark>    SetSize( wxSize( m_bitmap.GetWidth(), m_bitmap.GetHeight() ) );
</mark>80<br><mark>    SetMinSize( wxSize( m_bitmap.GetWidth(), m_bitmap.GetHeight() ) );
</mark>81<br><mark>
</mark>82<br><mark>    m_bLeftDown = false;
</mark>83<br><mark>    m_bRightDown = false;
</mark>84<br><mark>    m_scale_factor = scale_factor;
</mark>85<br><mark>    m_ptoolbar = toolbar;
</mark>86<br><mark>    m_dragging = false;
</mark>87<br><mark>    Hide();
</mark>88<br><mark>    
</mark>89<br><mark>}
</mark>90<br><mark>
</mark>91<br><mark>
</mark>92<br><mark>void GrabberWin::OnPaint( wxPaintEvent& event )
</mark>93<br><mark>{
</mark>94<br><mark>    wxPaintDC dc( this );
</mark>95<br><mark>    
</mark>96<br><mark>    wxColour back_color = GetGlobalColor( _T("GREY2") );
</mark>97<br><mark>    SetBackgroundColour( back_color );
</mark>98<br><mark>    ClearBackground();
</mark>99<br><mark>    
</mark>100<br><mark>    dc.DrawBitmap( m_bitmap, 0, 0, true );
</mark>101<br><mark>}
</mark>102<br><mark>
</mark>103<br><mark>void GrabberWin::SetColorScheme( ColorScheme cs )
</mark>104<br><mark>{
</mark>105<br><mark>    wxColour back_color = GetGlobalColor( _T("GREY2") );
</mark>106<br><mark>
</mark>107<br><mark>    SetBackgroundColour( back_color );
</mark>108<br><mark>    ClearBackground();
</mark>109<br><mark>
</mark>110<br><mark>    wxBitmap bitmap = m_style->GetIcon( m_icon_name) ;
</mark>111<br><mark>    if(m_scale_factor > 1.0f){
</mark>112<br><mark>        int new_width = bitmap.GetWidth() * m_scale_factor;
</mark>113<br><mark>        int new_height = bitmap.GetHeight() * m_scale_factor;
</mark>114<br><mark>        wxImage scaled_image = bitmap.ConvertToImage();
</mark>115<br><mark>        m_bitmap = wxBitmap(scaled_image.Scale(new_width, new_height, wxIMAGE_QUALITY_HIGH));
</mark>116<br><mark>    }
</mark>117<br><mark>    else
</mark>118<br><mark>        m_bitmap = bitmap;
</mark>119<br><mark>}
</mark>120<br><mark>
</mark>121<br><mark>void GrabberWin::MouseEvent( wxMouseEvent& event )
</mark>122<br><mark>{
</mark>123<br><mark>    static wxPoint s_gspt;
</mark>124<br><mark>    int x, y;
</mark>125<br><mark>
</mark>126<br><mark>    event.GetPosition( &x, &y );
</mark>127<br><mark>
</mark>128<br><mark>    wxPoint spt = ClientToScreen( wxPoint( x, y ) );
</mark>129<br><mark>    if( event.LeftDown() ) {
</mark>130<br><mark>        s_gspt = spt;
</mark>131<br><mark>    }
</mark>132<br><mark>    
</mark>133<br><mark>    
</mark>134<br><mark>#ifndef __WXQT__
</mark>135<br><mark>
</mark>136<br><mark>    if( event.LeftDown() ) {
</mark>137<br><mark>        CaptureMouse();
</mark>138<br><mark>    }
</mark>139<br><mark>
</mark>140<br><mark>    if( event.LeftUp() ) {
</mark>141<br><mark>        if( HasCapture() ) ReleaseMouse();
</mark>142<br><mark>    }
</mark>143<br><mark>
</mark>144<br><mark>#endif
</mark>145<br><mark>
</mark>146<br><mark>
</mark>147<br><mark>    if( event.RightDown() ){
</mark>148<br><mark>        if(m_ptoolbar){
</mark>149<br><mark>            m_dragging = true;
</mark>150<br><mark>            
</mark>151<br><mark>            if( !m_ptoolbar->m_bnavgrabber ){
</mark>152<br><mark>                m_ptoolbar->m_bnavgrabber = true;
</mark>153<br><mark>                m_ptoolbar->SetGrabber(_T("4WayMove") );
</mark>154<br><mark>            }
</mark>155<br><mark>            else{
</mark>156<br><mark>                m_ptoolbar->m_bnavgrabber = false;
</mark>157<br><mark>                m_ptoolbar->SetGrabber(_T("grabber_hi") );
</mark>158<br><mark>            }
</mark>159<br><mark>                
</mark>160<br><mark>        }
</mark>161<br><mark>    }
</mark>162<br><mark>    
</mark>163<br><mark>
</mark>164<br><mark>
</mark>165<br><mark>    if( event.Dragging() ) {
</mark>166<br><mark>        if(m_ptoolbar && m_ptoolbar->IsShown() /*&& m_ptoolbar->m_bnavgrabber*/){
</mark>167<br><mark>            wxPoint par_pos_old = m_ptoolbar->GetPosition();
</mark>168<br><mark>
</mark>169<br><mark>            wxPoint par_pos = par_pos_old;
</mark>170<br><mark>            par_pos.x += spt.x - s_gspt.x;
</mark>171<br><mark>            par_pos.y += spt.y - s_gspt.y;
</mark>172<br><mark>
</mark>173<br><mark>            m_ptoolbar->MoveDialogInScreenCoords( par_pos, par_pos_old );
</mark>174<br><mark>
</mark>175<br><mark>            s_gspt = spt;
</mark>176<br><mark>            m_dragging = true;
</mark>177<br><mark>        }
</mark>178<br><mark>
</mark>179<br><mark>    }
</mark>180<br><mark>
</mark>181<br><mark>    if( event.LeftUp() ) {
</mark>182<br><mark>        if(m_ptoolbar){
</mark>183<br><mark>            if(m_ptoolbar->m_bnavgrabber){
</mark>184<br><mark>                if(!m_dragging)
</mark>185<br><mark>                    m_ptoolbar->ToggleOrientation();
</mark>186<br><mark>            }
</mark>187<br><mark>            else if(!m_dragging){
</mark>188<br><mark>                if(m_ptoolbar->m_bsubmerged){
</mark>189<br><mark>                    m_ptoolbar->SurfaceFromGrabber();
</mark>190<br><mark>                }
</mark>191<br><mark>                else{
</mark>192<br><mark>                    m_ptoolbar->SubmergeToGrabber();
</mark>193<br><mark>                 }
</mark>194<br><mark>            }
</mark>195<br><mark>        }
</mark>196<br><mark>        m_dragging = false;
</mark>197<br><mark>    }
</mark>198<br><mark>    
</mark>199<br><mark>    
</mark>200<br><mark>#ifndef __OCPN__ANDROID__
</mark>201<br><mark>    gFrame->Raise();
</mark>202<br><mark>#endif
</mark>203<br><mark>    
</mark>204<br><mark>}
</mark>205<br><mark>
</mark>206<br><mark>class ocpnToolBarTool: public wxToolBarToolBase {
</mark>207<br><mark>public:
</mark>208<br><mark>    ocpnToolBarTool( ocpnToolBarSimple *tbar, int id, const wxString& label,
</mark>209<br><mark>            const wxBitmap& bmpNormal, const wxBitmap& bmpRollover, wxItemKind kind,
</mark>210<br><mark>            wxObject *clientData, const wxString& shortHelp, const wxString& longHelp ) :
</mark>211<br><mark>            wxToolBarToolBase( (wxToolBarBase*) tbar, id, label, bmpNormal, bmpRollover, kind,
</mark>212<br><mark>                    clientData, shortHelp, longHelp )
</mark>213<br><mark>    {
</mark>214<br><mark>        m_enabled = true;
</mark>215<br><mark>        m_toggled = false;
</mark>216<br><mark>        rollover = false;
</mark>217<br><mark>        bitmapOK = false;
</mark>218<br><mark>        m_btooltip_hiviz = false;
</mark>219<br><mark>
</mark>220<br><mark>        toolname = g_pi_manager->GetToolOwnerCommonName( id );
</mark>221<br><mark>        if( toolname == _T("") ) {
</mark>222<br><mark>            isPluginTool = false;
</mark>223<br><mark>            toolname = label;
</mark>224<br><mark>            iconName = label;
</mark>225<br><mark>        } else {
</mark>226<br><mark>            isPluginTool = true;
</mark>227<br><mark>            pluginNormalIcon = &bmpNormal;
</mark>228<br><mark>            pluginRolloverIcon = &bmpRollover;
</mark>229<br><mark>        }
</mark>230<br><mark>    }
</mark>231<br><mark>
</mark>232<br><mark>    void SetSize( const wxSize& size )
</mark>233<br><mark>    {
</mark>234<br><mark>        m_width = size.x;
</mark>235<br><mark>        m_height = size.y;
</mark>236<br><mark>    }
</mark>237<br><mark>
</mark>238<br><mark>    wxCoord GetWidth() const
</mark>239<br><mark>    {
</mark>240<br><mark>        return m_width;
</mark>241<br><mark>    }
</mark>242<br><mark>
</mark>243<br><mark>    wxCoord GetHeight() const
</mark>244<br><mark>    {
</mark>245<br><mark>        return m_height;
</mark>246<br><mark>    }
</mark>247<br><mark>
</mark>248<br><mark>    wxString GetToolname()
</mark>249<br><mark>    {
</mark>250<br><mark>        return toolname;
</mark>251<br><mark>    }
</mark>252<br><mark>
</mark>253<br><mark>    void SetIconName(wxString name)
</mark>254<br><mark>    {
</mark>255<br><mark>        iconName = name;
</mark>256<br><mark>    }
</mark>257<br><mark>    wxString GetIconName()
</mark>258<br><mark>    {
</mark>259<br><mark>        return iconName;
</mark>260<br><mark>    }
</mark>261<br><mark>
</mark>262<br><mark>    void SetTooltipHiviz( bool enable){ m_btooltip_hiviz = enable; }
</mark>263<br><mark>
</mark>264<br><mark>    wxCoord m_x;
</mark>265<br><mark>    wxCoord m_y;
</mark>266<br><mark>    wxCoord m_width;
</mark>267<br><mark>    wxCoord m_height;
</mark>268<br><mark>    wxRect trect;
</mark>269<br><mark>    wxString toolname;
</mark>270<br><mark>    wxString iconName;
</mark>271<br><mark>    const wxBitmap* pluginNormalIcon;
</mark>272<br><mark>    const wxBitmap* pluginRolloverIcon;
</mark>273<br><mark>    bool firstInLine;
</mark>274<br><mark>    bool lastInLine;
</mark>275<br><mark>    bool rollover;
</mark>276<br><mark>    bool bitmapOK;
</mark>277<br><mark>    bool isPluginTool;
</mark>278<br><mark>    bool b_hilite;
</mark>279<br><mark>    bool m_btooltip_hiviz;
</mark>280<br><mark>    wxRect last_rect;
</mark>281<br><mark>};
</mark>282<br><mark>
</mark>283<br><mark>//---------------------------------------------------------------------------------------
</mark>284<br><mark>//          ocpnFloatingToolbarDialog Implementation
</mark>285<br><mark>//---------------------------------------------------------------------------------------
</mark>286<br><mark>BEGIN_EVENT_TABLE(ocpnFloatingToolbarDialog, wxDialog)
</mark>287<br><mark>    EVT_MOUSE_EVENTS ( ocpnFloatingToolbarDialog::MouseEvent )
</mark>288<br><mark>    EVT_MENU(wxID_ANY, ocpnFloatingToolbarDialog::OnToolLeftClick)
</mark>289<br><mark>    EVT_TIMER ( FADE_TIMER, ocpnFloatingToolbarDialog::FadeTimerEvent )
</mark>290<br><mark>    EVT_TIMER ( DESTROY_TIMER, ocpnFloatingToolbarDialog::DestroyTimerEvent )
</mark>291<br><mark>    EVT_WINDOW_CREATE(ocpnFloatingToolbarDialog::OnWindowCreate)
</mark>292<br><mark>END_EVENT_TABLE()
</mark>293<br><mark>
</mark>294<br><mark>ocpnFloatingToolbarDialog::ocpnFloatingToolbarDialog( wxWindow *parent, wxPoint position,
</mark>295<br><mark>                                                      long orient, float size_factor )
</mark>296<br><mark>{
</mark>297<br><mark>    m_pparent = parent;
</mark>298<br><mark>    long wstyle = wxNO_BORDER | wxFRAME_NO_TASKBAR;
</mark>299<br><mark>#ifndef __WXMAC__
</mark>300<br><mark>    wstyle |= wxFRAME_SHAPED;
</mark>301<br><mark>#endif
</mark>302<br><mark>
</mark>303<br><mark>    m_ptoolbar = NULL;
</mark>304<br><mark>
</mark>305<br><mark>#ifdef __WXOSX__
</mark>306<br><mark>    wstyle |= wxSTAY_ON_TOP;
</mark>307<br><mark>#endif
</mark>308<br><mark>    wxDialog::Create( parent, -1, _T("ocpnToolbarDialog"), wxPoint( -1, -1 ), wxSize( -1, -1 ),
</mark>309<br><mark>            wstyle );
</mark>310<br><mark>
</mark>311<br><mark>    m_opacity = 255;
</mark>312<br><mark>
</mark>313<br><mark>    m_pGrabberwin = new GrabberWin( this, this, size_factor, _T("grabber_hi") );
</mark>314<br><mark>    m_pGrabberwin->Show();
</mark>315<br><mark>    
</mark>316<br><mark>    m_pRecoverwin = NULL;
</mark>317<br><mark>    m_position = position;
</mark>318<br><mark>    m_orient = orient;
</mark>319<br><mark>    m_sizefactor = size_factor;
</mark>320<br><mark>    
</mark>321<br><mark>    m_bAutoHideToolbar = false;
</mark>322<br><mark>    m_nAutoHideToolbar = 5;
</mark>323<br><mark>    
</mark>324<br><mark>
</mark>325<br><mark>    m_style = g_StyleManager->GetCurrentStyle();
</mark>326<br><mark>
</mark>327<br><mark>// A top-level sizer
</mark>328<br><mark>    m_topSizer = new wxBoxSizer( wxHORIZONTAL );
</mark>329<br><mark>    SetSizer( m_topSizer );
</mark>330<br><mark>
</mark>331<br><mark>    //    Set initial "Dock" parameters
</mark>332<br><mark>    m_dock_x = 0;
</mark>333<br><mark>    m_dock_y = 0;
</mark>334<br><mark>    m_block = false;
</mark>335<br><mark>
</mark>336<br><mark>    m_marginsInvisible = m_style->marginsInvisible;
</mark>337<br><mark>
</mark>338<br><mark>//    if(m_sizefactor > 1.0 )
</mark>339<br><mark> //       m_marginsInvisible = true;
</mark>340<br><mark>
</mark>341<br><mark>    m_bnavgrabber = false;    
</mark>342<br><mark>    
</mark>343<br><mark>    Hide();
</mark>344<br><mark>
</mark>345<br><mark>    m_bsubmerged = false;
</mark>346<br><mark>    
</mark>347<br><mark>    m_fade_timer.SetOwner( this, FADE_TIMER );
</mark>348<br><mark>    if( g_bTransparentToolbar )
</mark>349<br><mark>        m_fade_timer.Start( 5000 );
</mark>350<br><mark>    
</mark>351<br><mark>    if( m_bAutoHideToolbar && (m_nAutoHideToolbar > 0))
</mark>352<br><mark>        m_fade_timer.Start( m_nAutoHideToolbar * 1000 );
</mark>353<br><mark>    
</mark>354<br><mark>    m_destroyTimer.SetOwner( this, DESTROY_TIMER );
</mark>355<br><mark>}
</mark>356<br><mark>
</mark>357<br><mark>ocpnFloatingToolbarDialog::~ocpnFloatingToolbarDialog()
</mark>358<br><mark>{
</mark>359<br><mark>    DestroyToolBar();
</mark>360<br><mark>}
</mark>361<br><mark>
</mark>362<br><mark>void ocpnFloatingToolbarDialog::OnWindowCreate( wxWindowCreateEvent& event )
</mark>363<br><mark>{
</mark>364<br><mark>    Realize();
</mark>365<br><mark>}
</mark>366<br><mark>
</mark>367<br><mark>void ocpnFloatingToolbarDialog::SetGrabber( wxString icon_name )
</mark>368<br><mark>{
</mark>369<br><mark>//    m_pGrabberwin->Destroy();
</mark>370<br><mark>    m_pGrabberwin = new GrabberWin( this, this, m_sizefactor, icon_name );
</mark>371<br><mark>    m_pGrabberwin->Show();
</mark>372<br><mark>    
</mark>373<br><mark>    Realize();
</mark>374<br><mark>    
</mark>375<br><mark>#ifdef __WXOSX__    
</mark>376<br><mark>    m_pGrabberwin->Refresh();
</mark>377<br><mark>#endif    
</mark>378<br><mark>    
</mark>379<br><mark>}
</mark>380<br><mark>
</mark>381<br><mark>
</mark>382<br><mark>    
</mark>383<br><mark>void ocpnFloatingToolbarDialog::SetColorScheme( ColorScheme cs )
</mark>384<br><mark>{
</mark>385<br><mark>    m_cs = cs;
</mark>386<br><mark>
</mark>387<br><mark>    wxColour back_color = GetGlobalColor( _T("GREY2") );
</mark>388<br><mark>
</mark>389<br><mark>    //  Set background
</mark>390<br><mark>    SetBackgroundColour( back_color );
</mark>391<br><mark>    ClearBackground();
</mark>392<br><mark>
</mark>393<br><mark>    if( m_ptoolbar ) {
</mark>394<br><mark>        wxColour back_color = GetGlobalColor( _T("GREY2") );
</mark>395<br><mark>
</mark>396<br><mark>        //  Set background
</mark>397<br><mark>        m_ptoolbar->SetBackgroundColour( back_color );
</mark>398<br><mark>        m_ptoolbar->ClearBackground();
</mark>399<br><mark>
</mark>400<br><mark>        m_ptoolbar->SetToggledBackgroundColour( GetGlobalColor( _T("GREY1") ) );
</mark>401<br><mark>
</mark>402<br><mark>        m_ptoolbar->SetColorScheme( cs );
</mark>403<br><mark>        m_ptoolbar->Refresh( true );
</mark>404<br><mark>    }
</mark>405<br><mark>
</mark>406<br><mark>    if( m_pGrabberwin ) m_pGrabberwin->SetColorScheme( cs );
</mark>407<br><mark>
</mark>408<br><mark>}
</mark>409<br><mark>
</mark>410<br><mark>void ocpnFloatingToolbarDialog::SetGeometry(bool bAvoid, wxRect rectAvoid)
</mark>411<br><mark>{
</mark>412<br><mark>
</mark>413<br><mark>    if( m_ptoolbar ) {
</mark>414<br><mark>        wxSize style_tool_size = m_style->GetToolSize();
</mark>415<br><mark>
</mark>416<br><mark>        style_tool_size.x *= m_sizefactor;
</mark>417<br><mark>        style_tool_size.y *= m_sizefactor;
</mark>418<br><mark>
</mark>419<br><mark>        m_ptoolbar->SetToolBitmapSize( style_tool_size );
</mark>420<br><mark>
</mark>421<br><mark>        wxSize tool_size = m_ptoolbar->GetToolBitmapSize();
</mark>422<br><mark>        int grabber_width =  m_style->GetIcon( _T("grabber") ).GetWidth();
</mark>423<br><mark>        
</mark>424<br><mark>        int max_rows = 10;
</mark>425<br><mark>        int max_cols = 100;
</mark>426<br><mark>        if(cc1){
</mark>427<br><mark>
</mark>428<br><mark>            int avoid_start = cc1->GetClientSize().x - (tool_size.x + m_style->GetToolSeparation()) * 2;  // default
</mark>429<br><mark>            if(bAvoid && !rectAvoid.IsEmpty()){
</mark>430<br><mark>                avoid_start = cc1->GetClientSize().x - rectAvoid.width - 10;  // this is compass window, if shown
</mark>431<br><mark>            }
</mark>432<br><mark>            
</mark>433<br><mark>            
</mark>434<br><mark>            max_rows = (cc1->GetClientSize().y / ( tool_size.y + m_style->GetToolSeparation())) - 1;
</mark>435<br><mark>            
</mark>436<br><mark>            max_cols = (avoid_start - grabber_width) / ( tool_size.x + m_style->GetToolSeparation());
</mark>437<br><mark>            max_cols -= 1;
</mark>438<br><mark>            
</mark>439<br><mark>            if(m_orient == wxTB_VERTICAL)
</mark>440<br><mark>                max_rows = wxMax( max_rows, 2);             // at least two rows
</mark>441<br><mark>            else
</mark>442<br><mark>                max_cols = wxMax( max_cols, 2);             // at least two columns
</mark>443<br><mark>        }
</mark>444<br><mark>
</mark>445<br><mark>        if( m_orient == wxTB_VERTICAL )
</mark>446<br><mark>            m_ptoolbar->SetMaxRowsCols(max_rows, 100);
</mark>447<br><mark>        else
</mark>448<br><mark>            m_ptoolbar->SetMaxRowsCols( 100, max_cols);
</mark>449<br><mark>        m_ptoolbar->SetSizeFactor(m_sizefactor);
</mark>450<br><mark>        
</mark>451<br><mark>    }
</mark>452<br><mark> }
</mark>453<br><mark>
</mark>454<br><mark>void ocpnFloatingToolbarDialog::RePosition()
</mark>455<br><mark>{
</mark>456<br><mark>    if(m_block) return;
</mark>457<br><mark>
</mark>458<br><mark>    if( m_pparent && m_ptoolbar ) {
</mark>459<br><mark>        wxSize cs = m_pparent->GetClientSize();
</mark>460<br><mark>        if( -1 == m_dock_x ) m_position.x = 0;
</mark>461<br><mark>        else
</mark>462<br><mark>            if( 1 == m_dock_x ) m_position.x = cs.x - GetSize().x;
</mark>463<br><mark>
</mark>464<br><mark>        if( -1 == m_dock_y ) m_position.y = 0;
</mark>465<br><mark>        else
</mark>466<br><mark>            if( 1 == m_dock_y ) m_position.y = cs.y - GetSize().y;
</mark>467<br><mark>
</mark>468<br><mark>        m_position.x = wxMin(cs.x - GetSize().x, m_position.x);
</mark>469<br><mark>        m_position.y = wxMin(cs.y - GetSize().y, m_position.y);
</mark>470<br><mark>
</mark>471<br><mark>        m_position.x = wxMax(0, m_position.x);
</mark>472<br><mark>        m_position.y = wxMax(0, m_position.y);
</mark>473<br><mark>
</mark>474<br><mark>        wxPoint screen_pos = m_pparent->ClientToScreen( m_position );
</mark>475<br><mark>
</mark>476<br><mark>        Move( screen_pos );
</mark>477<br><mark>
</mark>478<br><mark>#ifdef __WXQT__
</mark>479<br><mark>        Raise();
</mark>480<br><mark>#endif
</mark>481<br><mark>
</mark>482<br><mark>    }
</mark>483<br><mark>}
</mark>484<br><mark>
</mark>485<br><mark>void ocpnFloatingToolbarDialog::Submerge()
</mark>486<br><mark>{
</mark>487<br><mark>    m_bsubmerged = true;
</mark>488<br><mark>    Hide();
</mark>489<br><mark>    if( m_ptoolbar ) m_ptoolbar->KillTooltip();
</mark>490<br><mark>}
</mark>491<br><mark>
</mark>492<br><mark>void ocpnFloatingToolbarDialog::SubmergeToGrabber()
</mark>493<br><mark>{
</mark>494<br><mark>//Submerge();
</mark>495<br><mark>    m_bsubmerged = true;
</mark>496<br><mark>    Hide();
</mark>497<br><mark>    if( m_ptoolbar ) m_ptoolbar->KillTooltip();
</mark>498<br><mark>
</mark>499<br><mark>    m_pRecoverwin = new GrabberWin( m_pparent, this, m_sizefactor, _T("grabber_ext" ), wxPoint(10,10) );
</mark>500<br><mark>   
</mark>501<br><mark>    m_pRecoverwin->Show();
</mark>502<br><mark>    m_pRecoverwin->Raise();
</mark>503<br><mark>#ifdef __WXQT__
</mark>504<br><mark>    wxSize s = gFrame->GetSize();
</mark>505<br><mark>    m_recoversize = s;
</mark>506<br><mark>    s.y--;
</mark>507<br><mark>    gFrame->TriggerResize(s);
</mark>508<br><mark>    Raise();
</mark>509<br><mark>#endif    
</mark>510<br><mark>
</mark>511<br><mark>    gFrame->Refresh();          // Needed for MSW OpenGL
</mark>512<br><mark>}
</mark>513<br><mark>
</mark>514<br><mark>void ocpnFloatingToolbarDialog::Surface()
</mark>515<br><mark>{
</mark>516<br><mark>    
</mark>517<br><mark>    if(m_pRecoverwin){
</mark>518<br><mark>        m_pRecoverwin->Show();
</mark>519<br><mark>        m_pRecoverwin->Raise();
</mark>520<br><mark>    }
</mark>521<br><mark>    else {
</mark>522<br><mark>        m_bsubmerged = false;
</mark>523<br><mark>        #ifndef __WXOSX__
</mark>524<br><mark>        Hide();
</mark>525<br><mark>        Move( 0, 0 );
</mark>526<br><mark>        #endif
</mark>527<br><mark>
</mark>528<br><mark>        RePosition();
</mark>529<br><mark>        Show();
</mark>530<br><mark>        if( m_ptoolbar )
</mark>531<br><mark>            m_ptoolbar->EnableTooltips();
</mark>532<br><mark>
</mark>533<br><mark>        #ifdef __WXQT__
</mark>534<br><mark>        Raise();
</mark>535<br><mark>        #endif
</mark>536<br><mark>    }
</mark>537<br><mark>    
</mark>538<br><mark>    if( m_bAutoHideToolbar && (m_nAutoHideToolbar > 0) ){
</mark>539<br><mark>        m_fade_timer.Start( m_nAutoHideToolbar * 1000 );
</mark>540<br><mark>    }
</mark>541<br><mark>}
</mark>542<br><mark>
</mark>543<br><mark>bool ocpnFloatingToolbarDialog::CheckSurfaceRequest( wxMouseEvent &event )
</mark>544<br><mark>{
</mark>545<br><mark>    if( m_bsubmerged ){
</mark>546<br><mark>        if( event.LeftUp() ){
</mark>547<br><mark>            int x,y;
</mark>548<br><mark>            event.GetPosition( &x, &y );
</mark>549<br><mark>            if( m_pRecoverwin ){
</mark>550<br><mark>                wxRect winRect = m_pRecoverwin->GetRect();
</mark>551<br><mark>                if( winRect.Contains( x, y ) ){
</mark>552<br><mark>                    SurfaceFromGrabber();
</mark>553<br><mark>                    return true;
</mark>554<br><mark>                }
</mark>555<br><mark>            }
</mark>556<br><mark>        }
</mark>557<br><mark>    }
</mark>558<br><mark>    
</mark>559<br><mark>    return false;
</mark>560<br><mark>}
</mark>561<br><mark>        
</mark>562<br><mark>void ocpnFloatingToolbarDialog::SurfaceFromGrabber()
</mark>563<br><mark>{
</mark>564<br><mark>    m_bsubmerged = false;
</mark>565<br><mark>    
</mark>566<br><mark>#ifndef __WXOSX__
</mark>567<br><mark>    Hide();
</mark>568<br><mark>    Move( 0, 0 );
</mark>569<br><mark>#endif
</mark>570<br><mark>
</mark>571<br><mark>    if( m_ptoolbar )
</mark>572<br><mark>        m_ptoolbar->InvalidateBitmaps();
</mark>573<br><mark>    
</mark>574<br><mark>    RePosition();
</mark>575<br><mark>    Show();
</mark>576<br><mark>    if( m_ptoolbar )
</mark>577<br><mark>        m_ptoolbar->EnableTooltips();
</mark>578<br><mark>    
</mark>579<br><mark>    if( m_bAutoHideToolbar && (m_nAutoHideToolbar > 0) ){
</mark>580<br><mark>        m_fade_timer.Start( m_nAutoHideToolbar * 1000 );
</mark>581<br><mark>    }
</mark>582<br><mark>    
</mark>583<br><mark>#ifdef __WXQT__
</mark>584<br><mark>    wxSize s = gFrame->GetSize();               // check for rotation
</mark>585<br><mark>    if(m_recoversize.x == s.x)
</mark>586<br><mark>        gFrame->TriggerResize(m_recoversize);
</mark>587<br><mark>    Raise();
</mark>588<br><mark>#endif
</mark>589<br><mark>    
</mark>590<br><mark>    m_destroyGrabber = m_pRecoverwin;
</mark>591<br><mark>    m_destroyTimer.Start( 5, wxTIMER_ONE_SHOT );           //  Destor the unneeded recovery grabber
</mark>592<br><mark>    
</mark>593<br><mark>}
</mark>594<br><mark>
</mark>595<br><mark>void ocpnFloatingToolbarDialog::DestroyTimerEvent( wxTimerEvent& event )
</mark>596<br><mark>{
</mark>597<br><mark>    delete m_destroyGrabber;
</mark>598<br><mark>    m_destroyGrabber = NULL;
</mark>599<br><mark>    m_pRecoverwin = NULL;
</mark>600<br><mark>}
</mark>601<br><mark>
</mark>602<br><mark>void ocpnFloatingToolbarDialog::HideTooltip()
</mark>603<br><mark>{
</mark>604<br><mark>    if( m_ptoolbar ) m_ptoolbar->HideTooltip();
</mark>605<br><mark>}
</mark>606<br><mark>
</mark>607<br><mark>void ocpnFloatingToolbarDialog::ShowTooltips()
</mark>608<br><mark>{
</mark>609<br><mark>    if( m_ptoolbar ) m_ptoolbar->EnableTooltips();
</mark>610<br><mark>}
</mark>611<br><mark>
</mark>612<br><mark>void ocpnFloatingToolbarDialog::ToggleOrientation()
</mark>613<br><mark>{
</mark>614<br><mark>    if( m_orient == wxTB_HORIZONTAL )
</mark>615<br><mark>        m_orient = wxTB_VERTICAL;
</mark>616<br><mark>    else
</mark>617<br><mark>        m_orient = wxTB_HORIZONTAL;
</mark>618<br><mark>
</mark>619<br><mark>    m_style->SetOrientation( m_orient );
</mark>620<br><mark>
</mark>621<br><mark>    wxPoint old_screen_pos = m_pparent->ClientToScreen( m_position );
</mark>622<br><mark>    wxPoint grabber_point_abs = ClientToScreen( m_pGrabberwin->GetPosition() );
</mark>623<br><mark>
</mark>624<br><mark>    gFrame->RequestNewToolbar();
</mark>625<br><mark>    wxPoint pos_abs = grabber_point_abs;
</mark>626<br><mark>    pos_abs.x -= m_pGrabberwin->GetPosition().x;
</mark>627<br><mark>    MoveDialogInScreenCoords( pos_abs, old_screen_pos );
</mark>628<br><mark>
</mark>629<br><mark>
</mark>630<br><mark>    Show();   // this seems to be necessary on GTK to kick the sizer into gear...(FS#553)
</mark>631<br><mark>    Refresh(true);
</mark>632<br><mark>    Raise();
</mark>633<br><mark>}
</mark>634<br><mark>
</mark>635<br><mark>void ocpnFloatingToolbarDialog::MouseEvent( wxMouseEvent& event )
</mark>636<br><mark>{
</mark>637<br><mark>    if( g_bTransparentToolbar ) {
</mark>638<br><mark>        if( event.Entering() && ( m_opacity < 255 ) ) {
</mark>639<br><mark>            SetTransparent( 255 );
</mark>640<br><mark>            m_opacity = 255;
</mark>641<br><mark>        }
</mark>642<br><mark>
</mark>643<br><mark>        m_fade_timer.Start( 5000 );           // retrigger the continuous timer
</mark>644<br><mark>    }
</mark>645<br><mark>    
</mark>646<br><mark>    if(m_bAutoHideToolbar && (m_nAutoHideToolbar > 0) ){
</mark>647<br><mark>        m_fade_timer.Start( m_nAutoHideToolbar * 1000 );
</mark>648<br><mark>    }
</mark>649<br><mark>}
</mark>650<br><mark>
</mark>651<br><mark>void ocpnFloatingToolbarDialog::FadeTimerEvent( wxTimerEvent& event )
</mark>652<br><mark>{
</mark>653<br><mark>    if(m_bnavgrabber){
</mark>654<br><mark>        m_fade_timer.Start( 5000 );           // do nothing if nav grabber is shown
</mark>655<br><mark>    }
</mark>656<br><mark>    else{
</mark>657<br><mark>        if( g_bTransparentToolbar && (!g_bopengl || g_bTransparentToolbarInOpenGLOK) ){
</mark>658<br><mark>            DoFade( 128 );
</mark>659<br><mark>            m_fade_timer.Start( 5000 );           // retrigger the continuous timer
</mark>660<br><mark>        }
</mark>661<br><mark>        
</mark>662<br><mark>        if(m_bAutoHideToolbar && (m_nAutoHideToolbar > 0) && !m_bsubmerged){
</mark>663<br><mark>            SubmergeToGrabber();
</mark>664<br><mark>//            m_fade_timer.Stop();
</mark>665<br><mark>        }
</mark>666<br><mark>    }
</mark>667<br><mark>}
</mark>668<br><mark>
</mark>669<br><mark>void ocpnFloatingToolbarDialog::SetAutoHideTimer(int time)
</mark>670<br><mark>{
</mark>671<br><mark>    m_nAutoHideToolbar = time;
</mark>672<br><mark>    if(m_bAutoHideToolbar){
</mark>673<br><mark>        m_fade_timer.Stop();
</mark>674<br><mark>        m_fade_timer.Start( m_nAutoHideToolbar * 1000 );
</mark>675<br><mark>    }
</mark>676<br><mark>}
</mark>677<br><mark>        
</mark>678<br><mark>void ocpnFloatingToolbarDialog::DoFade( int value )
</mark>679<br><mark>{
</mark>680<br><mark>    if( value != m_opacity ) SetTransparent( value );
</mark>681<br><mark>    m_opacity = value;
</mark>682<br><mark>}
</mark>683<br><mark>
</mark>684<br><mark>void ocpnFloatingToolbarDialog::RefreshFadeTimer()
</mark>685<br><mark>{
</mark>686<br><mark>    SetTransparent( 255 );
</mark>687<br><mark>    m_opacity = 255;
</mark>688<br><mark>    m_fade_timer.Start( 500 );           // retrigger the continuous timer
</mark>689<br><mark>    
</mark>690<br><mark>    if(m_bAutoHideToolbar && (m_nAutoHideToolbar > 0) ){
</mark>691<br><mark>        m_fade_timer.Start( m_nAutoHideToolbar * 1000 );
</mark>692<br><mark>    }
</mark>693<br><mark>    
</mark>694<br><mark>}
</mark>695<br><mark>
</mark>696<br><mark>void ocpnFloatingToolbarDialog::MoveDialogInScreenCoords( wxPoint posn, wxPoint posn_old )
</mark>697<br><mark>{
</mark>698<br><mark>    wxPoint pos_in_parent = m_pparent->ScreenToClient( posn );
</mark>699<br><mark>    wxPoint pos_in_parent_old = m_pparent->ScreenToClient( posn_old );
</mark>700<br><mark>
</mark>701<br><mark>    //    "Docking" support
</mark>702<br><mark>#define DOCK_MARGIN 40
</mark>703<br><mark>
</mark>704<br><mark>    // X
</mark>705<br><mark>    m_dock_x = 0;
</mark>706<br><mark>    if( pos_in_parent.x < pos_in_parent_old.x )            // moving left
</mark>707<br><mark>            {
</mark>708<br><mark>        if( pos_in_parent.x < DOCK_MARGIN ) {
</mark>709<br><mark>            pos_in_parent.x = 0;
</mark>710<br><mark>            m_dock_x = -1;
</mark>711<br><mark>        }
</mark>712<br><mark>    } else
</mark>713<br><mark>        if( pos_in_parent.x > pos_in_parent_old.x )            // moving right
</mark>714<br><mark>                {
</mark>715<br><mark>            int max_right = m_pparent->GetClientSize().x - GetSize().x;
</mark>716<br><mark>            if( pos_in_parent.x > ( max_right - DOCK_MARGIN ) ) {
</mark>717<br><mark>                pos_in_parent.x = max_right;
</mark>718<br><mark>                m_dock_x = 1;
</mark>719<br><mark>            }
</mark>720<br><mark>        }
</mark>721<br><mark>
</mark>722<br><mark>    // Y
</mark>723<br><mark>    m_dock_y = 0;
</mark>724<br><mark>    if( pos_in_parent.y < pos_in_parent_old.y )            // moving up
</mark>725<br><mark>            {
</mark>726<br><mark>        if( pos_in_parent.y < DOCK_MARGIN ) {
</mark>727<br><mark>            pos_in_parent.y = 0;
</mark>728<br><mark>            m_dock_y = -1;
</mark>729<br><mark>        }
</mark>730<br><mark>    } else
</mark>731<br><mark>        if( pos_in_parent.y > pos_in_parent_old.y )            // moving down
</mark>732<br><mark>                {
</mark>733<br><mark>            int max_down = m_pparent->GetClientSize().y - GetSize().y;
</mark>734<br><mark>            if( pos_in_parent.y > ( max_down - DOCK_MARGIN ) ) {
</mark>735<br><mark>                pos_in_parent.y = max_down;
</mark>736<br><mark>                m_dock_y = 1;
</mark>737<br><mark>            }
</mark>738<br><mark>        }
</mark>739<br><mark>
</mark>740<br><mark>    m_position = pos_in_parent;
</mark>741<br><mark>
</mark>742<br><mark>    wxPoint final_pos = m_pparent->ClientToScreen( pos_in_parent );
</mark>743<br><mark>
</mark>744<br><mark>    Move( final_pos );
</mark>745<br><mark>}
</mark>746<br><mark>
</mark>747<br><mark>void ocpnFloatingToolbarDialog::Realize()
</mark>748<br><mark>{
</mark>749<br><mark>    if( m_ptoolbar ) {
</mark>750<br><mark>        m_ptoolbar->Realize();
</mark>751<br><mark>
</mark>752<br><mark>        m_topSizer->Clear();
</mark>753<br><mark>        m_topSizer->Add( m_ptoolbar );
</mark>754<br><mark>        m_topSizer->Add( m_pGrabberwin, 0, wxTOP, m_style->GetTopMargin() );
</mark>755<br><mark>
</mark>756<br><mark>        m_topSizer->Layout();
</mark>757<br><mark>        Fit();
</mark>758<br><mark>
</mark>759<br><mark>        //    Update "Dock" parameters
</mark>760<br><mark>        if( m_position.x == 0 ) m_dock_x = -1;
</mark>761<br><mark>        else
</mark>762<br><mark>            if( m_position.x == m_pparent->GetClientSize().x - GetSize().x ) m_dock_x = 1;
</mark>763<br><mark>
</mark>764<br><mark>        if( m_position.y == 0 ) m_dock_y = -1;
</mark>765<br><mark>        else
</mark>766<br><mark>            if( m_position.y == m_pparent->GetClientSize().y - GetSize().y ) m_dock_y = 1;
</mark>767<br><mark>
</mark>768<br><mark>        // Now create a bitmap mask forthe frame shape.
</mark>769<br><mark>
</mark>770<br><mark>        if( m_marginsInvisible ) {
</mark>771<br><mark>
</mark>772<br><mark>            wxSize tool_size = m_ptoolbar->GetToolBitmapSize();
</mark>773<br><mark>
</mark>774<br><mark>            //  Determine whether the tool icons are meant (by style) to join without speces between
</mark>775<br><mark>            //  This will determine what type of region to draw.
</mark>776<br><mark>            bool b_overlap = false;
</mark>777<br><mark>
</mark>778<br><mark>            wxToolBarToolsList::compatibility_iterator node1 = m_ptoolbar->m_tools.GetFirst();
</mark>779<br><mark>            wxToolBarToolsList::compatibility_iterator node2 = node1->GetNext() ;
</mark>780<br><mark>
</mark>781<br><mark>            wxToolBarToolBase *tool1 = node1->GetData();
</mark>782<br><mark>            ocpnToolBarTool *tools1 = (ocpnToolBarTool *) tool1;
</mark>783<br><mark>
</mark>784<br><mark>            wxToolBarToolBase *tool2 = node2->GetData();
</mark>785<br><mark>            ocpnToolBarTool *tools2 = (ocpnToolBarTool *) tool2;
</mark>786<br><mark>
</mark>787<br><mark>            if( (tools1->m_x + tools1->m_width) >= tools2->m_x)
</mark>788<br><mark>                b_overlap = true;
</mark>789<br><mark>
</mark>790<br><mark>
</mark>791<br><mark>
</mark>792<br><mark>
</mark>793<br><mark>            int toolCount = m_ptoolbar->GetVisibleToolCount();
</mark>794<br><mark>
</mark>795<br><mark>            wxPoint upperLeft( m_style->GetLeftMargin(), m_style->GetTopMargin() );
</mark>796<br><mark>            wxSize visibleSize;
</mark>797<br><mark>            if( m_ptoolbar->IsVertical() ) {
</mark>798<br><mark>                int noTools = m_ptoolbar->GetMaxRows();
</mark>799<br><mark>                if( noTools > toolCount )
</mark>800<br><mark>                    noTools = toolCount;
</mark>801<br><mark>                visibleSize.x = m_ptoolbar->GetLineCount() * ( tool_size.x + m_style->GetTopMargin() );
</mark>802<br><mark>                visibleSize.y = noTools * ( tool_size.y + m_style->GetToolSeparation() );
</mark>803<br><mark>                visibleSize.x -= m_style->GetTopMargin();
</mark>804<br><mark>                visibleSize.y -= m_style->GetToolSeparation();
</mark>805<br><mark>            } else {
</mark>806<br><mark>                    int noTools = m_ptoolbar->GetMaxCols();
</mark>807<br><mark>                    if( noTools > toolCount )
</mark>808<br><mark>                        noTools = toolCount;
</mark>809<br><mark>                visibleSize.x = noTools * ( tool_size.x + m_style->GetToolSeparation() );
</mark>810<br><mark>                visibleSize.y = m_ptoolbar->GetLineCount() * ( tool_size.y + m_style->GetTopMargin() );
</mark>811<br><mark>                visibleSize.x -= m_style->GetToolSeparation();
</mark>812<br><mark>                visibleSize.y -= m_style->GetTopMargin();
</mark>813<br><mark>            }
</mark>814<br><mark>
</mark>815<br><mark>            wxBitmap shape( visibleSize.x + tool_size.x, visibleSize.y + tool_size.y);          // + fluff
</mark>816<br><mark>            wxMemoryDC sdc( shape );
</mark>817<br><mark>            sdc.SetBackground( *wxWHITE_BRUSH );
</mark>818<br><mark>            sdc.SetBrush( *wxBLACK_BRUSH );
</mark>819<br><mark>            sdc.SetPen( *wxBLACK_PEN );
</mark>820<br><mark>            sdc.Clear();
</mark>821<br><mark>
</mark>822<br><mark>            if(b_overlap) {
</mark>823<br><mark>                int lines = m_ptoolbar->GetLineCount();
</mark>824<br><mark>                for( int i = 1; i <= lines; i++ ) {
</mark>825<br><mark>                    if( m_ptoolbar->IsVertical() ) {
</mark>826<br><mark>                        wxSize barsize( tool_size.x, visibleSize.y );
</mark>827<br><mark>                        if( i == lines && i > 1 ) {
</mark>828<br><mark>                            int toolsInLastLine = toolCount % m_ptoolbar->GetMaxRows();
</mark>829<br><mark>                            if( toolsInLastLine == 0 ) toolsInLastLine = m_ptoolbar->GetMaxRows();
</mark>830<br><mark>                            int emptySpace = ( m_ptoolbar->GetMaxRows() - toolsInLastLine );
</mark>831<br><mark>                            barsize.y -= emptySpace
</mark>832<br><mark>                            * ( tool_size.y + m_style->GetToolSeparation() );
</mark>833<br><mark>                        }
</mark>834<br><mark>                        if( i == lines ) {
</mark>835<br><mark>                            // Also do grabber here, since it is to the right of the last line.
</mark>836<br><mark>                            wxRect grabMask( upperLeft, barsize );
</mark>837<br><mark>                            grabMask.width += m_style->GetIcon( _T("grabber") ).GetWidth();
</mark>838<br><mark>                            grabMask.height = m_style->GetIcon( _T("grabber") ).GetHeight();
</mark>839<br><mark>                            sdc.DrawRoundedRectangle( grabMask, m_style->GetToolbarCornerRadius() );
</mark>840<br><mark>                        }
</mark>841<br><mark>                        sdc.DrawRoundedRectangle( upperLeft, barsize,
</mark>842<br><mark>                                m_style->GetToolbarCornerRadius() );
</mark>843<br><mark>                        upperLeft.x += m_style->GetTopMargin() + tool_size.x;
</mark>844<br><mark>                    } else {
</mark>845<br><mark>                        wxSize barsize( visibleSize.x, tool_size.y );
</mark>846<br><mark>
</mark>847<br><mark>                        if( i == 1 ) {
</mark>848<br><mark>                            barsize.x += m_style->GetIcon( _T("grabber") ).GetWidth();
</mark>849<br><mark>                        }
</mark>850<br><mark>                        if( i == lines && i > 1 ) {
</mark>851<br><mark>                            int toolsInLastLine = toolCount % m_ptoolbar->GetMaxCols();
</mark>852<br><mark>                            if( toolsInLastLine == 0 ) toolsInLastLine = m_ptoolbar->GetMaxCols();
</mark>853<br><mark>                            int emptySpace = ( m_ptoolbar->GetMaxCols() - toolsInLastLine );
</mark>854<br><mark>                            barsize.x -= emptySpace * ( tool_size.x + m_style->GetToolSeparation() );
</mark>855<br><mark>                        }
</mark>856<br><mark>
</mark>857<br><mark>                        sdc.DrawRoundedRectangle( upperLeft, barsize,
</mark>858<br><mark>                                m_style->GetToolbarCornerRadius() );
</mark>859<br><mark>                        upperLeft.y += m_style->GetTopMargin() + tool_size.y;
</mark>860<br><mark>                    }
</mark>861<br><mark>                }
</mark>862<br><mark>            } //b_overlap
</mark>863<br><mark>            else {
</mark>864<br><mark>                for( wxToolBarToolsList::compatibility_iterator node = m_ptoolbar->m_tools.GetFirst(); node; node = node->GetNext() ) {
</mark>865<br><mark>                    wxToolBarToolBase *tool = node->GetData();
</mark>866<br><mark>                    ocpnToolBarTool *tools = (ocpnToolBarTool *) tool;
</mark>867<br><mark>                    wxRect toolRect = tools->trect;
</mark>868<br><mark>
</mark>869<br><mark>                    sdc.DrawRoundedRectangle( tools->m_x, tools->m_y, tool_size.x, tool_size.y,
</mark>870<br><mark>                                              m_style->GetToolbarCornerRadius() );
</mark>871<br><mark>                }
</mark>872<br><mark>            }
</mark>873<br><mark>
</mark>874<br><mark>#ifndef __OCPN__ANDROID__
</mark>875<br><mark>            if(shape.GetWidth() && shape.GetHeight())
</mark>876<br><mark>                SetShape( wxRegion( shape, *wxWHITE, 10 ) );
</mark>877<br><mark>#endif
</mark>878<br><mark>        }
</mark>879<br><mark>    }
</mark>880<br><mark>}
</mark>881<br><mark>
</mark>882<br><mark>void ocpnFloatingToolbarDialog::OnToolLeftClick( wxCommandEvent& event )
</mark>883<br><mark>{
</mark>884<br><mark>    // First see if it was actually the context menu that was clicked.
</mark>885<br><mark>
</mark>886<br><mark>    if( event.GetId() >= ID_PLUGIN_BASE + 100 ) {
</mark>887<br><mark>
</mark>888<br><mark>        int itemId = event.GetId() - ID_PLUGIN_BASE - 100;
</mark>889<br><mark>        wxMenuItem *item = g_FloatingToolbarConfigMenu->FindItem( event.GetId() );
</mark>890<br><mark>
</mark>891<br><mark>        if(item){
</mark>892<br><mark>            bool toolIsChecked = item->IsChecked();
</mark>893<br><mark>
</mark>894<br><mark>            if( toolIsChecked ) {
</mark>895<br><mark>                g_toolbarConfig.SetChar( itemId, _T('X') );
</mark>896<br><mark>            } else {
</mark>897<br><mark>
</mark>898<br><mark>                if( itemId + ID_ZOOMIN == ID_MOB ) {
</mark>899<br><mark>                    ToolbarMOBDialog mdlg( this );
</mark>900<br><mark>                    int dialog_ret = mdlg.ShowModal();
</mark>901<br><mark>                    int answer = mdlg.GetSelection();
</mark>902<br><mark>
</mark>903<br><mark>                    if( answer == 0 || answer == 1 || dialog_ret == wxID_CANCEL ) {
</mark>904<br><mark>                        g_FloatingToolbarConfigMenu->FindItem( event.GetId() )->Check( true );
</mark>905<br><mark>                        if( answer == 1 && dialog_ret == wxID_OK ) {
</mark>906<br><mark>                            g_bPermanentMOBIcon = true;
</mark>907<br><mark>                            delete g_FloatingToolbarConfigMenu;
</mark>908<br><mark>                            g_FloatingToolbarConfigMenu = new wxMenu();
</mark>909<br><mark>                            toolbarConfigChanged = true;
</mark>910<br><mark>                        }
</mark>911<br><mark>                        return;
</mark>912<br><mark>                    }
</mark>913<br><mark>                }
</mark>914<br><mark>
</mark>915<br><mark>                if( m_ptoolbar->GetVisibleToolCount() == 1 ) {
</mark>916<br><mark>                    OCPNMessageBox( this,
</mark>917<br><mark>                            _("You can't hide the last tool from the toolbar\nas this would make it inaccessible."),
</mark>918<br><mark>                            _("OpenCPN Alert"), wxOK );
</mark>919<br><mark>                    g_FloatingToolbarConfigMenu->FindItem( event.GetId() )->Check( true );
</mark>920<br><mark>                    return;
</mark>921<br><mark>                }
</mark>922<br><mark>
</mark>923<br><mark>                g_toolbarConfig.SetChar( itemId, _T('.') );
</mark>924<br><mark>            }
</mark>925<br><mark>        }
</mark>926<br><mark>
</mark>927<br><mark>        toolbarConfigChanged = true;
</mark>928<br><mark>        return;
</mark>929<br><mark>    }
</mark>930<br><mark>
</mark>931<br><mark>    // No it was a button that was clicked.
</mark>932<br><mark>    // Since Dialog events don't propagate automatically, we send it explicitly
</mark>933<br><mark>    // (instead of relying on event.Skip()). Send events up the window hierarchy
</mark>934<br><mark>
</mark>935<br><mark>    m_pparent->GetEventHandler()->AddPendingEvent( event );
</mark>936<br><mark>#ifndef __WXQT__
</mark>937<br><mark>    gFrame->Raise();
</mark>938<br><mark>#endif    
</mark>939<br><mark>}
</mark>940<br><mark>
</mark>941<br><mark>ocpnToolBarSimple *ocpnFloatingToolbarDialog::GetToolbar()
</mark>942<br><mark>{
</mark>943<br><mark>    if( !m_ptoolbar ) {
</mark>944<br><mark>        long winstyle = wxNO_BORDER | wxTB_FLAT;
</mark>945<br><mark>        winstyle |= m_orient;
</mark>946<br><mark>
</mark>947<br><mark>        m_ptoolbar = new ocpnToolBarSimple( this, -1, wxPoint( -1, -1 ), wxSize( -1, -1 ),
</mark>948<br><mark>                winstyle );
</mark>949<br><mark>
</mark>950<br><mark>        m_ptoolbar->SetBackgroundColour( GetGlobalColor( _T("GREY2") ) );
</mark>951<br><mark>        m_ptoolbar->ClearBackground();
</mark>952<br><mark>        m_ptoolbar->SetToggledBackgroundColour( GetGlobalColor( _T("GREY1") ) );
</mark>953<br><mark>        m_ptoolbar->SetColorScheme( m_cs );
</mark>954<br><mark>
</mark>955<br><mark>        SetGeometry(false, wxRect());
</mark>956<br><mark>    }
</mark>957<br><mark>
</mark>958<br><mark>    return m_ptoolbar;
</mark>959<br><mark>}
</mark>960<br><mark>
</mark>961<br><mark>void ocpnFloatingToolbarDialog::DestroyToolBar()
</mark>962<br><mark>{
</mark>963<br><mark>    if( m_ptoolbar ) {
</mark>964<br><mark>        m_ptoolbar->ClearTools();
</mark>965<br><mark>        delete m_ptoolbar;                  //->Destroy();
</mark>966<br><mark>        m_ptoolbar = NULL;
</mark>967<br><mark>    }
</mark>968<br><mark> 
</mark>969<br><mark>    m_destroyGrabber = m_pRecoverwin;
</mark>970<br><mark>    m_destroyTimer.Start( 5, wxTIMER_ONE_SHOT );           //  Destor the unneeded recovery grabber
</mark>971<br><mark>    
</mark>972<br><mark>}
</mark>973<br><mark>
</mark>974<br><mark>//----------------------------------------------------------------------------
</mark>975<br><mark>// Toolbar Tooltip Popup Window Definition
</mark>976<br><mark>//----------------------------------------------------------------------------
</mark>977<br><mark>class ToolTipWin: public wxDialog {
</mark>978<br><mark>public:
</mark>979<br><mark>    ToolTipWin( wxWindow *parent );
</mark>980<br><mark>    ~ToolTipWin();
</mark>981<br><mark>
</mark>982<br><mark>    void OnPaint( wxPaintEvent& event );
</mark>983<br><mark>
</mark>984<br><mark>    void SetColorScheme( ColorScheme cs );
</mark>985<br><mark>    void SetString( wxString &s )
</mark>986<br><mark>    {
</mark>987<br><mark>        m_string = s;
</mark>988<br><mark>    }
</mark>989<br><mark>    void SetPosition( wxPoint pt )
</mark>990<br><mark>    {
</mark>991<br><mark>        m_position = pt;
</mark>992<br><mark>    }
</mark>993<br><mark>    void SetBitmap( void );
</mark>994<br><mark>
</mark>995<br><mark>    void SetHiviz( bool hiviz){ m_hiviz = hiviz; }
</mark>996<br><mark>    
</mark>997<br><mark>    wxSize GetRenderedSize( void );
</mark>998<br><mark>    
</mark>999<br><mark>private:
</mark>1000<br><mark>
</mark>1001<br><mark>    wxString m_string;
</mark>1002<br><mark>    wxSize m_size;
</mark>1003<br><mark>    wxPoint m_position;
</mark>1004<br><mark>    wxBitmap *m_pbm;
</mark>1005<br><mark>    wxColour m_back_color;
</mark>1006<br><mark>    wxColour m_text_color;
</mark>1007<br><mark>    ColorScheme m_cs ;
</mark>1008<br><mark>    bool m_hiviz;
</mark>1009<br><mark>
</mark>1010<br><mark>DECLARE_EVENT_TABLE()
</mark>1011<br><mark>};
</mark>1012<br><mark>//-----------------------------------------------------------------------
</mark>1013<br><mark>//
</mark>1014<br><mark>//    Toolbar Tooltip window implementation
</mark>1015<br><mark>//
</mark>1016<br><mark>//-----------------------------------------------------------------------
</mark>1017<br><mark>BEGIN_EVENT_TABLE(ToolTipWin, wxDialog) EVT_PAINT(ToolTipWin::OnPaint)
</mark>1018<br><mark>
</mark>1019<br><mark>END_EVENT_TABLE()
</mark>1020<br><mark>
</mark>1021<br><mark>// Define a constructor
</mark>1022<br><mark>ToolTipWin::ToolTipWin( wxWindow *parent ) :
</mark>1023<br><mark>        wxDialog( parent, wxID_ANY, _T(""), wxPoint( 0, 0 ), wxSize( 1, 1 ),
</mark>1024<br><mark>                wxNO_BORDER | wxSTAY_ON_TOP )
</mark>1025<br><mark>{
</mark>1026<br><mark>    m_pbm = NULL;
</mark>1027<br><mark>
</mark>1028<br><mark>    m_back_color = GetGlobalColor( _T ( "UIBCK" ) );
</mark>1029<br><mark>    m_text_color = GetGlobalColor( _T ( "UITX1" ) );
</mark>1030<br><mark>
</mark>1031<br><mark>    SetBackgroundStyle( wxBG_STYLE_CUSTOM );
</mark>1032<br><mark>    SetBackgroundColour( m_back_color );
</mark>1033<br><mark>    m_cs = GLOBAL_COLOR_SCHEME_RGB;
</mark>1034<br><mark>
</mark>1035<br><mark>    Hide();
</mark>1036<br><mark>}
</mark>1037<br><mark>
</mark>1038<br><mark>ToolTipWin::~ToolTipWin()
</mark>1039<br><mark>{
</mark>1040<br><mark>    delete m_pbm;
</mark>1041<br><mark>}
</mark>1042<br><mark>
</mark>1043<br><mark>void ToolTipWin::SetColorScheme( ColorScheme cs )
</mark>1044<br><mark>{
</mark>1045<br><mark>    m_back_color = GetGlobalColor( _T ( "UIBCK" ) );
</mark>1046<br><mark>    m_text_color = FontMgr::Get().GetFontColor( _("ToolTips") );
</mark>1047<br><mark>
</mark>1048<br><mark>    m_cs = cs;
</mark>1049<br><mark>}
</mark>1050<br><mark>
</mark>1051<br><mark>wxSize ToolTipWin::GetRenderedSize( void )
</mark>1052<br><mark>{
</mark>1053<br><mark>    int h, w;
</mark>1054<br><mark>    wxSize sz;
</mark>1055<br><mark>
</mark>1056<br><mark>    wxClientDC cdc( GetParent() );
</mark>1057<br><mark>
</mark>1058<br><mark>    wxFont *plabelFont = FontMgr::Get().GetFont( _("ToolTips") );
</mark>1059<br><mark>    cdc.GetTextExtent( m_string, &w, &h, NULL, NULL, plabelFont );
</mark>1060<br><mark>
</mark>1061<br><mark>    sz.x = w + 8;
</mark>1062<br><mark>    sz.y = h + 4;
</mark>1063<br><mark>    
</mark>1064<br><mark>    return sz;
</mark>1065<br><mark>
</mark>1066<br><mark>}
</mark>1067<br><mark>
</mark>1068<br><mark>void ToolTipWin::SetBitmap()
</mark>1069<br><mark>{
</mark>1070<br><mark>    int h, w;
</mark>1071<br><mark>
</mark>1072<br><mark>    wxClientDC cdc( GetParent() );
</mark>1073<br><mark>
</mark>1074<br><mark>    wxFont *plabelFont = FontMgr::Get().GetFont( _("ToolTips") );
</mark>1075<br><mark>    cdc.GetTextExtent( m_string, &w, &h, NULL, NULL, plabelFont );
</mark>1076<br><mark>
</mark>1077<br><mark>    m_size.x = w + 8;
</mark>1078<br><mark>    m_size.y = h + 4;
</mark>1079<br><mark>
</mark>1080<br><mark>    wxMemoryDC mdc;
</mark>1081<br><mark>
</mark>1082<br><mark>    delete m_pbm;
</mark>1083<br><mark>    m_pbm = new wxBitmap( m_size.x, m_size.y, -1 );
</mark>1084<br><mark>    mdc.SelectObject( *m_pbm );
</mark>1085<br><mark>
</mark>1086<br><mark>    wxPen pborder( m_text_color );
</mark>1087<br><mark>    wxBrush bback( m_back_color );
</mark>1088<br><mark>    mdc.SetPen( pborder );
</mark>1089<br><mark>    mdc.SetBrush( bback );
</mark>1090<br><mark>
</mark>1091<br><mark>    if(m_hiviz){
</mark>1092<br><mark>        if((m_cs == GLOBAL_COLOR_SCHEME_DUSK) || (m_cs == GLOBAL_COLOR_SCHEME_NIGHT)){
</mark>1093<br><mark>            wxBrush hv_back( wxColour(200,200,200));
</mark>1094<br><mark>            mdc.SetBrush( hv_back );
</mark>1095<br><mark>        }
</mark>1096<br><mark>    }
</mark>1097<br><mark>    mdc.DrawRectangle( 0, 0, m_size.x, m_size.y );
</mark>1098<br><mark>
</mark>1099<br><mark>    //    Draw the text
</mark>1100<br><mark>    mdc.SetFont( *plabelFont );
</mark>1101<br><mark>    mdc.SetTextForeground( m_text_color );
</mark>1102<br><mark>    mdc.SetTextBackground( m_back_color );
</mark>1103<br><mark>
</mark>1104<br><mark>    mdc.DrawText( m_string, 4, 2 );
</mark>1105<br><mark>
</mark>1106<br><mark>    SetSize( m_position.x, m_position.y, m_size.x, m_size.y );
</mark>1107<br><mark>
</mark>1108<br><mark>}
</mark>1109<br><mark>
</mark>1110<br><mark>void ToolTipWin::OnPaint( wxPaintEvent& event )
</mark>1111<br><mark>{
</mark>1112<br><mark>    int width, height;
</mark>1113<br><mark>    GetClientSize( &width, &height );
</mark>1114<br><mark>    wxPaintDC dc( this );
</mark>1115<br><mark>
</mark>1116<br><mark>    if( m_string.Len() ) {
</mark>1117<br><mark>        wxMemoryDC mdc;
</mark>1118<br><mark>        mdc.SelectObject( *m_pbm );
</mark>1119<br><mark>        dc.Blit( 0, 0, width, height, &mdc, 0, 0 );
</mark>1120<br><mark>    }
</mark>1121<br><mark>}
</mark>1122<br><mark>
</mark>1123<br><mark>
</mark>1124<br><mark>// ----------------------------------------------------------------------------
</mark>1125<br><mark>BEGIN_EVENT_TABLE(ocpnToolBarSimple, wxControl) EVT_SIZE(ocpnToolBarSimple::OnSize)
</mark>1126<br><mark>EVT_PAINT(ocpnToolBarSimple::OnPaint)
</mark>1127<br><mark>EVT_KILL_FOCUS(ocpnToolBarSimple::OnKillFocus)
</mark>1128<br><mark>EVT_MOUSE_EVENTS(ocpnToolBarSimple::OnMouseEvent)
</mark>1129<br><mark>EVT_TIMER(TOOLTIPON_TIMER, ocpnToolBarSimple::OnToolTipTimerEvent)
</mark>1130<br><mark>EVT_TIMER(TOOLTIPOFF_TIMER, ocpnToolBarSimple::OnToolTipOffTimerEvent)
</mark>1131<br><mark>
</mark>1132<br><mark>END_EVENT_TABLE()
</mark>1133<br><mark>
</mark>1134<br><mark>// ============================================================================
</mark>1135<br><mark>// implementation
</mark>1136<br><mark>// ============================================================================
</mark>1137<br><mark>
</mark>1138<br><mark>// ----------------------------------------------------------------------------
</mark>1139<br><mark>// tool bar tools creation
</mark>1140<br><mark>// ----------------------------------------------------------------------------
</mark>1141<br><mark>
</mark>1142<br><mark>wxToolBarToolBase *ocpnToolBarSimple::CreateTool( int id, const wxString& label,
</mark>1143<br><mark>        const wxBitmap& bmpNormal, const wxBitmap& bmpDisabled, wxItemKind kind,
</mark>1144<br><mark>        wxObject *clientData, const wxString& shortHelp, const wxString& longHelp )
</mark>1145<br><mark>{
</mark>1146<br><mark>    return new ocpnToolBarTool( this, id, label, bmpNormal, bmpDisabled, kind, clientData,
</mark>1147<br><mark>            shortHelp, longHelp );
</mark>1148<br><mark>}
</mark>1149<br><mark>
</mark>1150<br><mark>// ----------------------------------------------------------------------------
</mark>1151<br><mark>// ocpnToolBarSimple creation
</mark>1152<br><mark>// ----------------------------------------------------------------------------
</mark>1153<br><mark>
</mark>1154<br><mark>void ocpnToolBarSimple::Init()
</mark>1155<br><mark>{
</mark>1156<br><mark>    m_currentRowsOrColumns = 0;
</mark>1157<br><mark>
</mark>1158<br><mark>    m_lastX = m_lastY = 0;
</mark>1159<br><mark>
</mark>1160<br><mark>    m_maxWidth = m_maxHeight = 0;
</mark>1161<br><mark>
</mark>1162<br><mark>    m_pressedTool = m_currentTool = -1;
</mark>1163<br><mark>
</mark>1164<br><mark>    m_xPos = m_yPos = wxDefaultCoord;
</mark>1165<br><mark>
</mark>1166<br><mark>    m_style = g_StyleManager->GetCurrentStyle();
</mark>1167<br><mark>
</mark>1168<br><mark>    m_defaultWidth = 16;
</mark>1169<br><mark>    m_defaultHeight = 15;
</mark>1170<br><mark>
</mark>1171<br><mark>    m_toggle_bg_color = wxSystemSettings::GetColour( wxSYS_COLOUR_3DFACE );
</mark>1172<br><mark>    m_toolOutlineColour.Set( _T("BLACK") );
</mark>1173<br><mark>    m_pToolTipWin = NULL;
</mark>1174<br><mark>    m_last_ro_tool = NULL;
</mark>1175<br><mark>
</mark>1176<br><mark>    m_btoolbar_is_zooming = false;
</mark>1177<br><mark>    m_sizefactor = 1.0f;
</mark>1178<br><mark>
</mark>1179<br><mark>    m_last_plugin_down_id = -1;
</mark>1180<br><mark>    
</mark>1181<br><mark>    EnableTooltips();
</mark>1182<br><mark>}
</mark>1183<br><mark>
</mark>1184<br><mark>wxToolBarToolBase *ocpnToolBarSimple::DoAddTool( int id, const wxString& label,
</mark>1185<br><mark>        const wxBitmap& bitmap, const wxBitmap& bmpDisabled, wxItemKind kind,
</mark>1186<br><mark>        const wxString& shortHelp, const wxString& longHelp, wxObject *clientData, wxCoord xPos,
</mark>1187<br><mark>        wxCoord yPos )
</mark>1188<br><mark>{
</mark>1189<br><mark>    // rememeber the position for DoInsertTool()
</mark>1190<br><mark>    m_xPos = xPos;
</mark>1191<br><mark>    m_yPos = yPos;
</mark>1192<br><mark>
</mark>1193<br><mark>    InvalidateBestSize();
</mark>1194<br><mark>    return InsertTool( GetToolsCount(), id, label, bitmap, bmpDisabled, kind, shortHelp, longHelp,
</mark>1195<br><mark>            clientData );
</mark>1196<br><mark>
</mark>1197<br><mark>}
</mark>1198<br><mark>
</mark>1199<br><mark>///
</mark>1200<br><mark>
</mark>1201<br><mark>wxToolBarToolBase *ocpnToolBarSimple::AddTool( int toolid, const wxString& label,
</mark>1202<br><mark>        const wxBitmap& bitmap, const wxBitmap& bmpDisabled, wxItemKind kind,
</mark>1203<br><mark>        const wxString& shortHelp, const wxString& longHelp, wxObject *data )
</mark>1204<br><mark>{
</mark>1205<br><mark>    InvalidateBestSize();
</mark>1206<br><mark>    ocpnToolBarTool* tool = (ocpnToolBarTool*)InsertTool( GetToolsCount(), toolid, label, bitmap, bmpDisabled, kind,
</mark>1207<br><mark>            shortHelp, longHelp, data );
</mark>1208<br><mark>    return tool;
</mark>1209<br><mark>}
</mark>1210<br><mark>
</mark>1211<br><mark>wxToolBarToolBase *ocpnToolBarSimple::InsertTool( size_t pos, int id, const wxString& label,
</mark>1212<br><mark>        const wxBitmap& bitmap, const wxBitmap& bmpDisabled, wxItemKind kind,
</mark>1213<br><mark>        const wxString& shortHelp, const wxString& longHelp, wxObject *clientData )
</mark>1214<br><mark>{
</mark>1215<br><mark>    wxCHECK_MSG( pos <= GetToolsCount(), (wxToolBarToolBase *)NULL,
</mark>1216<br><mark>            _T("invalid position in wxToolBar::InsertTool()") );
</mark>1217<br><mark>
</mark>1218<br><mark>    wxToolBarToolBase *tool = CreateTool( id, label, bitmap, bmpDisabled, kind, clientData,
</mark>1219<br><mark>            shortHelp, longHelp );
</mark>1220<br><mark>
</mark>1221<br><mark>    if( !InsertTool( pos, tool ) ) {
</mark>1222<br><mark>        delete tool;
</mark>1223<br><mark>
</mark>1224<br><mark>        return NULL;
</mark>1225<br><mark>    }
</mark>1226<br><mark>
</mark>1227<br><mark>    return tool;
</mark>1228<br><mark>}
</mark>1229<br><mark>
</mark>1230<br><mark>wxToolBarToolBase *ocpnToolBarSimple::InsertTool( size_t pos, wxToolBarToolBase *tool )
</mark>1231<br><mark>{
</mark>1232<br><mark>    wxCHECK_MSG( pos <= GetToolsCount(), (wxToolBarToolBase *)NULL,
</mark>1233<br><mark>            _T("invalid position in wxToolBar::InsertTool()") );
</mark>1234<br><mark>
</mark>1235<br><mark>    if( !tool || !DoInsertTool( pos, tool ) ) {
</mark>1236<br><mark>        return NULL;
</mark>1237<br><mark>    }
</mark>1238<br><mark>
</mark>1239<br><mark>    m_tools.Insert( pos, tool );
</mark>1240<br><mark>
</mark>1241<br><mark>    return tool;
</mark>1242<br><mark>}
</mark>1243<br><mark>
</mark>1244<br><mark>bool ocpnToolBarSimple::DoInsertTool( size_t WXUNUSED(pos), wxToolBarToolBase *toolBase )
</mark>1245<br><mark>{
</mark>1246<br><mark>    ocpnToolBarTool *tool = (ocpnToolBarTool *) toolBase;
</mark>1247<br><mark>
</mark>1248<br><mark>    // Check if the plugin is inserting same-named tools. Make sure they have different names,
</mark>1249<br><mark>    // otherwise the style manager cannot differentiate between them.
</mark>1250<br><mark>    if( tool->isPluginTool ) {
</mark>1251<br><mark>        for( unsigned int i=0; i<GetToolsCount(); i++ ) {
</mark>1252<br><mark>            if( tool->GetToolname() == ((ocpnToolBarTool *)m_tools.Item(i)->GetData())->GetToolname()) {
</mark>1253<br><mark>                tool->toolname << _T("1");
</mark>1254<br><mark>            }
</mark>1255<br><mark>        }
</mark>1256<br><mark>    }
</mark>1257<br><mark>
</mark>1258<br><mark>    tool->m_x = m_xPos;
</mark>1259<br><mark>    if( tool->m_x == wxDefaultCoord ) tool->m_x = m_style->GetLeftMargin();
</mark>1260<br><mark>
</mark>1261<br><mark>    tool->m_y = m_yPos;
</mark>1262<br><mark>    if( tool->m_y == wxDefaultCoord ) tool->m_y = m_style->GetTopMargin();
</mark>1263<br><mark>
</mark>1264<br><mark>    if( tool->IsButton() ) {
</mark>1265<br><mark>        tool->SetSize( GetToolSize() );
</mark>1266<br><mark>
</mark>1267<br><mark>        // Calculate reasonable max size in case Layout() not called
</mark>1268<br><mark>        if( ( tool->m_x + tool->GetNormalBitmap().GetWidth() + m_style->GetLeftMargin() )
</mark>1269<br><mark>                > m_maxWidth ) m_maxWidth = (wxCoord) ( ( tool->m_x + tool->GetWidth()
</mark>1270<br><mark>                + m_style->GetLeftMargin() ) );
</mark>1271<br><mark>
</mark>1272<br><mark>        if( ( tool->m_y + tool->GetNormalBitmap().GetHeight() + m_style->GetTopMargin() )
</mark>1273<br><mark>                > m_maxHeight ) m_maxHeight = (wxCoord) ( ( tool->m_y + tool->GetHeight()
</mark>1274<br><mark>                + m_style->GetTopMargin() ) );
</mark>1275<br><mark>    }
</mark>1276<br><mark>
</mark>1277<br><mark>    else
</mark>1278<br><mark>        if( tool->IsControl() ) {
</mark>1279<br><mark>            tool->SetSize( tool->GetControl()->GetSize() );
</mark>1280<br><mark>        }
</mark>1281<br><mark>
</mark>1282<br><mark>    tool->b_hilite = false;
</mark>1283<br><mark>
</mark>1284<br><mark>    return true;
</mark>1285<br><mark>}
</mark>1286<br><mark>
</mark>1287<br><mark>bool ocpnToolBarSimple::DoDeleteTool( size_t WXUNUSED(pos), wxToolBarToolBase *tool )
</mark>1288<br><mark>{
</mark>1289<br><mark>    // VZ: didn't test whether it works, but why not...
</mark>1290<br><mark>    tool->Detach();
</mark>1291<br><mark>
</mark>1292<br><mark>    if( m_last_ro_tool == tool ) m_last_ro_tool = NULL;
</mark>1293<br><mark>
</mark>1294<br><mark>    Refresh( false );
</mark>1295<br><mark>
</mark>1296<br><mark>    return true;
</mark>1297<br><mark>}
</mark>1298<br><mark>
</mark>1299<br><mark>bool ocpnToolBarSimple::Create( wxWindow *parent, wxWindowID id, const wxPoint& pos,
</mark>1300<br><mark>        const wxSize& size, long style, const wxString& name )
</mark>1301<br><mark>{
</mark>1302<br><mark>    if( !wxWindow::Create( parent, id, pos, size, style, name ) ) return false;
</mark>1303<br><mark>
</mark>1304<br><mark>    // Set it to grey (or other 3D face colour)
</mark>1305<br><mark>    SetBackgroundColour( wxSystemSettings::GetColour( wxSYS_COLOUR_3DFACE ) );
</mark>1306<br><mark>
</mark>1307<br><mark>    if( GetWindowStyleFlag() & wxTB_VERTICAL ) {
</mark>1308<br><mark>        m_lastX = 7;
</mark>1309<br><mark>        m_lastY = 3;
</mark>1310<br><mark>
</mark>1311<br><mark>        m_maxRows = 32000;      // a lot
</mark>1312<br><mark>        m_maxCols = 1;
</mark>1313<br><mark>    } else {
</mark>1314<br><mark>        m_lastX = 3;
</mark>1315<br><mark>        m_lastY = 7;
</mark>1316<br><mark>
</mark>1317<br><mark>        m_maxRows = 1;
</mark>1318<br><mark>        m_maxCols = 32000;      // a lot
</mark>1319<br><mark>    }
</mark>1320<br><mark>
</mark>1321<br><mark>    SetCursor( *wxSTANDARD_CURSOR );
</mark>1322<br><mark>
</mark>1323<br><mark>    m_tooltip_timer.SetOwner( this, TOOLTIPON_TIMER );
</mark>1324<br><mark>    m_tooltipoff_timer.SetOwner( this, TOOLTIPOFF_TIMER );
</mark>1325<br><mark>    m_tooltip_off = 3000;
</mark>1326<br><mark>
</mark>1327<br><mark>    return true;
</mark>1328<br><mark>}
</mark>1329<br><mark>
</mark>1330<br><mark>ocpnToolBarSimple::~ocpnToolBarSimple()
</mark>1331<br><mark>{
</mark>1332<br><mark>    if( m_pToolTipWin ) {
</mark>1333<br><mark>        m_pToolTipWin->Destroy();
</mark>1334<br><mark>        m_pToolTipWin = NULL;
</mark>1335<br><mark>    }
</mark>1336<br><mark>
</mark>1337<br><mark>}
</mark>1338<br><mark>
</mark>1339<br><mark>void ocpnToolBarSimple::KillTooltip()
</mark>1340<br><mark>{
</mark>1341<br><mark>    m_btooltip_show = false;
</mark>1342<br><mark>
</mark>1343<br><mark>    if( m_pToolTipWin ) {
</mark>1344<br><mark>        m_pToolTipWin->Hide();
</mark>1345<br><mark>        m_pToolTipWin->Destroy();
</mark>1346<br><mark>        m_pToolTipWin = NULL;
</mark>1347<br><mark>    }
</mark>1348<br><mark>    m_tooltip_timer.Stop();
</mark>1349<br><mark>
</mark>1350<br><mark>    if( m_last_ro_tool ) {
</mark>1351<br><mark>        if( m_last_ro_tool->IsEnabled() ) {
</mark>1352<br><mark>            if( m_last_ro_tool->IsToggled() ) {
</mark>1353<br><mark>                m_last_ro_tool->SetNormalBitmap( m_style->GetToolIcon( m_last_ro_tool->GetToolname(), TOOLICON_TOGGLED ) );
</mark>1354<br><mark>            }
</mark>1355<br><mark>            else {
</mark>1356<br><mark>                m_last_ro_tool->SetNormalBitmap( m_style->GetToolIcon( m_last_ro_tool->GetToolname(), TOOLICON_NORMAL ) );
</mark>1357<br><mark>            }
</mark>1358<br><mark>        }
</mark>1359<br><mark>    }
</mark>1360<br><mark>}
</mark>1361<br><mark>
</mark>1362<br><mark>void ocpnToolBarSimple::HideTooltip()
</mark>1363<br><mark>{
</mark>1364<br><mark>    if( m_pToolTipWin ) {
</mark>1365<br><mark>        m_pToolTipWin->Hide();
</mark>1366<br><mark>    }
</mark>1367<br><mark>}
</mark>1368<br><mark>
</mark>1369<br><mark>void ocpnToolBarSimple::SetColorScheme( ColorScheme cs )
</mark>1370<br><mark>{
</mark>1371<br><mark>    if( m_pToolTipWin ) {
</mark>1372<br><mark>        m_pToolTipWin->Destroy();
</mark>1373<br><mark>        m_pToolTipWin = NULL;
</mark>1374<br><mark>    }
</mark>1375<br><mark>
</mark>1376<br><mark>    m_toolOutlineColour = GetGlobalColor( _T("UIBDR") );
</mark>1377<br><mark>
</mark>1378<br><mark>    m_currentColorScheme = cs;
</mark>1379<br><mark>}
</mark>1380<br><mark>
</mark>1381<br><mark>bool ocpnToolBarSimple::Realize()
</mark>1382<br><mark>{
</mark>1383<br><mark>    m_currentRowsOrColumns = 0;
</mark>1384<br><mark>    m_LineCount = 1;
</mark>1385<br><mark>    m_lastX = m_style->GetLeftMargin();
</mark>1386<br><mark>    m_lastY = m_style->GetTopMargin();
</mark>1387<br><mark>    m_maxWidth = 0;
</mark>1388<br><mark>    m_maxHeight = 0;
</mark>1389<br><mark>
</mark>1390<br><mark>    if( IsVertical() ) m_style->SetOrientation( wxTB_VERTICAL );
</mark>1391<br><mark>    else
</mark>1392<br><mark>        m_style->SetOrientation( wxTB_HORIZONTAL );
</mark>1393<br><mark>
</mark>1394<br><mark>    wxSize toolSize = wxSize(-1, -1);
</mark>1395<br><mark>    int separatorSize = m_style->GetToolSeparation();
</mark>1396<br><mark>
</mark>1397<br><mark>    ocpnToolBarTool *lastTool = NULL;
</mark>1398<br><mark>    bool firstNode = true;
</mark>1399<br><mark>    wxToolBarToolsList::compatibility_iterator node = m_tools.GetFirst();
</mark>1400<br><mark>
</mark>1401<br><mark>    while( node ) {
</mark>1402<br><mark>        ocpnToolBarTool *tool = (ocpnToolBarTool *) node->GetData();
</mark>1403<br><mark>
</mark>1404<br><mark>        // Set the tool size to be the size of the first non-separator tool, usually the first one
</mark>1405<br><mark>        if(toolSize.x == -1){
</mark>1406<br><mark>            if( !tool->IsSeparator() ){
</mark>1407<br><mark>                toolSize.x = tool->m_width;
</mark>1408<br><mark>                toolSize.y = tool->m_height;
</mark>1409<br><mark>            }
</mark>1410<br><mark>        }
</mark>1411<br><mark>
</mark>1412<br><mark>        tool->firstInLine = firstNode;
</mark>1413<br><mark>        tool->lastInLine = false;
</mark>1414<br><mark>        firstNode = false;
</mark>1415<br><mark>
</mark>1416<br><mark>        tool->last_rect.width = 0;              // mark it invalid
</mark>1417<br><mark>        
</mark>1418<br><mark>        if( tool->IsSeparator() ) {
</mark>1419<br><mark>            if( GetWindowStyleFlag() & wxTB_HORIZONTAL ) {
</mark>1420<br><mark>                if( m_currentRowsOrColumns >= m_maxCols ) m_lastY += separatorSize;
</mark>1421<br><mark>                else
</mark>1422<br><mark>                    m_lastX += separatorSize;
</mark>1423<br><mark>            } else {
</mark>1424<br><mark>                if( m_currentRowsOrColumns >= m_maxRows ) m_lastX += separatorSize;
</mark>1425<br><mark>                else
</mark>1426<br><mark>                    m_lastY += separatorSize;
</mark>1427<br><mark>            }
</mark>1428<br><mark>        } else
</mark>1429<br><mark>            if( tool->IsButton() ) {
</mark>1430<br><mark>                if( !IsVertical() ) {
</mark>1431<br><mark>                    if( m_currentRowsOrColumns >= m_maxCols ) {
</mark>1432<br><mark>                        tool->firstInLine = true;
</mark>1433<br><mark>                        if( lastTool && m_LineCount > 1 ) lastTool->lastInLine = true;
</mark>1434<br><mark>                        m_LineCount++;
</mark>1435<br><mark>                        m_currentRowsOrColumns = 0;
</mark>1436<br><mark>                        m_lastX = m_style->GetLeftMargin();
</mark>1437<br><mark>                        m_lastY += toolSize.y + m_style->GetTopMargin();
</mark>1438<br><mark>                    }
</mark>1439<br><mark>                    tool->m_x = (wxCoord) m_lastX;
</mark>1440<br><mark>                    tool->m_y = (wxCoord) m_lastY;
</mark>1441<br><mark>
</mark>1442<br><mark>                    tool->trect = wxRect( tool->m_x, tool->m_y, toolSize.x, toolSize.y );
</mark>1443<br><mark>                    tool->trect.Inflate( m_style->GetToolSeparation() / 2,
</mark>1444<br><mark>                            m_style->GetTopMargin() );
</mark>1445<br><mark>
</mark>1446<br><mark>                    m_lastX += toolSize.x + m_style->GetToolSeparation();
</mark>1447<br><mark>                } else {
</mark>1448<br><mark>                    if( m_currentRowsOrColumns >= m_maxRows ) {
</mark>1449<br><mark>                        tool->firstInLine = true;
</mark>1450<br><mark>                        if( lastTool ) lastTool->lastInLine = true;
</mark>1451<br><mark>                        m_LineCount++;
</mark>1452<br><mark>                        m_currentRowsOrColumns = 0;
</mark>1453<br><mark>                        m_lastX += toolSize.x + m_style->GetTopMargin();
</mark>1454<br><mark>                        m_lastY = m_style->GetTopMargin();
</mark>1455<br><mark>                    }
</mark>1456<br><mark>                    tool->m_x = (wxCoord) m_lastX;
</mark>1457<br><mark>                    tool->m_y = (wxCoord) m_lastY;
</mark>1458<br><mark>
</mark>1459<br><mark>                    tool->trect = wxRect( tool->m_x, tool->m_y, toolSize.x, toolSize.y );
</mark>1460<br><mark>                    tool->trect.Inflate( m_style->GetToolSeparation() / 2,
</mark>1461<br><mark>                            m_style->GetTopMargin() );
</mark>1462<br><mark>
</mark>1463<br><mark>                    m_lastY += toolSize.y + m_style->GetToolSeparation();
</mark>1464<br><mark>                }
</mark>1465<br><mark>                m_currentRowsOrColumns++;
</mark>1466<br><mark>            } else
</mark>1467<br><mark>                if( tool->IsControl() ) {
</mark>1468<br><mark>                    tool->m_x = (wxCoord) ( m_lastX );
</mark>1469<br><mark>                    tool->m_y = (wxCoord) ( m_lastY - ( m_style->GetTopMargin() / 2 ) );
</mark>1470<br><mark>
</mark>1471<br><mark>                    tool->trect = wxRect( tool->m_x, tool->m_y, tool->GetWidth(),
</mark>1472<br><mark>                            tool->GetHeight() );
</mark>1473<br><mark>                    tool->trect.Inflate( m_style->GetToolSeparation() / 2,
</mark>1474<br><mark>                            m_style->GetTopMargin() );
</mark>1475<br><mark>                    ;
</mark>1476<br><mark>
</mark>1477<br><mark>                    wxSize s = tool->GetControl()->GetSize();
</mark>1478<br><mark>                    m_lastX += s.x + m_style->GetToolSeparation();
</mark>1479<br><mark>
</mark>1480<br><mark>                }
</mark>1481<br><mark>
</mark>1482<br><mark>        if( m_lastX > m_maxWidth ) m_maxWidth = m_lastX;
</mark>1483<br><mark>        if( m_lastY > m_maxHeight ) m_maxHeight = m_lastY;
</mark>1484<br><mark>
</mark>1485<br><mark>        lastTool = tool;
</mark>1486<br><mark>        node = node->GetNext();
</mark>1487<br><mark>    }
</mark>1488<br><mark>    if( lastTool && (m_LineCount > 1 || IsVertical()) )
</mark>1489<br><mark>        lastTool->lastInLine = true;
</mark>1490<br><mark>
</mark>1491<br><mark>    if( GetWindowStyleFlag() & wxTB_HORIZONTAL ) m_maxHeight += toolSize.y;
</mark>1492<br><mark>    else
</mark>1493<br><mark>        m_maxWidth += toolSize.x;
</mark>1494<br><mark>
</mark>1495<br><mark>    m_maxWidth += m_style->GetRightMargin();
</mark>1496<br><mark>    m_maxHeight += m_style->GetBottomMargin();
</mark>1497<br><mark>
</mark>1498<br><mark>    SetSize( m_maxWidth, m_maxHeight );
</mark>1499<br><mark>    SetMinSize( wxSize( m_maxWidth, m_maxHeight ) );
</mark>1500<br><mark>
</mark>1501<br><mark>    return true;
</mark>1502<br><mark>}
</mark>1503<br><mark>
</mark>1504<br><mark>// ----------------------------------------------------------------------------
</mark>1505<br><mark>// event handlers
</mark>1506<br><mark>// ----------------------------------------------------------------------------
</mark>1507<br><mark>
</mark>1508<br><mark>void ocpnToolBarSimple::OnPaint( wxPaintEvent& WXUNUSED(event) )
</mark>1509<br><mark>{
</mark>1510<br><mark>    wxPaintDC dc( this );
</mark>1511<br><mark>    PrepareDC( dc );
</mark>1512<br><mark>
</mark>1513<br><mark>    wxRegion ru = GetUpdateRegion();
</mark>1514<br><mark>    wxRect upRect = ru.GetBox();
</mark>1515<br><mark>
</mark>1516<br><mark>    static int count = 0;
</mark>1517<br><mark>    // Prevent reentry of OnPaint which would cause wxMemoryDC errors.
</mark>1518<br><mark>    if( count > 0 ) return;
</mark>1519<br><mark>    count++;
</mark>1520<br><mark>
</mark>1521<br><mark>    for( wxToolBarToolsList::compatibility_iterator node = m_tools.GetFirst(); node;
</mark>1522<br><mark>            node = node->GetNext() ) {
</mark>1523<br><mark>        wxToolBarToolBase *tool = node->GetData();
</mark>1524<br><mark>        ocpnToolBarTool *tools = (ocpnToolBarTool *) tool;
</mark>1525<br><mark>        wxRect toolRect = tools->trect;
</mark>1526<br><mark>
</mark>1527<br><mark>        if( toolRect.Intersects( upRect ) ) {
</mark>1528<br><mark>
</mark>1529<br><mark>            if( tool->IsButton() ) {
</mark>1530<br><mark>                DrawTool( dc, tool );
</mark>1531<br><mark>            } else
</mark>1532<br><mark>                if( tool->IsControl() ) {
</mark>1533<br><mark>                    if( tool->GetControl()->IsKindOf( CLASSINFO(wxStaticBitmap) ) ) {
</mark>1534<br><mark>                        wxStaticBitmap *psbm = (wxStaticBitmap *) tool->GetControl();
</mark>1535<br><mark>                        ocpnToolBarTool *toolsimp = (ocpnToolBarTool *) tool;
</mark>1536<br><mark>                        dc.DrawBitmap( psbm->GetBitmap(), toolsimp->m_x, toolsimp->m_y, false );
</mark>1537<br><mark>                    }
</mark>1538<br><mark>                }
</mark>1539<br><mark>        }
</mark>1540<br><mark>    }
</mark>1541<br><mark>
</mark>1542<br><mark>    count--;
</mark>1543<br><mark>}
</mark>1544<br><mark>
</mark>1545<br><mark>void ocpnToolBarSimple::OnSize( wxSizeEvent& WXUNUSED(event) )
</mark>1546<br><mark>{
</mark>1547<br><mark>    if( GetAutoLayout() ) Layout();
</mark>1548<br><mark>}
</mark>1549<br><mark>
</mark>1550<br><mark>void ocpnToolBarSimple::OnKillFocus( wxFocusEvent& WXUNUSED(event) )
</mark>1551<br><mark>{
</mark>1552<br><mark>    OnMouseEnter( m_pressedTool = m_currentTool = -1 );
</mark>1553<br><mark>}
</mark>1554<br><mark>
</mark>1555<br><mark>void ocpnToolBarSimple::OnToolTipTimerEvent( wxTimerEvent& event )
</mark>1556<br><mark>{
</mark>1557<br><mark>    if( !gFrame->IsActive() ) return;
</mark>1558<br><mark>
</mark>1559<br><mark>    if( m_btooltip_show && IsShown() && m_pToolTipWin && ( !m_pToolTipWin->IsShown() ) ) {
</mark>1560<br><mark>        if( m_last_ro_tool ) {
</mark>1561<br><mark>            wxString s = m_last_ro_tool->GetShortHelp();
</mark>1562<br><mark>
</mark>1563<br><mark>            if( s.Len() ) {
</mark>1564<br><mark>                m_pToolTipWin->SetString( s );
</mark>1565<br><mark>                m_pToolTipWin->SetHiviz(m_last_ro_tool->m_btooltip_hiviz);
</mark>1566<br><mark>
</mark>1567<br><mark>                wxPoint pos_in_toolbar( m_last_ro_tool->m_x, m_last_ro_tool->m_y );
</mark>1568<br><mark>                pos_in_toolbar.x += m_last_ro_tool->m_width + 2;
</mark>1569<br><mark>
</mark>1570<br><mark>                m_pToolTipWin->Move(0,0);       // workaround for gtk autocentre dialog behavior
</mark>1571<br><mark>
</mark>1572<br><mark>                wxPoint screenPosition = ClientToScreen( pos_in_toolbar );
</mark>1573<br><mark>                wxPoint framePosition = gFrame->ScreenToClient(screenPosition);
</mark>1574<br><mark>                wxSize tipSize = m_pToolTipWin->GetRenderedSize();
</mark>1575<br><mark>                
</mark>1576<br><mark>                if( (framePosition.x + tipSize.x) > gFrame->GetSize().x)
</mark>1577<br><mark>                    screenPosition.x -= (tipSize.x + m_last_ro_tool->m_width + 4);
</mark>1578<br><mark>                
</mark>1579<br><mark>                m_pToolTipWin->SetPosition( screenPosition );
</mark>1580<br><mark>                m_pToolTipWin->SetBitmap();
</mark>1581<br><mark>                m_pToolTipWin->Show();
</mark>1582<br><mark>                gFrame->Raise();
</mark>1583<br><mark>                if( g_btouch )
</mark>1584<br><mark>                    m_tooltipoff_timer.Start(m_tooltip_off, wxTIMER_ONE_SHOT);
</mark>1585<br><mark>            }
</mark>1586<br><mark>        }
</mark>1587<br><mark>    }
</mark>1588<br><mark>}
</mark>1589<br><mark>
</mark>1590<br><mark>void ocpnToolBarSimple::OnToolTipOffTimerEvent( wxTimerEvent& event )
</mark>1591<br><mark>{
</mark>1592<br><mark>    HideTooltip();
</mark>1593<br><mark>}
</mark>1594<br><mark>
</mark>1595<br><mark>
</mark>1596<br><mark>int s_dragx, s_dragy;
</mark>1597<br><mark>
</mark>1598<br><mark>void ocpnToolBarSimple::OnMouseEvent( wxMouseEvent & event )
</mark>1599<br><mark>{
</mark>1600<br><mark>#ifdef __OCPN__ANDROID__
</mark>1601<br><mark>    if(!event.IsButton())
</mark>1602<br><mark>        return;
</mark>1603<br><mark>#endif
</mark>1604<br><mark>
</mark>1605<br><mark>    wxCoord x, y;
</mark>1606<br><mark>    event.GetPosition( &x, &y );
</mark>1607<br><mark>    ocpnToolBarTool *tool = (ocpnToolBarTool *) FindToolForPosition( x, y );
</mark>1608<br><mark>
</mark>1609<br><mark>#ifndef __OCPN__ANDROID__
</mark>1610<br><mark>    if( event.LeftDown() ) {
</mark>1611<br><mark>        CaptureMouse();
</mark>1612<br><mark>        s_dragx = x;
</mark>1613<br><mark>        s_dragy = y;
</mark>1614<br><mark>    }
</mark>1615<br><mark>    if( event.LeftUp() ) {
</mark>1616<br><mark>        if( HasCapture() ) ReleaseMouse();
</mark>1617<br><mark>    }
</mark>1618<br><mark>#endif
</mark>1619<br><mark>
</mark>1620<br><mark>    if( tool && tool->IsButton() && IsShown() ) {
</mark>1621<br><mark>
</mark>1622<br><mark>        //    ToolTips
</mark>1623<br><mark>        if( NULL == m_pToolTipWin ) {
</mark>1624<br><mark>            m_pToolTipWin = new ToolTipWin( GetParent() );
</mark>1625<br><mark>            m_pToolTipWin->SetColorScheme( m_currentColorScheme );
</mark>1626<br><mark>            m_pToolTipWin->Hide();
</mark>1627<br><mark>        }
</mark>1628<br><mark>
</mark>1629<br><mark>        if( tool != m_last_ro_tool ) m_pToolTipWin->Hide();
</mark>1630<br><mark>
</mark>1631<br><mark>#ifndef __OCPN__ANDROID__
</mark>1632<br><mark>        if( !m_pToolTipWin->IsShown() ) {
</mark>1633<br><mark>            m_tooltip_timer.Start( m_one_shot, wxTIMER_ONE_SHOT );
</mark>1634<br><mark>        }
</mark>1635<br><mark>#endif
</mark>1636<br><mark>
</mark>1637<br><mark>        //    Tool Rollover highlighting
</mark>1638<br><mark>        if(!g_btouch){
</mark>1639<br><mark>            if( tool != m_last_ro_tool ) {
</mark>1640<br><mark>                if( tool->IsEnabled() ) {
</mark>1641<br><mark>                    tool->rollover = true;
</mark>1642<br><mark>                    tool->bitmapOK = false;
</mark>1643<br><mark>                }
</mark>1644<br><mark>                if( m_last_ro_tool ) {
</mark>1645<br><mark>                    if( m_last_ro_tool->IsEnabled() ) {
</mark>1646<br><mark>                        m_last_ro_tool->rollover = false;
</mark>1647<br><mark>                        m_last_ro_tool->bitmapOK = false;
</mark>1648<br><mark>                    }
</mark>1649<br><mark>                }
</mark>1650<br><mark>                m_last_ro_tool = tool;
</mark>1651<br><mark>                if(g_toolbar)
</mark>1652<br><mark>                    g_toolbar->Refresh( false );
</mark>1653<br><mark>            }
</mark>1654<br><mark>        }
</mark>1655<br><mark>    } else {
</mark>1656<br><mark>        //    Tooltips
</mark>1657<br><mark>        if( m_pToolTipWin && m_pToolTipWin->IsShown() ) m_pToolTipWin->Hide();
</mark>1658<br><mark>
</mark>1659<br><mark>        //    Remove Highlighting
</mark>1660<br><mark>        if( m_last_ro_tool ) {
</mark>1661<br><mark>            if( m_last_ro_tool->IsEnabled() ) {
</mark>1662<br><mark>                m_last_ro_tool->rollover = false;
</mark>1663<br><mark>                m_last_ro_tool->bitmapOK = false;
</mark>1664<br><mark>            }
</mark>1665<br><mark>            g_toolbar->Refresh( false );
</mark>1666<br><mark>        }
</mark>1667<br><mark>    }
</mark>1668<br><mark>
</mark>1669<br><mark>    m_last_ro_tool = tool;
</mark>1670<br><mark>
</mark>1671<br><mark>    // allow smooth zooming while toolbutton is held down
</mark>1672<br><mark>    if(g_bsmoothpanzoom && !g_btouch) {
</mark>1673<br><mark>        if(event.LeftUp() && m_btoolbar_is_zooming) {
</mark>1674<br><mark>            cc1->StopMovement();
</mark>1675<br><mark>            m_btoolbar_is_zooming = false;
</mark>1676<br><mark>            return;
</mark>1677<br><mark>        }
</mark>1678<br><mark>
</mark>1679<br><mark>        if( event.LeftDown() && tool &&
</mark>1680<br><mark>            (tool->GetId() == ID_ZOOMIN || tool->GetId() == ID_ZOOMOUT) ) {
</mark>1681<br><mark>            cc1->ZoomCanvas( tool->GetId() == ID_ZOOMIN ? 2.0 : .5, false, false );
</mark>1682<br><mark>            m_btoolbar_is_zooming = true;
</mark>1683<br><mark>            return;
</mark>1684<br><mark>        }
</mark>1685<br><mark>    }
</mark>1686<br><mark>
</mark>1687<br><mark>    if( !tool ) {
</mark>1688<br><mark>        if( m_currentTool > -1 ) {
</mark>1689<br><mark>            if( event.LeftIsDown() ) SpringUpButton( m_currentTool );
</mark>1690<br><mark>            m_currentTool = -1;
</mark>1691<br><mark>            OnMouseEnter( -1 );
</mark>1692<br><mark>        }
</mark>1693<br><mark>
</mark>1694<br><mark>        wxMouseEvent *pev = (wxMouseEvent *) event.Clone();
</mark>1695<br><mark>        GetParent()->GetEventHandler()->AddPendingEvent( *pev );
</mark>1696<br><mark>        wxDELETE( pev );
</mark>1697<br><mark>
</mark>1698<br><mark>        return;
</mark>1699<br><mark>    }
</mark>1700<br><mark>
</mark>1701<br><mark>    if( !event.IsButton() ) {
</mark>1702<br><mark>        if( tool->GetId() != m_currentTool ) {
</mark>1703<br><mark>            // If the left button is kept down and moved over buttons,
</mark>1704<br><mark>            // press those buttons.
</mark>1705<br><mark>            if( event.LeftIsDown() && tool->IsEnabled() ) {
</mark>1706<br><mark>                SpringUpButton( m_currentTool );
</mark>1707<br><mark>
</mark>1708<br><mark>                if( tool->CanBeToggled() ) {
</mark>1709<br><mark>                    tool->Toggle();
</mark>1710<br><mark>                }
</mark>1711<br><mark>
</mark>1712<br><mark>                DrawTool( tool );
</mark>1713<br><mark>            }
</mark>1714<br><mark>
</mark>1715<br><mark>            m_currentTool = tool->GetId();
</mark>1716<br><mark>            OnMouseEnter( m_currentTool );
</mark>1717<br><mark>        }
</mark>1718<br><mark>
</mark>1719<br><mark>        wxMouseEvent *pev = (wxMouseEvent *) event.Clone();
</mark>1720<br><mark>        GetParent()->GetEventHandler()->AddPendingEvent( *pev );
</mark>1721<br><mark>        wxDELETE( pev );
</mark>1722<br><mark>
</mark>1723<br><mark>        return;
</mark>1724<br><mark>    }
</mark>1725<br><mark>
</mark>1726<br><mark>    // Left button pressed.
</mark>1727<br><mark>    if( event.LeftDown() && tool->IsEnabled() ) {
</mark>1728<br><mark>        if( tool->CanBeToggled() ) {
</mark>1729<br><mark>            tool->Toggle();
</mark>1730<br><mark>            tool->bitmapOK = false;
</mark>1731<br><mark>            
</mark>1732<br><mark>        }
</mark>1733<br><mark>
</mark>1734<br><mark>        DrawTool( tool );
</mark>1735<br><mark>
</mark>1736<br><mark>        //        Look for PlugIn tools
</mark>1737<br><mark>        //        If found, make the callback.
</mark>1738<br><mark>        if( g_pi_manager ) {
</mark>1739<br><mark>            ArrayOfPlugInToolbarTools tool_array = g_pi_manager->GetPluginToolbarToolArray();
</mark>1740<br><mark>            for( unsigned int i = 0; i < tool_array.GetCount(); i++ ) {
</mark>1741<br><mark>                PlugInToolbarToolContainer *pttc = tool_array.Item( i );
</mark>1742<br><mark>                if( tool->GetId() == pttc->id ) {
</mark>1743<br><mark>                    opencpn_plugin_113 *ppi = dynamic_cast<opencpn_plugin_113 *>(pttc->m_pplugin);
</mark>1744<br><mark>                    if( ppi ) {
</mark>1745<br><mark>                        ppi->OnToolbarToolDownCallback( pttc->id );
</mark>1746<br><mark>                        m_last_plugin_down_id = pttc->id;
</mark>1747<br><mark>                    }
</mark>1748<br><mark>                }
</mark>1749<br><mark>            }
</mark>1750<br><mark>        }
</mark>1751<br><mark>    } else
</mark>1752<br><mark>        if( event.RightDown() ) {
</mark>1753<br><mark>            OnRightClick( tool->GetId(), x, y );
</mark>1754<br><mark>        }
</mark>1755<br><mark>
</mark>1756<br><mark>    // Left Button Released.  Only this action confirms selection.
</mark>1757<br><mark>    // If the button is enabled and it is not a toggle tool and it is
</mark>1758<br><mark>    // in the pressed state, then raise the button and call OnLeftClick.
</mark>1759<br><mark>    //
</mark>1760<br><mark>    if( event.LeftUp() && tool->IsEnabled() ) {
</mark>1761<br><mark>        // Pass the OnLeftClick event to tool
</mark>1762<br><mark>        if( !OnLeftClick( tool->GetId(), tool->IsToggled() ) && tool->CanBeToggled() ) {
</mark>1763<br><mark>            // If it was a toggle, and OnLeftClick says No Toggle allowed,
</mark>1764<br><mark>            // then change it back
</mark>1765<br><mark>            tool->Toggle();
</mark>1766<br><mark>            tool->bitmapOK = false;
</mark>1767<br><mark>        }
</mark>1768<br><mark>
</mark>1769<br><mark>        DoPluginToolUp();
</mark>1770<br><mark>    }
</mark>1771<br><mark>
</mark>1772<br><mark>    wxMouseEvent *pev = (wxMouseEvent *) event.Clone();
</mark>1773<br><mark>    GetParent()->GetEventHandler()->AddPendingEvent( *pev );
</mark>1774<br><mark>    wxDELETE( pev );
</mark>1775<br><mark>    event.Skip();
</mark>1776<br><mark>}
</mark>1777<br><mark>
</mark>1778<br><mark>// ----------------------------------------------------------------------------
</mark>1779<br><mark>// drawing
</mark>1780<br><mark>// ----------------------------------------------------------------------------
</mark>1781<br><mark>
</mark>1782<br><mark>void ocpnToolBarSimple::DrawTool( wxToolBarToolBase *tool )
</mark>1783<br><mark>{
</mark>1784<br><mark>    wxClientDC dc( this );
</mark>1785<br><mark>    DrawTool( dc, tool );
</mark>1786<br><mark>}
</mark>1787<br><mark>
</mark>1788<br><mark>// NB! The current DrawTool code assumes that plugin tools are never disabled
</mark>1789<br><mark>// when they are present on the toolbar, since disabled plugins are removed.
</mark>1790<br><mark>
</mark>1791<br><mark>void ocpnToolBarSimple::DrawTool( wxDC& dc, wxToolBarToolBase *toolBase )
</mark>1792<br><mark>{
</mark>1793<br><mark>    ocpnToolBarTool *tool = (ocpnToolBarTool *) toolBase;
</mark>1794<br><mark>    PrepareDC( dc );
</mark>1795<br><mark>
</mark>1796<br><mark>    wxPoint drawAt( tool->m_x, tool->m_y );
</mark>1797<br><mark>    wxBitmap bmp;
</mark>1798<br><mark>
</mark>1799<br><mark>    if( tool->bitmapOK ) {
</mark>1800<br><mark>        if( tool->IsEnabled() ) {
</mark>1801<br><mark>            bmp = tool->GetNormalBitmap();
</mark>1802<br><mark>            if( !bmp.IsOk() ){
</mark>1803<br><mark>                bmp = m_style->GetToolIcon( tool->GetToolname(), TOOLICON_NORMAL, tool->rollover );
</mark>1804<br><mark>                if(m_sizefactor > 1.0 ){
</mark>1805<br><mark>                    wxImage scaled_image = bmp.ConvertToImage();
</mark>1806<br><mark>                    bmp = wxBitmap(scaled_image.Scale(tool->m_width, tool->m_height, wxIMAGE_QUALITY_HIGH));
</mark>1807<br><mark>                }
</mark>1808<br><mark>                tool->SetNormalBitmap( bmp );
</mark>1809<br><mark>                tool->bitmapOK = true;
</mark>1810<br><mark>            }
</mark>1811<br><mark>        } else {
</mark>1812<br><mark>            bmp = tool->GetDisabledBitmap();
</mark>1813<br><mark>            if( !bmp.IsOk() ){
</mark>1814<br><mark>                bmp = m_style->GetToolIcon( tool->GetToolname(), TOOLICON_DISABLED );
</mark>1815<br><mark>                if(m_sizefactor > 1.0 ){
</mark>1816<br><mark>                    wxImage scaled_image = bmp.ConvertToImage();
</mark>1817<br><mark>                    bmp = wxBitmap(scaled_image.Scale(tool->m_width, tool->m_height, wxIMAGE_QUALITY_HIGH));
</mark>1818<br><mark>                }
</mark>1819<br><mark>                tool->SetDisabledBitmap( bmp );
</mark>1820<br><mark>                tool->bitmapOK = true;
</mark>1821<br><mark>            }
</mark>1822<br><mark>        }
</mark>1823<br><mark>    } else {
</mark>1824<br><mark>        if ( tool->isPluginTool ) {
</mark>1825<br><mark>
</mark>1826<br><mark>            // First try getting the icon from the Style.
</mark>1827<br><mark>            // If it is not in the style we build a new icon from the style BG and the plugin icon.
</mark>1828<br><mark>
</mark>1829<br><mark>            if( tool->IsToggled() ) {
</mark>1830<br><mark>                bmp = m_style->GetToolIcon( tool->GetToolname(), TOOLICON_TOGGLED, tool->rollover );
</mark>1831<br><mark>                if( bmp.GetDepth() == 1 ) {
</mark>1832<br><mark>                    if( tool->rollover ) {
</mark>1833<br><mark>                        bmp = m_style->BuildPluginIcon( tool->pluginRolloverIcon, TOOLICON_TOGGLED );
</mark>1834<br><mark>                        if( ! bmp.IsOk() )
</mark>1835<br><mark>                            bmp = m_style->BuildPluginIcon( tool->pluginNormalIcon, TOOLICON_TOGGLED );
</mark>1836<br><mark>                    }
</mark>1837<br><mark>                    else
</mark>1838<br><mark>                        bmp = m_style->BuildPluginIcon( tool->pluginNormalIcon, TOOLICON_TOGGLED );
</mark>1839<br><mark>                }
</mark>1840<br><mark>            } else {
</mark>1841<br><mark>                bmp = m_style->GetToolIcon( tool->GetToolname(), TOOLICON_NORMAL, tool->rollover );
</mark>1842<br><mark>                if( bmp.GetDepth() == 1 ) {
</mark>1843<br><mark>                    if( tool->rollover ) {
</mark>1844<br><mark>                        bmp = m_style->BuildPluginIcon( tool->pluginRolloverIcon, TOOLICON_NORMAL );
</mark>1845<br><mark>                        if( ! bmp.IsOk() )
</mark>1846<br><mark>                            bmp = m_style->BuildPluginIcon( tool->pluginNormalIcon, TOOLICON_NORMAL );
</mark>1847<br><mark>                    }
</mark>1848<br><mark>                    else
</mark>1849<br><mark>                        bmp = m_style->BuildPluginIcon( tool->pluginNormalIcon, TOOLICON_NORMAL );
</mark>1850<br><mark>                }
</mark>1851<br><mark>            }
</mark>1852<br><mark>            if(m_sizefactor > 1.0 ){
</mark>1853<br><mark>                wxImage scaled_image = bmp.ConvertToImage();
</mark>1854<br><mark>                bmp = wxBitmap(scaled_image.Scale(tool->m_width, tool->m_height, wxIMAGE_QUALITY_HIGH));
</mark>1855<br><mark>            }
</mark>1856<br><mark>            tool->SetNormalBitmap( bmp );
</mark>1857<br><mark>            tool->bitmapOK = true;
</mark>1858<br><mark>        } else {
</mark>1859<br><mark>            if( tool->IsEnabled() ) {
</mark>1860<br><mark>                if( tool->IsToggled() )
</mark>1861<br><mark>                    bmp = m_style->GetToolIcon( tool->GetToolname(), TOOLICON_TOGGLED, tool->rollover );
</mark>1862<br><mark>                else
</mark>1863<br><mark>                    bmp = m_style->GetToolIcon( tool->GetIconName(), TOOLICON_NORMAL, tool->rollover );
</mark>1864<br><mark>
</mark>1865<br><mark>                if(m_sizefactor > 1.0 ){
</mark>1866<br><mark>                    wxImage scaled_image = bmp.ConvertToImage();
</mark>1867<br><mark>                    bmp = wxBitmap(scaled_image.Scale(tool->m_width, tool->m_height, wxIMAGE_QUALITY_HIGH));
</mark>1868<br><mark>                }
</mark>1869<br><mark>                tool->SetNormalBitmap( bmp );
</mark>1870<br><mark>                tool->bitmapOK = true;
</mark>1871<br><mark>            } else {
</mark>1872<br><mark>                bmp = m_style->GetToolIcon( tool->GetToolname(), TOOLICON_DISABLED );
</mark>1873<br><mark>                if(m_sizefactor > 1.0 ){
</mark>1874<br><mark>                    wxImage scaled_image = bmp.ConvertToImage();
</mark>1875<br><mark>                    bmp = wxBitmap(scaled_image.Scale(tool->m_width, tool->m_height, wxIMAGE_QUALITY_HIGH));
</mark>1876<br><mark>                }
</mark>1877<br><mark>                tool->SetDisabledBitmap( bmp );
</mark>1878<br><mark>                tool->bitmapOK = true;
</mark>1879<br><mark>            }
</mark>1880<br><mark>        }
</mark>1881<br><mark>    }
</mark>1882<br><mark>
</mark>1883<br><mark>    if( tool->firstInLine ) {
</mark>1884<br><mark>        m_style->DrawToolbarLineStart( bmp );
</mark>1885<br><mark>    }
</mark>1886<br><mark>    if( tool->lastInLine ) {
</mark>1887<br><mark>        m_style->DrawToolbarLineEnd( bmp );
</mark>1888<br><mark>    }
</mark>1889<br><mark>
</mark>1890<br><mark>    if( bmp.GetWidth() != m_style->GetToolSize().x
</mark>1891<br><mark>            || bmp.GetHeight() != m_style->GetToolSize().y ) {
</mark>1892<br><mark>//        drawAt.x -= ( bmp.GetWidth() - m_style->GetToolSize().x ) / 2;
</mark>1893<br><mark>//        drawAt.y -= ( bmp.GetHeight() - m_style->GetToolSize().y ) / 2;
</mark>1894<br><mark>    }
</mark>1895<br><mark>
</mark>1896<br><mark>    //      Clear the last drawn tool if necessary
</mark>1897<br><mark>    if( tool->last_rect.width && ((tool->last_rect.x != drawAt.x) || (tool->last_rect.y != drawAt.y)) ){
</mark>1898<br><mark>        wxBrush bb(GetGlobalColor( _T("GREY2") ));
</mark>1899<br><mark>        dc.SetBrush(bb);
</mark>1900<br><mark>        dc.SetPen( *wxTRANSPARENT_PEN );
</mark>1901<br><mark>        dc.DrawRectangle(tool->last_rect.x, tool->last_rect.y, tool->last_rect.width, tool->last_rect.height);
</mark>1902<br><mark>    }
</mark>1903<br><mark>
</mark>1904<br><mark>    //  could cache this in the tool...
</mark>1905<br><mark>    //  A bit of a hack here.  We only scale tools if they are to be magnified globally
</mark>1906<br><mark>    if(0/*m_sizefactor > 1.0*/ )
</mark>1907<br><mark>    {
</mark>1908<br><mark>        wxImage scaled_image = bmp.ConvertToImage();
</mark>1909<br><mark>        wxBitmap sbmp = wxBitmap(scaled_image.Scale(tool->m_width, tool->m_height, wxIMAGE_QUALITY_HIGH));
</mark>1910<br><mark>        dc.DrawBitmap( sbmp, drawAt );
</mark>1911<br><mark>        tool->last_rect = wxRect(drawAt.x, drawAt.y, sbmp.GetWidth(), sbmp.GetHeight());
</mark>1912<br><mark>
</mark>1913<br><mark>    }
</mark>1914<br><mark>    else
</mark>1915<br><mark>    {
</mark>1916<br><mark>        dc.DrawBitmap( bmp, drawAt );
</mark>1917<br><mark>        tool->last_rect = wxRect(drawAt.x, drawAt.y, bmp.GetWidth(), bmp.GetHeight());
</mark>1918<br><mark>    }
</mark>1919<br><mark>
</mark>1920<br><mark>}
</mark>1921<br><mark>
</mark>1922<br><mark>// ----------------------------------------------------------------------------
</mark>1923<br><mark>// toolbar geometry
</mark>1924<br><mark>// ----------------------------------------------------------------------------
</mark>1925<br><mark>
</mark>1926<br><mark>wxToolBarToolBase *ocpnToolBarSimple::FindToolForPosition( wxCoord x, wxCoord y )
</mark>1927<br><mark>{
</mark>1928<br><mark>    wxToolBarToolsList::compatibility_iterator node = m_tools.GetFirst();
</mark>1929<br><mark>    while( node ) {
</mark>1930<br><mark>        ocpnToolBarTool *tool = (ocpnToolBarTool *) node->GetData();
</mark>1931<br><mark>        if( ( x >= tool->m_x ) && ( y >= tool->m_y ) && ( x < ( tool->m_x + tool->GetWidth() ) )
</mark>1932<br><mark>                && ( y < ( tool->m_y + tool->GetHeight() ) ) ) {
</mark>1933<br><mark>            return tool;
</mark>1934<br><mark>        }
</mark>1935<br><mark>
</mark>1936<br><mark>        node = node->GetNext();
</mark>1937<br><mark>    }
</mark>1938<br><mark>
</mark>1939<br><mark>    return (wxToolBarToolBase *) NULL;
</mark>1940<br><mark>}
</mark>1941<br><mark>
</mark>1942<br><mark>void ocpnToolBarSimple::InvalidateBitmaps()
</mark>1943<br><mark>{
</mark>1944<br><mark>    wxToolBarToolsList::compatibility_iterator node = m_tools.GetFirst();
</mark>1945<br><mark>    while( node ) {
</mark>1946<br><mark>        ocpnToolBarTool *tool = (ocpnToolBarTool *) node->GetData();
</mark>1947<br><mark>        tool->bitmapOK = false;
</mark>1948<br><mark>        node = node->GetNext();
</mark>1949<br><mark>    }
</mark>1950<br><mark>}
</mark>1951<br><mark>
</mark>1952<br><mark>wxRect ocpnToolBarSimple::GetToolRect( int tool_id )
</mark>1953<br><mark>{
</mark>1954<br><mark>    wxRect rect;
</mark>1955<br><mark>    wxToolBarToolBase *tool = FindById( tool_id );
</mark>1956<br><mark>    if( tool ) {
</mark>1957<br><mark>        ocpnToolBarTool *otool = (ocpnToolBarTool *) tool;
</mark>1958<br><mark>        if( otool ) rect = otool->trect;
</mark>1959<br><mark>    }
</mark>1960<br><mark>
</mark>1961<br><mark>    return rect;
</mark>1962<br><mark>}
</mark>1963<br><mark>
</mark>1964<br><mark>// ----------------------------------------------------------------------------
</mark>1965<br><mark>// tool state change handlers
</mark>1966<br><mark>// ----------------------------------------------------------------------------
</mark>1967<br><mark>
</mark>1968<br><mark>void ocpnToolBarSimple::DoEnableTool( wxToolBarToolBase *tool, bool WXUNUSED(enable) )
</mark>1969<br><mark>{
</mark>1970<br><mark>    DrawTool( tool );
</mark>1971<br><mark>}
</mark>1972<br><mark>
</mark>1973<br><mark>void ocpnToolBarSimple::DoToggleTool( wxToolBarToolBase *tool, bool WXUNUSED(toggle) )
</mark>1974<br><mark>{
</mark>1975<br><mark>    ocpnToolBarTool *t = (ocpnToolBarTool *) tool;
</mark>1976<br><mark>    t->bitmapOK = false;
</mark>1977<br><mark>    DrawTool( tool );
</mark>1978<br><mark>}
</mark>1979<br><mark>
</mark>1980<br><mark>// Okay, so we've left the tool we're in ... we must check if the tool we're
</mark>1981<br><mark>// leaving was a 'sprung push button' and if so, spring it back to the up
</mark>1982<br><mark>// state.
</mark>1983<br><mark>void ocpnToolBarSimple::SpringUpButton( int id )
</mark>1984<br><mark>{
</mark>1985<br><mark>    wxToolBarToolBase *tool = FindById( id );
</mark>1986<br><mark>
</mark>1987<br><mark>    if( tool && tool->CanBeToggled() ) {
</mark>1988<br><mark>        if( tool->IsToggled() ) tool->Toggle();
</mark>1989<br><mark>
</mark>1990<br><mark>        DrawTool( tool );
</mark>1991<br><mark>    }
</mark>1992<br><mark>}
</mark>1993<br><mark>
</mark>1994<br><mark>// ----------------------------------------------------------------------------
</mark>1995<br><mark>// scrolling implementation
</mark>1996<br><mark>// ----------------------------------------------------------------------------
</mark>1997<br><mark>
</mark>1998<br><mark>wxString ocpnToolBarSimple::GetToolShortHelp( int id ) const
</mark>1999<br><mark>{
</mark>2000<br><mark>    wxToolBarToolBase *tool = FindById( id );
</mark>2001<br><mark>    wxCHECK_MSG( tool, wxEmptyString, _T("no such tool") );
</mark>2002<br><mark>
</mark>2003<br><mark>    return tool->GetShortHelp();
</mark>2004<br><mark>}
</mark>2005<br><mark>
</mark>2006<br><mark>wxString ocpnToolBarSimple::GetToolLongHelp( int id ) const
</mark>2007<br><mark>{
</mark>2008<br><mark>    wxToolBarToolBase *tool = FindById( id );
</mark>2009<br><mark>    wxCHECK_MSG( tool, wxEmptyString, _T("no such tool") );
</mark>2010<br><mark>
</mark>2011<br><mark>    return tool->GetLongHelp();
</mark>2012<br><mark>}
</mark>2013<br><mark>
</mark>2014<br><mark>void ocpnToolBarSimple::SetToolShortHelp( int id, const wxString& help )
</mark>2015<br><mark>{
</mark>2016<br><mark>    wxToolBarToolBase *tool = FindById( id );
</mark>2017<br><mark>    if( tool ) {
</mark>2018<br><mark>        (void) tool->SetShortHelp( help );
</mark>2019<br><mark>    }
</mark>2020<br><mark>}
</mark>2021<br><mark>
</mark>2022<br><mark>void ocpnToolBarSimple::SetToolLongHelp( int id, const wxString& help )
</mark>2023<br><mark>{
</mark>2024<br><mark>    wxToolBarToolBase *tool = FindById( id );
</mark>2025<br><mark>    if( tool ) {
</mark>2026<br><mark>        (void) tool->SetLongHelp( help );
</mark>2027<br><mark>    }
</mark>2028<br><mark>}
</mark>2029<br><mark>
</mark>2030<br><mark>int ocpnToolBarSimple::GetToolPos( int id ) const
</mark>2031<br><mark>{
</mark>2032<br><mark>    size_t pos = 0;
</mark>2033<br><mark>    wxToolBarToolsList::compatibility_iterator node;
</mark>2034<br><mark>
</mark>2035<br><mark>    for( node = m_tools.GetFirst(); node; node = node->GetNext() ) {
</mark>2036<br><mark>        if( node->GetData()->GetId() == id ) return pos;
</mark>2037<br><mark>
</mark>2038<br><mark>        pos++;
</mark>2039<br><mark>    }
</mark>2040<br><mark>
</mark>2041<br><mark>    return wxNOT_FOUND;
</mark>2042<br><mark>}
</mark>2043<br><mark>bool ocpnToolBarSimple::GetToolState( int id ) const
</mark>2044<br><mark>{
</mark>2045<br><mark>    wxToolBarToolBase *tool = FindById( id );
</mark>2046<br><mark>    wxCHECK_MSG( tool, false, _T("no such tool") );
</mark>2047<br><mark>
</mark>2048<br><mark>    return tool->IsToggled();
</mark>2049<br><mark>}
</mark>2050<br><mark>
</mark>2051<br><mark>bool ocpnToolBarSimple::GetToolEnabled( int id ) const
</mark>2052<br><mark>{
</mark>2053<br><mark>    wxToolBarToolBase *tool = FindById( id );
</mark>2054<br><mark>    wxCHECK_MSG( tool, false, _T("no such tool") );
</mark>2055<br><mark>
</mark>2056<br><mark>    return tool->IsEnabled();
</mark>2057<br><mark>}
</mark>2058<br><mark>
</mark>2059<br><mark>void ocpnToolBarSimple::ToggleTool( int id, bool toggle )
</mark>2060<br><mark>{
</mark>2061<br><mark>    wxToolBarToolBase *tool = FindById( id );
</mark>2062<br><mark>        
</mark>2063<br><mark>    if( tool && tool->CanBeToggled() && tool->Toggle( toggle ) ) {
</mark>2064<br><mark>        DoToggleTool( tool, toggle );
</mark>2065<br><mark>        if( g_toolbar ) g_toolbar->Refresh();
</mark>2066<br><mark>    }
</mark>2067<br><mark>}
</mark>2068<br><mark>
</mark>2069<br><mark>wxObject *ocpnToolBarSimple::GetToolClientData( int id ) const
</mark>2070<br><mark>{
</mark>2071<br><mark>    wxToolBarToolBase *tool = FindById( id );
</mark>2072<br><mark>    return tool ? tool->GetClientData() : (wxObject *) NULL;
</mark>2073<br><mark>}
</mark>2074<br><mark>
</mark>2075<br><mark>void ocpnToolBarSimple::SetToolClientData( int id, wxObject *clientData )
</mark>2076<br><mark>{
</mark>2077<br><mark>    wxToolBarToolBase *tool = FindById( id );
</mark>2078<br><mark>
</mark>2079<br><mark>    wxCHECK_RET( tool, _T("no such tool in wxToolBar::SetToolClientData") );
</mark>2080<br><mark>
</mark>2081<br><mark>    tool->SetClientData( clientData );
</mark>2082<br><mark>}
</mark>2083<br><mark>
</mark>2084<br><mark>void ocpnToolBarSimple::EnableTool( int id, bool enable )
</mark>2085<br><mark>{
</mark>2086<br><mark>    wxToolBarToolBase *tool = FindById( id );
</mark>2087<br><mark>    if( tool ) {
</mark>2088<br><mark>        if( tool->Enable( enable ) ) {
</mark>2089<br><mark>            DoEnableTool( tool, enable );
</mark>2090<br><mark>        }
</mark>2091<br><mark>    }
</mark>2092<br><mark>    wxMenuItem* configItem = g_FloatingToolbarConfigMenu->FindItem( id );
</mark>2093<br><mark>    configItem->Check( true );
</mark>2094<br><mark>}
</mark>2095<br><mark>
</mark>2096<br><mark>void ocpnToolBarSimple::SetToolBitmaps( int id, wxBitmap *bmp, wxBitmap *bmpRollover )
</mark>2097<br><mark>{
</mark>2098<br><mark>    ocpnToolBarTool *tool = (ocpnToolBarTool*)FindById( id );
</mark>2099<br><mark>    if( tool ) {
</mark>2100<br><mark>        tool->pluginNormalIcon = bmp;
</mark>2101<br><mark>        tool->pluginRolloverIcon = bmpRollover;
</mark>2102<br><mark>        tool->bitmapOK = false;
</mark>2103<br><mark>    }
</mark>2104<br><mark>}
</mark>2105<br><mark>
</mark>2106<br><mark>void ocpnToolBarSimple::SetToolTooltipHiViz( int id, bool b_hiviz )
</mark>2107<br><mark>{
</mark>2108<br><mark>    ocpnToolBarTool *tool = (ocpnToolBarTool*)FindById( id );
</mark>2109<br><mark>    if( tool ) {
</mark>2110<br><mark>        tool->SetTooltipHiviz( b_hiviz );
</mark>2111<br><mark>    }
</mark>2112<br><mark>}
</mark>2113<br><mark>
</mark>2114<br><mark>
</mark>2115<br><mark>void ocpnToolBarSimple::ClearTools()
</mark>2116<br><mark>{
</mark>2117<br><mark>    while( GetToolsCount() ) {
</mark>2118<br><mark>        DeleteToolByPos( 0 );
</mark>2119<br><mark>    }
</mark>2120<br><mark>}
</mark>2121<br><mark>
</mark>2122<br><mark>int ocpnToolBarSimple::GetVisibleToolCount()
</mark>2123<br><mark>{
</mark>2124<br><mark>    int counter = 0;
</mark>2125<br><mark>    wxToolBarToolsList::compatibility_iterator node = m_tools.GetFirst();
</mark>2126<br><mark>    while( node ) {
</mark>2127<br><mark>        ocpnToolBarTool *tool = (ocpnToolBarTool *) node->GetData();
</mark>2128<br><mark>        counter++;
</mark>2129<br><mark>        node = node->GetNext();
</mark>2130<br><mark>    }
</mark>2131<br><mark>    return counter;
</mark>2132<br><mark>}
</mark>2133<br><mark>
</mark>2134<br><mark>bool ocpnToolBarSimple::DeleteToolByPos( size_t pos )
</mark>2135<br><mark>{
</mark>2136<br><mark>    wxCHECK_MSG( pos < GetToolsCount(), false,
</mark>2137<br><mark>            _T("invalid position in wxToolBar::DeleteToolByPos()") );
</mark>2138<br><mark>
</mark>2139<br><mark>    wxToolBarToolsList::compatibility_iterator node = m_tools.Item( pos );
</mark>2140<br><mark>
</mark>2141<br><mark>    if( !DoDeleteTool( pos, node->GetData() ) ) {
</mark>2142<br><mark>        return false;
</mark>2143<br><mark>    }
</mark>2144<br><mark>
</mark>2145<br><mark>    delete node->GetData();
</mark>2146<br><mark>    m_tools.Erase( node );
</mark>2147<br><mark>
</mark>2148<br><mark>    return true;
</mark>2149<br><mark>}
</mark>2150<br><mark>
</mark>2151<br><mark>bool ocpnToolBarSimple::DeleteTool( int id )
</mark>2152<br><mark>{
</mark>2153<br><mark>    size_t pos = 0;
</mark>2154<br><mark>    wxToolBarToolsList::compatibility_iterator node;
</mark>2155<br><mark>    for( node = m_tools.GetFirst(); node; node = node->GetNext() ) {
</mark>2156<br><mark>        if( node->GetData()->GetId() == id ) break;
</mark>2157<br><mark>
</mark>2158<br><mark>        pos++;
</mark>2159<br><mark>    }
</mark>2160<br><mark>
</mark>2161<br><mark>    if( !node || !DoDeleteTool( pos, node->GetData() ) ) {
</mark>2162<br><mark>        return false;
</mark>2163<br><mark>    }
</mark>2164<br><mark>
</mark>2165<br><mark>    delete node->GetData();
</mark>2166<br><mark>    m_tools.Erase( node );
</mark>2167<br><mark>
</mark>2168<br><mark>    return true;
</mark>2169<br><mark>}
</mark>2170<br><mark>
</mark>2171<br><mark>wxToolBarToolBase *ocpnToolBarSimple::AddSeparator()
</mark>2172<br><mark>{
</mark>2173<br><mark>    return InsertSeparator( GetToolsCount() );
</mark>2174<br><mark>}
</mark>2175<br><mark>
</mark>2176<br><mark>wxToolBarToolBase *ocpnToolBarSimple::InsertSeparator( size_t pos )
</mark>2177<br><mark>{
</mark>2178<br><mark>    wxCHECK_MSG( pos <= GetToolsCount(), (wxToolBarToolBase *)NULL,
</mark>2179<br><mark>            _T("invalid position in wxToolBar::InsertSeparator()") );
</mark>2180<br><mark>
</mark>2181<br><mark>    wxToolBarToolBase *tool = CreateTool( wxID_SEPARATOR, wxEmptyString, wxNullBitmap, wxNullBitmap,
</mark>2182<br><mark>            wxITEM_SEPARATOR, (wxObject *) NULL, wxEmptyString, wxEmptyString );
</mark>2183<br><mark>
</mark>2184<br><mark>    if( !tool || !DoInsertTool( pos, tool ) ) {
</mark>2185<br><mark>        delete tool;
</mark>2186<br><mark>
</mark>2187<br><mark>        return NULL;
</mark>2188<br><mark>    }
</mark>2189<br><mark>
</mark>2190<br><mark>    m_tools.Insert( pos, tool );
</mark>2191<br><mark>
</mark>2192<br><mark>    return tool;
</mark>2193<br><mark>}
</mark>2194<br><mark>
</mark>2195<br><mark>wxToolBarToolBase *ocpnToolBarSimple::RemoveTool( int id )
</mark>2196<br><mark>{
</mark>2197<br><mark>    size_t pos = 0;
</mark>2198<br><mark>    wxToolBarToolsList::compatibility_iterator node;
</mark>2199<br><mark>    for( node = m_tools.GetFirst(); node; node = node->GetNext() ) {
</mark>2200<br><mark>        if( node->GetData()->GetId() == id ) break;
</mark>2201<br><mark>
</mark>2202<br><mark>        pos++;
</mark>2203<br><mark>    }
</mark>2204<br><mark>
</mark>2205<br><mark>    if( !node ) {
</mark>2206<br><mark>        // don't give any error messages - sometimes we might call RemoveTool()
</mark>2207<br><mark>        // without knowing whether the tool is or not in the toolbar
</mark>2208<br><mark>        return (wxToolBarToolBase *) NULL;
</mark>2209<br><mark>    }
</mark>2210<br><mark>
</mark>2211<br><mark>    wxToolBarToolBase *tool = node->GetData();
</mark>2212<br><mark>    if( !DoDeleteTool( pos, tool ) ) {
</mark>2213<br><mark>        return (wxToolBarToolBase *) NULL;
</mark>2214<br><mark>    }
</mark>2215<br><mark>
</mark>2216<br><mark>    m_tools.Erase( node );
</mark>2217<br><mark>
</mark>2218<br><mark>    return tool;
</mark>2219<br><mark>}
</mark>2220<br><mark>
</mark>2221<br><mark>
</mark>2222<br><mark>wxControl *ocpnToolBarSimple::FindControl( int id )
</mark>2223<br><mark>{
</mark>2224<br><mark>    for( wxToolBarToolsList::compatibility_iterator node = m_tools.GetFirst(); node;
</mark>2225<br><mark>            node = node->GetNext() ) {
</mark>2226<br><mark>        const wxToolBarToolBase * const tool = node->GetData();
</mark>2227<br><mark>        if( tool->IsControl() ) {
</mark>2228<br><mark>            wxControl * const control = tool->GetControl();
</mark>2229<br><mark>
</mark>2230<br><mark>            if( !control ) {
</mark>2231<br><mark>                wxFAIL_MSG( _T("NULL control in toolbar?") );
</mark>2232<br><mark>            } else
</mark>2233<br><mark>                if( control->GetId() == id ) {
</mark>2234<br><mark>                    // found
</mark>2235<br><mark>                    return control;
</mark>2236<br><mark>                }
</mark>2237<br><mark>        }
</mark>2238<br><mark>    }
</mark>2239<br><mark>
</mark>2240<br><mark>    return NULL;
</mark>2241<br><mark>}
</mark>2242<br><mark>
</mark>2243<br><mark>wxToolBarToolBase *ocpnToolBarSimple::FindById( int id ) const
</mark>2244<br><mark>{
</mark>2245<br><mark>    wxToolBarToolBase *tool = (wxToolBarToolBase *) NULL;
</mark>2246<br><mark>
</mark>2247<br><mark>    for( wxToolBarToolsList::compatibility_iterator node = m_tools.GetFirst(); node;
</mark>2248<br><mark>            node = node->GetNext() ) {
</mark>2249<br><mark>        tool = node->GetData();
</mark>2250<br><mark>        if( tool->GetId() == id ) {
</mark>2251<br><mark>            // found
</mark>2252<br><mark>            break;
</mark>2253<br><mark>        }
</mark>2254<br><mark>
</mark>2255<br><mark>        tool = NULL;
</mark>2256<br><mark>    }
</mark>2257<br><mark>
</mark>2258<br><mark>    return tool;
</mark>2259<br><mark>}
</mark>2260<br><mark>
</mark>2261<br><mark>// ----------------------------------------------------------------------------
</mark>2262<br><mark>// event processing
</mark>2263<br><mark>// ----------------------------------------------------------------------------
</mark>2264<br><mark>
</mark>2265<br><mark>// Only allow toggle if returns true
</mark>2266<br><mark>bool ocpnToolBarSimple::OnLeftClick( int id, bool toggleDown )
</mark>2267<br><mark>{
</mark>2268<br><mark>    wxCommandEvent event( wxEVT_COMMAND_TOOL_CLICKED, id );
</mark>2269<br><mark>    event.SetEventObject( this );
</mark>2270<br><mark>
</mark>2271<br><mark>    // we use SetInt() to make wxCommandEvent::IsChecked() return toggleDown
</mark>2272<br><mark>    event.SetInt( (int) toggleDown );
</mark>2273<br><mark>
</mark>2274<br><mark>    // and SetExtraLong() for backwards compatibility
</mark>2275<br><mark>    event.SetExtraLong( (long) toggleDown );
</mark>2276<br><mark>
</mark>2277<br><mark>    // Send events to this toolbar instead (and thence up the window hierarchy)
</mark>2278<br><mark>    GetEventHandler()->ProcessEvent( event );
</mark>2279<br><mark>
</mark>2280<br><mark>    return true;
</mark>2281<br><mark>}
</mark>2282<br><mark>
</mark>2283<br><mark>// Call when right button down.
</mark>2284<br><mark>void ocpnToolBarSimple::OnRightClick( int id, long WXUNUSED(x), long WXUNUSED(y) )
</mark>2285<br><mark>{
</mark>2286<br><mark>    wxCommandEvent event( wxEVT_COMMAND_TOOL_RCLICKED, id );
</mark>2287<br><mark>    event.SetEventObject( this );
</mark>2288<br><mark>    event.SetInt( id );
</mark>2289<br><mark>
</mark>2290<br><mark>    HideTooltip();
</mark>2291<br><mark>    ((ocpnFloatingToolbarDialog*)GetParent())->toolbarConfigChanged = false;
</mark>2292<br><mark>    wxMenu* contextMenu = new wxMenu();
</mark>2293<br><mark>    wxMenuItem* submenu = contextMenu->AppendSubMenu( g_FloatingToolbarConfigMenu, _("Visible buttons") );
</mark>2294<br><mark>
</mark>2295<br><mark>    PopupMenu( contextMenu );
</mark>2296<br><mark>
</mark>2297<br><mark>    contextMenu->Remove( submenu );
</mark>2298<br><mark>    delete contextMenu;
</mark>2299<br><mark>
</mark>2300<br><mark>    if( ((ocpnFloatingToolbarDialog*)GetParent())->toolbarConfigChanged )
</mark>2301<br><mark>        gFrame->GetEventHandler()->AddPendingEvent( event );
</mark>2302<br><mark>}
</mark>2303<br><mark>
</mark>2304<br><mark>// Called when the mouse cursor enters a tool bitmap (no button pressed).
</mark>2305<br><mark>// Argument is wxID_ANY if mouse is exiting the toolbar.
</mark>2306<br><mark>// Note that for this event, the id of the window is used,
</mark>2307<br><mark>// and the integer parameter of wxCommandEvent is used to retrieve
</mark>2308<br><mark>// the tool id.
</mark>2309<br><mark>void ocpnToolBarSimple::OnMouseEnter( int id )
</mark>2310<br><mark>{
</mark>2311<br><mark>    wxCommandEvent event( wxEVT_COMMAND_TOOL_ENTER, GetId() );
</mark>2312<br><mark>    event.SetEventObject( this );
</mark>2313<br><mark>    event.SetInt( id );
</mark>2314<br><mark>
</mark>2315<br><mark>    wxFrame *frame = wxDynamicCast(GetParent(), wxFrame);
</mark>2316<br><mark>    if( frame ) {
</mark>2317<br><mark>        wxString help;
</mark>2318<br><mark>        wxToolBarToolBase* tool = id == wxID_ANY ? (wxToolBarToolBase*) NULL : FindById( id );
</mark>2319<br><mark>        if( tool ) help = tool->GetLongHelp();
</mark>2320<br><mark>        frame->DoGiveHelp( help, id != wxID_ANY );
</mark>2321<br><mark>    }
</mark>2322<br><mark>
</mark>2323<br><mark>    (void) GetEventHandler()->ProcessEvent( event );
</mark>2324<br><mark>
</mark>2325<br><mark>    DoPluginToolUp();
</mark>2326<br><mark>}
</mark>2327<br><mark>
</mark>2328<br><mark>void ocpnToolBarSimple::DoPluginToolUp()
</mark>2329<br><mark>{
</mark>2330<br><mark>    //        Look for PlugIn tools
</mark>2331<br><mark>    //        If found, make the callback.
</mark>2332<br><mark>    if( !g_pi_manager)
</mark>2333<br><mark>        return;
</mark>2334<br><mark>
</mark>2335<br><mark>    ArrayOfPlugInToolbarTools tool_array = g_pi_manager->GetPluginToolbarToolArray();
</mark>2336<br><mark>    for( unsigned int i = 0; i < tool_array.GetCount(); i++ ) {
</mark>2337<br><mark>        PlugInToolbarToolContainer *pttc = tool_array.Item( i );
</mark>2338<br><mark>        if( m_last_plugin_down_id == pttc->id ) {
</mark>2339<br><mark>            opencpn_plugin_113 *ppi = dynamic_cast<opencpn_plugin_113 *>(pttc->m_pplugin);
</mark>2340<br><mark>            if( ppi )
</mark>2341<br><mark>                ppi->OnToolbarToolUpCallback( pttc->id );
</mark>2342<br><mark>        }
</mark>2343<br><mark>    }
</mark>2344<br><mark>
</mark>2345<br><mark>    m_last_plugin_down_id = -1;
</mark>2346<br><mark>}
</mark>2347<br><mark>
</mark>2348<br><mark>void ocpnToolBarSimple::SetToolNormalBitmapEx( wxToolBarToolBase *tool, const wxString &iconName)
</mark>2349<br><mark>{
</mark>2350<br><mark>    if( tool ) {
</mark>2351<br><mark>        ocpnToolBarTool *otool = (ocpnToolBarTool *) tool;
</mark>2352<br><mark>        if(otool){
</mark>2353<br><mark>            ocpnStyle::Style *style = g_StyleManager->GetCurrentStyle();
</mark>2354<br><mark>
</mark>2355<br><mark>            wxBitmap bmp = style->GetToolIcon( iconName, TOOLICON_NORMAL );
</mark>2356<br><mark>            if(m_sizefactor > 1.0 ){
</mark>2357<br><mark>                wxImage scaled_image = bmp.ConvertToImage();
</mark>2358<br><mark>                bmp = wxBitmap(scaled_image.Scale(otool->m_width, otool->m_height, wxIMAGE_QUALITY_HIGH));
</mark>2359<br><mark>            }
</mark>2360<br><mark>        
</mark>2361<br><mark>            tool->SetNormalBitmap( bmp );
</mark>2362<br><mark>            otool->SetIconName( iconName );
</mark>2363<br><mark>        }
</mark>2364<br><mark>    }
</mark>2365<br><mark>}
</mark>2366<br><mark>
</mark>2367<br><mark>
</mark>2368<br><mark>//-------------------------------------------------------------------------------------
</mark>2369<br><mark>
</mark>2370<br><mark>ToolbarMOBDialog::ToolbarMOBDialog( wxWindow* parent )
</mark>2371<br><mark>       : wxDialog( parent, wxID_ANY, _("OpenCPN Alert"), wxDefaultPosition, wxSize(250, 230) )
</mark>2372<br><mark>{
</mark>2373<br><mark>    wxBoxSizer* topSizer = new wxBoxSizer( wxVERTICAL );
</mark>2374<br><mark>
</mark>2375<br><mark>    wxBoxSizer* sizer = new wxBoxSizer( wxVERTICAL );
</mark>2376<br><mark>    topSizer->Add( sizer, 0, wxALIGN_CENTER_HORIZONTAL | wxALL, 5 );
</mark>2377<br><mark>
</mark>2378<br><mark>    choices.push_back( new wxRadioButton( this, 0,  _("No, I don't want to hide it."),
</mark>2379<br><mark>            wxDefaultPosition, wxDefaultSize, wxRB_GROUP ) );
</mark>2380<br><mark>
</mark>2381<br><mark>    choices.push_back( new wxRadioButton( this, 1, _("No, and permanently remove the option to hide it."),
</mark>2382<br><mark>            wxDefaultPosition) );
</mark>2383<br><mark>
</mark>2384<br><mark>    choices.push_back( new wxRadioButton( this, 2, _("Yes, hide it."),
</mark>2385<br><mark>            wxDefaultPosition) );
</mark>2386<br><mark>
</mark>2387<br><mark>    wxStdDialogButtonSizer* buttonSizer = CreateStdDialogButtonSizer( wxOK | wxCANCEL );
</mark>2388<br><mark>
</mark>2389<br><mark>
</mark>2390<br><mark>    wxStaticText* textCtrl = new wxStaticText( this, wxID_ANY, _("The Man Over Board button could be an important safety feature.\nAre you sure you want to hide it?") );
</mark>2391<br><mark>
</mark>2392<br><mark>    sizer->Add( textCtrl, 0, wxEXPAND | wxALL, 5 );
</mark>2393<br><mark>    sizer->Add( choices[0], 0, wxEXPAND | wxALL, 5 );
</mark>2394<br><mark>    sizer->Add( choices[1], 0, wxEXPAND | wxALL, 5 );
</mark>2395<br><mark>    sizer->Add( choices[2], 0, wxEXPAND | wxALL, 5 );
</mark>2396<br><mark>    sizer->Add( buttonSizer, 0, wxEXPAND | wxTOP, 5 );
</mark>2397<br><mark>
</mark>2398<br><mark>    topSizer->SetSizeHints(this);
</mark>2399<br><mark>    SetSizer( topSizer );
</mark>2400<br><mark>}
</mark>2401<br><mark>
</mark>2402<br><mark>int ToolbarMOBDialog::GetSelection() {
</mark>2403<br><mark>    for( unsigned int i=0; i<choices.size(); i++ ) {
</mark>2404<br><mark>        if( choices[i]->GetValue() ) return choices[i]->GetId();
</mark>2405<br><mark>    }
</mark>2406<br><mark>    return 0;
</mark>2407<br><mark>}
</mark></p></body>
    </html><html>
    <head></head>
    <body><p><br>1<mark>/***************************************************************************
</mark><br>2<mark> *
</mark><br>3<mark> * Project:  OpenCPN
</mark><br>4<mark> * Purpose:  OpenCPN Toolbar
</mark><br>5<mark> * Author:   David Register
</mark><br>6<mark> *
</mark><br>7<mark> ***************************************************************************
</mark><br>8<mark> *   Copyright (C) 2010 by David S. Register                               *
</mark><br>9<mark> *                                                                         *
</mark><br>10<mark> *   This program is free software; you can redistribute it and/or modify  *
</mark><br>11<mark> *   it under the terms of the GNU General Public License as published by  *
</mark><br>12<mark> *   the Free Software Foundation; either version 2 of the License, or     *
</mark><br>13<mark> *   (at your option) any later version.                                   *
</mark><br>14<mark> *                                                                         *
</mark><br>15<mark> *   This program is distributed in the hope that it will be useful,       *
</mark><br>16<mark> *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
</mark><br>17<mark> *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
</mark><br>18<mark> *   GNU General Public License for more details.                          *
</mark><br>19<mark> *                                                                         *
</mark><br>20<mark> *   You should have received a copy of the GNU General Public License     *
</mark><br>21<mark> *   along with this program; if not, write to the                         *
</mark><br>22<mark> *   Free Software Foundation, Inc.,                                       *
</mark><br>23<mark> *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,  USA.         *
</mark><br>24<mark> **************************************************************************/
</mark><br>25<mark>
</mark><br>26<mark>#include "wx/wxprec.h"
</mark><br>27<mark>
</mark><br>28<mark>#ifndef  WX_PRECOMP
</mark><br>29<mark>#include "wx/wx.h"
</mark><br>30<mark>#endif
</mark><br>31<mark>
</mark><br>32<mark>#include <vector>
</mark><br>33<mark>
</mark><br>34<mark>#include "ocpn_types.h"
</mark><br>35<mark>#include "navutil.h"
</mark><br>36<mark>#include "styles.h"
</mark><br>37<mark>#include "toolbar.h"
</mark><br>38<mark>#include "chart1.h"
</mark><br>39<mark>#include "pluginmanager.h"
</mark><br>40<mark>#include "FontMgr.h"
</mark><br>41<mark>
</mark><br>42<mark>extern ocpnFloatingToolbarDialog* g_FloatingToolbarDialog;
</mark><br>43<mark>extern bool                       g_bTransparentToolbar;
</mark><br>44<mark>extern bool                       g_bTransparentToolbarInOpenGLOK;
</mark><br>45<mark>extern ChartCanvas*               cc1;
</mark><br>46<mark>extern bool                       g_bopengl;
</mark><br>47<mark>extern ocpnToolBarSimple*         g_toolbar;
</mark><br>48<mark>extern ocpnStyle::StyleManager*   g_StyleManager;
</mark><br>49<mark>extern MyFrame*                   gFrame;
</mark><br>50<mark>extern PlugInManager*             g_pi_manager;
</mark><br>51<mark>extern wxMenu*                    g_FloatingToolbarConfigMenu;
</mark><br>52<mark>extern wxString                   g_toolbarConfig;
</mark><br>53<mark>extern bool                       g_bPermanentMOBIcon;
</mark><br>54<mark>extern bool                       g_btouch;
</mark><br>55<mark>extern bool                       g_bsmoothpanzoom;
</mark><br>56<mark>
</mark><br>57<mark>//----------------------------------------------------------------------------
</mark><br>58<mark>// GrabberWindow Implementation
</mark><br>59<mark>//----------------------------------------------------------------------------
</mark><br>60<mark>BEGIN_EVENT_TABLE(GrabberWin, wxPanel) EVT_MOUSE_EVENTS ( GrabberWin::MouseEvent )
</mark><br>61<mark>EVT_PAINT ( GrabberWin::OnPaint )
</mark><br>62<mark>END_EVENT_TABLE()
</mark><br>63<mark>
</mark><br>64<mark>GrabberWin::GrabberWin( wxWindow *parent, ocpnFloatingToolbarDialog *toolbar, float scale_factor, wxString icon_name, wxPoint position ):
</mark><br>65<mark>    wxPanel( parent, wxID_ANY, position, wxDefaultSize, wxNO_BORDER )
</mark><br>66<mark>{
</mark><br>67<mark>    m_icon_name = icon_name;
</mark><br>68<mark>    m_style = g_StyleManager->GetCurrentStyle();
</mark><br>69<mark>    wxBitmap bitmap = m_style->GetIcon( icon_name );
</mark><br>70<mark>    if(scale_factor > 1.0f){
</mark><br>71<mark>        int new_width = bitmap.GetWidth() * scale_factor;
</mark><br>72<mark>        int new_height = bitmap.GetHeight() * scale_factor;
</mark><br>73<mark>        wxImage scaled_image = bitmap.ConvertToImage();
</mark><br>74<mark>        m_bitmap = wxBitmap(scaled_image.Scale(new_width, new_height, wxIMAGE_QUALITY_HIGH));
</mark><br>75<mark>    }
</mark><br>76<mark>    else
</mark><br>77<mark>        m_bitmap = bitmap;
</mark><br>78<mark>
</mark><br>79<mark>    SetSize( wxSize( m_bitmap.GetWidth(), m_bitmap.GetHeight() ) );
</mark><br>80<mark>    SetMinSize( wxSize( m_bitmap.GetWidth(), m_bitmap.GetHeight() ) );
</mark><br>81<mark>
</mark><br>82<mark>    m_bLeftDown = false;
</mark><br>83<mark>    m_bRightDown = false;
</mark><br>84<mark>    m_scale_factor = scale_factor;
</mark><br>85<mark>    m_ptoolbar = toolbar;
</mark><br>86<mark>    m_dragging = false;
</mark><br>87<mark>    Hide();
</mark><br>88<mark>    
</mark><br>89<mark>}
</mark><br>90<mark>
</mark><br>91<mark>
</mark><br>92<mark>void GrabberWin::OnPaint( wxPaintEvent& event )
</mark><br>93<mark>{
</mark><br>94<mark>    wxPaintDC dc( this );
</mark><br>95<mark>    
</mark><br>96<mark>    wxColour back_color = GetGlobalColor( _T("GREY2") );
</mark><br>97<mark>    SetBackgroundColour( back_color );
</mark><br>98<mark>    ClearBackground();
</mark><br>99<mark>    
</mark><br>100<mark>    dc.DrawBitmap( m_bitmap, 0, 0, true );
</mark><br>101<mark>}
</mark><br>102<mark>
</mark><br>103<mark>void GrabberWin::SetColorScheme( ColorScheme cs )
</mark><br>104<mark>{
</mark><br>105<mark>    wxColour back_color = GetGlobalColor( _T("GREY2") );
</mark><br>106<mark>
</mark><br>107<mark>    SetBackgroundColour( back_color );
</mark><br>108<mark>    ClearBackground();
</mark><br>109<mark>
</mark><br>110<mark>    wxBitmap bitmap = m_style->GetIcon( m_icon_name) ;
</mark><br>111<mark>    if(m_scale_factor > 1.0f){
</mark><br>112<mark>        int new_width = bitmap.GetWidth() * m_scale_factor;
</mark><br>113<mark>        int new_height = bitmap.GetHeight() * m_scale_factor;
</mark><br>114<mark>        wxImage scaled_image = bitmap.ConvertToImage();
</mark><br>115<mark>        m_bitmap = wxBitmap(scaled_image.Scale(new_width, new_height, wxIMAGE_QUALITY_HIGH));
</mark><br>116<mark>    }
</mark><br>117<mark>    else
</mark><br>118<mark>        m_bitmap = bitmap;
</mark><br>119<mark>}
</mark><br>120<mark>
</mark><br>121<mark>void GrabberWin::MouseEvent( wxMouseEvent& event )
</mark><br>122<mark>{
</mark><br>123<mark>    static wxPoint s_gspt;
</mark><br>124<mark>    int x, y;
</mark><br>125<mark>
</mark><br>126<mark>    event.GetPosition( &x, &y );
</mark><br>127<mark>
</mark><br>128<mark>    wxPoint spt = ClientToScreen( wxPoint( x, y ) );
</mark><br>129<mark>    if( event.LeftDown() ) {
</mark><br>130<mark>        s_gspt = spt;
</mark><br>131<mark>    }
</mark><br>132<mark>    
</mark><br>133<mark>    
</mark><br>134<mark>#ifndef __WXQT__
</mark><br>135<mark>
</mark><br>136<mark>    if( event.LeftDown() ) {
</mark><br>137<mark>        CaptureMouse();
</mark><br>138<mark>    }
</mark><br>139<mark>
</mark><br>140<mark>    if( event.LeftUp() ) {
</mark><br>141<mark>        if( HasCapture() ) ReleaseMouse();
</mark><br>142<mark>    }
</mark><br>143<mark>
</mark><br>144<mark>#endif
</mark><br>145<mark>
</mark><br>146<mark>
</mark><br>147<mark>    if( event.RightDown() ){
</mark><br>148<mark>        if(m_ptoolbar){
</mark><br>149<mark>            m_dragging = true;
</mark><br>150<mark>            
</mark><br>151<mark>            if( !m_ptoolbar->m_bnavgrabber ){
</mark><br>152<mark>                m_ptoolbar->m_bnavgrabber = true;
</mark><br>153<mark>                m_ptoolbar->SetGrabber(_T("4WayMove") );
</mark><br>154<mark>            }
</mark><br>155<mark>            else{
</mark><br>156<mark>                m_ptoolbar->m_bnavgrabber = false;
</mark><br>157<mark>                m_ptoolbar->SetGrabber(_T("grabber_hi") );
</mark><br>158<mark>            }
</mark><br>159<mark>                
</mark><br>160<mark>        }
</mark><br>161<mark>    }
</mark><br>162<mark>    
</mark><br>163<mark>
</mark><br>164<mark>
</mark><br>165<mark>    if( event.Dragging() ) {
</mark><br>166<mark>        if(m_ptoolbar && m_ptoolbar->IsShown() /*&& m_ptoolbar->m_bnavgrabber*/){
</mark><br>167<mark>            wxPoint par_pos_old = m_ptoolbar->GetPosition();
</mark><br>168<mark>
</mark><br>169<mark>            wxPoint par_pos = par_pos_old;
</mark><br>170<mark>            par_pos.x += spt.x - s_gspt.x;
</mark><br>171<mark>            par_pos.y += spt.y - s_gspt.y;
</mark><br>172<mark>
</mark><br>173<mark>            m_ptoolbar->MoveDialogInScreenCoords( par_pos, par_pos_old );
</mark><br>174<mark>
</mark><br>175<mark>            s_gspt = spt;
</mark><br>176<mark>            m_dragging = true;
</mark><br>177<mark>        }
</mark><br>178<mark>
</mark><br>179<mark>    }
</mark><br>180<mark>
</mark><br>181<mark>    if( event.LeftUp() ) {
</mark><br>182<mark>        if(m_ptoolbar){
</mark><br>183<mark>            if(m_ptoolbar->m_bnavgrabber){
</mark><br>184<mark>                if(!m_dragging)
</mark><br>185<mark>                    m_ptoolbar->ToggleOrientation();
</mark><br>186<mark>            }
</mark><br>187<mark>            else if(!m_dragging){
</mark><br>188<mark>                if(m_ptoolbar->m_bsubmerged){
</mark><br>189<mark>                    m_ptoolbar->SurfaceFromGrabber();
</mark><br>190<mark>                }
</mark><br>191<mark>                else{
</mark><br>192<mark>                    m_ptoolbar->SubmergeToGrabber();
</mark><br>193<mark>                 }
</mark><br>194<mark>            }
</mark><br>195<mark>        }
</mark><br>196<mark>        m_dragging = false;
</mark><br>197<mark>    }
</mark><br>198<mark>    
</mark><br>199<mark>    
</mark><br>200<mark>#ifndef __OCPN__ANDROID__
</mark><br>201<mark>    gFrame->Raise();
</mark><br>202<mark>#endif
</mark><br>203<mark>    
</mark><br>204<mark>}
</mark><br>205<mark>
</mark><br>206<mark>class ocpnToolBarTool: public wxToolBarToolBase {
</mark><br>207<mark>public:
</mark><br>208<mark>    ocpnToolBarTool( ocpnToolBarSimple *tbar, int id, const wxString& label,
</mark><br>209<mark>            const wxBitmap& bmpNormal, const wxBitmap& bmpRollover, wxItemKind kind,
</mark><br>210<mark>            wxObject *clientData, const wxString& shortHelp, const wxString& longHelp ) :
</mark><br>211<mark>            wxToolBarToolBase( (wxToolBarBase*) tbar, id, label, bmpNormal, bmpRollover, kind,
</mark><br>212<mark>                    clientData, shortHelp, longHelp )
</mark><br>213<mark>    {
</mark><br>214<mark>        m_enabled = true;
</mark><br>215<mark>        m_toggled = false;
</mark><br>216<mark>        rollover = false;
</mark><br>217<mark>        bitmapOK = false;
</mark><br>218<mark>        m_btooltip_hiviz = false;
</mark><br>219<mark>
</mark><br>220<mark>        toolname = g_pi_manager->GetToolOwnerCommonName( id );
</mark><br>221<mark>        if( toolname == _T("") ) {
</mark><br>222<mark>            isPluginTool = false;
</mark><br>223<mark>            toolname = label;
</mark><br>224<mark>            iconName = label;
</mark><br>225<mark>        } else {
</mark><br>226<mark>            isPluginTool = true;
</mark><br>227<mark>            pluginNormalIcon = &bmpNormal;
</mark><br>228<mark>            pluginRolloverIcon = &bmpRollover;
</mark><br>229<mark>        }
</mark><br>230<mark>    }
</mark><br>231<mark>
</mark><br>232<mark>    void SetSize( const wxSize& size )
</mark><br>233<mark>    {
</mark><br>234<mark>        m_width = size.x;
</mark><br>235<mark>        m_height = size.y;
</mark><br>236<mark>    }
</mark><br>237<mark>
</mark><br>238<mark>    wxCoord GetWidth() const
</mark><br>239<mark>    {
</mark><br>240<mark>        return m_width;
</mark><br>241<mark>    }
</mark><br>242<mark>
</mark><br>243<mark>    wxCoord GetHeight() const
</mark><br>244<mark>    {
</mark><br>245<mark>        return m_height;
</mark><br>246<mark>    }
</mark><br>247<mark>
</mark><br>248<mark>    wxString GetToolname()
</mark><br>249<mark>    {
</mark><br>250<mark>        return toolname;
</mark><br>251<mark>    }
</mark><br>252<mark>
</mark><br>253<mark>    void SetIconName(wxString name)
</mark><br>254<mark>    {
</mark><br>255<mark>        iconName = name;
</mark><br>256<mark>    }
</mark><br>257<mark>    wxString GetIconName()
</mark><br>258<mark>    {
</mark><br>259<mark>        return iconName;
</mark><br>260<mark>    }
</mark><br>261<mark>
</mark><br>262<mark>    void SetTooltipHiviz( bool enable){ m_btooltip_hiviz = enable; }
</mark><br>263<mark>
</mark><br>264<mark>    wxCoord m_x;
</mark><br>265<mark>    wxCoord m_y;
</mark><br>266<mark>    wxCoord m_width;
</mark><br>267<mark>    wxCoord m_height;
</mark><br>268<mark>    wxRect trect;
</mark><br>269<mark>    wxString toolname;
</mark><br>270<mark>    wxString iconName;
</mark><br>271<mark>    const wxBitmap* pluginNormalIcon;
</mark><br>272<mark>    const wxBitmap* pluginRolloverIcon;
</mark><br>273<mark>    bool firstInLine;
</mark><br>274<mark>    bool lastInLine;
</mark><br>275<mark>    bool rollover;
</mark><br>276<mark>    bool bitmapOK;
</mark><br>277<mark>    bool isPluginTool;
</mark><br>278<mark>    bool b_hilite;
</mark><br>279<mark>    bool m_btooltip_hiviz;
</mark><br>280<mark>    wxRect last_rect;
</mark><br>281<mark>};
</mark><br>282<mark>
</mark><br>283<mark>//---------------------------------------------------------------------------------------
</mark><br>284<mark>//          ocpnFloatingToolbarDialog Implementation
</mark><br>285<mark>//---------------------------------------------------------------------------------------
</mark><br>286<mark>BEGIN_EVENT_TABLE(ocpnFloatingToolbarDialog, wxDialog)
</mark><br>287<mark>    EVT_MOUSE_EVENTS ( ocpnFloatingToolbarDialog::MouseEvent )
</mark><br>288<mark>    EVT_MENU(wxID_ANY, ocpnFloatingToolbarDialog::OnToolLeftClick)
</mark><br>289<mark>    EVT_TIMER ( FADE_TIMER, ocpnFloatingToolbarDialog::FadeTimerEvent )
</mark><br>290<mark>    EVT_TIMER ( DESTROY_TIMER, ocpnFloatingToolbarDialog::DestroyTimerEvent )
</mark><br>291<mark>    EVT_WINDOW_CREATE(ocpnFloatingToolbarDialog::OnWindowCreate)
</mark><br>292<mark>END_EVENT_TABLE()
</mark><br>293<mark>
</mark><br>294<mark>ocpnFloatingToolbarDialog::ocpnFloatingToolbarDialog( wxWindow *parent, wxPoint position,
</mark><br>295<mark>                                                      long orient, float size_factor )
</mark><br>296<mark>{
</mark><br>297<mark>    m_pparent = parent;
</mark><br>298<mark>    long wstyle = wxNO_BORDER | wxFRAME_NO_TASKBAR;
</mark><br>299<mark>#ifndef __WXMAC__
</mark><br>300<mark>    wstyle |= wxFRAME_SHAPED;
</mark><br>301<mark>#endif
</mark><br>302<mark>
</mark><br>303<mark>    m_ptoolbar = NULL;
</mark><br>304<mark>
</mark><br>305<mark>#ifdef __WXOSX__
</mark><br>306<mark>    wstyle |= wxSTAY_ON_TOP;
</mark><br>307<mark>#endif
</mark><br>308<mark>    wxDialog::Create( parent, -1, _T("ocpnToolbarDialog"), wxPoint( -1, -1 ), wxSize( -1, -1 ),
</mark><br>309<mark>            wstyle );
</mark><br>310<mark>
</mark><br>311<mark>    m_opacity = 255;
</mark><br>312<mark>
</mark><br>313<mark>    m_pGrabberwin = new GrabberWin( this, this, size_factor, _T("grabber_hi") );
</mark><br>314<mark>    m_pGrabberwin->Show();
</mark><br>315<mark>    
</mark><br>316<mark>    m_pRecoverwin = NULL;
</mark><br>317<mark>    m_position = position;
</mark><br>318<mark>    m_orient = orient;
</mark><br>319<mark>    m_sizefactor = size_factor;
</mark><br>320<mark>    
</mark><br>321<mark>    m_bAutoHideToolbar = false;
</mark><br>322<mark>    m_nAutoHideToolbar = 5;
</mark><br>323<mark>    
</mark><br>324<mark>
</mark><br>325<mark>    m_style = g_StyleManager->GetCurrentStyle();
</mark><br>326<mark>
</mark><br>327<mark>// A top-level sizer
</mark><br>328<mark>    m_topSizer = new wxBoxSizer( wxHORIZONTAL );
</mark><br>329<mark>    SetSizer( m_topSizer );
</mark><br>330<mark>
</mark><br>331<mark>    //    Set initial "Dock" parameters
</mark><br>332<mark>    m_dock_x = 0;
</mark><br>333<mark>    m_dock_y = 0;
</mark><br>334<mark>    m_block = false;
</mark><br>335<mark>
</mark><br>336<mark>    m_marginsInvisible = m_style->marginsInvisible;
</mark><br>337<mark>
</mark><br>338<mark>//    if(m_sizefactor > 1.0 )
</mark><br>339<mark> //       m_marginsInvisible = true;
</mark><br>340<mark>
</mark><br>341<mark>    m_bnavgrabber = false;    
</mark><br>342<mark>    
</mark><br>343<mark>    Hide();
</mark><br>344<mark>
</mark><br>345<mark>    m_bsubmerged = false;
</mark><br>346<mark>    
</mark><br>347<mark>    m_fade_timer.SetOwner( this, FADE_TIMER );
</mark><br>348<mark>    if( g_bTransparentToolbar )
</mark><br>349<mark>        m_fade_timer.Start( 5000 );
</mark><br>350<mark>    
</mark><br>351<mark>    if( m_bAutoHideToolbar && (m_nAutoHideToolbar > 0))
</mark><br>352<mark>        m_fade_timer.Start( m_nAutoHideToolbar * 1000 );
</mark><br>353<mark>    
</mark><br>354<mark>    m_destroyTimer.SetOwner( this, DESTROY_TIMER );
</mark><br>355<mark>}
</mark><br>356<mark>
</mark><br>357<mark>ocpnFloatingToolbarDialog::~ocpnFloatingToolbarDialog()
</mark><br>358<mark>{
</mark><br>359<mark>    DestroyToolBar();
</mark><br>360<mark>}
</mark><br>361<mark>
</mark><br>362<mark>void ocpnFloatingToolbarDialog::OnWindowCreate( wxWindowCreateEvent& event )
</mark><br>363<mark>{
</mark><br>364<mark>    Realize();
</mark><br>365<mark>}
</mark><br>366<mark>
</mark><br>367<mark>void ocpnFloatingToolbarDialog::SetGrabber( wxString icon_name )
</mark><br>368<mark>{
</mark><br>369<mark>//    m_pGrabberwin->Destroy();
</mark><br>370<mark>    m_pGrabberwin = new GrabberWin( this, this, m_sizefactor, icon_name );
</mark><br>371<mark>    m_pGrabberwin->Show();
</mark><br>372<mark>    
</mark><br>373<mark>    Realize();
</mark><br>374<mark>    
</mark><br>375<mark>#ifdef __WXOSX__    
</mark><br>376<mark>    m_pGrabberwin->Refresh();
</mark><br>377<mark>#endif    
</mark><br>378<mark>    
</mark><br>379<mark>}
</mark><br>380<mark>
</mark><br>381<mark>
</mark><br>382<mark>    
</mark><br>383<mark>void ocpnFloatingToolbarDialog::SetColorScheme( ColorScheme cs )
</mark><br>384<mark>{
</mark><br>385<mark>    m_cs = cs;
</mark><br>386<mark>
</mark><br>387<mark>    wxColour back_color = GetGlobalColor( _T("GREY2") );
</mark><br>388<mark>
</mark><br>389<mark>    //  Set background
</mark><br>390<mark>    SetBackgroundColour( back_color );
</mark><br>391<mark>    ClearBackground();
</mark><br>392<mark>
</mark><br>393<mark>    if( m_ptoolbar ) {
</mark><br>394<mark>        wxColour back_color = GetGlobalColor( _T("GREY2") );
</mark><br>395<mark>
</mark><br>396<mark>        //  Set background
</mark><br>397<mark>        m_ptoolbar->SetBackgroundColour( back_color );
</mark><br>398<mark>        m_ptoolbar->ClearBackground();
</mark><br>399<mark>
</mark><br>400<mark>        m_ptoolbar->SetToggledBackgroundColour( GetGlobalColor( _T("GREY1") ) );
</mark><br>401<mark>
</mark><br>402<mark>        m_ptoolbar->SetColorScheme( cs );
</mark><br>403<mark>        m_ptoolbar->Refresh( true );
</mark><br>404<mark>    }
</mark><br>405<mark>
</mark><br>406<mark>    if( m_pGrabberwin ) m_pGrabberwin->SetColorScheme( cs );
</mark><br>407<mark>
</mark><br>408<mark>}
</mark><br>409<mark>
</mark><br>410<mark>void ocpnFloatingToolbarDialog::SetGeometry(bool bAvoid, wxRect rectAvoid)
</mark><br>411<mark>{
</mark><br>412<mark>
</mark><br>413<mark>    if( m_ptoolbar ) {
</mark><br>414<mark>        wxSize style_tool_size = m_style->GetToolSize();
</mark><br>415<mark>
</mark><br>416<mark>        style_tool_size.x *= m_sizefactor;
</mark><br>417<mark>        style_tool_size.y *= m_sizefactor;
</mark><br>418<mark>
</mark><br>419<mark>        m_ptoolbar->SetToolBitmapSize( style_tool_size );
</mark><br>420<mark>
</mark><br>421<mark>        wxSize tool_size = m_ptoolbar->GetToolBitmapSize();
</mark><br>422<mark>        int grabber_width =  m_style->GetIcon( _T("grabber") ).GetWidth();
</mark><br>423<mark>        
</mark><br>424<mark>        int max_rows = 10;
</mark><br>425<mark>        int max_cols = 100;
</mark><br>426<mark>        if(cc1){
</mark><br>427<mark>
</mark><br>428<mark>            int avoid_start = cc1->GetClientSize().x - (tool_size.x + m_style->GetToolSeparation()) * 2;  // default
</mark><br>429<mark>            if(bAvoid && !rectAvoid.IsEmpty()){
</mark><br>430<mark>                avoid_start = cc1->GetClientSize().x - rectAvoid.width - 10;  // this is compass window, if shown
</mark><br>431<mark>            }
</mark><br>432<mark>            
</mark><br>433<mark>            
</mark><br>434<mark>            max_rows = (cc1->GetClientSize().y / ( tool_size.y + m_style->GetToolSeparation())) - 1;
</mark><br>435<mark>            
</mark><br>436<mark>            max_cols = (avoid_start - grabber_width) / ( tool_size.x + m_style->GetToolSeparation());
</mark><br>437<mark>            max_cols -= 1;
</mark><br>438<mark>            
</mark><br>439<mark>            if(m_orient == wxTB_VERTICAL)
</mark><br>440<mark>                max_rows = wxMax( max_rows, 2);             // at least two rows
</mark><br>441<mark>            else
</mark><br>442<mark>                max_cols = wxMax( max_cols, 2);             // at least two columns
</mark><br>443<mark>        }
</mark><br>444<mark>
</mark><br>445<mark>        if( m_orient == wxTB_VERTICAL )
</mark><br>446<mark>            m_ptoolbar->SetMaxRowsCols(max_rows, 100);
</mark><br>447<mark>        else
</mark><br>448<mark>            m_ptoolbar->SetMaxRowsCols( 100, max_cols);
</mark><br>449<mark>        m_ptoolbar->SetSizeFactor(m_sizefactor);
</mark><br>450<mark>        
</mark><br>451<mark>    }
</mark><br>452<mark> }
</mark><br>453<mark>
</mark><br>454<mark>void ocpnFloatingToolbarDialog::RePosition()
</mark><br>455<mark>{
</mark><br>456<mark>    if(m_block) return;
</mark><br>457<mark>
</mark><br>458<mark>    if( m_pparent && m_ptoolbar ) {
</mark><br>459<mark>        wxSize cs = m_pparent->GetClientSize();
</mark><br>460<mark>        if( -1 == m_dock_x ) m_position.x = 0;
</mark><br>461<mark>        else
</mark><br>462<mark>            if( 1 == m_dock_x ) m_position.x = cs.x - GetSize().x;
</mark><br>463<mark>
</mark><br>464<mark>        if( -1 == m_dock_y ) m_position.y = 0;
</mark><br>465<mark>        else
</mark><br>466<mark>            if( 1 == m_dock_y ) m_position.y = cs.y - GetSize().y;
</mark><br>467<mark>
</mark><br>468<mark>        m_position.x = wxMin(cs.x - GetSize().x, m_position.x);
</mark><br>469<mark>        m_position.y = wxMin(cs.y - GetSize().y, m_position.y);
</mark><br>470<mark>
</mark><br>471<mark>        m_position.x = wxMax(0, m_position.x);
</mark><br>472<mark>        m_position.y = wxMax(0, m_position.y);
</mark><br>473<mark>
</mark><br>474<mark>        wxPoint screen_pos = m_pparent->ClientToScreen( m_position );
</mark><br>475<mark>
</mark><br>476<mark>        Move( screen_pos );
</mark><br>477<mark>
</mark><br>478<mark>#ifdef __WXQT__
</mark><br>479<mark>        Raise();
</mark><br>480<mark>#endif
</mark><br>481<mark>
</mark><br>482<mark>    }
</mark><br>483<mark>}
</mark><br>484<mark>
</mark><br>485<mark>void ocpnFloatingToolbarDialog::Submerge()
</mark><br>486<mark>{
</mark><br>487<mark>    m_bsubmerged = true;
</mark><br>488<mark>    Hide();
</mark><br>489<mark>    if( m_ptoolbar ) m_ptoolbar->KillTooltip();
</mark><br>490<mark>}
</mark><br>491<mark>
</mark><br>492<mark>void ocpnFloatingToolbarDialog::SubmergeToGrabber()
</mark><br>493<mark>{
</mark><br>494<mark>//Submerge();
</mark><br>495<mark>    m_bsubmerged = true;
</mark><br>496<mark>    Hide();
</mark><br>497<mark>    if( m_ptoolbar ) m_ptoolbar->KillTooltip();
</mark><br>498<mark>
</mark><br>499<mark>    m_pRecoverwin = new GrabberWin( m_pparent, this, m_sizefactor, _T("grabber_ext" ), wxPoint(10,10) );
</mark><br>500<mark>   
</mark><br>501<mark>    m_pRecoverwin->Show();
</mark><br>502<mark>    m_pRecoverwin->Raise();
</mark><br>503<mark>#ifdef __WXQT__
</mark><br>504<mark>    wxSize s = gFrame->GetSize();
</mark><br>505<mark>    m_recoversize = s;
</mark><br>506<mark>    s.y--;
</mark><br>507<mark>    gFrame->TriggerResize(s);
</mark><br>508<mark>    Raise();
</mark><br>509<mark>#endif    
</mark><br>510<mark>
</mark><br>511<mark>    gFrame->Refresh();          // Needed for MSW OpenGL
</mark><br>512<mark>}
</mark><br>513<mark>
</mark><br>514<mark>void ocpnFloatingToolbarDialog::Surface()
</mark><br>515<mark>{
</mark><br>516<mark>    
</mark><br>517<mark>    if(m_pRecoverwin){
</mark><br>518<mark>        m_pRecoverwin->Show();
</mark><br>519<mark>        m_pRecoverwin->Raise();
</mark><br>520<mark>    }
</mark><br>521<mark>    else {
</mark><br>522<mark>        m_bsubmerged = false;
</mark><br>523<mark>        #ifndef __WXOSX__
</mark><br>524<mark>        Hide();
</mark><br>525<mark>        Move( 0, 0 );
</mark><br>526<mark>        #endif
</mark><br>527<mark>
</mark><br>528<mark>        RePosition();
</mark><br>529<mark>        Show();
</mark><br>530<mark>        if( m_ptoolbar )
</mark><br>531<mark>            m_ptoolbar->EnableTooltips();
</mark><br>532<mark>
</mark><br>533<mark>        #ifdef __WXQT__
</mark><br>534<mark>        Raise();
</mark><br>535<mark>        #endif
</mark><br>536<mark>    }
</mark><br>537<mark>    
</mark><br>538<mark>    if( m_bAutoHideToolbar && (m_nAutoHideToolbar > 0) ){
</mark><br>539<mark>        m_fade_timer.Start( m_nAutoHideToolbar * 1000 );
</mark><br>540<mark>    }
</mark><br>541<mark>}
</mark><br>542<mark>
</mark><br>543<mark>bool ocpnFloatingToolbarDialog::CheckSurfaceRequest( wxMouseEvent &event )
</mark><br>544<mark>{
</mark><br>545<mark>    if( m_bsubmerged ){
</mark><br>546<mark>        if( event.LeftUp() ){
</mark><br>547<mark>            int x,y;
</mark><br>548<mark>            event.GetPosition( &x, &y );
</mark><br>549<mark>            if( m_pRecoverwin ){
</mark><br>550<mark>                wxRect winRect = m_pRecoverwin->GetRect();
</mark><br>551<mark>                if( winRect.Contains( x, y ) ){
</mark><br>552<mark>                    SurfaceFromGrabber();
</mark><br>553<mark>                    return true;
</mark><br>554<mark>                }
</mark><br>555<mark>            }
</mark><br>556<mark>        }
</mark><br>557<mark>    }
</mark><br>558<mark>    
</mark><br>559<mark>    return false;
</mark><br>560<mark>}
</mark><br>561<mark>        
</mark><br>562<mark>void ocpnFloatingToolbarDialog::SurfaceFromGrabber()
</mark><br>563<mark>{
</mark><br>564<mark>    m_bsubmerged = false;
</mark><br>565<mark>    
</mark><br>566<mark>#ifndef __WXOSX__
</mark><br>567<mark>    Hide();
</mark><br>568<mark>    Move( 0, 0 );
</mark><br>569<mark>#endif
</mark><br>570<mark>
</mark><br>571<mark>    if( m_ptoolbar )
</mark><br>572<mark>        m_ptoolbar->InvalidateBitmaps();
</mark><br>573<mark>    
</mark><br>574<mark>    RePosition();
</mark><br>575<mark>    Show();
</mark><br>576<mark>    if( m_ptoolbar )
</mark><br>577<mark>        m_ptoolbar->EnableTooltips();
</mark><br>578<mark>    
</mark><br>579<mark>    if( m_bAutoHideToolbar && (m_nAutoHideToolbar > 0) ){
</mark><br>580<mark>        m_fade_timer.Start( m_nAutoHideToolbar * 1000 );
</mark><br>581<mark>    }
</mark><br>582<mark>    
</mark><br>583<mark>#ifdef __WXQT__
</mark><br>584<mark>    wxSize s = gFrame->GetSize();               // check for rotation
</mark><br>585<mark>    if(m_recoversize.x == s.x)
</mark><br>586<mark>        gFrame->TriggerResize(m_recoversize);
</mark><br>587<mark>    Raise();
</mark><br>588<mark>#endif
</mark><br>589<mark>    
</mark><br>590<mark>    m_destroyGrabber = m_pRecoverwin;
</mark><br>591<mark>    m_destroyTimer.Start( 5, wxTIMER_ONE_SHOT );           //  Destor the unneeded recovery grabber
</mark><br>592<mark>    
</mark><br>593<mark>}
</mark><br>594<mark>
</mark><br>595<mark>void ocpnFloatingToolbarDialog::DestroyTimerEvent( wxTimerEvent& event )
</mark><br>596<mark>{
</mark><br>597<mark>    delete m_destroyGrabber;
</mark><br>598<mark>    m_destroyGrabber = NULL;
</mark><br>599<mark>    m_pRecoverwin = NULL;
</mark><br>600<mark>}
</mark><br>601<mark>
</mark><br>602<mark>void ocpnFloatingToolbarDialog::HideTooltip()
</mark><br>603<mark>{
</mark><br>604<mark>    if( m_ptoolbar ) m_ptoolbar->HideTooltip();
</mark><br>605<mark>}
</mark><br>606<mark>
</mark><br>607<mark>void ocpnFloatingToolbarDialog::ShowTooltips()
</mark><br>608<mark>{
</mark><br>609<mark>    if( m_ptoolbar ) m_ptoolbar->EnableTooltips();
</mark><br>610<mark>}
</mark><br>611<mark>
</mark><br>612<mark>void ocpnFloatingToolbarDialog::ToggleOrientation()
</mark><br>613<mark>{
</mark><br>614<mark>    if( m_orient == wxTB_HORIZONTAL )
</mark><br>615<mark>        m_orient = wxTB_VERTICAL;
</mark><br>616<mark>    else
</mark><br>617<mark>        m_orient = wxTB_HORIZONTAL;
</mark><br>618<mark>
</mark><br>619<mark>    m_style->SetOrientation( m_orient );
</mark><br>620<mark>
</mark><br>621<mark>    wxPoint old_screen_pos = m_pparent->ClientToScreen( m_position );
</mark><br>622<mark>    wxPoint grabber_point_abs = ClientToScreen( m_pGrabberwin->GetPosition() );
</mark><br>623<mark>
</mark><br>624<mark>    gFrame->RequestNewToolbar();
</mark><br>625<mark>    wxPoint pos_abs = grabber_point_abs;
</mark><br>626<mark>    pos_abs.x -= m_pGrabberwin->GetPosition().x;
</mark><br>627<mark>    MoveDialogInScreenCoords( pos_abs, old_screen_pos );
</mark><br>628<mark>
</mark><br>629<mark>
</mark><br>630<mark>    Show();   // this seems to be necessary on GTK to kick the sizer into gear...(FS#553)
</mark><br>631<mark>    Refresh(true);
</mark><br>632<mark>    Raise();
</mark><br>633<mark>}
</mark><br>634<mark>
</mark><br>635<mark>void ocpnFloatingToolbarDialog::MouseEvent( wxMouseEvent& event )
</mark><br>636<mark>{
</mark><br>637<mark>    if( g_bTransparentToolbar ) {
</mark><br>638<mark>        if( event.Entering() && ( m_opacity < 255 ) ) {
</mark><br>639<mark>            SetTransparent( 255 );
</mark><br>640<mark>            m_opacity = 255;
</mark><br>641<mark>        }
</mark><br>642<mark>
</mark><br>643<mark>        m_fade_timer.Start( 5000 );           // retrigger the continuous timer
</mark><br>644<mark>    }
</mark><br>645<mark>    
</mark><br>646<mark>    if(m_bAutoHideToolbar && (m_nAutoHideToolbar > 0) ){
</mark><br>647<mark>        m_fade_timer.Start( m_nAutoHideToolbar * 1000 );
</mark><br>648<mark>    }
</mark><br>649<mark>}
</mark><br>650<mark>
</mark><br>651<mark>void ocpnFloatingToolbarDialog::FadeTimerEvent( wxTimerEvent& event )
</mark><br>652<mark>{
</mark><br>653<mark>    if(m_bnavgrabber){
</mark><br>654<mark>        m_fade_timer.Start( 5000 );           // do nothing if nav grabber is shown
</mark><br>655<mark>    }
</mark><br>656<mark>    else{
</mark><br>657<mark>        if( g_bTransparentToolbar && (!g_bopengl || g_bTransparentToolbarInOpenGLOK) ){
</mark><br>658<mark>            DoFade( 128 );
</mark><br>659<mark>            m_fade_timer.Start( 5000 );           // retrigger the continuous timer
</mark><br>660<mark>        }
</mark><br>661<mark>        
</mark><br>662<mark>        if(m_bAutoHideToolbar && (m_nAutoHideToolbar > 0) && !m_bsubmerged){
</mark><br>663<mark>            SubmergeToGrabber();
</mark><br>664<mark>//            m_fade_timer.Stop();
</mark><br>665<mark>        }
</mark><br>666<mark>    }
</mark><br>667<mark>}
</mark><br>668<mark>
</mark><br>669<mark>void ocpnFloatingToolbarDialog::SetAutoHideTimer(int time)
</mark><br>670<mark>{
</mark><br>671<mark>    m_nAutoHideToolbar = time;
</mark><br>672<mark>    if(m_bAutoHideToolbar){
</mark><br>673<mark>        m_fade_timer.Stop();
</mark><br>674<mark>        m_fade_timer.Start( m_nAutoHideToolbar * 1000 );
</mark><br>675<mark>    }
</mark><br>676<mark>}
</mark><br>677<mark>        
</mark><br>678<mark>void ocpnFloatingToolbarDialog::DoFade( int value )
</mark><br>679<mark>{
</mark><br>680<mark>    if( value != m_opacity ) SetTransparent( value );
</mark><br>681<mark>    m_opacity = value;
</mark><br>682<mark>}
</mark><br>683<mark>
</mark><br>684<mark>void ocpnFloatingToolbarDialog::RefreshFadeTimer()
</mark><br>685<mark>{
</mark><br>686<mark>    SetTransparent( 255 );
</mark><br>687<mark>    m_opacity = 255;
</mark><br>688<mark>    m_fade_timer.Start( 500 );           // retrigger the continuous timer
</mark><br>689<mark>    
</mark><br>690<mark>    if(m_bAutoHideToolbar && (m_nAutoHideToolbar > 0) ){
</mark><br>691<mark>        m_fade_timer.Start( m_nAutoHideToolbar * 1000 );
</mark><br>692<mark>    }
</mark><br>693<mark>    
</mark><br>694<mark>}
</mark><br>695<mark>
</mark><br>696<mark>void ocpnFloatingToolbarDialog::MoveDialogInScreenCoords( wxPoint posn, wxPoint posn_old )
</mark><br>697<mark>{
</mark><br>698<mark>    wxPoint pos_in_parent = m_pparent->ScreenToClient( posn );
</mark><br>699<mark>    wxPoint pos_in_parent_old = m_pparent->ScreenToClient( posn_old );
</mark><br>700<mark>
</mark><br>701<mark>    //    "Docking" support
</mark><br>702<mark>#define DOCK_MARGIN 40
</mark><br>703<mark>
</mark><br>704<mark>    // X
</mark><br>705<mark>    m_dock_x = 0;
</mark><br>706<mark>    if( pos_in_parent.x < pos_in_parent_old.x )            // moving left
</mark><br>707<mark>            {
</mark><br>708<mark>        if( pos_in_parent.x < DOCK_MARGIN ) {
</mark><br>709<mark>            pos_in_parent.x = 0;
</mark><br>710<mark>            m_dock_x = -1;
</mark><br>711<mark>        }
</mark><br>712<mark>    } else
</mark><br>713<mark>        if( pos_in_parent.x > pos_in_parent_old.x )            // moving right
</mark><br>714<mark>                {
</mark><br>715<mark>            int max_right = m_pparent->GetClientSize().x - GetSize().x;
</mark><br>716<mark>            if( pos_in_parent.x > ( max_right - DOCK_MARGIN ) ) {
</mark><br>717<mark>                pos_in_parent.x = max_right;
</mark><br>718<mark>                m_dock_x = 1;
</mark><br>719<mark>            }
</mark><br>720<mark>        }
</mark><br>721<mark>
</mark><br>722<mark>    // Y
</mark><br>723<mark>    m_dock_y = 0;
</mark><br>724<mark>    if( pos_in_parent.y < pos_in_parent_old.y )            // moving up
</mark><br>725<mark>            {
</mark><br>726<mark>        if( pos_in_parent.y < DOCK_MARGIN ) {
</mark><br>727<mark>            pos_in_parent.y = 0;
</mark><br>728<mark>            m_dock_y = -1;
</mark><br>729<mark>        }
</mark><br>730<mark>    } else
</mark><br>731<mark>        if( pos_in_parent.y > pos_in_parent_old.y )            // moving down
</mark><br>732<mark>                {
</mark><br>733<mark>            int max_down = m_pparent->GetClientSize().y - GetSize().y;
</mark><br>734<mark>            if( pos_in_parent.y > ( max_down - DOCK_MARGIN ) ) {
</mark><br>735<mark>                pos_in_parent.y = max_down;
</mark><br>736<mark>                m_dock_y = 1;
</mark><br>737<mark>            }
</mark><br>738<mark>        }
</mark><br>739<mark>
</mark><br>740<mark>    m_position = pos_in_parent;
</mark><br>741<mark>
</mark><br>742<mark>    wxPoint final_pos = m_pparent->ClientToScreen( pos_in_parent );
</mark><br>743<mark>
</mark><br>744<mark>    Move( final_pos );
</mark><br>745<mark>}
</mark><br>746<mark>
</mark><br>747<mark>void ocpnFloatingToolbarDialog::Realize()
</mark><br>748<mark>{
</mark><br>749<mark>    if( m_ptoolbar ) {
</mark><br>750<mark>        m_ptoolbar->Realize();
</mark><br>751<mark>
</mark><br>752<mark>        m_topSizer->Clear();
</mark><br>753<mark>        m_topSizer->Add( m_ptoolbar );
</mark><br>754<mark>        m_topSizer->Add( m_pGrabberwin, 0, wxTOP, m_style->GetTopMargin() );
</mark><br>755<mark>
</mark><br>756<mark>        m_topSizer->Layout();
</mark><br>757<mark>        Fit();
</mark><br>758<mark>
</mark><br>759<mark>        //    Update "Dock" parameters
</mark><br>760<mark>        if( m_position.x == 0 ) m_dock_x = -1;
</mark><br>761<mark>        else
</mark><br>762<mark>            if( m_position.x == m_pparent->GetClientSize().x - GetSize().x ) m_dock_x = 1;
</mark><br>763<mark>
</mark><br>764<mark>        if( m_position.y == 0 ) m_dock_y = -1;
</mark><br>765<mark>        else
</mark><br>766<mark>            if( m_position.y == m_pparent->GetClientSize().y - GetSize().y ) m_dock_y = 1;
</mark><br>767<mark>
</mark><br>768<mark>        // Now create a bitmap mask forthe frame shape.
</mark><br>769<mark>
</mark><br>770<mark>        if( m_marginsInvisible ) {
</mark><br>771<mark>
</mark><br>772<mark>            wxSize tool_size = m_ptoolbar->GetToolBitmapSize();
</mark><br>773<mark>
</mark><br>774<mark>            //  Determine whether the tool icons are meant (by style) to join without speces between
</mark><br>775<mark>            //  This will determine what type of region to draw.
</mark><br>776<mark>            bool b_overlap = false;
</mark><br>777<mark>
</mark><br>778<mark>            wxToolBarToolsList::compatibility_iterator node1 = m_ptoolbar->m_tools.GetFirst();
</mark><br>779<mark>            wxToolBarToolsList::compatibility_iterator node2 = node1->GetNext() ;
</mark><br>780<mark>
</mark><br>781<mark>            wxToolBarToolBase *tool1 = node1->GetData();
</mark><br>782<mark>            ocpnToolBarTool *tools1 = (ocpnToolBarTool *) tool1;
</mark><br>783<mark>
</mark><br>784<mark>            wxToolBarToolBase *tool2 = node2->GetData();
</mark><br>785<mark>            ocpnToolBarTool *tools2 = (ocpnToolBarTool *) tool2;
</mark><br>786<mark>
</mark><br>787<mark>            if( (tools1->m_x + tools1->m_width) >= tools2->m_x)
</mark><br>788<mark>                b_overlap = true;
</mark><br>789<mark>
</mark><br>790<mark>
</mark><br>791<mark>
</mark><br>792<mark>
</mark><br>793<mark>            int toolCount = m_ptoolbar->GetVisibleToolCount();
</mark><br>794<mark>
</mark><br>795<mark>            wxPoint upperLeft( m_style->GetLeftMargin(), m_style->GetTopMargin() );
</mark><br>796<mark>            wxSize visibleSize;
</mark><br>797<mark>            if( m_ptoolbar->IsVertical() ) {
</mark><br>798<mark>                int noTools = m_ptoolbar->GetMaxRows();
</mark><br>799<mark>                if( noTools > toolCount )
</mark><br>800<mark>                    noTools = toolCount;
</mark><br>801<mark>                visibleSize.x = m_ptoolbar->GetLineCount() * ( tool_size.x + m_style->GetTopMargin() );
</mark><br>802<mark>                visibleSize.y = noTools * ( tool_size.y + m_style->GetToolSeparation() );
</mark><br>803<mark>                visibleSize.x -= m_style->GetTopMargin();
</mark><br>804<mark>                visibleSize.y -= m_style->GetToolSeparation();
</mark><br>805<mark>            } else {
</mark><br>806<mark>                    int noTools = m_ptoolbar->GetMaxCols();
</mark><br>807<mark>                    if( noTools > toolCount )
</mark><br>808<mark>                        noTools = toolCount;
</mark><br>809<mark>                visibleSize.x = noTools * ( tool_size.x + m_style->GetToolSeparation() );
</mark><br>810<mark>                visibleSize.y = m_ptoolbar->GetLineCount() * ( tool_size.y + m_style->GetTopMargin() );
</mark><br>811<mark>                visibleSize.x -= m_style->GetToolSeparation();
</mark><br>812<mark>                visibleSize.y -= m_style->GetTopMargin();
</mark><br>813<mark>            }
</mark><br>814<mark>
</mark><br>815<mark>            wxBitmap shape( visibleSize.x + tool_size.x, visibleSize.y + tool_size.y);          // + fluff
</mark><br>816<mark>            wxMemoryDC sdc( shape );
</mark><br>817<mark>            sdc.SetBackground( *wxWHITE_BRUSH );
</mark><br>818<mark>            sdc.SetBrush( *wxBLACK_BRUSH );
</mark><br>819<mark>            sdc.SetPen( *wxBLACK_PEN );
</mark><br>820<mark>            sdc.Clear();
</mark><br>821<mark>
</mark><br>822<mark>            if(b_overlap) {
</mark><br>823<mark>                int lines = m_ptoolbar->GetLineCount();
</mark><br>824<mark>                for( int i = 1; i <= lines; i++ ) {
</mark><br>825<mark>                    if( m_ptoolbar->IsVertical() ) {
</mark><br>826<mark>                        wxSize barsize( tool_size.x, visibleSize.y );
</mark><br>827<mark>                        if( i == lines && i > 1 ) {
</mark><br>828<mark>                            int toolsInLastLine = toolCount % m_ptoolbar->GetMaxRows();
</mark><br>829<mark>                            if( toolsInLastLine == 0 ) toolsInLastLine = m_ptoolbar->GetMaxRows();
</mark><br>830<mark>                            int emptySpace = ( m_ptoolbar->GetMaxRows() - toolsInLastLine );
</mark><br>831<mark>                            barsize.y -= emptySpace
</mark><br>832<mark>                            * ( tool_size.y + m_style->GetToolSeparation() );
</mark><br>833<mark>                        }
</mark><br>834<mark>                        if( i == lines ) {
</mark><br>835<mark>                            // Also do grabber here, since it is to the right of the last line.
</mark><br>836<mark>                            wxRect grabMask( upperLeft, barsize );
</mark><br>837<mark>                            grabMask.width += m_style->GetIcon( _T("grabber") ).GetWidth();
</mark><br>838<mark>                            grabMask.height = m_style->GetIcon( _T("grabber") ).GetHeight();
</mark><br>839<mark>                            sdc.DrawRoundedRectangle( grabMask, m_style->GetToolbarCornerRadius() );
</mark><br>840<mark>                        }
</mark><br>841<mark>                        sdc.DrawRoundedRectangle( upperLeft, barsize,
</mark><br>842<mark>                                m_style->GetToolbarCornerRadius() );
</mark><br>843<mark>                        upperLeft.x += m_style->GetTopMargin() + tool_size.x;
</mark><br>844<mark>                    } else {
</mark><br>845<mark>                        wxSize barsize( visibleSize.x, tool_size.y );
</mark><br>846<mark>
</mark><br>847<mark>                        if( i == 1 ) {
</mark><br>848<mark>                            barsize.x += m_style->GetIcon( _T("grabber") ).GetWidth();
</mark><br>849<mark>                        }
</mark><br>850<mark>                        if( i == lines && i > 1 ) {
</mark><br>851<mark>                            int toolsInLastLine = toolCount % m_ptoolbar->GetMaxCols();
</mark><br>852<mark>                            if( toolsInLastLine == 0 ) toolsInLastLine = m_ptoolbar->GetMaxCols();
</mark><br>853<mark>                            int emptySpace = ( m_ptoolbar->GetMaxCols() - toolsInLastLine );
</mark><br>854<mark>                            barsize.x -= emptySpace * ( tool_size.x + m_style->GetToolSeparation() );
</mark><br>855<mark>                        }
</mark><br>856<mark>
</mark><br>857<mark>                        sdc.DrawRoundedRectangle( upperLeft, barsize,
</mark><br>858<mark>                                m_style->GetToolbarCornerRadius() );
</mark><br>859<mark>                        upperLeft.y += m_style->GetTopMargin() + tool_size.y;
</mark><br>860<mark>                    }
</mark><br>861<mark>                }
</mark><br>862<mark>            } //b_overlap
</mark><br>863<mark>            else {
</mark><br>864<mark>                for( wxToolBarToolsList::compatibility_iterator node = m_ptoolbar->m_tools.GetFirst(); node; node = node->GetNext() ) {
</mark><br>865<mark>                    wxToolBarToolBase *tool = node->GetData();
</mark><br>866<mark>                    ocpnToolBarTool *tools = (ocpnToolBarTool *) tool;
</mark><br>867<mark>                    wxRect toolRect = tools->trect;
</mark><br>868<mark>
</mark><br>869<mark>                    sdc.DrawRoundedRectangle( tools->m_x, tools->m_y, tool_size.x, tool_size.y,
</mark><br>870<mark>                                              m_style->GetToolbarCornerRadius() );
</mark><br>871<mark>                }
</mark><br>872<mark>            }
</mark><br>873<mark>
</mark><br>874<mark>#ifndef __OCPN__ANDROID__
</mark><br>875<mark>            if(shape.GetWidth() && shape.GetHeight())
</mark><br>876<mark>                SetShape( wxRegion( shape, *wxWHITE, 10 ) );
</mark><br>877<mark>#endif
</mark><br>878<mark>        }
</mark><br>879<mark>    }
</mark><br>880<mark>}
</mark><br>881<mark>
</mark><br>882<mark>void ocpnFloatingToolbarDialog::OnToolLeftClick( wxCommandEvent& event )
</mark><br>883<mark>{
</mark><br>884<mark>    // First see if it was actually the context menu that was clicked.
</mark><br>885<mark>
</mark><br>886<mark>    if( event.GetId() >= ID_PLUGIN_BASE + 100 ) {
</mark><br>887<mark>
</mark><br>888<mark>        int itemId = event.GetId() - ID_PLUGIN_BASE - 100;
</mark><br>889<mark>        wxMenuItem *item = g_FloatingToolbarConfigMenu->FindItem( event.GetId() );
</mark><br>890<mark>
</mark><br>891<mark>        if(item){
</mark><br>892<mark>            bool toolIsChecked = item->IsChecked();
</mark><br>893<mark>
</mark><br>894<mark>            if( toolIsChecked ) {
</mark><br>895<mark>                g_toolbarConfig.SetChar( itemId, _T('X') );
</mark><br>896<mark>            } else {
</mark><br>897<mark>
</mark><br>898<mark>                if( itemId + ID_ZOOMIN == ID_MOB ) {
</mark><br>899<mark>                    ToolbarMOBDialog mdlg( this );
</mark><br>900<mark>                    int dialog_ret = mdlg.ShowModal();
</mark><br>901<mark>                    int answer = mdlg.GetSelection();
</mark><br>902<mark>
</mark><br>903<mark>                    if( answer == 0 || answer == 1 || dialog_ret == wxID_CANCEL ) {
</mark><br>904<mark>                        g_FloatingToolbarConfigMenu->FindItem( event.GetId() )->Check( true );
</mark><br>905<mark>                        if( answer == 1 && dialog_ret == wxID_OK ) {
</mark><br>906<mark>                            g_bPermanentMOBIcon = true;
</mark><br>907<mark>                            delete g_FloatingToolbarConfigMenu;
</mark><br>908<mark>                            g_FloatingToolbarConfigMenu = new wxMenu();
</mark><br>909<mark>                            toolbarConfigChanged = true;
</mark><br>910<mark>                        }
</mark><br>911<mark>                        return;
</mark><br>912<mark>                    }
</mark><br>913<mark>                }
</mark><br>914<mark>
</mark><br>915<mark>                if( m_ptoolbar->GetVisibleToolCount() == 1 ) {
</mark><br>916<mark>                    OCPNMessageBox( this,
</mark><br>917<mark>                            _("You can't hide the last tool from the toolbar\nas this would make it inaccessible."),
</mark><br>918<mark>                            _("OpenCPN Alert"), wxOK );
</mark><br>919<mark>                    g_FloatingToolbarConfigMenu->FindItem( event.GetId() )->Check( true );
</mark><br>920<mark>                    return;
</mark><br>921<mark>                }
</mark><br>922<mark>
</mark><br>923<mark>                g_toolbarConfig.SetChar( itemId, _T('.') );
</mark><br>924<mark>            }
</mark><br>925<mark>        }
</mark><br>926<mark>
</mark><br>927<mark>        toolbarConfigChanged = true;
</mark><br>928<mark>        return;
</mark><br>929<mark>    }
</mark><br>930<mark>
</mark><br>931<mark>    // No it was a button that was clicked.
</mark><br>932<mark>    // Since Dialog events don't propagate automatically, we send it explicitly
</mark><br>933<mark>    // (instead of relying on event.Skip()). Send events up the window hierarchy
</mark><br>934<mark>
</mark><br>935<mark>    m_pparent->GetEventHandler()->AddPendingEvent( event );
</mark><br>936<mark>#ifndef __WXQT__
</mark><br>937<mark>    gFrame->Raise();
</mark><br>938<mark>#endif    
</mark><br>939<mark>}
</mark><br>940<mark>
</mark><br>941<mark>ocpnToolBarSimple *ocpnFloatingToolbarDialog::GetToolbar()
</mark><br>942<mark>{
</mark><br>943<mark>    if( !m_ptoolbar ) {
</mark><br>944<mark>        long winstyle = wxNO_BORDER | wxTB_FLAT;
</mark><br>945<mark>        winstyle |= m_orient;
</mark><br>946<mark>
</mark><br>947<mark>        m_ptoolbar = new ocpnToolBarSimple( this, -1, wxPoint( -1, -1 ), wxSize( -1, -1 ),
</mark><br>948<mark>                winstyle );
</mark><br>949<mark>
</mark><br>950<mark>        m_ptoolbar->SetBackgroundColour( GetGlobalColor( _T("GREY2") ) );
</mark><br>951<mark>        m_ptoolbar->ClearBackground();
</mark><br>952<mark>        m_ptoolbar->SetToggledBackgroundColour( GetGlobalColor( _T("GREY1") ) );
</mark><br>953<mark>        m_ptoolbar->SetColorScheme( m_cs );
</mark><br>954<mark>
</mark><br>955<mark>        SetGeometry(false, wxRect());
</mark><br>956<mark>    }
</mark><br>957<mark>
</mark><br>958<mark>    return m_ptoolbar;
</mark><br>959<mark>}
</mark><br>960<mark>
</mark><br>961<mark>void ocpnFloatingToolbarDialog::DestroyToolBar()
</mark><br>962<mark>{
</mark><br>963<mark>    if( m_ptoolbar ) {
</mark><br>964<mark>        m_ptoolbar->ClearTools();
</mark><br>965<mark>        delete m_ptoolbar;                  //->Destroy();
</mark><br>966<mark>        m_ptoolbar = NULL;
</mark><br>967<mark>    }
</mark><br>968<mark> 
</mark><br>969<mark>    m_destroyGrabber = m_pRecoverwin;
</mark><br>970<mark>    m_destroyTimer.Start( 5, wxTIMER_ONE_SHOT );           //  Destor the unneeded recovery grabber
</mark><br>971<mark>    
</mark><br>972<mark>}
</mark><br>973<mark>
</mark><br>974<mark>//----------------------------------------------------------------------------
</mark><br>975<mark>// Toolbar Tooltip Popup Window Definition
</mark><br>976<mark>//----------------------------------------------------------------------------
</mark><br>977<mark>class ToolTipWin: public wxDialog {
</mark><br>978<mark>public:
</mark><br>979<mark>    ToolTipWin( wxWindow *parent );
</mark><br>980<mark>    ~ToolTipWin();
</mark><br>981<mark>
</mark><br>982<mark>    void OnPaint( wxPaintEvent& event );
</mark><br>983<mark>
</mark><br>984<mark>    void SetColorScheme( ColorScheme cs );
</mark><br>985<mark>    void SetString( wxString &s )
</mark><br>986<mark>    {
</mark><br>987<mark>        m_string = s;
</mark><br>988<mark>    }
</mark><br>989<mark>    void SetPosition( wxPoint pt )
</mark><br>990<mark>    {
</mark><br>991<mark>        m_position = pt;
</mark><br>992<mark>    }
</mark><br>993<mark>    void SetBitmap( void );
</mark><br>994<mark>
</mark><br>995<mark>    void SetHiviz( bool hiviz){ m_hiviz = hiviz; }
</mark><br>996<mark>    
</mark><br>997<mark>    wxSize GetRenderedSize( void );
</mark><br>998<mark>    
</mark><br>999<mark>private:
</mark><br>1000<mark>
</mark><br>1001<mark>    wxString m_string;
</mark><br>1002<mark>    wxSize m_size;
</mark><br>1003<mark>    wxPoint m_position;
</mark><br>1004<mark>    wxBitmap *m_pbm;
</mark><br>1005<mark>    wxColour m_back_color;
</mark><br>1006<mark>    wxColour m_text_color;
</mark><br>1007<mark>    ColorScheme m_cs ;
</mark><br>1008<mark>    bool m_hiviz;
</mark><br>1009<mark>
</mark><br>1010<mark>DECLARE_EVENT_TABLE()
</mark><br>1011<mark>};
</mark><br>1012<mark>//-----------------------------------------------------------------------
</mark><br>1013<mark>//
</mark><br>1014<mark>//    Toolbar Tooltip window implementation
</mark><br>1015<mark>//
</mark><br>1016<mark>//-----------------------------------------------------------------------
</mark><br>1017<mark>BEGIN_EVENT_TABLE(ToolTipWin, wxDialog) EVT_PAINT(ToolTipWin::OnPaint)
</mark><br>1018<mark>
</mark><br>1019<mark>END_EVENT_TABLE()
</mark><br>1020<mark>
</mark><br>1021<mark>// Define a constructor
</mark><br>1022<mark>ToolTipWin::ToolTipWin( wxWindow *parent ) :
</mark><br>1023<mark>        wxDialog( parent, wxID_ANY, _T(""), wxPoint( 0, 0 ), wxSize( 1, 1 ),
</mark><br>1024<mark>                wxNO_BORDER | wxSTAY_ON_TOP )
</mark><br>1025<mark>{
</mark><br>1026<mark>    m_pbm = NULL;
</mark><br>1027<mark>
</mark><br>1028<mark>    m_back_color = GetGlobalColor( _T ( "UIBCK" ) );
</mark><br>1029<mark>    m_text_color = GetGlobalColor( _T ( "UITX1" ) );
</mark><br>1030<mark>
</mark><br>1031<mark>    SetBackgroundStyle( wxBG_STYLE_CUSTOM );
</mark><br>1032<mark>    SetBackgroundColour( m_back_color );
</mark><br>1033<mark>    m_cs = GLOBAL_COLOR_SCHEME_RGB;
</mark><br>1034<mark>
</mark><br>1035<mark>    Hide();
</mark><br>1036<mark>}
</mark><br>1037<mark>
</mark><br>1038<mark>ToolTipWin::~ToolTipWin()
</mark><br>1039<mark>{
</mark><br>1040<mark>    delete m_pbm;
</mark><br>1041<mark>}
</mark><br>1042<mark>
</mark><br>1043<mark>void ToolTipWin::SetColorScheme( ColorScheme cs )
</mark><br>1044<mark>{
</mark><br>1045<mark>    m_back_color = GetGlobalColor( _T ( "UIBCK" ) );
</mark><br>1046<mark>    m_text_color = FontMgr::Get().GetFontColor( _("ToolTips") );
</mark><br>1047<mark>
</mark><br>1048<mark>    m_cs = cs;
</mark><br>1049<mark>}
</mark><br>1050<mark>
</mark><br>1051<mark>wxSize ToolTipWin::GetRenderedSize( void )
</mark><br>1052<mark>{
</mark><br>1053<mark>    int h, w;
</mark><br>1054<mark>    wxSize sz;
</mark><br>1055<mark>
</mark><br>1056<mark>    wxClientDC cdc( GetParent() );
</mark><br>1057<mark>
</mark><br>1058<mark>    wxFont *plabelFont = FontMgr::Get().GetFont( _("ToolTips") );
</mark><br>1059<mark>    cdc.GetTextExtent( m_string, &w, &h, NULL, NULL, plabelFont );
</mark><br>1060<mark>
</mark><br>1061<mark>    sz.x = w + 8;
</mark><br>1062<mark>    sz.y = h + 4;
</mark><br>1063<mark>    
</mark><br>1064<mark>    return sz;
</mark><br>1065<mark>
</mark><br>1066<mark>}
</mark><br>1067<mark>
</mark><br>1068<mark>void ToolTipWin::SetBitmap()
</mark><br>1069<mark>{
</mark><br>1070<mark>    int h, w;
</mark><br>1071<mark>
</mark><br>1072<mark>    wxClientDC cdc( GetParent() );
</mark><br>1073<mark>
</mark><br>1074<mark>    wxFont *plabelFont = FontMgr::Get().GetFont( _("ToolTips") );
</mark><br>1075<mark>    cdc.GetTextExtent( m_string, &w, &h, NULL, NULL, plabelFont );
</mark><br>1076<mark>
</mark><br>1077<mark>    m_size.x = w + 8;
</mark><br>1078<mark>    m_size.y = h + 4;
</mark><br>1079<mark>
</mark><br>1080<mark>    wxMemoryDC mdc;
</mark><br>1081<mark>
</mark><br>1082<mark>    delete m_pbm;
</mark><br>1083<mark>    m_pbm = new wxBitmap( m_size.x, m_size.y, -1 );
</mark><br>1084<mark>    mdc.SelectObject( *m_pbm );
</mark><br>1085<mark>
</mark><br>1086<mark>    wxPen pborder( m_text_color );
</mark><br>1087<mark>    wxBrush bback( m_back_color );
</mark><br>1088<mark>    mdc.SetPen( pborder );
</mark><br>1089<mark>    mdc.SetBrush( bback );
</mark><br>1090<mark>
</mark><br>1091<mark>    if(m_hiviz){
</mark><br>1092<mark>        if((m_cs == GLOBAL_COLOR_SCHEME_DUSK) || (m_cs == GLOBAL_COLOR_SCHEME_NIGHT)){
</mark><br>1093<mark>            wxBrush hv_back( wxColour(200,200,200));
</mark><br>1094<mark>            mdc.SetBrush( hv_back );
</mark><br>1095<mark>        }
</mark><br>1096<mark>    }
</mark><br>1097<mark>    mdc.DrawRectangle( 0, 0, m_size.x, m_size.y );
</mark><br>1098<mark>
</mark><br>1099<mark>    //    Draw the text
</mark><br>1100<mark>    mdc.SetFont( *plabelFont );
</mark><br>1101<mark>    mdc.SetTextForeground( m_text_color );
</mark><br>1102<mark>    mdc.SetTextBackground( m_back_color );
</mark><br>1103<mark>
</mark><br>1104<mark>    mdc.DrawText( m_string, 4, 2 );
</mark><br>1105<mark>
</mark><br>1106<mark>    SetSize( m_position.x, m_position.y, m_size.x, m_size.y );
</mark><br>1107<mark>
</mark><br>1108<mark>}
</mark><br>1109<mark>
</mark><br>1110<mark>void ToolTipWin::OnPaint( wxPaintEvent& event )
</mark><br>1111<mark>{
</mark><br>1112<mark>    int width, height;
</mark><br>1113<mark>    GetClientSize( &width, &height );
</mark><br>1114<mark>    wxPaintDC dc( this );
</mark><br>1115<mark>
</mark><br>1116<mark>    if( m_string.Len() ) {
</mark><br>1117<mark>        wxMemoryDC mdc;
</mark><br>1118<mark>        mdc.SelectObject( *m_pbm );
</mark><br>1119<mark>        dc.Blit( 0, 0, width, height, &mdc, 0, 0 );
</mark><br>1120<mark>    }
</mark><br>1121<mark>}
</mark><br>1122<mark>
</mark><br>1123<mark>
</mark><br>1124<mark>// ----------------------------------------------------------------------------
</mark><br>1125<mark>BEGIN_EVENT_TABLE(ocpnToolBarSimple, wxControl) EVT_SIZE(ocpnToolBarSimple::OnSize)
</mark><br>1126<mark>EVT_PAINT(ocpnToolBarSimple::OnPaint)
</mark><br>1127<mark>EVT_KILL_FOCUS(ocpnToolBarSimple::OnKillFocus)
</mark><br>1128<mark>EVT_MOUSE_EVENTS(ocpnToolBarSimple::OnMouseEvent)
</mark><br>1129<mark>EVT_TIMER(TOOLTIPON_TIMER, ocpnToolBarSimple::OnToolTipTimerEvent)
</mark><br>1130<mark>EVT_TIMER(TOOLTIPOFF_TIMER, ocpnToolBarSimple::OnToolTipOffTimerEvent)
</mark><br>1131<mark>
</mark><br>1132<mark>END_EVENT_TABLE()
</mark><br>1133<mark>
</mark><br>1134<mark>// ============================================================================
</mark><br>1135<mark>// implementation
</mark><br>1136<mark>// ============================================================================
</mark><br>1137<mark>
</mark><br>1138<mark>// ----------------------------------------------------------------------------
</mark><br>1139<mark>// tool bar tools creation
</mark><br>1140<mark>// ----------------------------------------------------------------------------
</mark><br>1141<mark>
</mark><br>1142<mark>wxToolBarToolBase *ocpnToolBarSimple::CreateTool( int id, const wxString& label,
</mark><br>1143<mark>        const wxBitmap& bmpNormal, const wxBitmap& bmpDisabled, wxItemKind kind,
</mark><br>1144<mark>        wxObject *clientData, const wxString& shortHelp, const wxString& longHelp )
</mark><br>1145<mark>{
</mark><br>1146<mark>    return new ocpnToolBarTool( this, id, label, bmpNormal, bmpDisabled, kind, clientData,
</mark><br>1147<mark>            shortHelp, longHelp );
</mark><br>1148<mark>}
</mark><br>1149<mark>
</mark><br>1150<mark>// ----------------------------------------------------------------------------
</mark><br>1151<mark>// ocpnToolBarSimple creation
</mark><br>1152<mark>// ----------------------------------------------------------------------------
</mark><br>1153<mark>
</mark><br>1154<mark>void ocpnToolBarSimple::Init()
</mark><br>1155<mark>{
</mark><br>1156<mark>    m_currentRowsOrColumns = 0;
</mark><br>1157<mark>
</mark><br>1158<mark>    m_lastX = m_lastY = 0;
</mark><br>1159<mark>
</mark><br>1160<mark>    m_maxWidth = m_maxHeight = 0;
</mark><br>1161<mark>
</mark><br>1162<mark>    m_pressedTool = m_currentTool = -1;
</mark><br>1163<mark>
</mark><br>1164<mark>    m_xPos = m_yPos = wxDefaultCoord;
</mark><br>1165<mark>
</mark><br>1166<mark>    m_style = g_StyleManager->GetCurrentStyle();
</mark><br>1167<mark>
</mark><br>1168<mark>    m_defaultWidth = 16;
</mark><br>1169<mark>    m_defaultHeight = 15;
</mark><br>1170<mark>
</mark><br>1171<mark>    m_toggle_bg_color = wxSystemSettings::GetColour( wxSYS_COLOUR_3DFACE );
</mark><br>1172<mark>    m_toolOutlineColour.Set( _T("BLACK") );
</mark><br>1173<mark>    m_pToolTipWin = NULL;
</mark><br>1174<mark>    m_last_ro_tool = NULL;
</mark><br>1175<mark>
</mark><br>1176<mark>    m_btoolbar_is_zooming = false;
</mark><br>1177<mark>    m_sizefactor = 1.0f;
</mark><br>1178<mark>
</mark><br>1179<mark>    m_last_plugin_down_id = -1;
</mark><br>1180<mark>    
</mark><br>1181<mark>    EnableTooltips();
</mark><br>1182<mark>}
</mark><br>1183<mark>
</mark><br>1184<mark>wxToolBarToolBase *ocpnToolBarSimple::DoAddTool( int id, const wxString& label,
</mark><br>1185<mark>        const wxBitmap& bitmap, const wxBitmap& bmpDisabled, wxItemKind kind,
</mark><br>1186<mark>        const wxString& shortHelp, const wxString& longHelp, wxObject *clientData, wxCoord xPos,
</mark><br>1187<mark>        wxCoord yPos )
</mark><br>1188<mark>{
</mark><br>1189<mark>    // rememeber the position for DoInsertTool()
</mark><br>1190<mark>    m_xPos = xPos;
</mark><br>1191<mark>    m_yPos = yPos;
</mark><br>1192<mark>
</mark><br>1193<mark>    InvalidateBestSize();
</mark><br>1194<mark>    return InsertTool( GetToolsCount(), id, label, bitmap, bmpDisabled, kind, shortHelp, longHelp,
</mark><br>1195<mark>            clientData );
</mark><br>1196<mark>
</mark><br>1197<mark>}
</mark><br>1198<mark>
</mark><br>1199<mark>///
</mark><br>1200<mark>
</mark><br>1201<mark>wxToolBarToolBase *ocpnToolBarSimple::AddTool( int toolid, const wxString& label,
</mark><br>1202<mark>        const wxBitmap& bitmap, const wxBitmap& bmpDisabled, wxItemKind kind,
</mark><br>1203<mark>        const wxString& shortHelp, const wxString& longHelp, wxObject *data )
</mark><br>1204<mark>{
</mark><br>1205<mark>    InvalidateBestSize();
</mark><br>1206<mark>    ocpnToolBarTool* tool = (ocpnToolBarTool*)InsertTool( GetToolsCount(), toolid, label, bitmap, bmpDisabled, kind,
</mark><br>1207<mark>            shortHelp, longHelp, data );
</mark><br>1208<mark>    return tool;
</mark><br>1209<mark>}
</mark><br>1210<mark>
</mark><br>1211<mark>wxToolBarToolBase *ocpnToolBarSimple::InsertTool( size_t pos, int id, const wxString& label,
</mark><br>1212<mark>        const wxBitmap& bitmap, const wxBitmap& bmpDisabled, wxItemKind kind,
</mark><br>1213<mark>        const wxString& shortHelp, const wxString& longHelp, wxObject *clientData )
</mark><br>1214<mark>{
</mark><br>1215<mark>    wxCHECK_MSG( pos <= GetToolsCount(), (wxToolBarToolBase *)NULL,
</mark><br>1216<mark>            _T("invalid position in wxToolBar::InsertTool()") );
</mark><br>1217<mark>
</mark><br>1218<mark>    wxToolBarToolBase *tool = CreateTool( id, label, bitmap, bmpDisabled, kind, clientData,
</mark><br>1219<mark>            shortHelp, longHelp );
</mark><br>1220<mark>
</mark><br>1221<mark>    if( !InsertTool( pos, tool ) ) {
</mark><br>1222<mark>        delete tool;
</mark><br>1223<mark>
</mark><br>1224<mark>        return NULL;
</mark><br>1225<mark>    }
</mark><br>1226<mark>
</mark><br>1227<mark>    return tool;
</mark><br>1228<mark>}
</mark><br>1229<mark>
</mark><br>1230<mark>wxToolBarToolBase *ocpnToolBarSimple::InsertTool( size_t pos, wxToolBarToolBase *tool )
</mark><br>1231<mark>{
</mark><br>1232<mark>    wxCHECK_MSG( pos <= GetToolsCount(), (wxToolBarToolBase *)NULL,
</mark><br>1233<mark>            _T("invalid position in wxToolBar::InsertTool()") );
</mark><br>1234<mark>
</mark><br>1235<mark>    if( !tool || !DoInsertTool( pos, tool ) ) {
</mark><br>1236<mark>        return NULL;
</mark><br>1237<mark>    }
</mark><br>1238<mark>
</mark><br>1239<mark>    m_tools.Insert( pos, tool );
</mark><br>1240<mark>
</mark><br>1241<mark>    return tool;
</mark><br>1242<mark>}
</mark><br>1243<mark>
</mark><br>1244<mark>bool ocpnToolBarSimple::DoInsertTool( size_t WXUNUSED(pos), wxToolBarToolBase *toolBase )
</mark><br>1245<mark>{
</mark><br>1246<mark>    ocpnToolBarTool *tool = (ocpnToolBarTool *) toolBase;
</mark><br>1247<mark>
</mark><br>1248<mark>    // Check if the plugin is inserting same-named tools. Make sure they have different names,
</mark><br>1249<mark>    // otherwise the style manager cannot differentiate between them.
</mark><br>1250<mark>    if( tool->isPluginTool ) {
</mark><br>1251<mark>        for( unsigned int i=0; i<GetToolsCount(); i++ ) {
</mark><br>1252<mark>            if( tool->GetToolname() == ((ocpnToolBarTool *)m_tools.Item(i)->GetData())->GetToolname()) {
</mark><br>1253<mark>                tool->toolname << _T("1");
</mark><br>1254<mark>            }
</mark><br>1255<mark>        }
</mark><br>1256<mark>    }
</mark><br>1257<mark>
</mark><br>1258<mark>    tool->m_x = m_xPos;
</mark><br>1259<mark>    if( tool->m_x == wxDefaultCoord ) tool->m_x = m_style->GetLeftMargin();
</mark><br>1260<mark>
</mark><br>1261<mark>    tool->m_y = m_yPos;
</mark><br>1262<mark>    if( tool->m_y == wxDefaultCoord ) tool->m_y = m_style->GetTopMargin();
</mark><br>1263<mark>
</mark><br>1264<mark>    if( tool->IsButton() ) {
</mark><br>1265<mark>        tool->SetSize( GetToolSize() );
</mark><br>1266<mark>
</mark><br>1267<mark>        // Calculate reasonable max size in case Layout() not called
</mark><br>1268<mark>        if( ( tool->m_x + tool->GetNormalBitmap().GetWidth() + m_style->GetLeftMargin() )
</mark><br>1269<mark>                > m_maxWidth ) m_maxWidth = (wxCoord) ( ( tool->m_x + tool->GetWidth()
</mark><br>1270<mark>                + m_style->GetLeftMargin() ) );
</mark><br>1271<mark>
</mark><br>1272<mark>        if( ( tool->m_y + tool->GetNormalBitmap().GetHeight() + m_style->GetTopMargin() )
</mark><br>1273<mark>                > m_maxHeight ) m_maxHeight = (wxCoord) ( ( tool->m_y + tool->GetHeight()
</mark><br>1274<mark>                + m_style->GetTopMargin() ) );
</mark><br>1275<mark>    }
</mark><br>1276<mark>
</mark><br>1277<mark>    else
</mark><br>1278<mark>        if( tool->IsControl() ) {
</mark><br>1279<mark>            tool->SetSize( tool->GetControl()->GetSize() );
</mark><br>1280<mark>        }
</mark><br>1281<mark>
</mark><br>1282<mark>    tool->b_hilite = false;
</mark><br>1283<mark>
</mark><br>1284<mark>    return true;
</mark><br>1285<mark>}
</mark><br>1286<mark>
</mark><br>1287<mark>bool ocpnToolBarSimple::DoDeleteTool( size_t WXUNUSED(pos), wxToolBarToolBase *tool )
</mark><br>1288<mark>{
</mark><br>1289<mark>    // VZ: didn't test whether it works, but why not...
</mark><br>1290<mark>    tool->Detach();
</mark><br>1291<mark>
</mark><br>1292<mark>    if( m_last_ro_tool == tool ) m_last_ro_tool = NULL;
</mark><br>1293<mark>
</mark><br>1294<mark>    Refresh( false );
</mark><br>1295<mark>
</mark><br>1296<mark>    return true;
</mark><br>1297<mark>}
</mark><br>1298<mark>
</mark><br>1299<mark>bool ocpnToolBarSimple::Create( wxWindow *parent, wxWindowID id, const wxPoint& pos,
</mark><br>1300<mark>        const wxSize& size, long style, const wxString& name )
</mark><br>1301<mark>{
</mark><br>1302<mark>    if( !wxWindow::Create( parent, id, pos, size, style, name ) ) return false;
</mark><br>1303<mark>
</mark><br>1304<mark>    // Set it to grey (or other 3D face colour)
</mark><br>1305<mark>    SetBackgroundColour( wxSystemSettings::GetColour( wxSYS_COLOUR_3DFACE ) );
</mark><br>1306<mark>
</mark><br>1307<mark>    if( GetWindowStyleFlag() & wxTB_VERTICAL ) {
</mark><br>1308<mark>        m_lastX = 7;
</mark><br>1309<mark>        m_lastY = 3;
</mark><br>1310<mark>
</mark><br>1311<mark>        m_maxRows = 32000;      // a lot
</mark><br>1312<mark>        m_maxCols = 1;
</mark><br>1313<mark>    } else {
</mark><br>1314<mark>        m_lastX = 3;
</mark><br>1315<mark>        m_lastY = 7;
</mark><br>1316<mark>
</mark><br>1317<mark>        m_maxRows = 1;
</mark><br>1318<mark>        m_maxCols = 32000;      // a lot
</mark><br>1319<mark>    }
</mark><br>1320<mark>
</mark><br>1321<mark>    SetCursor( *wxSTANDARD_CURSOR );
</mark><br>1322<mark>
</mark><br>1323<mark>    m_tooltip_timer.SetOwner( this, TOOLTIPON_TIMER );
</mark><br>1324<mark>    m_tooltipoff_timer.SetOwner( this, TOOLTIPOFF_TIMER );
</mark><br>1325<mark>    m_tooltip_off = 3000;
</mark><br>1326<mark>
</mark><br>1327<mark>    return true;
</mark><br>1328<mark>}
</mark><br>1329<mark>
</mark><br>1330<mark>ocpnToolBarSimple::~ocpnToolBarSimple()
</mark><br>1331<mark>{
</mark><br>1332<mark>    if( m_pToolTipWin ) {
</mark><br>1333<mark>        m_pToolTipWin->Destroy();
</mark><br>1334<mark>        m_pToolTipWin = NULL;
</mark><br>1335<mark>    }
</mark><br>1336<mark>
</mark><br>1337<mark>}
</mark><br>1338<mark>
</mark><br>1339<mark>void ocpnToolBarSimple::KillTooltip()
</mark><br>1340<mark>{
</mark><br>1341<mark>    m_btooltip_show = false;
</mark><br>1342<mark>
</mark><br>1343<mark>    if( m_pToolTipWin ) {
</mark><br>1344<mark>        m_pToolTipWin->Hide();
</mark><br>1345<mark>        m_pToolTipWin->Destroy();
</mark><br>1346<mark>        m_pToolTipWin = NULL;
</mark><br>1347<mark>    }
</mark><br>1348<mark>    m_tooltip_timer.Stop();
</mark><br>1349<mark>
</mark><br>1350<mark>    if( m_last_ro_tool ) {
</mark><br>1351<mark>        if( m_last_ro_tool->IsEnabled() ) {
</mark><br>1352<mark>            if( m_last_ro_tool->IsToggled() ) {
</mark><br>1353<mark>                m_last_ro_tool->SetNormalBitmap( m_style->GetToolIcon( m_last_ro_tool->GetToolname(), TOOLICON_TOGGLED ) );
</mark><br>1354<mark>            }
</mark><br>1355<mark>            else {
</mark><br>1356<mark>                m_last_ro_tool->SetNormalBitmap( m_style->GetToolIcon( m_last_ro_tool->GetToolname(), TOOLICON_NORMAL ) );
</mark><br>1357<mark>            }
</mark><br>1358<mark>        }
</mark><br>1359<mark>    }
</mark><br>1360<mark>}
</mark><br>1361<mark>
</mark><br>1362<mark>void ocpnToolBarSimple::HideTooltip()
</mark><br>1363<mark>{
</mark><br>1364<mark>    if( m_pToolTipWin ) {
</mark><br>1365<mark>        m_pToolTipWin->Hide();
</mark><br>1366<mark>    }
</mark><br>1367<mark>}
</mark><br>1368<mark>
</mark><br>1369<mark>void ocpnToolBarSimple::SetColorScheme( ColorScheme cs )
</mark><br>1370<mark>{
</mark><br>1371<mark>    if( m_pToolTipWin ) {
</mark><br>1372<mark>        m_pToolTipWin->Destroy();
</mark><br>1373<mark>        m_pToolTipWin = NULL;
</mark><br>1374<mark>    }
</mark><br>1375<mark>
</mark><br>1376<mark>    m_toolOutlineColour = GetGlobalColor( _T("UIBDR") );
</mark><br>1377<mark>
</mark><br>1378<mark>    m_currentColorScheme = cs;
</mark><br>1379<mark>}
</mark><br>1380<mark>
</mark><br>1381<mark>bool ocpnToolBarSimple::Realize()
</mark><br>1382<mark>{
</mark><br>1383<mark>    m_currentRowsOrColumns = 0;
</mark><br>1384<mark>    m_LineCount = 1;
</mark><br>1385<mark>    m_lastX = m_style->GetLeftMargin();
</mark><br>1386<mark>    m_lastY = m_style->GetTopMargin();
</mark><br>1387<mark>    m_maxWidth = 0;
</mark><br>1388<mark>    m_maxHeight = 0;
</mark><br>1389<mark>
</mark><br>1390<mark>    if( IsVertical() ) m_style->SetOrientation( wxTB_VERTICAL );
</mark><br>1391<mark>    else
</mark><br>1392<mark>        m_style->SetOrientation( wxTB_HORIZONTAL );
</mark><br>1393<mark>
</mark><br>1394<mark>    wxSize toolSize = wxSize(-1, -1);
</mark><br>1395<mark>    int separatorSize = m_style->GetToolSeparation();
</mark><br>1396<mark>
</mark><br>1397<mark>    ocpnToolBarTool *lastTool = NULL;
</mark><br>1398<mark>    bool firstNode = true;
</mark><br>1399<mark>    wxToolBarToolsList::compatibility_iterator node = m_tools.GetFirst();
</mark><br>1400<mark>
</mark><br>1401<mark>    while( node ) {
</mark><br>1402<mark>        ocpnToolBarTool *tool = (ocpnToolBarTool *) node->GetData();
</mark><br>1403<mark>
</mark><br>1404<mark>        // Set the tool size to be the size of the first non-separator tool, usually the first one
</mark><br>1405<mark>        if(toolSize.x == -1){
</mark><br>1406<mark>            if( !tool->IsSeparator() ){
</mark><br>1407<mark>                toolSize.x = tool->m_width;
</mark><br>1408<mark>                toolSize.y = tool->m_height;
</mark><br>1409<mark>            }
</mark><br>1410<mark>        }
</mark><br>1411<mark>
</mark><br>1412<mark>        tool->firstInLine = firstNode;
</mark><br>1413<mark>        tool->lastInLine = false;
</mark><br>1414<mark>        firstNode = false;
</mark><br>1415<mark>
</mark><br>1416<mark>        tool->last_rect.width = 0;              // mark it invalid
</mark><br>1417<mark>        
</mark><br>1418<mark>        if( tool->IsSeparator() ) {
</mark><br>1419<mark>            if( GetWindowStyleFlag() & wxTB_HORIZONTAL ) {
</mark><br>1420<mark>                if( m_currentRowsOrColumns >= m_maxCols ) m_lastY += separatorSize;
</mark><br>1421<mark>                else
</mark><br>1422<mark>                    m_lastX += separatorSize;
</mark><br>1423<mark>            } else {
</mark><br>1424<mark>                if( m_currentRowsOrColumns >= m_maxRows ) m_lastX += separatorSize;
</mark><br>1425<mark>                else
</mark><br>1426<mark>                    m_lastY += separatorSize;
</mark><br>1427<mark>            }
</mark><br>1428<mark>        } else
</mark><br>1429<mark>            if( tool->IsButton() ) {
</mark><br>1430<mark>                if( !IsVertical() ) {
</mark><br>1431<mark>                    if( m_currentRowsOrColumns >= m_maxCols ) {
</mark><br>1432<mark>                        tool->firstInLine = true;
</mark><br>1433<mark>                        if( lastTool && m_LineCount > 1 ) lastTool->lastInLine = true;
</mark><br>1434<mark>                        m_LineCount++;
</mark><br>1435<mark>                        m_currentRowsOrColumns = 0;
</mark><br>1436<mark>                        m_lastX = m_style->GetLeftMargin();
</mark><br>1437<mark>                        m_lastY += toolSize.y + m_style->GetTopMargin();
</mark><br>1438<mark>                    }
</mark><br>1439<mark>                    tool->m_x = (wxCoord) m_lastX;
</mark><br>1440<mark>                    tool->m_y = (wxCoord) m_lastY;
</mark><br>1441<mark>
</mark><br>1442<mark>                    tool->trect = wxRect( tool->m_x, tool->m_y, toolSize.x, toolSize.y );
</mark><br>1443<mark>                    tool->trect.Inflate( m_style->GetToolSeparation() / 2,
</mark><br>1444<mark>                            m_style->GetTopMargin() );
</mark><br>1445<mark>
</mark><br>1446<mark>                    m_lastX += toolSize.x + m_style->GetToolSeparation();
</mark><br>1447<mark>                } else {
</mark><br>1448<mark>                    if( m_currentRowsOrColumns >= m_maxRows ) {
</mark><br>1449<mark>                        tool->firstInLine = true;
</mark><br>1450<mark>                        if( lastTool ) lastTool->lastInLine = true;
</mark><br>1451<mark>                        m_LineCount++;
</mark><br>1452<mark>                        m_currentRowsOrColumns = 0;
</mark><br>1453<mark>                        m_lastX += toolSize.x + m_style->GetTopMargin();
</mark><br>1454<mark>                        m_lastY = m_style->GetTopMargin();
</mark><br>1455<mark>                    }
</mark><br>1456<mark>                    tool->m_x = (wxCoord) m_lastX;
</mark><br>1457<mark>                    tool->m_y = (wxCoord) m_lastY;
</mark><br>1458<mark>
</mark><br>1459<mark>                    tool->trect = wxRect( tool->m_x, tool->m_y, toolSize.x, toolSize.y );
</mark><br>1460<mark>                    tool->trect.Inflate( m_style->GetToolSeparation() / 2,
</mark><br>1461<mark>                            m_style->GetTopMargin() );
</mark><br>1462<mark>
</mark><br>1463<mark>                    m_lastY += toolSize.y + m_style->GetToolSeparation();
</mark><br>1464<mark>                }
</mark><br>1465<mark>                m_currentRowsOrColumns++;
</mark><br>1466<mark>            } else
</mark><br>1467<mark>                if( tool->IsControl() ) {
</mark><br>1468<mark>                    tool->m_x = (wxCoord) ( m_lastX );
</mark><br>1469<mark>                    tool->m_y = (wxCoord) ( m_lastY - ( m_style->GetTopMargin() / 2 ) );
</mark><br>1470<mark>
</mark><br>1471<mark>                    tool->trect = wxRect( tool->m_x, tool->m_y, tool->GetWidth(),
</mark><br>1472<mark>                            tool->GetHeight() );
</mark><br>1473<mark>                    tool->trect.Inflate( m_style->GetToolSeparation() / 2,
</mark><br>1474<mark>                            m_style->GetTopMargin() );
</mark><br>1475<mark>                    ;
</mark><br>1476<mark>
</mark><br>1477<mark>                    wxSize s = tool->GetControl()->GetSize();
</mark><br>1478<mark>                    m_lastX += s.x + m_style->GetToolSeparation();
</mark><br>1479<mark>
</mark><br>1480<mark>                }
</mark><br>1481<mark>
</mark><br>1482<mark>        if( m_lastX > m_maxWidth ) m_maxWidth = m_lastX;
</mark><br>1483<mark>        if( m_lastY > m_maxHeight ) m_maxHeight = m_lastY;
</mark><br>1484<mark>
</mark><br>1485<mark>        lastTool = tool;
</mark><br>1486<mark>        node = node->GetNext();
</mark><br>1487<mark>    }
</mark><br>1488<mark>    if( lastTool && (m_LineCount > 1 || IsVertical()) )
</mark><br>1489<mark>        lastTool->lastInLine = true;
</mark><br>1490<mark>
</mark><br>1491<mark>    if( GetWindowStyleFlag() & wxTB_HORIZONTAL ) m_maxHeight += toolSize.y;
</mark><br>1492<mark>    else
</mark><br>1493<mark>        m_maxWidth += toolSize.x;
</mark><br>1494<mark>
</mark><br>1495<mark>    m_maxWidth += m_style->GetRightMargin();
</mark><br>1496<mark>    m_maxHeight += m_style->GetBottomMargin();
</mark><br>1497<mark>
</mark><br>1498<mark>    SetSize( m_maxWidth, m_maxHeight );
</mark><br>1499<mark>    SetMinSize( wxSize( m_maxWidth, m_maxHeight ) );
</mark><br>1500<mark>
</mark><br>1501<mark>    return true;
</mark><br>1502<mark>}
</mark><br>1503<mark>
</mark><br>1504<mark>// ----------------------------------------------------------------------------
</mark><br>1505<mark>// event handlers
</mark><br>1506<mark>// ----------------------------------------------------------------------------
</mark><br>1507<mark>
</mark><br>1508<mark>void ocpnToolBarSimple::OnPaint( wxPaintEvent& WXUNUSED(event) )
</mark><br>1509<mark>{
</mark><br>1510<mark>    wxPaintDC dc( this );
</mark><br>1511<mark>    PrepareDC( dc );
</mark><br>1512<mark>
</mark><br>1513<mark>    wxRegion ru = GetUpdateRegion();
</mark><br>1514<mark>    wxRect upRect = ru.GetBox();
</mark><br>1515<mark>
</mark><br>1516<mark>    static int count = 0;
</mark><br>1517<mark>    // Prevent reentry of OnPaint which would cause wxMemoryDC errors.
</mark><br>1518<mark>    if( count > 0 ) return;
</mark><br>1519<mark>    count++;
</mark><br>1520<mark>
</mark><br>1521<mark>    for( wxToolBarToolsList::compatibility_iterator node = m_tools.GetFirst(); node;
</mark><br>1522<mark>            node = node->GetNext() ) {
</mark><br>1523<mark>        wxToolBarToolBase *tool = node->GetData();
</mark><br>1524<mark>        ocpnToolBarTool *tools = (ocpnToolBarTool *) tool;
</mark><br>1525<mark>        wxRect toolRect = tools->trect;
</mark><br>1526<mark>
</mark><br>1527<mark>        if( toolRect.Intersects( upRect ) ) {
</mark><br>1528<mark>
</mark><br>1529<mark>            if( tool->IsButton() ) {
</mark><br>1530<mark>                DrawTool( dc, tool );
</mark><br>1531<mark>            } else
</mark><br>1532<mark>                if( tool->IsControl() ) {
</mark><br>1533<mark>                    if( tool->GetControl()->IsKindOf( CLASSINFO(wxStaticBitmap) ) ) {
</mark><br>1534<mark>                        wxStaticBitmap *psbm = (wxStaticBitmap *) tool->GetControl();
</mark><br>1535<mark>                        ocpnToolBarTool *toolsimp = (ocpnToolBarTool *) tool;
</mark><br>1536<mark>                        dc.DrawBitmap( psbm->GetBitmap(), toolsimp->m_x, toolsimp->m_y, false );
</mark><br>1537<mark>                    }
</mark><br>1538<mark>                }
</mark><br>1539<mark>        }
</mark><br>1540<mark>    }
</mark><br>1541<mark>
</mark><br>1542<mark>    count--;
</mark><br>1543<mark>}
</mark><br>1544<mark>
</mark><br>1545<mark>void ocpnToolBarSimple::OnSize( wxSizeEvent& WXUNUSED(event) )
</mark><br>1546<mark>{
</mark><br>1547<mark>    if( GetAutoLayout() ) Layout();
</mark><br>1548<mark>}
</mark><br>1549<mark>
</mark><br>1550<mark>void ocpnToolBarSimple::OnKillFocus( wxFocusEvent& WXUNUSED(event) )
</mark><br>1551<mark>{
</mark><br>1552<mark>    OnMouseEnter( m_pressedTool = m_currentTool = -1 );
</mark><br>1553<mark>}
</mark><br>1554<mark>
</mark><br>1555<mark>void ocpnToolBarSimple::OnToolTipTimerEvent( wxTimerEvent& event )
</mark><br>1556<mark>{
</mark><br>1557<mark>    if( !gFrame->IsActive() ) return;
</mark><br>1558<mark>
</mark><br>1559<mark>    if( m_btooltip_show && IsShown() && m_pToolTipWin && ( !m_pToolTipWin->IsShown() ) ) {
</mark><br>1560<mark>        if( m_last_ro_tool ) {
</mark><br>1561<mark>            wxString s = m_last_ro_tool->GetShortHelp();
</mark><br>1562<mark>
</mark><br>1563<mark>            if( s.Len() ) {
</mark><br>1564<mark>                m_pToolTipWin->SetString( s );
</mark><br>1565<mark>                m_pToolTipWin->SetHiviz(m_last_ro_tool->m_btooltip_hiviz);
</mark><br>1566<mark>
</mark><br>1567<mark>                wxPoint pos_in_toolbar( m_last_ro_tool->m_x, m_last_ro_tool->m_y );
</mark><br>1568<mark>                pos_in_toolbar.x += m_last_ro_tool->m_width + 2;
</mark><br>1569<mark>
</mark><br>1570<mark>                m_pToolTipWin->Move(0,0);       // workaround for gtk autocentre dialog behavior
</mark><br>1571<mark>
</mark><br>1572<mark>                wxPoint screenPosition = ClientToScreen( pos_in_toolbar );
</mark><br>1573<mark>                wxPoint framePosition = gFrame->ScreenToClient(screenPosition);
</mark><br>1574<mark>                wxSize tipSize = m_pToolTipWin->GetRenderedSize();
</mark><br>1575<mark>                
</mark><br>1576<mark>                if( (framePosition.x + tipSize.x) > gFrame->GetSize().x)
</mark><br>1577<mark>                    screenPosition.x -= (tipSize.x + m_last_ro_tool->m_width + 4);
</mark><br>1578<mark>                
</mark><br>1579<mark>                m_pToolTipWin->SetPosition( screenPosition );
</mark><br>1580<mark>                m_pToolTipWin->SetBitmap();
</mark><br>1581<mark>                m_pToolTipWin->Show();
</mark><br>1582<mark>                gFrame->Raise();
</mark><br>1583<mark>                if( g_btouch )
</mark><br>1584<mark>                    m_tooltipoff_timer.Start(m_tooltip_off, wxTIMER_ONE_SHOT);
</mark><br>1585<mark>            }
</mark><br>1586<mark>        }
</mark><br>1587<mark>    }
</mark><br>1588<mark>}
</mark><br>1589<mark>
</mark><br>1590<mark>void ocpnToolBarSimple::OnToolTipOffTimerEvent( wxTimerEvent& event )
</mark><br>1591<mark>{
</mark><br>1592<mark>    HideTooltip();
</mark><br>1593<mark>}
</mark><br>1594<mark>
</mark><br>1595<mark>
</mark><br>1596<mark>int s_dragx, s_dragy;
</mark><br>1597<mark>
</mark><br>1598<mark>void ocpnToolBarSimple::OnMouseEvent( wxMouseEvent & event )
</mark><br>1599<mark>{
</mark><br>1600<mark>#ifdef __OCPN__ANDROID__
</mark><br>1601<mark>    if(!event.IsButton())
</mark><br>1602<mark>        return;
</mark><br>1603<mark>#endif
</mark><br>1604<mark>
</mark><br>1605<mark>    wxCoord x, y;
</mark><br>1606<mark>    event.GetPosition( &x, &y );
</mark><br>1607<mark>    ocpnToolBarTool *tool = (ocpnToolBarTool *) FindToolForPosition( x, y );
</mark><br>1608<mark>
</mark><br>1609<mark>#ifndef __OCPN__ANDROID__
</mark><br>1610<mark>    if( event.LeftDown() ) {
</mark><br>1611<mark>        CaptureMouse();
</mark><br>1612<mark>        s_dragx = x;
</mark><br>1613<mark>        s_dragy = y;
</mark><br>1614<mark>    }
</mark><br>1615<mark>    if( event.LeftUp() ) {
</mark><br>1616<mark>        if( HasCapture() ) ReleaseMouse();
</mark><br>1617<mark>    }
</mark><br>1618<mark>#endif
</mark><br>1619<mark>
</mark><br>1620<mark>    if( tool && tool->IsButton() && IsShown() ) {
</mark><br>1621<mark>
</mark><br>1622<mark>        //    ToolTips
</mark><br>1623<mark>        if( NULL == m_pToolTipWin ) {
</mark><br>1624<mark>            m_pToolTipWin = new ToolTipWin( GetParent() );
</mark><br>1625<mark>            m_pToolTipWin->SetColorScheme( m_currentColorScheme );
</mark><br>1626<mark>            m_pToolTipWin->Hide();
</mark><br>1627<mark>        }
</mark><br>1628<mark>
</mark><br>1629<mark>        if( tool != m_last_ro_tool ) m_pToolTipWin->Hide();
</mark><br>1630<mark>
</mark><br>1631<mark>#ifndef __OCPN__ANDROID__
</mark><br>1632<mark>        if( !m_pToolTipWin->IsShown() ) {
</mark><br>1633<mark>            m_tooltip_timer.Start( m_one_shot, wxTIMER_ONE_SHOT );
</mark><br>1634<mark>        }
</mark><br>1635<mark>#endif
</mark><br>1636<mark>
</mark><br>1637<mark>        //    Tool Rollover highlighting
</mark><br>1638<mark>        if(!g_btouch){
</mark><br>1639<mark>            if( tool != m_last_ro_tool ) {
</mark><br>1640<mark>                if( tool->IsEnabled() ) {
</mark><br>1641<mark>                    tool->rollover = true;
</mark><br>1642<mark>                    tool->bitmapOK = false;
</mark><br>1643<mark>                }
</mark><br>1644<mark>                if( m_last_ro_tool ) {
</mark><br>1645<mark>                    if( m_last_ro_tool->IsEnabled() ) {
</mark><br>1646<mark>                        m_last_ro_tool->rollover = false;
</mark><br>1647<mark>                        m_last_ro_tool->bitmapOK = false;
</mark><br>1648<mark>                    }
</mark><br>1649<mark>                }
</mark><br>1650<mark>                m_last_ro_tool = tool;
</mark><br>1651<mark>                if(g_toolbar)
</mark><br>1652<mark>                    g_toolbar->Refresh( false );
</mark><br>1653<mark>            }
</mark><br>1654<mark>        }
</mark><br>1655<mark>    } else {
</mark><br>1656<mark>        //    Tooltips
</mark><br>1657<mark>        if( m_pToolTipWin && m_pToolTipWin->IsShown() ) m_pToolTipWin->Hide();
</mark><br>1658<mark>
</mark><br>1659<mark>        //    Remove Highlighting
</mark><br>1660<mark>        if( m_last_ro_tool ) {
</mark><br>1661<mark>            if( m_last_ro_tool->IsEnabled() ) {
</mark><br>1662<mark>                m_last_ro_tool->rollover = false;
</mark><br>1663<mark>                m_last_ro_tool->bitmapOK = false;
</mark><br>1664<mark>            }
</mark><br>1665<mark>            g_toolbar->Refresh( false );
</mark><br>1666<mark>        }
</mark><br>1667<mark>    }
</mark><br>1668<mark>
</mark><br>1669<mark>    m_last_ro_tool = tool;
</mark><br>1670<mark>
</mark><br>1671<mark>    // allow smooth zooming while toolbutton is held down
</mark><br>1672<mark>    if(g_bsmoothpanzoom && !g_btouch) {
</mark><br>1673<mark>        if(event.LeftUp() && m_btoolbar_is_zooming) {
</mark><br>1674<mark>            cc1->StopMovement();
</mark><br>1675<mark>            m_btoolbar_is_zooming = false;
</mark><br>1676<mark>            return;
</mark><br>1677<mark>        }
</mark><br>1678<mark>
</mark><br>1679<mark>        if( event.LeftDown() && tool &&
</mark><br>1680<mark>            (tool->GetId() == ID_ZOOMIN || tool->GetId() == ID_ZOOMOUT) ) {
</mark><br>1681<mark>            cc1->ZoomCanvas( tool->GetId() == ID_ZOOMIN ? 2.0 : .5, false, false );
</mark><br>1682<mark>            m_btoolbar_is_zooming = true;
</mark><br>1683<mark>            return;
</mark><br>1684<mark>        }
</mark><br>1685<mark>    }
</mark><br>1686<mark>
</mark><br>1687<mark>    if( !tool ) {
</mark><br>1688<mark>        if( m_currentTool > -1 ) {
</mark><br>1689<mark>            if( event.LeftIsDown() ) SpringUpButton( m_currentTool );
</mark><br>1690<mark>            m_currentTool = -1;
</mark><br>1691<mark>            OnMouseEnter( -1 );
</mark><br>1692<mark>        }
</mark><br>1693<mark>
</mark><br>1694<mark>        wxMouseEvent *pev = (wxMouseEvent *) event.Clone();
</mark><br>1695<mark>        GetParent()->GetEventHandler()->AddPendingEvent( *pev );
</mark><br>1696<mark>        wxDELETE( pev );
</mark><br>1697<mark>
</mark><br>1698<mark>        return;
</mark><br>1699<mark>    }
</mark><br>1700<mark>
</mark><br>1701<mark>    if( !event.IsButton() ) {
</mark><br>1702<mark>        if( tool->GetId() != m_currentTool ) {
</mark><br>1703<mark>            // If the left button is kept down and moved over buttons,
</mark><br>1704<mark>            // press those buttons.
</mark><br>1705<mark>            if( event.LeftIsDown() && tool->IsEnabled() ) {
</mark><br>1706<mark>                SpringUpButton( m_currentTool );
</mark><br>1707<mark>
</mark><br>1708<mark>                if( tool->CanBeToggled() ) {
</mark><br>1709<mark>                    tool->Toggle();
</mark><br>1710<mark>                }
</mark><br>1711<mark>
</mark><br>1712<mark>                DrawTool( tool );
</mark><br>1713<mark>            }
</mark><br>1714<mark>
</mark><br>1715<mark>            m_currentTool = tool->GetId();
</mark><br>1716<mark>            OnMouseEnter( m_currentTool );
</mark><br>1717<mark>        }
</mark><br>1718<mark>
</mark><br>1719<mark>        wxMouseEvent *pev = (wxMouseEvent *) event.Clone();
</mark><br>1720<mark>        GetParent()->GetEventHandler()->AddPendingEvent( *pev );
</mark><br>1721<mark>        wxDELETE( pev );
</mark><br>1722<mark>
</mark><br>1723<mark>        return;
</mark><br>1724<mark>    }
</mark><br>1725<mark>
</mark><br>1726<mark>    // Left button pressed.
</mark><br>1727<mark>    if( event.LeftDown() && tool->IsEnabled() ) {
</mark><br>1728<mark>        if( tool->CanBeToggled() ) {
</mark><br>1729<mark>            tool->Toggle();
</mark><br>1730<mark>            tool->bitmapOK = false;
</mark><br>1731<mark>            
</mark><br>1732<mark>        }
</mark><br>1733<mark>
</mark><br>1734<mark>        DrawTool( tool );
</mark><br>1735<mark>
</mark><br>1736<mark>        //        Look for PlugIn tools
</mark><br>1737<mark>        //        If found, make the callback.
</mark><br>1738<mark>        if( g_pi_manager ) {
</mark><br>1739<mark>            ArrayOfPlugInToolbarTools tool_array = g_pi_manager->GetPluginToolbarToolArray();
</mark><br>1740<mark>            for( unsigned int i = 0; i < tool_array.GetCount(); i++ ) {
</mark><br>1741<mark>                PlugInToolbarToolContainer *pttc = tool_array.Item( i );
</mark><br>1742<mark>                if( tool->GetId() == pttc->id ) {
</mark><br>1743<mark>                    opencpn_plugin_113 *ppi = dynamic_cast<opencpn_plugin_113 *>(pttc->m_pplugin);
</mark><br>1744<mark>                    if( ppi ) {
</mark><br>1745<mark>                        ppi->OnToolbarToolDownCallback( pttc->id );
</mark><br>1746<mark>                        m_last_plugin_down_id = pttc->id;
</mark><br>1747<mark>                    }
</mark><br>1748<mark>                }
</mark><br>1749<mark>            }
</mark><br>1750<mark>        }
</mark><br>1751<mark>    } else
</mark><br>1752<mark>        if( event.RightDown() ) {
</mark><br>1753<mark>            OnRightClick( tool->GetId(), x, y );
</mark><br>1754<mark>        }
</mark><br>1755<mark>
</mark><br>1756<mark>    // Left Button Released.  Only this action confirms selection.
</mark><br>1757<mark>    // If the button is enabled and it is not a toggle tool and it is
</mark><br>1758<mark>    // in the pressed state, then raise the button and call OnLeftClick.
</mark><br>1759<mark>    //
</mark><br>1760<mark>    if( event.LeftUp() && tool->IsEnabled() ) {
</mark><br>1761<mark>        // Pass the OnLeftClick event to tool
</mark><br>1762<mark>        if( !OnLeftClick( tool->GetId(), tool->IsToggled() ) && tool->CanBeToggled() ) {
</mark><br>1763<mark>            // If it was a toggle, and OnLeftClick says No Toggle allowed,
</mark><br>1764<mark>            // then change it back
</mark><br>1765<mark>            tool->Toggle();
</mark><br>1766<mark>            tool->bitmapOK = false;
</mark><br>1767<mark>        }
</mark><br>1768<mark>
</mark><br>1769<mark>        DoPluginToolUp();
</mark><br>1770<mark>    }
</mark><br>1771<mark>
</mark><br>1772<mark>    wxMouseEvent *pev = (wxMouseEvent *) event.Clone();
</mark><br>1773<mark>    GetParent()->GetEventHandler()->AddPendingEvent( *pev );
</mark><br>1774<mark>    wxDELETE( pev );
</mark><br>1775<mark>    event.Skip();
</mark><br>1776<mark>}
</mark><br>1777<mark>
</mark><br>1778<mark>// ----------------------------------------------------------------------------
</mark><br>1779<mark>// drawing
</mark><br>1780<mark>// ----------------------------------------------------------------------------
</mark><br>1781<mark>
</mark><br>1782<mark>void ocpnToolBarSimple::DrawTool( wxToolBarToolBase *tool )
</mark><br>1783<mark>{
</mark><br>1784<mark>    wxClientDC dc( this );
</mark><br>1785<mark>    DrawTool( dc, tool );
</mark><br>1786<mark>}
</mark><br>1787<mark>
</mark><br>1788<mark>// NB! The current DrawTool code assumes that plugin tools are never disabled
</mark><br>1789<mark>// when they are present on the toolbar, since disabled plugins are removed.
</mark><br>1790<mark>
</mark><br>1791<mark>void ocpnToolBarSimple::DrawTool( wxDC& dc, wxToolBarToolBase *toolBase )
</mark><br>1792<mark>{
</mark><br>1793<mark>    ocpnToolBarTool *tool = (ocpnToolBarTool *) toolBase;
</mark><br>1794<mark>    PrepareDC( dc );
</mark><br>1795<mark>
</mark><br>1796<mark>    wxPoint drawAt( tool->m_x, tool->m_y );
</mark><br>1797<mark>    wxBitmap bmp;
</mark><br>1798<mark>
</mark><br>1799<mark>    if( tool->bitmapOK ) {
</mark><br>1800<mark>        if( tool->IsEnabled() ) {
</mark><br>1801<mark>            bmp = tool->GetNormalBitmap();
</mark><br>1802<mark>            if( !bmp.IsOk() ){
</mark><br>1803<mark>                bmp = m_style->GetToolIcon( tool->GetToolname(), TOOLICON_NORMAL, tool->rollover );
</mark><br>1804<mark>                if(m_sizefactor > 1.0 ){
</mark><br>1805<mark>                    wxImage scaled_image = bmp.ConvertToImage();
</mark><br>1806<mark>                    bmp = wxBitmap(scaled_image.Scale(tool->m_width, tool->m_height, wxIMAGE_QUALITY_HIGH));
</mark><br>1807<mark>                }
</mark><br>1808<mark>                tool->SetNormalBitmap( bmp );
</mark><br>1809<mark>                tool->bitmapOK = true;
</mark><br>1810<mark>            }
</mark><br>1811<mark>        } else {
</mark><br>1812<mark>            bmp = tool->GetDisabledBitmap();
</mark><br>1813<mark>            if( !bmp.IsOk() ){
</mark><br>1814<mark>                bmp = m_style->GetToolIcon( tool->GetToolname(), TOOLICON_DISABLED );
</mark><br>1815<mark>                if(m_sizefactor > 1.0 ){
</mark><br>1816<mark>                    wxImage scaled_image = bmp.ConvertToImage();
</mark><br>1817<mark>                    bmp = wxBitmap(scaled_image.Scale(tool->m_width, tool->m_height, wxIMAGE_QUALITY_HIGH));
</mark><br>1818<mark>                }
</mark><br>1819<mark>                tool->SetDisabledBitmap( bmp );
</mark><br>1820<mark>                tool->bitmapOK = true;
</mark><br>1821<mark>            }
</mark><br>1822<mark>        }
</mark><br>1823<mark>    } else {
</mark><br>1824<mark>        if ( tool->isPluginTool ) {
</mark><br>1825<mark>
</mark><br>1826<mark>            // First try getting the icon from the Style.
</mark><br>1827<mark>            // If it is not in the style we build a new icon from the style BG and the plugin icon.
</mark><br>1828<mark>
</mark><br>1829<mark>            if( tool->IsToggled() ) {
</mark><br>1830<mark>                bmp = m_style->GetToolIcon( tool->GetToolname(), TOOLICON_TOGGLED, tool->rollover );
</mark><br>1831<mark>                if( bmp.GetDepth() == 1 ) {
</mark><br>1832<mark>                    if( tool->rollover ) {
</mark><br>1833<mark>                        bmp = m_style->BuildPluginIcon( tool->pluginRolloverIcon, TOOLICON_TOGGLED );
</mark><br>1834<mark>                        if( ! bmp.IsOk() )
</mark><br>1835<mark>                            bmp = m_style->BuildPluginIcon( tool->pluginNormalIcon, TOOLICON_TOGGLED );
</mark><br>1836<mark>                    }
</mark><br>1837<mark>                    else
</mark><br>1838<mark>                        bmp = m_style->BuildPluginIcon( tool->pluginNormalIcon, TOOLICON_TOGGLED );
</mark><br>1839<mark>                }
</mark><br>1840<mark>            } else {
</mark><br>1841<mark>                bmp = m_style->GetToolIcon( tool->GetToolname(), TOOLICON_NORMAL, tool->rollover );
</mark><br>1842<mark>                if( bmp.GetDepth() == 1 ) {
</mark><br>1843<mark>                    if( tool->rollover ) {
</mark><br>1844<mark>                        bmp = m_style->BuildPluginIcon( tool->pluginRolloverIcon, TOOLICON_NORMAL );
</mark><br>1845<mark>                        if( ! bmp.IsOk() )
</mark><br>1846<mark>                            bmp = m_style->BuildPluginIcon( tool->pluginNormalIcon, TOOLICON_NORMAL );
</mark><br>1847<mark>                    }
</mark><br>1848<mark>                    else
</mark><br>1849<mark>                        bmp = m_style->BuildPluginIcon( tool->pluginNormalIcon, TOOLICON_NORMAL );
</mark><br>1850<mark>                }
</mark><br>1851<mark>            }
</mark><br>1852<mark>            if(m_sizefactor > 1.0 ){
</mark><br>1853<mark>                wxImage scaled_image = bmp.ConvertToImage();
</mark><br>1854<mark>                bmp = wxBitmap(scaled_image.Scale(tool->m_width, tool->m_height, wxIMAGE_QUALITY_HIGH));
</mark><br>1855<mark>            }
</mark><br>1856<mark>            tool->SetNormalBitmap( bmp );
</mark><br>1857<mark>            tool->bitmapOK = true;
</mark><br>1858<mark>        } else {
</mark><br>1859<mark>            if( tool->IsEnabled() ) {
</mark><br>1860<mark>                if( tool->IsToggled() )
</mark><br>1861<mark>                    bmp = m_style->GetToolIcon( tool->GetToolname(), TOOLICON_TOGGLED, tool->rollover );
</mark><br>1862<mark>                else
</mark><br>1863<mark>                    bmp = m_style->GetToolIcon( tool->GetIconName(), TOOLICON_NORMAL, tool->rollover );
</mark><br>1864<mark>
</mark><br>1865<mark>                if(m_sizefactor > 1.0 ){
</mark><br>1866<mark>                    wxImage scaled_image = bmp.ConvertToImage();
</mark><br>1867<mark>                    bmp = wxBitmap(scaled_image.Scale(tool->m_width, tool->m_height, wxIMAGE_QUALITY_HIGH));
</mark><br>1868<mark>                }
</mark><br>1869<mark>                tool->SetNormalBitmap( bmp );
</mark><br>1870<mark>                tool->bitmapOK = true;
</mark><br>1871<mark>            } else {
</mark><br>1872<mark>                bmp = m_style->GetToolIcon( tool->GetToolname(), TOOLICON_DISABLED );
</mark><br>1873<mark>                if(m_sizefactor > 1.0 ){
</mark><br>1874<mark>                    wxImage scaled_image = bmp.ConvertToImage();
</mark><br>1875<mark>                    bmp = wxBitmap(scaled_image.Scale(tool->m_width, tool->m_height, wxIMAGE_QUALITY_HIGH));
</mark><br>1876<mark>                }
</mark><br>1877<mark>                tool->SetDisabledBitmap( bmp );
</mark><br>1878<mark>                tool->bitmapOK = true;
</mark><br>1879<mark>            }
</mark><br>1880<mark>        }
</mark><br>1881<mark>    }
</mark><br>1882<mark>
</mark><br>1883<mark>    if( tool->firstInLine ) {
</mark><br>1884<mark>        m_style->DrawToolbarLineStart( bmp );
</mark><br>1885<mark>    }
</mark><br>1886<mark>    if( tool->lastInLine ) {
</mark><br>1887<mark>        m_style->DrawToolbarLineEnd( bmp );
</mark><br>1888<mark>    }
</mark><br>1889<mark>
</mark><br>1890<mark>    if( bmp.GetWidth() != m_style->GetToolSize().x
</mark><br>1891<mark>            || bmp.GetHeight() != m_style->GetToolSize().y ) {
</mark><br>1892<mark>//        drawAt.x -= ( bmp.GetWidth() - m_style->GetToolSize().x ) / 2;
</mark><br>1893<mark>//        drawAt.y -= ( bmp.GetHeight() - m_style->GetToolSize().y ) / 2;
</mark><br>1894<mark>    }
</mark><br>1895<mark>
</mark><br>1896<mark>    //      Clear the last drawn tool if necessary
</mark><br>1897<mark>    if( tool->last_rect.width && ((tool->last_rect.x != drawAt.x) || (tool->last_rect.y != drawAt.y)) ){
</mark><br>1898<mark>        wxBrush bb(GetGlobalColor( _T("GREY2") ));
</mark><br>1899<mark>        dc.SetBrush(bb);
</mark><br>1900<mark>        dc.SetPen( *wxTRANSPARENT_PEN );
</mark><br>1901<mark>        dc.DrawRectangle(tool->last_rect.x, tool->last_rect.y, tool->last_rect.width, tool->last_rect.height);
</mark><br>1902<mark>    }
</mark><br>1903<mark>
</mark><br>1904<mark>    //  could cache this in the tool...
</mark><br>1905<mark>    //  A bit of a hack here.  We only scale tools if they are to be magnified globally
</mark><br>1906<mark>    if(0/*m_sizefactor > 1.0*/ )
</mark><br>1907<mark>    {
</mark><br>1908<mark>        wxImage scaled_image = bmp.ConvertToImage();
</mark><br>1909<mark>        wxBitmap sbmp = wxBitmap(scaled_image.Scale(tool->m_width, tool->m_height, wxIMAGE_QUALITY_HIGH));
</mark><br>1910<mark>        dc.DrawBitmap( sbmp, drawAt );
</mark><br>1911<mark>        tool->last_rect = wxRect(drawAt.x, drawAt.y, sbmp.GetWidth(), sbmp.GetHeight());
</mark><br>1912<mark>
</mark><br>1913<mark>    }
</mark><br>1914<mark>    else
</mark><br>1915<mark>    {
</mark><br>1916<mark>        dc.DrawBitmap( bmp, drawAt );
</mark><br>1917<mark>        tool->last_rect = wxRect(drawAt.x, drawAt.y, bmp.GetWidth(), bmp.GetHeight());
</mark><br>1918<mark>    }
</mark><br>1919<mark>
</mark><br>1920<mark>}
</mark><br>1921<mark>
</mark><br>1922<mark>// ----------------------------------------------------------------------------
</mark><br>1923<mark>// toolbar geometry
</mark><br>1924<mark>// ----------------------------------------------------------------------------
</mark><br>1925<mark>
</mark><br>1926<mark>wxToolBarToolBase *ocpnToolBarSimple::FindToolForPosition( wxCoord x, wxCoord y )
</mark><br>1927<mark>{
</mark><br>1928<mark>    wxToolBarToolsList::compatibility_iterator node = m_tools.GetFirst();
</mark><br>1929<mark>    while( node ) {
</mark><br>1930<mark>        ocpnToolBarTool *tool = (ocpnToolBarTool *) node->GetData();
</mark><br>1931<mark>        if( ( x >= tool->m_x ) && ( y >= tool->m_y ) && ( x < ( tool->m_x + tool->GetWidth() ) )
</mark><br>1932<mark>                && ( y < ( tool->m_y + tool->GetHeight() ) ) ) {
</mark><br>1933<mark>            return tool;
</mark><br>1934<mark>        }
</mark><br>1935<mark>
</mark><br>1936<mark>        node = node->GetNext();
</mark><br>1937<mark>    }
</mark><br>1938<mark>
</mark><br>1939<mark>    return (wxToolBarToolBase *) NULL;
</mark><br>1940<mark>}
</mark><br>1941<mark>
</mark><br>1942<mark>void ocpnToolBarSimple::InvalidateBitmaps()
</mark><br>1943<mark>{
</mark><br>1944<mark>    wxToolBarToolsList::compatibility_iterator node = m_tools.GetFirst();
</mark><br>1945<mark>    while( node ) {
</mark><br>1946<mark>        ocpnToolBarTool *tool = (ocpnToolBarTool *) node->GetData();
</mark><br>1947<mark>        tool->bitmapOK = false;
</mark><br>1948<mark>        node = node->GetNext();
</mark><br>1949<mark>    }
</mark><br>1950<mark>}
</mark><br>1951<mark>
</mark><br>1952<mark>wxRect ocpnToolBarSimple::GetToolRect( int tool_id )
</mark><br>1953<mark>{
</mark><br>1954<mark>    wxRect rect;
</mark><br>1955<mark>    wxToolBarToolBase *tool = FindById( tool_id );
</mark><br>1956<mark>    if( tool ) {
</mark><br>1957<mark>        ocpnToolBarTool *otool = (ocpnToolBarTool *) tool;
</mark><br>1958<mark>        if( otool ) rect = otool->trect;
</mark><br>1959<mark>    }
</mark><br>1960<mark>
</mark><br>1961<mark>    return rect;
</mark><br>1962<mark>}
</mark><br>1963<mark>
</mark><br>1964<mark>// ----------------------------------------------------------------------------
</mark><br>1965<mark>// tool state change handlers
</mark><br>1966<mark>// ----------------------------------------------------------------------------
</mark><br>1967<mark>
</mark><br>1968<mark>void ocpnToolBarSimple::DoEnableTool( wxToolBarToolBase *tool, bool WXUNUSED(enable) )
</mark><br>1969<mark>{
</mark><br>1970<mark>    DrawTool( tool );
</mark><br>1971<mark>}
</mark><br>1972<mark>
</mark><br>1973<mark>void ocpnToolBarSimple::DoToggleTool( wxToolBarToolBase *tool, bool WXUNUSED(toggle) )
</mark><br>1974<mark>{
</mark><br>1975<mark>    ocpnToolBarTool *t = (ocpnToolBarTool *) tool;
</mark><br>1976<mark>    t->bitmapOK = false;
</mark><br>1977<mark>    DrawTool( tool );
</mark><br>1978<mark>}
</mark><br>1979<mark>
</mark><br>1980<mark>// Okay, so we've left the tool we're in ... we must check if the tool we're
</mark><br>1981<mark>// leaving was a 'sprung push button' and if so, spring it back to the up
</mark><br>1982<mark>// state.
</mark><br>1983<mark>void ocpnToolBarSimple::SpringUpButton( int id )
</mark><br>1984<mark>{
</mark><br>1985<mark>    wxToolBarToolBase *tool = FindById( id );
</mark><br>1986<mark>
</mark><br>1987<mark>    if( tool && tool->CanBeToggled() ) {
</mark><br>1988<mark>        if( tool->IsToggled() ) tool->Toggle();
</mark><br>1989<mark>
</mark><br>1990<mark>        DrawTool( tool );
</mark><br>1991<mark>    }
</mark><br>1992<mark>}
</mark><br>1993<mark>
</mark><br>1994<mark>// ----------------------------------------------------------------------------
</mark><br>1995<mark>// scrolling implementation
</mark><br>1996<mark>// ----------------------------------------------------------------------------
</mark><br>1997<mark>
</mark><br>1998<mark>wxString ocpnToolBarSimple::GetToolShortHelp( int id ) const
</mark><br>1999<mark>{
</mark><br>2000<mark>    wxToolBarToolBase *tool = FindById( id );
</mark><br>2001<mark>    wxCHECK_MSG( tool, wxEmptyString, _T("no such tool") );
</mark><br>2002<mark>
</mark><br>2003<mark>    return tool->GetShortHelp();
</mark><br>2004<mark>}
</mark><br>2005<mark>
</mark><br>2006<mark>wxString ocpnToolBarSimple::GetToolLongHelp( int id ) const
</mark><br>2007<mark>{
</mark><br>2008<mark>    wxToolBarToolBase *tool = FindById( id );
</mark><br>2009<mark>    wxCHECK_MSG( tool, wxEmptyString, _T("no such tool") );
</mark><br>2010<mark>
</mark><br>2011<mark>    return tool->GetLongHelp();
</mark><br>2012<mark>}
</mark><br>2013<mark>
</mark><br>2014<mark>void ocpnToolBarSimple::SetToolShortHelp( int id, const wxString& help )
</mark><br>2015<mark>{
</mark><br>2016<mark>    wxToolBarToolBase *tool = FindById( id );
</mark><br>2017<mark>    if( tool ) {
</mark><br>2018<mark>        (void) tool->SetShortHelp( help );
</mark><br>2019<mark>    }
</mark><br>2020<mark>}
</mark><br>2021<mark>
</mark><br>2022<mark>void ocpnToolBarSimple::SetToolLongHelp( int id, const wxString& help )
</mark><br>2023<mark>{
</mark><br>2024<mark>    wxToolBarToolBase *tool = FindById( id );
</mark><br>2025<mark>    if( tool ) {
</mark><br>2026<mark>        (void) tool->SetLongHelp( help );
</mark><br>2027<mark>    }
</mark><br>2028<mark>}
</mark><br>2029<mark>
</mark><br>2030<mark>int ocpnToolBarSimple::GetToolPos( int id ) const
</mark><br>2031<mark>{
</mark><br>2032<mark>    size_t pos = 0;
</mark><br>2033<mark>    wxToolBarToolsList::compatibility_iterator node;
</mark><br>2034<mark>
</mark><br>2035<mark>    for( node = m_tools.GetFirst(); node; node = node->GetNext() ) {
</mark><br>2036<mark>        if( node->GetData()->GetId() == id ) return pos;
</mark><br>2037<mark>
</mark><br>2038<mark>        pos++;
</mark><br>2039<mark>    }
</mark><br>2040<mark>
</mark><br>2041<mark>    return wxNOT_FOUND;
</mark><br>2042<mark>}
</mark><br>2043<mark>bool ocpnToolBarSimple::GetToolState( int id ) const
</mark><br>2044<mark>{
</mark><br>2045<mark>    wxToolBarToolBase *tool = FindById( id );
</mark><br>2046<mark>    wxCHECK_MSG( tool, false, _T("no such tool") );
</mark><br>2047<mark>
</mark><br>2048<mark>    return tool->IsToggled();
</mark><br>2049<mark>}
</mark><br>2050<mark>
</mark><br>2051<mark>bool ocpnToolBarSimple::GetToolEnabled( int id ) const
</mark><br>2052<mark>{
</mark><br>2053<mark>    wxToolBarToolBase *tool = FindById( id );
</mark><br>2054<mark>    wxCHECK_MSG( tool, false, _T("no such tool") );
</mark><br>2055<mark>
</mark><br>2056<mark>    return tool->IsEnabled();
</mark><br>2057<mark>}
</mark><br>2058<mark>
</mark><br>2059<mark>void ocpnToolBarSimple::ToggleTool( int id, bool toggle )
</mark><br>2060<mark>{
</mark><br>2061<mark>    wxToolBarToolBase *tool = FindById( id );
</mark><br>2062<mark>        
</mark><br>2063<mark>    if( tool && tool->CanBeToggled() && tool->Toggle( toggle ) ) {
</mark><br>2064<mark>        DoToggleTool( tool, toggle );
</mark><br>2065<mark>        if( g_toolbar ) g_toolbar->Refresh();
</mark><br>2066<mark>    }
</mark><br>2067<mark>}
</mark><br>2068<mark>
</mark><br>2069<mark>wxObject *ocpnToolBarSimple::GetToolClientData( int id ) const
</mark><br>2070<mark>{
</mark><br>2071<mark>    wxToolBarToolBase *tool = FindById( id );
</mark><br>2072<mark>    return tool ? tool->GetClientData() : (wxObject *) NULL;
</mark><br>2073<mark>}
</mark><br>2074<mark>
</mark><br>2075<mark>void ocpnToolBarSimple::SetToolClientData( int id, wxObject *clientData )
</mark><br>2076<mark>{
</mark><br>2077<mark>    wxToolBarToolBase *tool = FindById( id );
</mark><br>2078<mark>
</mark><br>2079<mark>    wxCHECK_RET( tool, _T("no such tool in wxToolBar::SetToolClientData") );
</mark><br>2080<mark>
</mark><br>2081<mark>    tool->SetClientData( clientData );
</mark><br>2082<mark>}
</mark><br>2083<mark>
</mark><br>2084<mark>void ocpnToolBarSimple::EnableTool( int id, bool enable )
</mark><br>2085<mark>{
</mark><br>2086<mark>    wxToolBarToolBase *tool = FindById( id );
</mark><br>2087<mark>    if( tool ) {
</mark><br>2088<mark>        if( tool->Enable( enable ) ) {
</mark><br>2089<mark>            DoEnableTool( tool, enable );
</mark><br>2090<mark>        }
</mark><br>2091<mark>    }
</mark><br>2092<mark>    wxMenuItem* configItem = g_FloatingToolbarConfigMenu->FindItem( id );
</mark><br>2093<mark>    configItem->Check( true );
</mark><br>2094<mark>}
</mark><br>2095<mark>
</mark><br>2096<mark>void ocpnToolBarSimple::SetToolBitmaps( int id, wxBitmap *bmp, wxBitmap *bmpRollover )
</mark><br>2097<mark>{
</mark><br>2098<mark>    ocpnToolBarTool *tool = (ocpnToolBarTool*)FindById( id );
</mark><br>2099<mark>    if( tool ) {
</mark><br>2100<mark>        tool->pluginNormalIcon = bmp;
</mark><br>2101<mark>        tool->pluginRolloverIcon = bmpRollover;
</mark><br>2102<mark>        tool->bitmapOK = false;
</mark><br>2103<mark>    }
</mark><br>2104<mark>}
</mark><br>2105<mark>
</mark><br>2106<mark>void ocpnToolBarSimple::SetToolTooltipHiViz( int id, bool b_hiviz )
</mark><br>2107<mark>{
</mark><br>2108<mark>    ocpnToolBarTool *tool = (ocpnToolBarTool*)FindById( id );
</mark><br>2109<mark>    if( tool ) {
</mark><br>2110<mark>        tool->SetTooltipHiviz( b_hiviz );
</mark><br>2111<mark>    }
</mark><br>2112<mark>}
</mark><br>2113<mark>
</mark><br>2114<mark>
</mark><br>2115<mark>void ocpnToolBarSimple::ClearTools()
</mark><br>2116<mark>{
</mark><br>2117<mark>    while( GetToolsCount() ) {
</mark><br>2118<mark>        DeleteToolByPos( 0 );
</mark><br>2119<mark>    }
</mark><br>2120<mark>}
</mark><br>2121<mark>
</mark><br>2122<mark>int ocpnToolBarSimple::GetVisibleToolCount()
</mark><br>2123<mark>{
</mark><br>2124<mark>    int counter = 0;
</mark><br>2125<mark>    wxToolBarToolsList::compatibility_iterator node = m_tools.GetFirst();
</mark><br>2126<mark>    while( node ) {
</mark><br>2127<mark>        ocpnToolBarTool *tool = (ocpnToolBarTool *) node->GetData();
</mark><br>2128<mark>        counter++;
</mark><br>2129<mark>        node = node->GetNext();
</mark><br>2130<mark>    }
</mark><br>2131<mark>    return counter;
</mark><br>2132<mark>}
</mark><br>2133<mark>
</mark><br>2134<mark>bool ocpnToolBarSimple::DeleteToolByPos( size_t pos )
</mark><br>2135<mark>{
</mark><br>2136<mark>    wxCHECK_MSG( pos < GetToolsCount(), false,
</mark><br>2137<mark>            _T("invalid position in wxToolBar::DeleteToolByPos()") );
</mark><br>2138<mark>
</mark><br>2139<mark>    wxToolBarToolsList::compatibility_iterator node = m_tools.Item( pos );
</mark><br>2140<mark>
</mark><br>2141<mark>    if( !DoDeleteTool( pos, node->GetData() ) ) {
</mark><br>2142<mark>        return false;
</mark><br>2143<mark>    }
</mark><br>2144<mark>
</mark><br>2145<mark>    delete node->GetData();
</mark><br>2146<mark>    m_tools.Erase( node );
</mark><br>2147<mark>
</mark><br>2148<mark>    return true;
</mark><br>2149<mark>}
</mark><br>2150<mark>
</mark><br>2151<mark>bool ocpnToolBarSimple::DeleteTool( int id )
</mark><br>2152<mark>{
</mark><br>2153<mark>    size_t pos = 0;
</mark><br>2154<mark>    wxToolBarToolsList::compatibility_iterator node;
</mark><br>2155<mark>    for( node = m_tools.GetFirst(); node; node = node->GetNext() ) {
</mark><br>2156<mark>        if( node->GetData()->GetId() == id ) break;
</mark><br>2157<mark>
</mark><br>2158<mark>        pos++;
</mark><br>2159<mark>    }
</mark><br>2160<mark>
</mark><br>2161<mark>    if( !node || !DoDeleteTool( pos, node->GetData() ) ) {
</mark><br>2162<mark>        return false;
</mark><br>2163<mark>    }
</mark><br>2164<mark>
</mark><br>2165<mark>    delete node->GetData();
</mark><br>2166<mark>    m_tools.Erase( node );
</mark><br>2167<mark>
</mark><br>2168<mark>    return true;
</mark><br>2169<mark>}
</mark><br>2170<mark>
</mark><br>2171<mark>wxToolBarToolBase *ocpnToolBarSimple::AddSeparator()
</mark><br>2172<mark>{
</mark><br>2173<mark>    return InsertSeparator( GetToolsCount() );
</mark><br>2174<mark>}
</mark><br>2175<mark>
</mark><br>2176<mark>wxToolBarToolBase *ocpnToolBarSimple::InsertSeparator( size_t pos )
</mark><br>2177<mark>{
</mark><br>2178<mark>    wxCHECK_MSG( pos <= GetToolsCount(), (wxToolBarToolBase *)NULL,
</mark><br>2179<mark>            _T("invalid position in wxToolBar::InsertSeparator()") );
</mark><br>2180<mark>
</mark><br>2181<mark>    wxToolBarToolBase *tool = CreateTool( wxID_SEPARATOR, wxEmptyString, wxNullBitmap, wxNullBitmap,
</mark><br>2182<mark>            wxITEM_SEPARATOR, (wxObject *) NULL, wxEmptyString, wxEmptyString );
</mark><br>2183<mark>
</mark><br>2184<mark>    if( !tool || !DoInsertTool( pos, tool ) ) {
</mark><br>2185<mark>        delete tool;
</mark><br>2186<mark>
</mark><br>2187<mark>        return NULL;
</mark><br>2188<mark>    }
</mark><br>2189<mark>
</mark><br>2190<mark>    m_tools.Insert( pos, tool );
</mark><br>2191<mark>
</mark><br>2192<mark>    return tool;
</mark><br>2193<mark>}
</mark><br>2194<mark>
</mark><br>2195<mark>wxToolBarToolBase *ocpnToolBarSimple::RemoveTool( int id )
</mark><br>2196<mark>{
</mark><br>2197<mark>    size_t pos = 0;
</mark><br>2198<mark>    wxToolBarToolsList::compatibility_iterator node;
</mark><br>2199<mark>    for( node = m_tools.GetFirst(); node; node = node->GetNext() ) {
</mark><br>2200<mark>        if( node->GetData()->GetId() == id ) break;
</mark><br>2201<mark>
</mark><br>2202<mark>        pos++;
</mark><br>2203<mark>    }
</mark><br>2204<mark>
</mark><br>2205<mark>    if( !node ) {
</mark><br>2206<mark>        // don't give any error messages - sometimes we might call RemoveTool()
</mark><br>2207<mark>        // without knowing whether the tool is or not in the toolbar
</mark><br>2208<mark>        return (wxToolBarToolBase *) NULL;
</mark><br>2209<mark>    }
</mark><br>2210<mark>
</mark><br>2211<mark>    wxToolBarToolBase *tool = node->GetData();
</mark><br>2212<mark>    if( !DoDeleteTool( pos, tool ) ) {
</mark><br>2213<mark>        return (wxToolBarToolBase *) NULL;
</mark><br>2214<mark>    }
</mark><br>2215<mark>
</mark><br>2216<mark>    m_tools.Erase( node );
</mark><br>2217<mark>
</mark><br>2218<mark>    return tool;
</mark><br>2219<mark>}
</mark><br>2220<mark>
</mark><br>2221<mark>
</mark><br>2222<mark>wxControl *ocpnToolBarSimple::FindControl( int id )
</mark><br>2223<mark>{
</mark><br>2224<mark>    for( wxToolBarToolsList::compatibility_iterator node = m_tools.GetFirst(); node;
</mark><br>2225<mark>            node = node->GetNext() ) {
</mark><br>2226<mark>        const wxToolBarToolBase * const tool = node->GetData();
</mark><br>2227<mark>        if( tool->IsControl() ) {
</mark><br>2228<mark>            wxControl * const control = tool->GetControl();
</mark><br>2229<mark>
</mark><br>2230<mark>            if( !control ) {
</mark><br>2231<mark>                wxFAIL_MSG( _T("NULL control in toolbar?") );
</mark><br>2232<mark>            } else
</mark><br>2233<mark>                if( control->GetId() == id ) {
</mark><br>2234<mark>                    // found
</mark><br>2235<mark>                    return control;
</mark><br>2236<mark>                }
</mark><br>2237<mark>        }
</mark><br>2238<mark>    }
</mark><br>2239<mark>
</mark><br>2240<mark>    return NULL;
</mark><br>2241<mark>}
</mark><br>2242<mark>
</mark><br>2243<mark>wxToolBarToolBase *ocpnToolBarSimple::FindById( int id ) const
</mark><br>2244<mark>{
</mark><br>2245<mark>    wxToolBarToolBase *tool = (wxToolBarToolBase *) NULL;
</mark><br>2246<mark>
</mark><br>2247<mark>    for( wxToolBarToolsList::compatibility_iterator node = m_tools.GetFirst(); node;
</mark><br>2248<mark>            node = node->GetNext() ) {
</mark><br>2249<mark>        tool = node->GetData();
</mark><br>2250<mark>        if( tool->GetId() == id ) {
</mark><br>2251<mark>            // found
</mark><br>2252<mark>            break;
</mark><br>2253<mark>        }
</mark><br>2254<mark>
</mark><br>2255<mark>        tool = NULL;
</mark><br>2256<mark>    }
</mark><br>2257<mark>
</mark><br>2258<mark>    return tool;
</mark><br>2259<mark>}
</mark><br>2260<mark>
</mark><br>2261<mark>// ----------------------------------------------------------------------------
</mark><br>2262<mark>// event processing
</mark><br>2263<mark>// ----------------------------------------------------------------------------
</mark><br>2264<mark>
</mark><br>2265<mark>// Only allow toggle if returns true
</mark><br>2266<mark>bool ocpnToolBarSimple::OnLeftClick( int id, bool toggleDown )
</mark><br>2267<mark>{
</mark><br>2268<mark>    wxCommandEvent event( wxEVT_COMMAND_TOOL_CLICKED, id );
</mark><br>2269<mark>    event.SetEventObject( this );
</mark><br>2270<mark>
</mark><br>2271<mark>    // we use SetInt() to make wxCommandEvent::IsChecked() return toggleDown
</mark><br>2272<mark>    event.SetInt( (int) toggleDown );
</mark><br>2273<mark>
</mark><br>2274<mark>    // and SetExtraLong() for backwards compatibility
</mark><br>2275<mark>    event.SetExtraLong( (long) toggleDown );
</mark><br>2276<mark>
</mark><br>2277<mark>    // Send events to this toolbar instead (and thence up the window hierarchy)
</mark><br>2278<mark>    GetEventHandler()->ProcessEvent( event );
</mark><br>2279<mark>
</mark><br>2280<mark>    return true;
</mark><br>2281<mark>}
</mark><br>2282<mark>
</mark><br>2283<mark>// Call when right button down.
</mark><br>2284<mark>void ocpnToolBarSimple::OnRightClick( int id, long WXUNUSED(x), long WXUNUSED(y) )
</mark><br>2285<mark>{
</mark><br>2286<mark>    wxCommandEvent event( wxEVT_COMMAND_TOOL_RCLICKED, id );
</mark><br>2287<mark>    event.SetEventObject( this );
</mark><br>2288<mark>    event.SetInt( id );
</mark><br>2289<mark>
</mark><br>2290<mark>    HideTooltip();
</mark><br>2291<mark>    ((ocpnFloatingToolbarDialog*)GetParent())->toolbarConfigChanged = false;
</mark><br>2292<mark>    wxMenu* contextMenu = new wxMenu();
</mark><br>2293<mark>    wxMenuItem* submenu = contextMenu->AppendSubMenu( g_FloatingToolbarConfigMenu, _("Visible buttons") );
</mark><br>2294<mark>
</mark><br>2295<mark>    PopupMenu( contextMenu );
</mark><br>2296<mark>
</mark><br>2297<mark>    contextMenu->Remove( submenu );
</mark><br>2298<mark>    delete contextMenu;
</mark><br>2299<mark>
</mark><br>2300<mark>    if( ((ocpnFloatingToolbarDialog*)GetParent())->toolbarConfigChanged )
</mark><br>2301<mark>        gFrame->GetEventHandler()->AddPendingEvent( event );
</mark><br>2302<mark>}
</mark><br>2303<mark>
</mark><br>2304<mark>// Called when the mouse cursor enters a tool bitmap (no button pressed).
</mark><br>2305<mark>// Argument is wxID_ANY if mouse is exiting the toolbar.
</mark><br>2306<mark>// Note that for this event, the id of the window is used,
</mark><br>2307<mark>// and the integer parameter of wxCommandEvent is used to retrieve
</mark><br>2308<mark>// the tool id.
</mark><br>2309<mark>void ocpnToolBarSimple::OnMouseEnter( int id )
</mark><br>2310<mark>{
</mark><br>2311<mark>    wxCommandEvent event( wxEVT_COMMAND_TOOL_ENTER, GetId() );
</mark><br>2312<mark>    event.SetEventObject( this );
</mark><br>2313<mark>    event.SetInt( id );
</mark><br>2314<mark>
</mark><br>2315<mark>    wxFrame *frame = wxDynamicCast(GetParent(), wxFrame);
</mark><br>2316<mark>    if( frame ) {
</mark><br>2317<mark>        wxString help;
</mark><br>2318<mark>        wxToolBarToolBase* tool = id == wxID_ANY ? (wxToolBarToolBase*) NULL : FindById( id );
</mark><br>2319<mark>        if( tool ) help = tool->GetLongHelp();
</mark><br>2320<mark>        frame->DoGiveHelp( help, id != wxID_ANY );
</mark><br>2321<mark>    }
</mark><br>2322<mark>
</mark><br>2323<mark>    (void) GetEventHandler()->ProcessEvent( event );
</mark><br>2324<mark>
</mark><br>2325<mark>    DoPluginToolUp();
</mark><br>2326<mark>}
</mark><br>2327<mark>
</mark><br>2328<mark>void ocpnToolBarSimple::DoPluginToolUp()
</mark><br>2329<mark>{
</mark><br>2330<mark>    //        Look for PlugIn tools
</mark><br>2331<mark>    //        If found, make the callback.
</mark><br>2332<mark>    if( !g_pi_manager)
</mark><br>2333<mark>        return;
</mark><br>2334<mark>
</mark><br>2335<mark>    ArrayOfPlugInToolbarTools tool_array = g_pi_manager->GetPluginToolbarToolArray();
</mark><br>2336<mark>    for( unsigned int i = 0; i < tool_array.GetCount(); i++ ) {
</mark><br>2337<mark>        PlugInToolbarToolContainer *pttc = tool_array.Item( i );
</mark><br>2338<mark>        if( m_last_plugin_down_id == pttc->id ) {
</mark><br>2339<mark>            opencpn_plugin_113 *ppi = dynamic_cast<opencpn_plugin_113 *>(pttc->m_pplugin);
</mark><br>2340<mark>            if( ppi )
</mark><br>2341<mark>                ppi->OnToolbarToolUpCallback( pttc->id );
</mark><br>2342<mark>        }
</mark><br>2343<mark>    }
</mark><br>2344<mark>
</mark><br>2345<mark>    m_last_plugin_down_id = -1;
</mark><br>2346<mark>}
</mark><br>2347<mark>
</mark><br>2348<mark>void ocpnToolBarSimple::SetToolNormalBitmapEx( wxToolBarToolBase *tool, const wxString &iconName)
</mark><br>2349<mark>{
</mark><br>2350<mark>    if( tool ) {
</mark><br>2351<mark>        ocpnToolBarTool *otool = (ocpnToolBarTool *) tool;
</mark><br>2352<mark>        if(otool){
</mark><br>2353<mark>            ocpnStyle::Style *style = g_StyleManager->GetCurrentStyle();
</mark><br>2354<mark>
</mark><br>2355<mark>            wxBitmap bmp = style->GetToolIcon( iconName, TOOLICON_NORMAL );
</mark><br>2356<mark>            if(m_sizefactor > 1.0 ){
</mark><br>2357<mark>                wxImage scaled_image = bmp.ConvertToImage();
</mark><br>2358<mark>                bmp = wxBitmap(scaled_image.Scale(otool->m_width, otool->m_height, wxIMAGE_QUALITY_HIGH));
</mark><br>2359<mark>            }
</mark><br>2360<mark>        
</mark><br>2361<mark>            tool->SetNormalBitmap( bmp );
</mark><br>2362<mark>            otool->SetIconName( iconName );
</mark><br>2363<mark>        }
</mark><br>2364<mark>    }
</mark><br>2365<mark>}
</mark><br>2366<mark>
</mark><br>2367<mark>
</mark><br>2368<mark>//-------------------------------------------------------------------------------------
</mark><br>2369<mark>
</mark><br>2370<mark>ToolbarMOBDialog::ToolbarMOBDialog( wxWindow* parent )
</mark><br>2371<mark>       : wxDialog( parent, wxID_ANY, _("OpenCPN Alert"), wxDefaultPosition, wxSize(250, 230) )
</mark><br>2372<mark>{
</mark><br>2373<mark>    wxBoxSizer* topSizer = new wxBoxSizer( wxVERTICAL );
</mark><br>2374<mark>
</mark><br>2375<mark>    wxBoxSizer* sizer = new wxBoxSizer( wxVERTICAL );
</mark><br>2376<mark>    topSizer->Add( sizer, 0, wxALIGN_CENTER_HORIZONTAL | wxALL, 5 );
</mark><br>2377<mark>
</mark><br>2378<mark>    choices.push_back( new wxRadioButton( this, 0,  _("No, I don't want to hide it."),
</mark><br>2379<mark>            wxDefaultPosition, wxDefaultSize, wxRB_GROUP ) );
</mark><br>2380<mark>
</mark><br>2381<mark>    choices.push_back( new wxRadioButton( this, 1, _("No, and permanently remove the option to hide it."),
</mark><br>2382<mark>            wxDefaultPosition) );
</mark><br>2383<mark>
</mark><br>2384<mark>    choices.push_back( new wxRadioButton( this, 2, _("Yes, hide it."),
</mark><br>2385<mark>            wxDefaultPosition) );
</mark><br>2386<mark>
</mark><br>2387<mark>    wxStdDialogButtonSizer* buttonSizer = CreateStdDialogButtonSizer( wxOK | wxCANCEL );
</mark><br>2388<mark>
</mark><br>2389<mark>
</mark><br>2390<mark>    wxStaticText* textCtrl = new wxStaticText( this, wxID_ANY, _("The Man Over Board button could be an important safety feature.\nAre you sure you want to hide it?") );
</mark><br>2391<mark>
</mark><br>2392<mark>    sizer->Add( textCtrl, 0, wxEXPAND | wxALL, 5 );
</mark><br>2393<mark>    sizer->Add( choices[0], 0, wxEXPAND | wxALL, 5 );
</mark><br>2394<mark>    sizer->Add( choices[1], 0, wxEXPAND | wxALL, 5 );
</mark><br>2395<mark>    sizer->Add( choices[2], 0, wxEXPAND | wxALL, 5 );
</mark><br>2396<mark>    sizer->Add( buttonSizer, 0, wxEXPAND | wxTOP, 5 );
</mark><br>2397<mark>
</mark><br>2398<mark>    topSizer->SetSizeHints(this);
</mark><br>2399<mark>    SetSizer( topSizer );
</mark><br>2400<mark>}
</mark><br>2401<mark>
</mark><br>2402<mark>int ToolbarMOBDialog::GetSelection() {
</mark><br>2403<mark>    for( unsigned int i=0; i<choices.size(); i++ ) {
</mark><br>2404<mark>        if( choices[i]->GetValue() ) return choices[i]->GetId();
</mark><br>2405<mark>    }
</mark><br>2406<mark>    return 0;
</mark><br>2407<mark>}
</mark></p></body>
    </html><html>
    <head></head>
    <body><p><br>1<mark>/***************************************************************************
</mark><br>2<mark> *
</mark><br>3<mark> * Project:  OpenCPN
</mark><br>4<mark> * Purpose:  OpenCPN Toolbar
</mark><br>5<mark> * Author:   David Register
</mark><br>6<mark> *
</mark><br>7<mark> ***************************************************************************
</mark><br>8<mark> *   Copyright (C) 2010 by David S. Register                               *
</mark><br>9<mark> *                                                                         *
</mark><br>10<mark> *   This program is free software; you can redistribute it and/or modify  *
</mark><br>11<mark> *   it under the terms of the GNU General Public License as published by  *
</mark><br>12<mark> *   the Free Software Foundation; either version 2 of the License, or     *
</mark><br>13<mark> *   (at your option) any later version.                                   *
</mark><br>14<mark> *                                                                         *
</mark><br>15<mark> *   This program is distributed in the hope that it will be useful,       *
</mark><br>16<mark> *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
</mark><br>17<mark> *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
</mark><br>18<mark> *   GNU General Public License for more details.                          *
</mark><br>19<mark> *                                                                         *
</mark><br>20<mark> *   You should have received a copy of the GNU General Public License     *
</mark><br>21<mark> *   along with this program; if not, write to the                         *
</mark><br>22<mark> *   Free Software Foundation, Inc.,                                       *
</mark><br>23<mark> *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,  USA.         *
</mark><br>24<mark> **************************************************************************/
</mark><br>25<mark>
</mark><br>26<mark>#include "wx/wxprec.h"
</mark><br>27<mark>
</mark><br>28<mark>#ifndef  WX_PRECOMP
</mark><br>29<mark>#include "wx/wx.h"
</mark><br>30<mark>#endif
</mark><br>31<mark>
</mark><br>32<mark>#include <vector>
</mark><br>33<mark>
</mark><br>34<mark>#include "ocpn_types.h"
</mark><br>35<mark>#include "navutil.h"
</mark><br>36<mark>#include "styles.h"
</mark><br>37<mark>#include "toolbar.h"
</mark><br>38<mark>#include "chart1.h"
</mark><br>39<mark>#include "pluginmanager.h"
</mark><br>40<mark>#include "FontMgr.h"
</mark><br>41<mark>
</mark><br>42<mark>extern ocpnFloatingToolbarDialog* g_FloatingToolbarDialog;
</mark><br>43<mark>extern bool                       g_bTransparentToolbar;
</mark><br>44<mark>extern bool                       g_bTransparentToolbarInOpenGLOK;
</mark><br>45<mark>extern ChartCanvas*               cc1;
</mark><br>46<mark>extern bool                       g_bopengl;
</mark><br>47<mark>extern ocpnToolBarSimple*         g_toolbar;
</mark><br>48<mark>extern ocpnStyle::StyleManager*   g_StyleManager;
</mark><br>49<mark>extern MyFrame*                   gFrame;
</mark><br>50<mark>extern PlugInManager*             g_pi_manager;
</mark><br>51<mark>extern wxMenu*                    g_FloatingToolbarConfigMenu;
</mark><br>52<mark>extern wxString                   g_toolbarConfig;
</mark><br>53<mark>extern bool                       g_bPermanentMOBIcon;
</mark><br>54<mark>extern bool                       g_btouch;
</mark><br>55<mark>extern bool                       g_bsmoothpanzoom;
</mark><br>56<mark>
</mark><br>57<mark>//----------------------------------------------------------------------------
</mark><br>58<mark>// GrabberWindow Implementation
</mark><br>59<mark>//----------------------------------------------------------------------------
</mark><br>60<mark>BEGIN_EVENT_TABLE(GrabberWin, wxPanel) EVT_MOUSE_EVENTS ( GrabberWin::MouseEvent )
</mark><br>61<mark>EVT_PAINT ( GrabberWin::OnPaint )
</mark><br>62<mark>END_EVENT_TABLE()
</mark><br>63<mark>
</mark><br>64<mark>GrabberWin::GrabberWin( wxWindow *parent, ocpnFloatingToolbarDialog *toolbar, float scale_factor, wxString icon_name, wxPoint position ):
</mark><br>65<mark>    wxPanel( parent, wxID_ANY, position, wxDefaultSize, wxNO_BORDER )
</mark><br>66<mark>{
</mark><br>67<mark>    m_icon_name = icon_name;
</mark><br>68<mark>    m_style = g_StyleManager->GetCurrentStyle();
</mark><br>69<mark>    wxBitmap bitmap = m_style->GetIcon( icon_name );
</mark><br>70<mark>    if(scale_factor > 1.0f){
</mark><br>71<mark>        int new_width = bitmap.GetWidth() * scale_factor;
</mark><br>72<mark>        int new_height = bitmap.GetHeight() * scale_factor;
</mark><br>73<mark>        wxImage scaled_image = bitmap.ConvertToImage();
</mark><br>74<mark>        m_bitmap = wxBitmap(scaled_image.Scale(new_width, new_height, wxIMAGE_QUALITY_HIGH));
</mark><br>75<mark>    }
</mark><br>76<mark>    else
</mark><br>77<mark>        m_bitmap = bitmap;
</mark><br>78<mark>
</mark><br>79<mark>    SetSize( wxSize( m_bitmap.GetWidth(), m_bitmap.GetHeight() ) );
</mark><br>80<mark>    SetMinSize( wxSize( m_bitmap.GetWidth(), m_bitmap.GetHeight() ) );
</mark><br>81<mark>
</mark><br>82<mark>    m_bLeftDown = false;
</mark><br>83<mark>    m_bRightDown = false;
</mark><br>84<mark>    m_scale_factor = scale_factor;
</mark><br>85<mark>    m_ptoolbar = toolbar;
</mark><br>86<mark>    m_dragging = false;
</mark><br>87<mark>    Hide();
</mark><br>88<mark>    
</mark><br>89<mark>}
</mark><br>90<mark>
</mark><br>91<mark>
</mark><br>92<mark>void GrabberWin::OnPaint( wxPaintEvent& event )
</mark><br>93<mark>{
</mark><br>94<mark>    wxPaintDC dc( this );
</mark><br>95<mark>    
</mark><br>96<mark>    wxColour back_color = GetGlobalColor( _T("GREY2") );
</mark><br>97<mark>    SetBackgroundColour( back_color );
</mark><br>98<mark>    ClearBackground();
</mark><br>99<mark>    
</mark><br>100<mark>    dc.DrawBitmap( m_bitmap, 0, 0, true );
</mark><br>101<mark>}
</mark><br>102<mark>
</mark><br>103<mark>void GrabberWin::SetColorScheme( ColorScheme cs )
</mark><br>104<mark>{
</mark><br>105<mark>    wxColour back_color = GetGlobalColor( _T("GREY2") );
</mark><br>106<mark>
</mark><br>107<mark>    SetBackgroundColour( back_color );
</mark><br>108<mark>    ClearBackground();
</mark><br>109<mark>
</mark><br>110<mark>    wxBitmap bitmap = m_style->GetIcon( m_icon_name) ;
</mark><br>111<mark>    if(m_scale_factor > 1.0f){
</mark><br>112<mark>        int new_width = bitmap.GetWidth() * m_scale_factor;
</mark><br>113<mark>        int new_height = bitmap.GetHeight() * m_scale_factor;
</mark><br>114<mark>        wxImage scaled_image = bitmap.ConvertToImage();
</mark><br>115<mark>        m_bitmap = wxBitmap(scaled_image.Scale(new_width, new_height, wxIMAGE_QUALITY_HIGH));
</mark><br>116<mark>    }
</mark><br>117<mark>    else
</mark><br>118<mark>        m_bitmap = bitmap;
</mark><br>119<mark>}
</mark><br>120<mark>
</mark><br>121<mark>void GrabberWin::MouseEvent( wxMouseEvent& event )
</mark><br>122<mark>{
</mark><br>123<mark>    static wxPoint s_gspt;
</mark><br>124<mark>    int x, y;
</mark><br>125<mark>
</mark><br>126<mark>    event.GetPosition( &x, &y );
</mark><br>127<mark>
</mark><br>128<mark>    wxPoint spt = ClientToScreen( wxPoint( x, y ) );
</mark><br>129<mark>    if( event.LeftDown() ) {
</mark><br>130<mark>        s_gspt = spt;
</mark><br>131<mark>    }
</mark><br>132<mark>    
</mark><br>133<mark>    
</mark><br>134<mark>#ifndef __WXQT__
</mark><br>135<mark>
</mark><br>136<mark>    if( event.LeftDown() ) {
</mark><br>137<mark>        CaptureMouse();
</mark><br>138<mark>    }
</mark><br>139<mark>
</mark><br>140<mark>    if( event.LeftUp() ) {
</mark><br>141<mark>        if( HasCapture() ) ReleaseMouse();
</mark><br>142<mark>    }
</mark><br>143<mark>
</mark><br>144<mark>#endif
</mark><br>145<mark>
</mark><br>146<mark>
</mark><br>147<mark>    if( event.RightDown() ){
</mark><br>148<mark>        if(m_ptoolbar){
</mark><br>149<mark>            m_dragging = true;
</mark><br>150<mark>            
</mark><br>151<mark>            if( !m_ptoolbar->m_bnavgrabber ){
</mark><br>152<mark>                m_ptoolbar->m_bnavgrabber = true;
</mark><br>153<mark>                m_ptoolbar->SetGrabber(_T("4WayMove") );
</mark><br>154<mark>            }
</mark><br>155<mark>            else{
</mark><br>156<mark>                m_ptoolbar->m_bnavgrabber = false;
</mark><br>157<mark>                m_ptoolbar->SetGrabber(_T("grabber_hi") );
</mark><br>158<mark>            }
</mark><br>159<mark>                
</mark><br>160<mark>        }
</mark><br>161<mark>    }
</mark><br>162<mark>    
</mark><br>163<mark>
</mark><br>164<mark>
</mark><br>165<mark>    if( event.Dragging() ) {
</mark><br>166<mark>        if(m_ptoolbar && m_ptoolbar->IsShown() /*&& m_ptoolbar->m_bnavgrabber*/){
</mark><br>167<mark>            wxPoint par_pos_old = m_ptoolbar->GetPosition();
</mark><br>168<mark>
</mark><br>169<mark>            wxPoint par_pos = par_pos_old;
</mark><br>170<mark>            par_pos.x += spt.x - s_gspt.x;
</mark><br>171<mark>            par_pos.y += spt.y - s_gspt.y;
</mark><br>172<mark>
</mark><br>173<mark>            m_ptoolbar->MoveDialogInScreenCoords( par_pos, par_pos_old );
</mark><br>174<mark>
</mark><br>175<mark>            s_gspt = spt;
</mark><br>176<mark>            m_dragging = true;
</mark><br>177<mark>        }
</mark><br>178<mark>
</mark><br>179<mark>    }
</mark><br>180<mark>
</mark><br>181<mark>    if( event.LeftUp() ) {
</mark><br>182<mark>        if(m_ptoolbar){
</mark><br>183<mark>            if(m_ptoolbar->m_bnavgrabber){
</mark><br>184<mark>                if(!m_dragging)
</mark><br>185<mark>                    m_ptoolbar->ToggleOrientation();
</mark><br>186<mark>            }
</mark><br>187<mark>            else if(!m_dragging){
</mark><br>188<mark>                if(m_ptoolbar->m_bsubmerged){
</mark><br>189<mark>                    m_ptoolbar->SurfaceFromGrabber();
</mark><br>190<mark>                }
</mark><br>191<mark>                else{
</mark><br>192<mark>                    m_ptoolbar->SubmergeToGrabber();
</mark><br>193<mark>                 }
</mark><br>194<mark>            }
</mark><br>195<mark>        }
</mark><br>196<mark>        m_dragging = false;
</mark><br>197<mark>    }
</mark><br>198<mark>    
</mark><br>199<mark>    
</mark><br>200<mark>#ifndef __OCPN__ANDROID__
</mark><br>201<mark>    gFrame->Raise();
</mark><br>202<mark>#endif
</mark><br>203<mark>    
</mark><br>204<mark>}
</mark><br>205<mark>
</mark><br>206<mark>class ocpnToolBarTool: public wxToolBarToolBase {
</mark><br>207<mark>public:
</mark><br>208<mark>    ocpnToolBarTool( ocpnToolBarSimple *tbar, int id, const wxString& label,
</mark><br>209<mark>            const wxBitmap& bmpNormal, const wxBitmap& bmpRollover, wxItemKind kind,
</mark><br>210<mark>            wxObject *clientData, const wxString& shortHelp, const wxString& longHelp ) :
</mark><br>211<mark>            wxToolBarToolBase( (wxToolBarBase*) tbar, id, label, bmpNormal, bmpRollover, kind,
</mark><br>212<mark>                    clientData, shortHelp, longHelp )
</mark><br>213<mark>    {
</mark><br>214<mark>        m_enabled = true;
</mark><br>215<mark>        m_toggled = false;
</mark><br>216<mark>        rollover = false;
</mark><br>217<mark>        bitmapOK = false;
</mark><br>218<mark>        m_btooltip_hiviz = false;
</mark><br>219<mark>
</mark><br>220<mark>        toolname = g_pi_manager->GetToolOwnerCommonName( id );
</mark><br>221<mark>        if( toolname == _T("") ) {
</mark><br>222<mark>            isPluginTool = false;
</mark><br>223<mark>            toolname = label;
</mark><br>224<mark>            iconName = label;
</mark><br>225<mark>        } else {
</mark><br>226<mark>            isPluginTool = true;
</mark><br>227<mark>            pluginNormalIcon = &bmpNormal;
</mark><br>228<mark>            pluginRolloverIcon = &bmpRollover;
</mark><br>229<mark>        }
</mark><br>230<mark>    }
</mark><br>231<mark>
</mark><br>232<mark>    void SetSize( const wxSize& size )
</mark><br>233<mark>    {
</mark><br>234<mark>        m_width = size.x;
</mark><br>235<mark>        m_height = size.y;
</mark><br>236<mark>    }
</mark><br>237<mark>
</mark><br>238<mark>    wxCoord GetWidth() const
</mark><br>239<mark>    {
</mark><br>240<mark>        return m_width;
</mark><br>241<mark>    }
</mark><br>242<mark>
</mark><br>243<mark>    wxCoord GetHeight() const
</mark><br>244<mark>    {
</mark><br>245<mark>        return m_height;
</mark><br>246<mark>    }
</mark><br>247<mark>
</mark><br>248<mark>    wxString GetToolname()
</mark><br>249<mark>    {
</mark><br>250<mark>        return toolname;
</mark><br>251<mark>    }
</mark><br>252<mark>
</mark><br>253<mark>    void SetIconName(wxString name)
</mark><br>254<mark>    {
</mark><br>255<mark>        iconName = name;
</mark><br>256<mark>    }
</mark><br>257<mark>    wxString GetIconName()
</mark><br>258<mark>    {
</mark><br>259<mark>        return iconName;
</mark><br>260<mark>    }
</mark><br>261<mark>
</mark><br>262<mark>    void SetTooltipHiviz( bool enable){ m_btooltip_hiviz = enable; }
</mark><br>263<mark>
</mark><br>264<mark>    wxCoord m_x;
</mark><br>265<mark>    wxCoord m_y;
</mark><br>266<mark>    wxCoord m_width;
</mark><br>267<mark>    wxCoord m_height;
</mark><br>268<mark>    wxRect trect;
</mark><br>269<mark>    wxString toolname;
</mark><br>270<mark>    wxString iconName;
</mark><br>271<mark>    const wxBitmap* pluginNormalIcon;
</mark><br>272<mark>    const wxBitmap* pluginRolloverIcon;
</mark><br>273<mark>    bool firstInLine;
</mark><br>274<mark>    bool lastInLine;
</mark><br>275<mark>    bool rollover;
</mark><br>276<mark>    bool bitmapOK;
</mark><br>277<mark>    bool isPluginTool;
</mark><br>278<mark>    bool b_hilite;
</mark><br>279<mark>    bool m_btooltip_hiviz;
</mark><br>280<mark>    wxRect last_rect;
</mark><br>281<mark>};
</mark><br>282<mark>
</mark><br>283<mark>//---------------------------------------------------------------------------------------
</mark><br>284<mark>//          ocpnFloatingToolbarDialog Implementation
</mark><br>285<mark>//---------------------------------------------------------------------------------------
</mark><br>286<mark>BEGIN_EVENT_TABLE(ocpnFloatingToolbarDialog, wxDialog)
</mark><br>287<mark>    EVT_MOUSE_EVENTS ( ocpnFloatingToolbarDialog::MouseEvent )
</mark><br>288<mark>    EVT_MENU(wxID_ANY, ocpnFloatingToolbarDialog::OnToolLeftClick)
</mark><br>289<mark>    EVT_TIMER ( FADE_TIMER, ocpnFloatingToolbarDialog::FadeTimerEvent )
</mark><br>290<mark>    EVT_TIMER ( DESTROY_TIMER, ocpnFloatingToolbarDialog::DestroyTimerEvent )
</mark><br>291<mark>    EVT_WINDOW_CREATE(ocpnFloatingToolbarDialog::OnWindowCreate)
</mark><br>292<mark>END_EVENT_TABLE()
</mark><br>293<mark>
</mark><br>294<mark>ocpnFloatingToolbarDialog::ocpnFloatingToolbarDialog( wxWindow *parent, wxPoint position,
</mark><br>295<mark>                                                      long orient, float size_factor )
</mark><br>296<mark>{
</mark><br>297<mark>    m_pparent = parent;
</mark><br>298<mark>    long wstyle = wxNO_BORDER | wxFRAME_NO_TASKBAR;
</mark><br>299<mark>#ifndef __WXMAC__
</mark><br>300<mark>    wstyle |= wxFRAME_SHAPED;
</mark><br>301<mark>#endif
</mark><br>302<mark>
</mark><br>303<mark>    m_ptoolbar = NULL;
</mark><br>304<mark>
</mark><br>305<mark>#ifdef __WXOSX__
</mark><br>306<mark>    wstyle |= wxSTAY_ON_TOP;
</mark><br>307<mark>#endif
</mark><br>308<mark>    wxDialog::Create( parent, -1, _T("ocpnToolbarDialog"), wxPoint( -1, -1 ), wxSize( -1, -1 ),
</mark><br>309<mark>            wstyle );
</mark><br>310<mark>
</mark><br>311<mark>    m_opacity = 255;
</mark><br>312<mark>
</mark><br>313<mark>    m_pGrabberwin = new GrabberWin( this, this, size_factor, _T("grabber_hi") );
</mark><br>314<mark>    m_pGrabberwin->Show();
</mark><br>315<mark>    
</mark><br>316<mark>    m_pRecoverwin = NULL;
</mark><br>317<mark>    m_position = position;
</mark><br>318<mark>    m_orient = orient;
</mark><br>319<mark>    m_sizefactor = size_factor;
</mark><br>320<mark>    
</mark><br>321<mark>    m_bAutoHideToolbar = false;
</mark><br>322<mark>    m_nAutoHideToolbar = 5;
</mark><br>323<mark>    
</mark><br>324<mark>
</mark><br>325<mark>    m_style = g_StyleManager->GetCurrentStyle();
</mark><br>326<mark>
</mark><br>327<mark>// A top-level sizer
</mark><br>328<mark>    m_topSizer = new wxBoxSizer( wxHORIZONTAL );
</mark><br>329<mark>    SetSizer( m_topSizer );
</mark><br>330<mark>
</mark><br>331<mark>    //    Set initial "Dock" parameters
</mark><br>332<mark>    m_dock_x = 0;
</mark><br>333<mark>    m_dock_y = 0;
</mark><br>334<mark>    m_block = false;
</mark><br>335<mark>
</mark><br>336<mark>    m_marginsInvisible = m_style->marginsInvisible;
</mark><br>337<mark>
</mark><br>338<mark>//    if(m_sizefactor > 1.0 )
</mark><br>339<mark> //       m_marginsInvisible = true;
</mark><br>340<mark>
</mark><br>341<mark>    m_bnavgrabber = false;    
</mark><br>342<mark>    
</mark><br>343<mark>    Hide();
</mark><br>344<mark>
</mark><br>345<mark>    m_bsubmerged = false;
</mark><br>346<mark>    
</mark><br>347<mark>    m_fade_timer.SetOwner( this, FADE_TIMER );
</mark><br>348<mark>    if( g_bTransparentToolbar )
</mark><br>349<mark>        m_fade_timer.Start( 5000 );
</mark><br>350<mark>    
</mark><br>351<mark>    if( m_bAutoHideToolbar && (m_nAutoHideToolbar > 0))
</mark><br>352<mark>        m_fade_timer.Start( m_nAutoHideToolbar * 1000 );
</mark><br>353<mark>    
</mark><br>354<mark>    m_destroyTimer.SetOwner( this, DESTROY_TIMER );
</mark><br>355<mark>}
</mark><br>356<mark>
</mark><br>357<mark>ocpnFloatingToolbarDialog::~ocpnFloatingToolbarDialog()
</mark><br>358<mark>{
</mark><br>359<mark>    DestroyToolBar();
</mark><br>360<mark>}
</mark><br>361<mark>
</mark><br>362<mark>void ocpnFloatingToolbarDialog::OnWindowCreate( wxWindowCreateEvent& event )
</mark><br>363<mark>{
</mark><br>364<mark>    Realize();
</mark><br>365<mark>}
</mark><br>366<mark>
</mark><br>367<mark>void ocpnFloatingToolbarDialog::SetGrabber( wxString icon_name )
</mark><br>368<mark>{
</mark><br>369<mark>//    m_pGrabberwin->Destroy();
</mark><br>370<mark>    m_pGrabberwin = new GrabberWin( this, this, m_sizefactor, icon_name );
</mark><br>371<mark>    m_pGrabberwin->Show();
</mark><br>372<mark>    
</mark><br>373<mark>    Realize();
</mark><br>374<mark>    
</mark><br>375<mark>#ifdef __WXOSX__    
</mark><br>376<mark>    m_pGrabberwin->Refresh();
</mark><br>377<mark>#endif    
</mark><br>378<mark>    
</mark><br>379<mark>}
</mark><br>380<mark>
</mark><br>381<mark>
</mark><br>382<mark>    
</mark><br>383<mark>void ocpnFloatingToolbarDialog::SetColorScheme( ColorScheme cs )
</mark><br>384<mark>{
</mark><br>385<mark>    m_cs = cs;
</mark><br>386<mark>
</mark><br>387<mark>    wxColour back_color = GetGlobalColor( _T("GREY2") );
</mark><br>388<mark>
</mark><br>389<mark>    //  Set background
</mark><br>390<mark>    SetBackgroundColour( back_color );
</mark><br>391<mark>    ClearBackground();
</mark><br>392<mark>
</mark><br>393<mark>    if( m_ptoolbar ) {
</mark><br>394<mark>        wxColour back_color = GetGlobalColor( _T("GREY2") );
</mark><br>395<mark>
</mark><br>396<mark>        //  Set background
</mark><br>397<mark>        m_ptoolbar->SetBackgroundColour( back_color );
</mark><br>398<mark>        m_ptoolbar->ClearBackground();
</mark><br>399<mark>
</mark><br>400<mark>        m_ptoolbar->SetToggledBackgroundColour( GetGlobalColor( _T("GREY1") ) );
</mark><br>401<mark>
</mark><br>402<mark>        m_ptoolbar->SetColorScheme( cs );
</mark><br>403<mark>        m_ptoolbar->Refresh( true );
</mark><br>404<mark>    }
</mark><br>405<mark>
</mark><br>406<mark>    if( m_pGrabberwin ) m_pGrabberwin->SetColorScheme( cs );
</mark><br>407<mark>
</mark><br>408<mark>}
</mark><br>409<mark>
</mark><br>410<mark>void ocpnFloatingToolbarDialog::SetGeometry(bool bAvoid, wxRect rectAvoid)
</mark><br>411<mark>{
</mark><br>412<mark>
</mark><br>413<mark>    if( m_ptoolbar ) {
</mark><br>414<mark>        wxSize style_tool_size = m_style->GetToolSize();
</mark><br>415<mark>
</mark><br>416<mark>        style_tool_size.x *= m_sizefactor;
</mark><br>417<mark>        style_tool_size.y *= m_sizefactor;
</mark><br>418<mark>
</mark><br>419<mark>        m_ptoolbar->SetToolBitmapSize( style_tool_size );
</mark><br>420<mark>
</mark><br>421<mark>        wxSize tool_size = m_ptoolbar->GetToolBitmapSize();
</mark><br>422<mark>        int grabber_width =  m_style->GetIcon( _T("grabber") ).GetWidth();
</mark><br>423<mark>        
</mark><br>424<mark>        int max_rows = 10;
</mark><br>425<mark>        int max_cols = 100;
</mark><br>426<mark>        if(cc1){
</mark><br>427<mark>
</mark><br>428<mark>            int avoid_start = cc1->GetClientSize().x - (tool_size.x + m_style->GetToolSeparation()) * 2;  // default
</mark><br>429<mark>            if(bAvoid && !rectAvoid.IsEmpty()){
</mark><br>430<mark>                avoid_start = cc1->GetClientSize().x - rectAvoid.width - 10;  // this is compass window, if shown
</mark><br>431<mark>            }
</mark><br>432<mark>            
</mark><br>433<mark>            
</mark><br>434<mark>            max_rows = (cc1->GetClientSize().y / ( tool_size.y + m_style->GetToolSeparation())) - 1;
</mark><br>435<mark>            
</mark><br>436<mark>            max_cols = (avoid_start - grabber_width) / ( tool_size.x + m_style->GetToolSeparation());
</mark><br>437<mark>            max_cols -= 1;
</mark><br>438<mark>            
</mark><br>439<mark>            if(m_orient == wxTB_VERTICAL)
</mark><br>440<mark>                max_rows = wxMax( max_rows, 2);             // at least two rows
</mark><br>441<mark>            else
</mark><br>442<mark>                max_cols = wxMax( max_cols, 2);             // at least two columns
</mark><br>443<mark>        }
</mark><br>444<mark>
</mark><br>445<mark>        if( m_orient == wxTB_VERTICAL )
</mark><br>446<mark>            m_ptoolbar->SetMaxRowsCols(max_rows, 100);
</mark><br>447<mark>        else
</mark><br>448<mark>            m_ptoolbar->SetMaxRowsCols( 100, max_cols);
</mark><br>449<mark>        m_ptoolbar->SetSizeFactor(m_sizefactor);
</mark><br>450<mark>        
</mark><br>451<mark>    }
</mark><br>452<mark> }
</mark><br>453<mark>
</mark><br>454<mark>void ocpnFloatingToolbarDialog::RePosition()
</mark><br>455<mark>{
</mark><br>456<mark>    if(m_block) return;
</mark><br>457<mark>
</mark><br>458<mark>    if( m_pparent && m_ptoolbar ) {
</mark><br>459<mark>        wxSize cs = m_pparent->GetClientSize();
</mark><br>460<mark>        if( -1 == m_dock_x ) m_position.x = 0;
</mark><br>461<mark>        else
</mark><br>462<mark>            if( 1 == m_dock_x ) m_position.x = cs.x - GetSize().x;
</mark><br>463<mark>
</mark><br>464<mark>        if( -1 == m_dock_y ) m_position.y = 0;
</mark><br>465<mark>        else
</mark><br>466<mark>            if( 1 == m_dock_y ) m_position.y = cs.y - GetSize().y;
</mark><br>467<mark>
</mark><br>468<mark>        m_position.x = wxMin(cs.x - GetSize().x, m_position.x);
</mark><br>469<mark>        m_position.y = wxMin(cs.y - GetSize().y, m_position.y);
</mark><br>470<mark>
</mark><br>471<mark>        m_position.x = wxMax(0, m_position.x);
</mark><br>472<mark>        m_position.y = wxMax(0, m_position.y);
</mark><br>473<mark>
</mark><br>474<mark>        wxPoint screen_pos = m_pparent->ClientToScreen( m_position );
</mark><br>475<mark>
</mark><br>476<mark>        Move( screen_pos );
</mark><br>477<mark>
</mark><br>478<mark>#ifdef __WXQT__
</mark><br>479<mark>        Raise();
</mark><br>480<mark>#endif
</mark><br>481<mark>
</mark><br>482<mark>    }
</mark><br>483<mark>}
</mark><br>484<mark>
</mark><br>485<mark>void ocpnFloatingToolbarDialog::Submerge()
</mark><br>486<mark>{
</mark><br>487<mark>    m_bsubmerged = true;
</mark><br>488<mark>    Hide();
</mark><br>489<mark>    if( m_ptoolbar ) m_ptoolbar->KillTooltip();
</mark><br>490<mark>}
</mark><br>491<mark>
</mark><br>492<mark>void ocpnFloatingToolbarDialog::SubmergeToGrabber()
</mark><br>493<mark>{
</mark><br>494<mark>//Submerge();
</mark><br>495<mark>    m_bsubmerged = true;
</mark><br>496<mark>    Hide();
</mark><br>497<mark>    if( m_ptoolbar ) m_ptoolbar->KillTooltip();
</mark><br>498<mark>
</mark><br>499<mark>    m_pRecoverwin = new GrabberWin( m_pparent, this, m_sizefactor, _T("grabber_ext" ), wxPoint(10,10) );
</mark><br>500<mark>   
</mark><br>501<mark>    m_pRecoverwin->Show();
</mark><br>502<mark>    m_pRecoverwin->Raise();
</mark><br>503<mark>#ifdef __WXQT__
</mark><br>504<mark>    wxSize s = gFrame->GetSize();
</mark><br>505<mark>    m_recoversize = s;
</mark><br>506<mark>    s.y--;
</mark><br>507<mark>    gFrame->TriggerResize(s);
</mark><br>508<mark>    Raise();
</mark><br>509<mark>#endif    
</mark><br>510<mark>
</mark><br>511<mark>    gFrame->Refresh();          // Needed for MSW OpenGL
</mark><br>512<mark>}
</mark><br>513<mark>
</mark><br>514<mark>void ocpnFloatingToolbarDialog::Surface()
</mark><br>515<mark>{
</mark><br>516<mark>    
</mark><br>517<mark>    if(m_pRecoverwin){
</mark><br>518<mark>        m_pRecoverwin->Show();
</mark><br>519<mark>        m_pRecoverwin->Raise();
</mark><br>520<mark>    }
</mark><br>521<mark>    else {
</mark><br>522<mark>        m_bsubmerged = false;
</mark><br>523<mark>        #ifndef __WXOSX__
</mark><br>524<mark>        Hide();
</mark><br>525<mark>        Move( 0, 0 );
</mark><br>526<mark>        #endif
</mark><br>527<mark>
</mark><br>528<mark>        RePosition();
</mark><br>529<mark>        Show();
</mark><br>530<mark>        if( m_ptoolbar )
</mark><br>531<mark>            m_ptoolbar->EnableTooltips();
</mark><br>532<mark>
</mark><br>533<mark>        #ifdef __WXQT__
</mark><br>534<mark>        Raise();
</mark><br>535<mark>        #endif
</mark><br>536<mark>    }
</mark><br>537<mark>    
</mark><br>538<mark>    if( m_bAutoHideToolbar && (m_nAutoHideToolbar > 0) ){
</mark><br>539<mark>        m_fade_timer.Start( m_nAutoHideToolbar * 1000 );
</mark><br>540<mark>    }
</mark><br>541<mark>}
</mark><br>542<mark>
</mark><br>543<mark>bool ocpnFloatingToolbarDialog::CheckSurfaceRequest( wxMouseEvent &event )
</mark><br>544<mark>{
</mark><br>545<mark>    if( m_bsubmerged ){
</mark><br>546<mark>        if( event.LeftUp() ){
</mark><br>547<mark>            int x,y;
</mark><br>548<mark>            event.GetPosition( &x, &y );
</mark><br>549<mark>            if( m_pRecoverwin ){
</mark><br>550<mark>                wxRect winRect = m_pRecoverwin->GetRect();
</mark><br>551<mark>                if( winRect.Contains( x, y ) ){
</mark><br>552<mark>                    SurfaceFromGrabber();
</mark><br>553<mark>                    return true;
</mark><br>554<mark>                }
</mark><br>555<mark>            }
</mark><br>556<mark>        }
</mark><br>557<mark>    }
</mark><br>558<mark>    
</mark><br>559<mark>    return false;
</mark><br>560<mark>}
</mark><br>561<mark>        
</mark><br>562<mark>void ocpnFloatingToolbarDialog::SurfaceFromGrabber()
</mark><br>563<mark>{
</mark><br>564<mark>    m_bsubmerged = false;
</mark><br>565<mark>    
</mark><br>566<mark>#ifndef __WXOSX__
</mark><br>567<mark>    Hide();
</mark><br>568<mark>    Move( 0, 0 );
</mark><br>569<mark>#endif
</mark><br>570<mark>
</mark><br>571<mark>    if( m_ptoolbar )
</mark><br>572<mark>        m_ptoolbar->InvalidateBitmaps();
</mark><br>573<mark>    
</mark><br>574<mark>    RePosition();
</mark><br>575<mark>    Show();
</mark><br>576<mark>    if( m_ptoolbar )
</mark><br>577<mark>        m_ptoolbar->EnableTooltips();
</mark><br>578<mark>    
</mark><br>579<mark>    if( m_bAutoHideToolbar && (m_nAutoHideToolbar > 0) ){
</mark><br>580<mark>        m_fade_timer.Start( m_nAutoHideToolbar * 1000 );
</mark><br>581<mark>    }
</mark><br>582<mark>    
</mark><br>583<mark>#ifdef __WXQT__
</mark><br>584<mark>    wxSize s = gFrame->GetSize();               // check for rotation
</mark><br>585<mark>    if(m_recoversize.x == s.x)
</mark><br>586<mark>        gFrame->TriggerResize(m_recoversize);
</mark><br>587<mark>    Raise();
</mark><br>588<mark>#endif
</mark><br>589<mark>    
</mark><br>590<mark>    m_destroyGrabber = m_pRecoverwin;
</mark><br>591<mark>    m_destroyTimer.Start( 5, wxTIMER_ONE_SHOT );           //  Destor the unneeded recovery grabber
</mark><br>592<mark>    
</mark><br>593<mark>}
</mark><br>594<mark>
</mark><br>595<mark>void ocpnFloatingToolbarDialog::DestroyTimerEvent( wxTimerEvent& event )
</mark><br>596<mark>{
</mark><br>597<mark>    delete m_destroyGrabber;
</mark><br>598<mark>    m_destroyGrabber = NULL;
</mark><br>599<mark>    m_pRecoverwin = NULL;
</mark><br>600<mark>}
</mark><br>601<mark>
</mark><br>602<mark>void ocpnFloatingToolbarDialog::HideTooltip()
</mark><br>603<mark>{
</mark><br>604<mark>    if( m_ptoolbar ) m_ptoolbar->HideTooltip();
</mark><br>605<mark>}
</mark><br>606<mark>
</mark><br>607<mark>void ocpnFloatingToolbarDialog::ShowTooltips()
</mark><br>608<mark>{
</mark><br>609<mark>    if( m_ptoolbar ) m_ptoolbar->EnableTooltips();
</mark><br>610<mark>}
</mark><br>611<mark>
</mark><br>612<mark>void ocpnFloatingToolbarDialog::ToggleOrientation()
</mark><br>613<mark>{
</mark><br>614<mark>    if( m_orient == wxTB_HORIZONTAL )
</mark><br>615<mark>        m_orient = wxTB_VERTICAL;
</mark><br>616<mark>    else
</mark><br>617<mark>        m_orient = wxTB_HORIZONTAL;
</mark><br>618<mark>
</mark><br>619<mark>    m_style->SetOrientation( m_orient );
</mark><br>620<mark>
</mark><br>621<mark>    wxPoint old_screen_pos = m_pparent->ClientToScreen( m_position );
</mark><br>622<mark>    wxPoint grabber_point_abs = ClientToScreen( m_pGrabberwin->GetPosition() );
</mark><br>623<mark>
</mark><br>624<mark>    gFrame->RequestNewToolbar();
</mark><br>625<mark>    wxPoint pos_abs = grabber_point_abs;
</mark><br>626<mark>    pos_abs.x -= m_pGrabberwin->GetPosition().x;
</mark><br>627<mark>    MoveDialogInScreenCoords( pos_abs, old_screen_pos );
</mark><br>628<mark>
</mark><br>629<mark>
</mark><br>630<mark>    Show();   // this seems to be necessary on GTK to kick the sizer into gear...(FS#553)
</mark><br>631<mark>    Refresh(true);
</mark><br>632<mark>    Raise();
</mark><br>633<mark>}
</mark><br>634<mark>
</mark><br>635<mark>void ocpnFloatingToolbarDialog::MouseEvent( wxMouseEvent& event )
</mark><br>636<mark>{
</mark><br>637<mark>    if( g_bTransparentToolbar ) {
</mark><br>638<mark>        if( event.Entering() && ( m_opacity < 255 ) ) {
</mark><br>639<mark>            SetTransparent( 255 );
</mark><br>640<mark>            m_opacity = 255;
</mark><br>641<mark>        }
</mark><br>642<mark>
</mark><br>643<mark>        m_fade_timer.Start( 5000 );           // retrigger the continuous timer
</mark><br>644<mark>    }
</mark><br>645<mark>    
</mark><br>646<mark>    if(m_bAutoHideToolbar && (m_nAutoHideToolbar > 0) ){
</mark><br>647<mark>        m_fade_timer.Start( m_nAutoHideToolbar * 1000 );
</mark><br>648<mark>    }
</mark><br>649<mark>}
</mark><br>650<mark>
</mark><br>651<mark>void ocpnFloatingToolbarDialog::FadeTimerEvent( wxTimerEvent& event )
</mark><br>652<mark>{
</mark><br>653<mark>    if(m_bnavgrabber){
</mark><br>654<mark>        m_fade_timer.Start( 5000 );           // do nothing if nav grabber is shown
</mark><br>655<mark>    }
</mark><br>656<mark>    else{
</mark><br>657<mark>        if( g_bTransparentToolbar && (!g_bopengl || g_bTransparentToolbarInOpenGLOK) ){
</mark><br>658<mark>            DoFade( 128 );
</mark><br>659<mark>            m_fade_timer.Start( 5000 );           // retrigger the continuous timer
</mark><br>660<mark>        }
</mark><br>661<mark>        
</mark><br>662<mark>        if(m_bAutoHideToolbar && (m_nAutoHideToolbar > 0) && !m_bsubmerged){
</mark><br>663<mark>            SubmergeToGrabber();
</mark><br>664<mark>//            m_fade_timer.Stop();
</mark><br>665<mark>        }
</mark><br>666<mark>    }
</mark><br>667<mark>}
</mark><br>668<mark>
</mark><br>669<mark>void ocpnFloatingToolbarDialog::SetAutoHideTimer(int time)
</mark><br>670<mark>{
</mark><br>671<mark>    m_nAutoHideToolbar = time;
</mark><br>672<mark>    if(m_bAutoHideToolbar){
</mark><br>673<mark>        m_fade_timer.Stop();
</mark><br>674<mark>        m_fade_timer.Start( m_nAutoHideToolbar * 1000 );
</mark><br>675<mark>    }
</mark><br>676<mark>}
</mark><br>677<mark>        
</mark><br>678<mark>void ocpnFloatingToolbarDialog::DoFade( int value )
</mark><br>679<mark>{
</mark><br>680<mark>    if( value != m_opacity ) SetTransparent( value );
</mark><br>681<mark>    m_opacity = value;
</mark><br>682<mark>}
</mark><br>683<mark>
</mark><br>684<mark>void ocpnFloatingToolbarDialog::RefreshFadeTimer()
</mark><br>685<mark>{
</mark><br>686<mark>    SetTransparent( 255 );
</mark><br>687<mark>    m_opacity = 255;
</mark><br>688<mark>    m_fade_timer.Start( 500 );           // retrigger the continuous timer
</mark><br>689<mark>    
</mark><br>690<mark>    if(m_bAutoHideToolbar && (m_nAutoHideToolbar > 0) ){
</mark><br>691<mark>        m_fade_timer.Start( m_nAutoHideToolbar * 1000 );
</mark><br>692<mark>    }
</mark><br>693<mark>    
</mark><br>694<mark>}
</mark><br>695<mark>
</mark><br>696<mark>void ocpnFloatingToolbarDialog::MoveDialogInScreenCoords( wxPoint posn, wxPoint posn_old )
</mark><br>697<mark>{
</mark><br>698<mark>    wxPoint pos_in_parent = m_pparent->ScreenToClient( posn );
</mark><br>699<mark>    wxPoint pos_in_parent_old = m_pparent->ScreenToClient( posn_old );
</mark><br>700<mark>
</mark><br>701<mark>    //    "Docking" support
</mark><br>702<mark>#define DOCK_MARGIN 40
</mark><br>703<mark>
</mark><br>704<mark>    // X
</mark><br>705<mark>    m_dock_x = 0;
</mark><br>706<mark>    if( pos_in_parent.x < pos_in_parent_old.x )            // moving left
</mark><br>707<mark>            {
</mark><br>708<mark>        if( pos_in_parent.x < DOCK_MARGIN ) {
</mark><br>709<mark>            pos_in_parent.x = 0;
</mark><br>710<mark>            m_dock_x = -1;
</mark><br>711<mark>        }
</mark><br>712<mark>    } else
</mark><br>713<mark>        if( pos_in_parent.x > pos_in_parent_old.x )            // moving right
</mark><br>714<mark>                {
</mark><br>715<mark>            int max_right = m_pparent->GetClientSize().x - GetSize().x;
</mark><br>716<mark>            if( pos_in_parent.x > ( max_right - DOCK_MARGIN ) ) {
</mark><br>717<mark>                pos_in_parent.x = max_right;
</mark><br>718<mark>                m_dock_x = 1;
</mark><br>719<mark>            }
</mark><br>720<mark>        }
</mark><br>721<mark>
</mark><br>722<mark>    // Y
</mark><br>723<mark>    m_dock_y = 0;
</mark><br>724<mark>    if( pos_in_parent.y < pos_in_parent_old.y )            // moving up
</mark><br>725<mark>            {
</mark><br>726<mark>        if( pos_in_parent.y < DOCK_MARGIN ) {
</mark><br>727<mark>            pos_in_parent.y = 0;
</mark><br>728<mark>            m_dock_y = -1;
</mark><br>729<mark>        }
</mark><br>730<mark>    } else
</mark><br>731<mark>        if( pos_in_parent.y > pos_in_parent_old.y )            // moving down
</mark><br>732<mark>                {
</mark><br>733<mark>            int max_down = m_pparent->GetClientSize().y - GetSize().y;
</mark><br>734<mark>            if( pos_in_parent.y > ( max_down - DOCK_MARGIN ) ) {
</mark><br>735<mark>                pos_in_parent.y = max_down;
</mark><br>736<mark>                m_dock_y = 1;
</mark><br>737<mark>            }
</mark><br>738<mark>        }
</mark><br>739<mark>
</mark><br>740<mark>    m_position = pos_in_parent;
</mark><br>741<mark>
</mark><br>742<mark>    wxPoint final_pos = m_pparent->ClientToScreen( pos_in_parent );
</mark><br>743<mark>
</mark><br>744<mark>    Move( final_pos );
</mark><br>745<mark>}
</mark><br>746<mark>
</mark><br>747<mark>void ocpnFloatingToolbarDialog::Realize()
</mark><br>748<mark>{
</mark><br>749<mark>    if( m_ptoolbar ) {
</mark><br>750<mark>        m_ptoolbar->Realize();
</mark><br>751<mark>
</mark><br>752<mark>        m_topSizer->Clear();
</mark><br>753<mark>        m_topSizer->Add( m_ptoolbar );
</mark><br>754<mark>        m_topSizer->Add( m_pGrabberwin, 0, wxTOP, m_style->GetTopMargin() );
</mark><br>755<mark>
</mark><br>756<mark>        m_topSizer->Layout();
</mark><br>757<mark>        Fit();
</mark><br>758<mark>
</mark><br>759<mark>        //    Update "Dock" parameters
</mark><br>760<mark>        if( m_position.x == 0 ) m_dock_x = -1;
</mark><br>761<mark>        else
</mark><br>762<mark>            if( m_position.x == m_pparent->GetClientSize().x - GetSize().x ) m_dock_x = 1;
</mark><br>763<mark>
</mark><br>764<mark>        if( m_position.y == 0 ) m_dock_y = -1;
</mark><br>765<mark>        else
</mark><br>766<mark>            if( m_position.y == m_pparent->GetClientSize().y - GetSize().y ) m_dock_y = 1;
</mark><br>767<mark>
</mark><br>768<mark>        // Now create a bitmap mask forthe frame shape.
</mark><br>769<mark>
</mark><br>770<mark>        if( m_marginsInvisible ) {
</mark><br>771<mark>
</mark><br>772<mark>            wxSize tool_size = m_ptoolbar->GetToolBitmapSize();
</mark><br>773<mark>
</mark><br>774<mark>            //  Determine whether the tool icons are meant (by style) to join without speces between
</mark><br>775<mark>            //  This will determine what type of region to draw.
</mark><br>776<mark>            bool b_overlap = false;
</mark><br>777<mark>
</mark><br>778<mark>            wxToolBarToolsList::compatibility_iterator node1 = m_ptoolbar->m_tools.GetFirst();
</mark><br>779<mark>            wxToolBarToolsList::compatibility_iterator node2 = node1->GetNext() ;
</mark><br>780<mark>
</mark><br>781<mark>            wxToolBarToolBase *tool1 = node1->GetData();
</mark><br>782<mark>            ocpnToolBarTool *tools1 = (ocpnToolBarTool *) tool1;
</mark><br>783<mark>
</mark><br>784<mark>            wxToolBarToolBase *tool2 = node2->GetData();
</mark><br>785<mark>            ocpnToolBarTool *tools2 = (ocpnToolBarTool *) tool2;
</mark><br>786<mark>
</mark><br>787<mark>            if( (tools1->m_x + tools1->m_width) >= tools2->m_x)
</mark><br>788<mark>                b_overlap = true;
</mark><br>789<mark>
</mark><br>790<mark>
</mark><br>791<mark>
</mark><br>792<mark>
</mark><br>793<mark>            int toolCount = m_ptoolbar->GetVisibleToolCount();
</mark><br>794<mark>
</mark><br>795<mark>            wxPoint upperLeft( m_style->GetLeftMargin(), m_style->GetTopMargin() );
</mark><br>796<mark>            wxSize visibleSize;
</mark><br>797<mark>            if( m_ptoolbar->IsVertical() ) {
</mark><br>798<mark>                int noTools = m_ptoolbar->GetMaxRows();
</mark><br>799<mark>                if( noTools > toolCount )
</mark><br>800<mark>                    noTools = toolCount;
</mark><br>801<mark>                visibleSize.x = m_ptoolbar->GetLineCount() * ( tool_size.x + m_style->GetTopMargin() );
</mark><br>802<mark>                visibleSize.y = noTools * ( tool_size.y + m_style->GetToolSeparation() );
</mark><br>803<mark>                visibleSize.x -= m_style->GetTopMargin();
</mark><br>804<mark>                visibleSize.y -= m_style->GetToolSeparation();
</mark><br>805<mark>            } else {
</mark><br>806<mark>                    int noTools = m_ptoolbar->GetMaxCols();
</mark><br>807<mark>                    if( noTools > toolCount )
</mark><br>808<mark>                        noTools = toolCount;
</mark><br>809<mark>                visibleSize.x = noTools * ( tool_size.x + m_style->GetToolSeparation() );
</mark><br>810<mark>                visibleSize.y = m_ptoolbar->GetLineCount() * ( tool_size.y + m_style->GetTopMargin() );
</mark><br>811<mark>                visibleSize.x -= m_style->GetToolSeparation();
</mark><br>812<mark>                visibleSize.y -= m_style->GetTopMargin();
</mark><br>813<mark>            }
</mark><br>814<mark>
</mark><br>815<mark>            wxBitmap shape( visibleSize.x + tool_size.x, visibleSize.y + tool_size.y);          // + fluff
</mark><br>816<mark>            wxMemoryDC sdc( shape );
</mark><br>817<mark>            sdc.SetBackground( *wxWHITE_BRUSH );
</mark><br>818<mark>            sdc.SetBrush( *wxBLACK_BRUSH );
</mark><br>819<mark>            sdc.SetPen( *wxBLACK_PEN );
</mark><br>820<mark>            sdc.Clear();
</mark><br>821<mark>
</mark><br>822<mark>            if(b_overlap) {
</mark><br>823<mark>                int lines = m_ptoolbar->GetLineCount();
</mark><br>824<mark>                for( int i = 1; i <= lines; i++ ) {
</mark><br>825<mark>                    if( m_ptoolbar->IsVertical() ) {
</mark><br>826<mark>                        wxSize barsize( tool_size.x, visibleSize.y );
</mark><br>827<mark>                        if( i == lines && i > 1 ) {
</mark><br>828<mark>                            int toolsInLastLine = toolCount % m_ptoolbar->GetMaxRows();
</mark><br>829<mark>                            if( toolsInLastLine == 0 ) toolsInLastLine = m_ptoolbar->GetMaxRows();
</mark><br>830<mark>                            int emptySpace = ( m_ptoolbar->GetMaxRows() - toolsInLastLine );
</mark><br>831<mark>                            barsize.y -= emptySpace
</mark><br>832<mark>                            * ( tool_size.y + m_style->GetToolSeparation() );
</mark><br>833<mark>                        }
</mark><br>834<mark>                        if( i == lines ) {
</mark><br>835<mark>                            // Also do grabber here, since it is to the right of the last line.
</mark><br>836<mark>                            wxRect grabMask( upperLeft, barsize );
</mark><br>837<mark>                            grabMask.width += m_style->GetIcon( _T("grabber") ).GetWidth();
</mark><br>838<mark>                            grabMask.height = m_style->GetIcon( _T("grabber") ).GetHeight();
</mark><br>839<mark>                            sdc.DrawRoundedRectangle( grabMask, m_style->GetToolbarCornerRadius() );
</mark><br>840<mark>                        }
</mark><br>841<mark>                        sdc.DrawRoundedRectangle( upperLeft, barsize,
</mark><br>842<mark>                                m_style->GetToolbarCornerRadius() );
</mark><br>843<mark>                        upperLeft.x += m_style->GetTopMargin() + tool_size.x;
</mark><br>844<mark>                    } else {
</mark><br>845<mark>                        wxSize barsize( visibleSize.x, tool_size.y );
</mark><br>846<mark>
</mark><br>847<mark>                        if( i == 1 ) {
</mark><br>848<mark>                            barsize.x += m_style->GetIcon( _T("grabber") ).GetWidth();
</mark><br>849<mark>                        }
</mark><br>850<mark>                        if( i == lines && i > 1 ) {
</mark><br>851<mark>                            int toolsInLastLine = toolCount % m_ptoolbar->GetMaxCols();
</mark><br>852<mark>                            if( toolsInLastLine == 0 ) toolsInLastLine = m_ptoolbar->GetMaxCols();
</mark><br>853<mark>                            int emptySpace = ( m_ptoolbar->GetMaxCols() - toolsInLastLine );
</mark><br>854<mark>                            barsize.x -= emptySpace * ( tool_size.x + m_style->GetToolSeparation() );
</mark><br>855<mark>                        }
</mark><br>856<mark>
</mark><br>857<mark>                        sdc.DrawRoundedRectangle( upperLeft, barsize,
</mark><br>858<mark>                                m_style->GetToolbarCornerRadius() );
</mark><br>859<mark>                        upperLeft.y += m_style->GetTopMargin() + tool_size.y;
</mark><br>860<mark>                    }
</mark><br>861<mark>                }
</mark><br>862<mark>            } //b_overlap
</mark><br>863<mark>            else {
</mark><br>864<mark>                for( wxToolBarToolsList::compatibility_iterator node = m_ptoolbar->m_tools.GetFirst(); node; node = node->GetNext() ) {
</mark><br>865<mark>                    wxToolBarToolBase *tool = node->GetData();
</mark><br>866<mark>                    ocpnToolBarTool *tools = (ocpnToolBarTool *) tool;
</mark><br>867<mark>                    wxRect toolRect = tools->trect;
</mark><br>868<mark>
</mark><br>869<mark>                    sdc.DrawRoundedRectangle( tools->m_x, tools->m_y, tool_size.x, tool_size.y,
</mark><br>870<mark>                                              m_style->GetToolbarCornerRadius() );
</mark><br>871<mark>                }
</mark><br>872<mark>            }
</mark><br>873<mark>
</mark><br>874<mark>#ifndef __OCPN__ANDROID__
</mark><br>875<mark>            if(shape.GetWidth() && shape.GetHeight())
</mark><br>876<mark>                SetShape( wxRegion( shape, *wxWHITE, 10 ) );
</mark><br>877<mark>#endif
</mark><br>878<mark>        }
</mark><br>879<mark>    }
</mark><br>880<mark>}
</mark><br>881<mark>
</mark><br>882<mark>void ocpnFloatingToolbarDialog::OnToolLeftClick( wxCommandEvent& event )
</mark><br>883<mark>{
</mark><br>884<mark>    // First see if it was actually the context menu that was clicked.
</mark><br>885<mark>
</mark><br>886<mark>    if( event.GetId() >= ID_PLUGIN_BASE + 100 ) {
</mark><br>887<mark>
</mark><br>888<mark>        int itemId = event.GetId() - ID_PLUGIN_BASE - 100;
</mark><br>889<mark>        wxMenuItem *item = g_FloatingToolbarConfigMenu->FindItem( event.GetId() );
</mark><br>890<mark>
</mark><br>891<mark>        if(item){
</mark><br>892<mark>            bool toolIsChecked = item->IsChecked();
</mark><br>893<mark>
</mark><br>894<mark>            if( toolIsChecked ) {
</mark><br>895<mark>                g_toolbarConfig.SetChar( itemId, _T('X') );
</mark><br>896<mark>            } else {
</mark><br>897<mark>
</mark><br>898<mark>                if( itemId + ID_ZOOMIN == ID_MOB ) {
</mark><br>899<mark>                    ToolbarMOBDialog mdlg( this );
</mark><br>900<mark>                    int dialog_ret = mdlg.ShowModal();
</mark><br>901<mark>                    int answer = mdlg.GetSelection();
</mark><br>902<mark>
</mark><br>903<mark>                    if( answer == 0 || answer == 1 || dialog_ret == wxID_CANCEL ) {
</mark><br>904<mark>                        g_FloatingToolbarConfigMenu->FindItem( event.GetId() )->Check( true );
</mark><br>905<mark>                        if( answer == 1 && dialog_ret == wxID_OK ) {
</mark><br>906<mark>                            g_bPermanentMOBIcon = true;
</mark><br>907<mark>                            delete g_FloatingToolbarConfigMenu;
</mark><br>908<mark>                            g_FloatingToolbarConfigMenu = new wxMenu();
</mark><br>909<mark>                            toolbarConfigChanged = true;
</mark><br>910<mark>                        }
</mark><br>911<mark>                        return;
</mark><br>912<mark>                    }
</mark><br>913<mark>                }
</mark><br>914<mark>
</mark><br>915<mark>                if( m_ptoolbar->GetVisibleToolCount() == 1 ) {
</mark><br>916<mark>                    OCPNMessageBox( this,
</mark><br>917<mark>                            _("You can't hide the last tool from the toolbar\nas this would make it inaccessible."),
</mark><br>918<mark>                            _("OpenCPN Alert"), wxOK );
</mark><br>919<mark>                    g_FloatingToolbarConfigMenu->FindItem( event.GetId() )->Check( true );
</mark><br>920<mark>                    return;
</mark><br>921<mark>                }
</mark><br>922<mark>
</mark><br>923<mark>                g_toolbarConfig.SetChar( itemId, _T('.') );
</mark><br>924<mark>            }
</mark><br>925<mark>        }
</mark><br>926<mark>
</mark><br>927<mark>        toolbarConfigChanged = true;
</mark><br>928<mark>        return;
</mark><br>929<mark>    }
</mark><br>930<mark>
</mark><br>931<mark>    // No it was a button that was clicked.
</mark><br>932<mark>    // Since Dialog events don't propagate automatically, we send it explicitly
</mark><br>933<mark>    // (instead of relying on event.Skip()). Send events up the window hierarchy
</mark><br>934<mark>
</mark><br>935<mark>    m_pparent->GetEventHandler()->AddPendingEvent( event );
</mark><br>936<mark>#ifndef __WXQT__
</mark><br>937<mark>    gFrame->Raise();
</mark><br>938<mark>#endif    
</mark><br>939<mark>}
</mark><br>940<mark>
</mark><br>941<mark>ocpnToolBarSimple *ocpnFloatingToolbarDialog::GetToolbar()
</mark><br>942<mark>{
</mark><br>943<mark>    if( !m_ptoolbar ) {
</mark><br>944<mark>        long winstyle = wxNO_BORDER | wxTB_FLAT;
</mark><br>945<mark>        winstyle |= m_orient;
</mark><br>946<mark>
</mark><br>947<mark>        m_ptoolbar = new ocpnToolBarSimple( this, -1, wxPoint( -1, -1 ), wxSize( -1, -1 ),
</mark><br>948<mark>                winstyle );
</mark><br>949<mark>
</mark><br>950<mark>        m_ptoolbar->SetBackgroundColour( GetGlobalColor( _T("GREY2") ) );
</mark><br>951<mark>        m_ptoolbar->ClearBackground();
</mark><br>952<mark>        m_ptoolbar->SetToggledBackgroundColour( GetGlobalColor( _T("GREY1") ) );
</mark><br>953<mark>        m_ptoolbar->SetColorScheme( m_cs );
</mark><br>954<mark>
</mark><br>955<mark>        SetGeometry(false, wxRect());
</mark><br>956<mark>    }
</mark><br>957<mark>
</mark><br>958<mark>    return m_ptoolbar;
</mark><br>959<mark>}
</mark><br>960<mark>
</mark><br>961<mark>void ocpnFloatingToolbarDialog::DestroyToolBar()
</mark><br>962<mark>{
</mark><br>963<mark>    if( m_ptoolbar ) {
</mark><br>964<mark>        m_ptoolbar->ClearTools();
</mark><br>965<mark>        delete m_ptoolbar;                  //->Destroy();
</mark><br>966<mark>        m_ptoolbar = NULL;
</mark><br>967<mark>    }
</mark><br>968<mark> 
</mark><br>969<mark>    m_destroyGrabber = m_pRecoverwin;
</mark><br>970<mark>    m_destroyTimer.Start( 5, wxTIMER_ONE_SHOT );           //  Destor the unneeded recovery grabber
</mark><br>971<mark>    
</mark><br>972<mark>}
</mark><br>973<mark>
</mark><br>974<mark>//----------------------------------------------------------------------------
</mark><br>975<mark>// Toolbar Tooltip Popup Window Definition
</mark><br>976<mark>//----------------------------------------------------------------------------
</mark><br>977<mark>class ToolTipWin: public wxDialog {
</mark><br>978<mark>public:
</mark><br>979<mark>    ToolTipWin( wxWindow *parent );
</mark><br>980<mark>    ~ToolTipWin();
</mark><br>981<mark>
</mark><br>982<mark>    void OnPaint( wxPaintEvent& event );
</mark><br>983<mark>
</mark><br>984<mark>    void SetColorScheme( ColorScheme cs );
</mark><br>985<mark>    void SetString( wxString &s )
</mark><br>986<mark>    {
</mark><br>987<mark>        m_string = s;
</mark><br>988<mark>    }
</mark><br>989<mark>    void SetPosition( wxPoint pt )
</mark><br>990<mark>    {
</mark><br>991<mark>        m_position = pt;
</mark><br>992<mark>    }
</mark><br>993<mark>    void SetBitmap( void );
</mark><br>994<mark>
</mark><br>995<mark>    void SetHiviz( bool hiviz){ m_hiviz = hiviz; }
</mark><br>996<mark>    
</mark><br>997<mark>    wxSize GetRenderedSize( void );
</mark><br>998<mark>    
</mark><br>999<mark>private:
</mark><br>1000<mark>
</mark><br>1001<mark>    wxString m_string;
</mark><br>1002<mark>    wxSize m_size;
</mark><br>1003<mark>    wxPoint m_position;
</mark><br>1004<mark>    wxBitmap *m_pbm;
</mark><br>1005<mark>    wxColour m_back_color;
</mark><br>1006<mark>    wxColour m_text_color;
</mark><br>1007<mark>    ColorScheme m_cs ;
</mark><br>1008<mark>    bool m_hiviz;
</mark><br>1009<mark>
</mark><br>1010<mark>DECLARE_EVENT_TABLE()
</mark><br>1011<mark>};
</mark><br>1012<mark>//-----------------------------------------------------------------------
</mark><br>1013<mark>//
</mark><br>1014<mark>//    Toolbar Tooltip window implementation
</mark><br>1015<mark>//
</mark><br>1016<mark>//-----------------------------------------------------------------------
</mark><br>1017<mark>BEGIN_EVENT_TABLE(ToolTipWin, wxDialog) EVT_PAINT(ToolTipWin::OnPaint)
</mark><br>1018<mark>
</mark><br>1019<mark>END_EVENT_TABLE()
</mark><br>1020<mark>
</mark><br>1021<mark>// Define a constructor
</mark><br>1022<mark>ToolTipWin::ToolTipWin( wxWindow *parent ) :
</mark><br>1023<mark>        wxDialog( parent, wxID_ANY, _T(""), wxPoint( 0, 0 ), wxSize( 1, 1 ),
</mark><br>1024<mark>                wxNO_BORDER | wxSTAY_ON_TOP )
</mark><br>1025<mark>{
</mark><br>1026<mark>    m_pbm = NULL;
</mark><br>1027<mark>
</mark><br>1028<mark>    m_back_color = GetGlobalColor( _T ( "UIBCK" ) );
</mark><br>1029<mark>    m_text_color = GetGlobalColor( _T ( "UITX1" ) );
</mark><br>1030<mark>
</mark><br>1031<mark>    SetBackgroundStyle( wxBG_STYLE_CUSTOM );
</mark><br>1032<mark>    SetBackgroundColour( m_back_color );
</mark><br>1033<mark>    m_cs = GLOBAL_COLOR_SCHEME_RGB;
</mark><br>1034<mark>
</mark><br>1035<mark>    Hide();
</mark><br>1036<mark>}
</mark><br>1037<mark>
</mark><br>1038<mark>ToolTipWin::~ToolTipWin()
</mark><br>1039<mark>{
</mark><br>1040<mark>    delete m_pbm;
</mark><br>1041<mark>}
</mark><br>1042<mark>
</mark><br>1043<mark>void ToolTipWin::SetColorScheme( ColorScheme cs )
</mark><br>1044<mark>{
</mark><br>1045<mark>    m_back_color = GetGlobalColor( _T ( "UIBCK" ) );
</mark><br>1046<mark>    m_text_color = FontMgr::Get().GetFontColor( _("ToolTips") );
</mark><br>1047<mark>
</mark><br>1048<mark>    m_cs = cs;
</mark><br>1049<mark>}
</mark><br>1050<mark>
</mark><br>1051<mark>wxSize ToolTipWin::GetRenderedSize( void )
</mark><br>1052<mark>{
</mark><br>1053<mark>    int h, w;
</mark><br>1054<mark>    wxSize sz;
</mark><br>1055<mark>
</mark><br>1056<mark>    wxClientDC cdc( GetParent() );
</mark><br>1057<mark>
</mark><br>1058<mark>    wxFont *plabelFont = FontMgr::Get().GetFont( _("ToolTips") );
</mark><br>1059<mark>    cdc.GetTextExtent( m_string, &w, &h, NULL, NULL, plabelFont );
</mark><br>1060<mark>
</mark><br>1061<mark>    sz.x = w + 8;
</mark><br>1062<mark>    sz.y = h + 4;
</mark><br>1063<mark>    
</mark><br>1064<mark>    return sz;
</mark><br>1065<mark>
</mark><br>1066<mark>}
</mark><br>1067<mark>
</mark><br>1068<mark>void ToolTipWin::SetBitmap()
</mark><br>1069<mark>{
</mark><br>1070<mark>    int h, w;
</mark><br>1071<mark>
</mark><br>1072<mark>    wxClientDC cdc( GetParent() );
</mark><br>1073<mark>
</mark><br>1074<mark>    wxFont *plabelFont = FontMgr::Get().GetFont( _("ToolTips") );
</mark><br>1075<mark>    cdc.GetTextExtent( m_string, &w, &h, NULL, NULL, plabelFont );
</mark><br>1076<mark>
</mark><br>1077<mark>    m_size.x = w + 8;
</mark><br>1078<mark>    m_size.y = h + 4;
</mark><br>1079<mark>
</mark><br>1080<mark>    wxMemoryDC mdc;
</mark><br>1081<mark>
</mark><br>1082<mark>    delete m_pbm;
</mark><br>1083<mark>    m_pbm = new wxBitmap( m_size.x, m_size.y, -1 );
</mark><br>1084<mark>    mdc.SelectObject( *m_pbm );
</mark><br>1085<mark>
</mark><br>1086<mark>    wxPen pborder( m_text_color );
</mark><br>1087<mark>    wxBrush bback( m_back_color );
</mark><br>1088<mark>    mdc.SetPen( pborder );
</mark><br>1089<mark>    mdc.SetBrush( bback );
</mark><br>1090<mark>
</mark><br>1091<mark>    if(m_hiviz){
</mark><br>1092<mark>        if((m_cs == GLOBAL_COLOR_SCHEME_DUSK) || (m_cs == GLOBAL_COLOR_SCHEME_NIGHT)){
</mark><br>1093<mark>            wxBrush hv_back( wxColour(200,200,200));
</mark><br>1094<mark>            mdc.SetBrush( hv_back );
</mark><br>1095<mark>        }
</mark><br>1096<mark>    }
</mark><br>1097<mark>    mdc.DrawRectangle( 0, 0, m_size.x, m_size.y );
</mark><br>1098<mark>
</mark><br>1099<mark>    //    Draw the text
</mark><br>1100<mark>    mdc.SetFont( *plabelFont );
</mark><br>1101<mark>    mdc.SetTextForeground( m_text_color );
</mark><br>1102<mark>    mdc.SetTextBackground( m_back_color );
</mark><br>1103<mark>
</mark><br>1104<mark>    mdc.DrawText( m_string, 4, 2 );
</mark><br>1105<mark>
</mark><br>1106<mark>    SetSize( m_position.x, m_position.y, m_size.x, m_size.y );
</mark><br>1107<mark>
</mark><br>1108<mark>}
</mark><br>1109<mark>
</mark><br>1110<mark>void ToolTipWin::OnPaint( wxPaintEvent& event )
</mark><br>1111<mark>{
</mark><br>1112<mark>    int width, height;
</mark><br>1113<mark>    GetClientSize( &width, &height );
</mark><br>1114<mark>    wxPaintDC dc( this );
</mark><br>1115<mark>
</mark><br>1116<mark>    if( m_string.Len() ) {
</mark><br>1117<mark>        wxMemoryDC mdc;
</mark><br>1118<mark>        mdc.SelectObject( *m_pbm );
</mark><br>1119<mark>        dc.Blit( 0, 0, width, height, &mdc, 0, 0 );
</mark><br>1120<mark>    }
</mark><br>1121<mark>}
</mark><br>1122<mark>
</mark><br>1123<mark>
</mark><br>1124<mark>// ----------------------------------------------------------------------------
</mark><br>1125<mark>BEGIN_EVENT_TABLE(ocpnToolBarSimple, wxControl) EVT_SIZE(ocpnToolBarSimple::OnSize)
</mark><br>1126<mark>EVT_PAINT(ocpnToolBarSimple::OnPaint)
</mark><br>1127<mark>EVT_KILL_FOCUS(ocpnToolBarSimple::OnKillFocus)
</mark><br>1128<mark>EVT_MOUSE_EVENTS(ocpnToolBarSimple::OnMouseEvent)
</mark><br>1129<mark>EVT_TIMER(TOOLTIPON_TIMER, ocpnToolBarSimple::OnToolTipTimerEvent)
</mark><br>1130<mark>EVT_TIMER(TOOLTIPOFF_TIMER, ocpnToolBarSimple::OnToolTipOffTimerEvent)
</mark><br>1131<mark>
</mark><br>1132<mark>END_EVENT_TABLE()
</mark><br>1133<mark>
</mark><br>1134<mark>// ============================================================================
</mark><br>1135<mark>// implementation
</mark><br>1136<mark>// ============================================================================
</mark><br>1137<mark>
</mark><br>1138<mark>// ----------------------------------------------------------------------------
</mark><br>1139<mark>// tool bar tools creation
</mark><br>1140<mark>// ----------------------------------------------------------------------------
</mark><br>1141<mark>
</mark><br>1142<mark>wxToolBarToolBase *ocpnToolBarSimple::CreateTool( int id, const wxString& label,
</mark><br>1143<mark>        const wxBitmap& bmpNormal, const wxBitmap& bmpDisabled, wxItemKind kind,
</mark><br>1144<mark>        wxObject *clientData, const wxString& shortHelp, const wxString& longHelp )
</mark><br>1145<mark>{
</mark><br>1146<mark>    return new ocpnToolBarTool( this, id, label, bmpNormal, bmpDisabled, kind, clientData,
</mark><br>1147<mark>            shortHelp, longHelp );
</mark><br>1148<mark>}
</mark><br>1149<mark>
</mark><br>1150<mark>// ----------------------------------------------------------------------------
</mark><br>1151<mark>// ocpnToolBarSimple creation
</mark><br>1152<mark>// ----------------------------------------------------------------------------
</mark><br>1153<mark>
</mark><br>1154<mark>void ocpnToolBarSimple::Init()
</mark><br>1155<mark>{
</mark><br>1156<mark>    m_currentRowsOrColumns = 0;
</mark><br>1157<mark>
</mark><br>1158<mark>    m_lastX = m_lastY = 0;
</mark><br>1159<mark>
</mark><br>1160<mark>    m_maxWidth = m_maxHeight = 0;
</mark><br>1161<mark>
</mark><br>1162<mark>    m_pressedTool = m_currentTool = -1;
</mark><br>1163<mark>
</mark><br>1164<mark>    m_xPos = m_yPos = wxDefaultCoord;
</mark><br>1165<mark>
</mark><br>1166<mark>    m_style = g_StyleManager->GetCurrentStyle();
</mark><br>1167<mark>
</mark><br>1168<mark>    m_defaultWidth = 16;
</mark><br>1169<mark>    m_defaultHeight = 15;
</mark><br>1170<mark>
</mark><br>1171<mark>    m_toggle_bg_color = wxSystemSettings::GetColour( wxSYS_COLOUR_3DFACE );
</mark><br>1172<mark>    m_toolOutlineColour.Set( _T("BLACK") );
</mark><br>1173<mark>    m_pToolTipWin = NULL;
</mark><br>1174<mark>    m_last_ro_tool = NULL;
</mark><br>1175<mark>
</mark><br>1176<mark>    m_btoolbar_is_zooming = false;
</mark><br>1177<mark>    m_sizefactor = 1.0f;
</mark><br>1178<mark>
</mark><br>1179<mark>    m_last_plugin_down_id = -1;
</mark><br>1180<mark>    
</mark><br>1181<mark>    EnableTooltips();
</mark><br>1182<mark>}
</mark><br>1183<mark>
</mark><br>1184<mark>wxToolBarToolBase *ocpnToolBarSimple::DoAddTool( int id, const wxString& label,
</mark><br>1185<mark>        const wxBitmap& bitmap, const wxBitmap& bmpDisabled, wxItemKind kind,
</mark><br>1186<mark>        const wxString& shortHelp, const wxString& longHelp, wxObject *clientData, wxCoord xPos,
</mark><br>1187<mark>        wxCoord yPos )
</mark><br>1188<mark>{
</mark><br>1189<mark>    // rememeber the position for DoInsertTool()
</mark><br>1190<mark>    m_xPos = xPos;
</mark><br>1191<mark>    m_yPos = yPos;
</mark><br>1192<mark>
</mark><br>1193<mark>    InvalidateBestSize();
</mark><br>1194<mark>    return InsertTool( GetToolsCount(), id, label, bitmap, bmpDisabled, kind, shortHelp, longHelp,
</mark><br>1195<mark>            clientData );
</mark><br>1196<mark>
</mark><br>1197<mark>}
</mark><br>1198<mark>
</mark><br>1199<mark>///
</mark><br>1200<mark>
</mark><br>1201<mark>wxToolBarToolBase *ocpnToolBarSimple::AddTool( int toolid, const wxString& label,
</mark><br>1202<mark>        const wxBitmap& bitmap, const wxBitmap& bmpDisabled, wxItemKind kind,
</mark><br>1203<mark>        const wxString& shortHelp, const wxString& longHelp, wxObject *data )
</mark><br>1204<mark>{
</mark><br>1205<mark>    InvalidateBestSize();
</mark><br>1206<mark>    ocpnToolBarTool* tool = (ocpnToolBarTool*)InsertTool( GetToolsCount(), toolid, label, bitmap, bmpDisabled, kind,
</mark><br>1207<mark>            shortHelp, longHelp, data );
</mark><br>1208<mark>    return tool;
</mark><br>1209<mark>}
</mark><br>1210<mark>
</mark><br>1211<mark>wxToolBarToolBase *ocpnToolBarSimple::InsertTool( size_t pos, int id, const wxString& label,
</mark><br>1212<mark>        const wxBitmap& bitmap, const wxBitmap& bmpDisabled, wxItemKind kind,
</mark><br>1213<mark>        const wxString& shortHelp, const wxString& longHelp, wxObject *clientData )
</mark><br>1214<mark>{
</mark><br>1215<mark>    wxCHECK_MSG( pos <= GetToolsCount(), (wxToolBarToolBase *)NULL,
</mark><br>1216<mark>            _T("invalid position in wxToolBar::InsertTool()") );
</mark><br>1217<mark>
</mark><br>1218<mark>    wxToolBarToolBase *tool = CreateTool( id, label, bitmap, bmpDisabled, kind, clientData,
</mark><br>1219<mark>            shortHelp, longHelp );
</mark><br>1220<mark>
</mark><br>1221<mark>    if( !InsertTool( pos, tool ) ) {
</mark><br>1222<mark>        delete tool;
</mark><br>1223<mark>
</mark><br>1224<mark>        return NULL;
</mark><br>1225<mark>    }
</mark><br>1226<mark>
</mark><br>1227<mark>    return tool;
</mark><br>1228<mark>}
</mark><br>1229<mark>
</mark><br>1230<mark>wxToolBarToolBase *ocpnToolBarSimple::InsertTool( size_t pos, wxToolBarToolBase *tool )
</mark><br>1231<mark>{
</mark><br>1232<mark>    wxCHECK_MSG( pos <= GetToolsCount(), (wxToolBarToolBase *)NULL,
</mark><br>1233<mark>            _T("invalid position in wxToolBar::InsertTool()") );
</mark><br>1234<mark>
</mark><br>1235<mark>    if( !tool || !DoInsertTool( pos, tool ) ) {
</mark><br>1236<mark>        return NULL;
</mark><br>1237<mark>    }
</mark><br>1238<mark>
</mark><br>1239<mark>    m_tools.Insert( pos, tool );
</mark><br>1240<mark>
</mark><br>1241<mark>    return tool;
</mark><br>1242<mark>}
</mark><br>1243<mark>
</mark><br>1244<mark>bool ocpnToolBarSimple::DoInsertTool( size_t WXUNUSED(pos), wxToolBarToolBase *toolBase )
</mark><br>1245<mark>{
</mark><br>1246<mark>    ocpnToolBarTool *tool = (ocpnToolBarTool *) toolBase;
</mark><br>1247<mark>
</mark><br>1248<mark>    // Check if the plugin is inserting same-named tools. Make sure they have different names,
</mark><br>1249<mark>    // otherwise the style manager cannot differentiate between them.
</mark><br>1250<mark>    if( tool->isPluginTool ) {
</mark><br>1251<mark>        for( unsigned int i=0; i<GetToolsCount(); i++ ) {
</mark><br>1252<mark>            if( tool->GetToolname() == ((ocpnToolBarTool *)m_tools.Item(i)->GetData())->GetToolname()) {
</mark><br>1253<mark>                tool->toolname << _T("1");
</mark><br>1254<mark>            }
</mark><br>1255<mark>        }
</mark><br>1256<mark>    }
</mark><br>1257<mark>
</mark><br>1258<mark>    tool->m_x = m_xPos;
</mark><br>1259<mark>    if( tool->m_x == wxDefaultCoord ) tool->m_x = m_style->GetLeftMargin();
</mark><br>1260<mark>
</mark><br>1261<mark>    tool->m_y = m_yPos;
</mark><br>1262<mark>    if( tool->m_y == wxDefaultCoord ) tool->m_y = m_style->GetTopMargin();
</mark><br>1263<mark>
</mark><br>1264<mark>    if( tool->IsButton() ) {
</mark><br>1265<mark>        tool->SetSize( GetToolSize() );
</mark><br>1266<mark>
</mark><br>1267<mark>        // Calculate reasonable max size in case Layout() not called
</mark><br>1268<mark>        if( ( tool->m_x + tool->GetNormalBitmap().GetWidth() + m_style->GetLeftMargin() )
</mark><br>1269<mark>                > m_maxWidth ) m_maxWidth = (wxCoord) ( ( tool->m_x + tool->GetWidth()
</mark><br>1270<mark>                + m_style->GetLeftMargin() ) );
</mark><br>1271<mark>
</mark><br>1272<mark>        if( ( tool->m_y + tool->GetNormalBitmap().GetHeight() + m_style->GetTopMargin() )
</mark><br>1273<mark>                > m_maxHeight ) m_maxHeight = (wxCoord) ( ( tool->m_y + tool->GetHeight()
</mark><br>1274<mark>                + m_style->GetTopMargin() ) );
</mark><br>1275<mark>    }
</mark><br>1276<mark>
</mark><br>1277<mark>    else
</mark><br>1278<mark>        if( tool->IsControl() ) {
</mark><br>1279<mark>            tool->SetSize( tool->GetControl()->GetSize() );
</mark><br>1280<mark>        }
</mark><br>1281<mark>
</mark><br>1282<mark>    tool->b_hilite = false;
</mark><br>1283<mark>
</mark><br>1284<mark>    return true;
</mark><br>1285<mark>}
</mark><br>1286<mark>
</mark><br>1287<mark>bool ocpnToolBarSimple::DoDeleteTool( size_t WXUNUSED(pos), wxToolBarToolBase *tool )
</mark><br>1288<mark>{
</mark><br>1289<mark>    // VZ: didn't test whether it works, but why not...
</mark><br>1290<mark>    tool->Detach();
</mark><br>1291<mark>
</mark><br>1292<mark>    if( m_last_ro_tool == tool ) m_last_ro_tool = NULL;
</mark><br>1293<mark>
</mark><br>1294<mark>    Refresh( false );
</mark><br>1295<mark>
</mark><br>1296<mark>    return true;
</mark><br>1297<mark>}
</mark><br>1298<mark>
</mark><br>1299<mark>bool ocpnToolBarSimple::Create( wxWindow *parent, wxWindowID id, const wxPoint& pos,
</mark><br>1300<mark>        const wxSize& size, long style, const wxString& name )
</mark><br>1301<mark>{
</mark><br>1302<mark>    if( !wxWindow::Create( parent, id, pos, size, style, name ) ) return false;
</mark><br>1303<mark>
</mark><br>1304<mark>    // Set it to grey (or other 3D face colour)
</mark><br>1305<mark>    SetBackgroundColour( wxSystemSettings::GetColour( wxSYS_COLOUR_3DFACE ) );
</mark><br>1306<mark>
</mark><br>1307<mark>    if( GetWindowStyleFlag() & wxTB_VERTICAL ) {
</mark><br>1308<mark>        m_lastX = 7;
</mark><br>1309<mark>        m_lastY = 3;
</mark><br>1310<mark>
</mark><br>1311<mark>        m_maxRows = 32000;      // a lot
</mark><br>1312<mark>        m_maxCols = 1;
</mark><br>1313<mark>    } else {
</mark><br>1314<mark>        m_lastX = 3;
</mark><br>1315<mark>        m_lastY = 7;
</mark><br>1316<mark>
</mark><br>1317<mark>        m_maxRows = 1;
</mark><br>1318<mark>        m_maxCols = 32000;      // a lot
</mark><br>1319<mark>    }
</mark><br>1320<mark>
</mark><br>1321<mark>    SetCursor( *wxSTANDARD_CURSOR );
</mark><br>1322<mark>
</mark><br>1323<mark>    m_tooltip_timer.SetOwner( this, TOOLTIPON_TIMER );
</mark><br>1324<mark>    m_tooltipoff_timer.SetOwner( this, TOOLTIPOFF_TIMER );
</mark><br>1325<mark>    m_tooltip_off = 3000;
</mark><br>1326<mark>
</mark><br>1327<mark>    return true;
</mark><br>1328<mark>}
</mark><br>1329<mark>
</mark><br>1330<mark>ocpnToolBarSimple::~ocpnToolBarSimple()
</mark><br>1331<mark>{
</mark><br>1332<mark>    if( m_pToolTipWin ) {
</mark><br>1333<mark>        m_pToolTipWin->Destroy();
</mark><br>1334<mark>        m_pToolTipWin = NULL;
</mark><br>1335<mark>    }
</mark><br>1336<mark>
</mark><br>1337<mark>}
</mark><br>1338<mark>
</mark><br>1339<mark>void ocpnToolBarSimple::KillTooltip()
</mark><br>1340<mark>{
</mark><br>1341<mark>    m_btooltip_show = false;
</mark><br>1342<mark>
</mark><br>1343<mark>    if( m_pToolTipWin ) {
</mark><br>1344<mark>        m_pToolTipWin->Hide();
</mark><br>1345<mark>        m_pToolTipWin->Destroy();
</mark><br>1346<mark>        m_pToolTipWin = NULL;
</mark><br>1347<mark>    }
</mark><br>1348<mark>    m_tooltip_timer.Stop();
</mark><br>1349<mark>
</mark><br>1350<mark>    if( m_last_ro_tool ) {
</mark><br>1351<mark>        if( m_last_ro_tool->IsEnabled() ) {
</mark><br>1352<mark>            if( m_last_ro_tool->IsToggled() ) {
</mark><br>1353<mark>                m_last_ro_tool->SetNormalBitmap( m_style->GetToolIcon( m_last_ro_tool->GetToolname(), TOOLICON_TOGGLED ) );
</mark><br>1354<mark>            }
</mark><br>1355<mark>            else {
</mark><br>1356<mark>                m_last_ro_tool->SetNormalBitmap( m_style->GetToolIcon( m_last_ro_tool->GetToolname(), TOOLICON_NORMAL ) );
</mark><br>1357<mark>            }
</mark><br>1358<mark>        }
</mark><br>1359<mark>    }
</mark><br>1360<mark>}
</mark><br>1361<mark>
</mark><br>1362<mark>void ocpnToolBarSimple::HideTooltip()
</mark><br>1363<mark>{
</mark><br>1364<mark>    if( m_pToolTipWin ) {
</mark><br>1365<mark>        m_pToolTipWin->Hide();
</mark><br>1366<mark>    }
</mark><br>1367<mark>}
</mark><br>1368<mark>
</mark><br>1369<mark>void ocpnToolBarSimple::SetColorScheme( ColorScheme cs )
</mark><br>1370<mark>{
</mark><br>1371<mark>    if( m_pToolTipWin ) {
</mark><br>1372<mark>        m_pToolTipWin->Destroy();
</mark><br>1373<mark>        m_pToolTipWin = NULL;
</mark><br>1374<mark>    }
</mark><br>1375<mark>
</mark><br>1376<mark>    m_toolOutlineColour = GetGlobalColor( _T("UIBDR") );
</mark><br>1377<mark>
</mark><br>1378<mark>    m_currentColorScheme = cs;
</mark><br>1379<mark>}
</mark><br>1380<mark>
</mark><br>1381<mark>bool ocpnToolBarSimple::Realize()
</mark><br>1382<mark>{
</mark><br>1383<mark>    m_currentRowsOrColumns = 0;
</mark><br>1384<mark>    m_LineCount = 1;
</mark><br>1385<mark>    m_lastX = m_style->GetLeftMargin();
</mark><br>1386<mark>    m_lastY = m_style->GetTopMargin();
</mark><br>1387<mark>    m_maxWidth = 0;
</mark><br>1388<mark>    m_maxHeight = 0;
</mark><br>1389<mark>
</mark><br>1390<mark>    if( IsVertical() ) m_style->SetOrientation( wxTB_VERTICAL );
</mark><br>1391<mark>    else
</mark><br>1392<mark>        m_style->SetOrientation( wxTB_HORIZONTAL );
</mark><br>1393<mark>
</mark><br>1394<mark>    wxSize toolSize = wxSize(-1, -1);
</mark><br>1395<mark>    int separatorSize = m_style->GetToolSeparation();
</mark><br>1396<mark>
</mark><br>1397<mark>    ocpnToolBarTool *lastTool = NULL;
</mark><br>1398<mark>    bool firstNode = true;
</mark><br>1399<mark>    wxToolBarToolsList::compatibility_iterator node = m_tools.GetFirst();
</mark><br>1400<mark>
</mark><br>1401<mark>    while( node ) {
</mark><br>1402<mark>        ocpnToolBarTool *tool = (ocpnToolBarTool *) node->GetData();
</mark><br>1403<mark>
</mark><br>1404<mark>        // Set the tool size to be the size of the first non-separator tool, usually the first one
</mark><br>1405<mark>        if(toolSize.x == -1){
</mark><br>1406<mark>            if( !tool->IsSeparator() ){
</mark><br>1407<mark>                toolSize.x = tool->m_width;
</mark><br>1408<mark>                toolSize.y = tool->m_height;
</mark><br>1409<mark>            }
</mark><br>1410<mark>        }
</mark><br>1411<mark>
</mark><br>1412<mark>        tool->firstInLine = firstNode;
</mark><br>1413<mark>        tool->lastInLine = false;
</mark><br>1414<mark>        firstNode = false;
</mark><br>1415<mark>
</mark><br>1416<mark>        tool->last_rect.width = 0;              // mark it invalid
</mark><br>1417<mark>        
</mark><br>1418<mark>        if( tool->IsSeparator() ) {
</mark><br>1419<mark>            if( GetWindowStyleFlag() & wxTB_HORIZONTAL ) {
</mark><br>1420<mark>                if( m_currentRowsOrColumns >= m_maxCols ) m_lastY += separatorSize;
</mark><br>1421<mark>                else
</mark><br>1422<mark>                    m_lastX += separatorSize;
</mark><br>1423<mark>            } else {
</mark><br>1424<mark>                if( m_currentRowsOrColumns >= m_maxRows ) m_lastX += separatorSize;
</mark><br>1425<mark>                else
</mark><br>1426<mark>                    m_lastY += separatorSize;
</mark><br>1427<mark>            }
</mark><br>1428<mark>        } else
</mark><br>1429<mark>            if( tool->IsButton() ) {
</mark><br>1430<mark>                if( !IsVertical() ) {
</mark><br>1431<mark>                    if( m_currentRowsOrColumns >= m_maxCols ) {
</mark><br>1432<mark>                        tool->firstInLine = true;
</mark><br>1433<mark>                        if( lastTool && m_LineCount > 1 ) lastTool->lastInLine = true;
</mark><br>1434<mark>                        m_LineCount++;
</mark><br>1435<mark>                        m_currentRowsOrColumns = 0;
</mark><br>1436<mark>                        m_lastX = m_style->GetLeftMargin();
</mark><br>1437<mark>                        m_lastY += toolSize.y + m_style->GetTopMargin();
</mark><br>1438<mark>                    }
</mark><br>1439<mark>                    tool->m_x = (wxCoord) m_lastX;
</mark><br>1440<mark>                    tool->m_y = (wxCoord) m_lastY;
</mark><br>1441<mark>
</mark><br>1442<mark>                    tool->trect = wxRect( tool->m_x, tool->m_y, toolSize.x, toolSize.y );
</mark><br>1443<mark>                    tool->trect.Inflate( m_style->GetToolSeparation() / 2,
</mark><br>1444<mark>                            m_style->GetTopMargin() );
</mark><br>1445<mark>
</mark><br>1446<mark>                    m_lastX += toolSize.x + m_style->GetToolSeparation();
</mark><br>1447<mark>                } else {
</mark><br>1448<mark>                    if( m_currentRowsOrColumns >= m_maxRows ) {
</mark><br>1449<mark>                        tool->firstInLine = true;
</mark><br>1450<mark>                        if( lastTool ) lastTool->lastInLine = true;
</mark><br>1451<mark>                        m_LineCount++;
</mark><br>1452<mark>                        m_currentRowsOrColumns = 0;
</mark><br>1453<mark>                        m_lastX += toolSize.x + m_style->GetTopMargin();
</mark><br>1454<mark>                        m_lastY = m_style->GetTopMargin();
</mark><br>1455<mark>                    }
</mark><br>1456<mark>                    tool->m_x = (wxCoord) m_lastX;
</mark><br>1457<mark>                    tool->m_y = (wxCoord) m_lastY;
</mark><br>1458<mark>
</mark><br>1459<mark>                    tool->trect = wxRect( tool->m_x, tool->m_y, toolSize.x, toolSize.y );
</mark><br>1460<mark>                    tool->trect.Inflate( m_style->GetToolSeparation() / 2,
</mark><br>1461<mark>                            m_style->GetTopMargin() );
</mark><br>1462<mark>
</mark><br>1463<mark>                    m_lastY += toolSize.y + m_style->GetToolSeparation();
</mark><br>1464<mark>                }
</mark><br>1465<mark>                m_currentRowsOrColumns++;
</mark><br>1466<mark>            } else
</mark><br>1467<mark>                if( tool->IsControl() ) {
</mark><br>1468<mark>                    tool->m_x = (wxCoord) ( m_lastX );
</mark><br>1469<mark>                    tool->m_y = (wxCoord) ( m_lastY - ( m_style->GetTopMargin() / 2 ) );
</mark><br>1470<mark>
</mark><br>1471<mark>                    tool->trect = wxRect( tool->m_x, tool->m_y, tool->GetWidth(),
</mark><br>1472<mark>                            tool->GetHeight() );
</mark><br>1473<mark>                    tool->trect.Inflate( m_style->GetToolSeparation() / 2,
</mark><br>1474<mark>                            m_style->GetTopMargin() );
</mark><br>1475<mark>                    ;
</mark><br>1476<mark>
</mark><br>1477<mark>                    wxSize s = tool->GetControl()->GetSize();
</mark><br>1478<mark>                    m_lastX += s.x + m_style->GetToolSeparation();
</mark><br>1479<mark>
</mark><br>1480<mark>                }
</mark><br>1481<mark>
</mark><br>1482<mark>        if( m_lastX > m_maxWidth ) m_maxWidth = m_lastX;
</mark><br>1483<mark>        if( m_lastY > m_maxHeight ) m_maxHeight = m_lastY;
</mark><br>1484<mark>
</mark><br>1485<mark>        lastTool = tool;
</mark><br>1486<mark>        node = node->GetNext();
</mark><br>1487<mark>    }
</mark><br>1488<mark>    if( lastTool && (m_LineCount > 1 || IsVertical()) )
</mark><br>1489<mark>        lastTool->lastInLine = true;
</mark><br>1490<mark>
</mark><br>1491<mark>    if( GetWindowStyleFlag() & wxTB_HORIZONTAL ) m_maxHeight += toolSize.y;
</mark><br>1492<mark>    else
</mark><br>1493<mark>        m_maxWidth += toolSize.x;
</mark><br>1494<mark>
</mark><br>1495<mark>    m_maxWidth += m_style->GetRightMargin();
</mark><br>1496<mark>    m_maxHeight += m_style->GetBottomMargin();
</mark><br>1497<mark>
</mark><br>1498<mark>    SetSize( m_maxWidth, m_maxHeight );
</mark><br>1499<mark>    SetMinSize( wxSize( m_maxWidth, m_maxHeight ) );
</mark><br>1500<mark>
</mark><br>1501<mark>    return true;
</mark><br>1502<mark>}
</mark><br>1503<mark>
</mark><br>1504<mark>// ----------------------------------------------------------------------------
</mark><br>1505<mark>// event handlers
</mark><br>1506<mark>// ----------------------------------------------------------------------------
</mark><br>1507<mark>
</mark><br>1508<mark>void ocpnToolBarSimple::OnPaint( wxPaintEvent& WXUNUSED(event) )
</mark><br>1509<mark>{
</mark><br>1510<mark>    wxPaintDC dc( this );
</mark><br>1511<mark>    PrepareDC( dc );
</mark><br>1512<mark>
</mark><br>1513<mark>    wxRegion ru = GetUpdateRegion();
</mark><br>1514<mark>    wxRect upRect = ru.GetBox();
</mark><br>1515<mark>
</mark><br>1516<mark>    static int count = 0;
</mark><br>1517<mark>    // Prevent reentry of OnPaint which would cause wxMemoryDC errors.
</mark><br>1518<mark>    if( count > 0 ) return;
</mark><br>1519<mark>    count++;
</mark><br>1520<mark>
</mark><br>1521<mark>    for( wxToolBarToolsList::compatibility_iterator node = m_tools.GetFirst(); node;
</mark><br>1522<mark>            node = node->GetNext() ) {
</mark><br>1523<mark>        wxToolBarToolBase *tool = node->GetData();
</mark><br>1524<mark>        ocpnToolBarTool *tools = (ocpnToolBarTool *) tool;
</mark><br>1525<mark>        wxRect toolRect = tools->trect;
</mark><br>1526<mark>
</mark><br>1527<mark>        if( toolRect.Intersects( upRect ) ) {
</mark><br>1528<mark>
</mark><br>1529<mark>            if( tool->IsButton() ) {
</mark><br>1530<mark>                DrawTool( dc, tool );
</mark><br>1531<mark>            } else
</mark><br>1532<mark>                if( tool->IsControl() ) {
</mark><br>1533<mark>                    if( tool->GetControl()->IsKindOf( CLASSINFO(wxStaticBitmap) ) ) {
</mark><br>1534<mark>                        wxStaticBitmap *psbm = (wxStaticBitmap *) tool->GetControl();
</mark><br>1535<mark>                        ocpnToolBarTool *toolsimp = (ocpnToolBarTool *) tool;
</mark><br>1536<mark>                        dc.DrawBitmap( psbm->GetBitmap(), toolsimp->m_x, toolsimp->m_y, false );
</mark><br>1537<mark>                    }
</mark><br>1538<mark>                }
</mark><br>1539<mark>        }
</mark><br>1540<mark>    }
</mark><br>1541<mark>
</mark><br>1542<mark>    count--;
</mark><br>1543<mark>}
</mark><br>1544<mark>
</mark><br>1545<mark>void ocpnToolBarSimple::OnSize( wxSizeEvent& WXUNUSED(event) )
</mark><br>1546<mark>{
</mark><br>1547<mark>    if( GetAutoLayout() ) Layout();
</mark><br>1548<mark>}
</mark><br>1549<mark>
</mark><br>1550<mark>void ocpnToolBarSimple::OnKillFocus( wxFocusEvent& WXUNUSED(event) )
</mark><br>1551<mark>{
</mark><br>1552<mark>    OnMouseEnter( m_pressedTool = m_currentTool = -1 );
</mark><br>1553<mark>}
</mark><br>1554<mark>
</mark><br>1555<mark>void ocpnToolBarSimple::OnToolTipTimerEvent( wxTimerEvent& event )
</mark><br>1556<mark>{
</mark><br>1557<mark>    if( !gFrame->IsActive() ) return;
</mark><br>1558<mark>
</mark><br>1559<mark>    if( m_btooltip_show && IsShown() && m_pToolTipWin && ( !m_pToolTipWin->IsShown() ) ) {
</mark><br>1560<mark>        if( m_last_ro_tool ) {
</mark><br>1561<mark>            wxString s = m_last_ro_tool->GetShortHelp();
</mark><br>1562<mark>
</mark><br>1563<mark>            if( s.Len() ) {
</mark><br>1564<mark>                m_pToolTipWin->SetString( s );
</mark><br>1565<mark>                m_pToolTipWin->SetHiviz(m_last_ro_tool->m_btooltip_hiviz);
</mark><br>1566<mark>
</mark><br>1567<mark>                wxPoint pos_in_toolbar( m_last_ro_tool->m_x, m_last_ro_tool->m_y );
</mark><br>1568<mark>                pos_in_toolbar.x += m_last_ro_tool->m_width + 2;
</mark><br>1569<mark>
</mark><br>1570<mark>                m_pToolTipWin->Move(0,0);       // workaround for gtk autocentre dialog behavior
</mark><br>1571<mark>
</mark><br>1572<mark>                wxPoint screenPosition = ClientToScreen( pos_in_toolbar );
</mark><br>1573<mark>                wxPoint framePosition = gFrame->ScreenToClient(screenPosition);
</mark><br>1574<mark>                wxSize tipSize = m_pToolTipWin->GetRenderedSize();
</mark><br>1575<mark>                
</mark><br>1576<mark>                if( (framePosition.x + tipSize.x) > gFrame->GetSize().x)
</mark><br>1577<mark>                    screenPosition.x -= (tipSize.x + m_last_ro_tool->m_width + 4);
</mark><br>1578<mark>                
</mark><br>1579<mark>                m_pToolTipWin->SetPosition( screenPosition );
</mark><br>1580<mark>                m_pToolTipWin->SetBitmap();
</mark><br>1581<mark>                m_pToolTipWin->Show();
</mark><br>1582<mark>                gFrame->Raise();
</mark><br>1583<mark>                if( g_btouch )
</mark><br>1584<mark>                    m_tooltipoff_timer.Start(m_tooltip_off, wxTIMER_ONE_SHOT);
</mark><br>1585<mark>            }
</mark><br>1586<mark>        }
</mark><br>1587<mark>    }
</mark><br>1588<mark>}
</mark><br>1589<mark>
</mark><br>1590<mark>void ocpnToolBarSimple::OnToolTipOffTimerEvent( wxTimerEvent& event )
</mark><br>1591<mark>{
</mark><br>1592<mark>    HideTooltip();
</mark><br>1593<mark>}
</mark><br>1594<mark>
</mark><br>1595<mark>
</mark><br>1596<mark>int s_dragx, s_dragy;
</mark><br>1597<mark>
</mark><br>1598<mark>void ocpnToolBarSimple::OnMouseEvent( wxMouseEvent & event )
</mark><br>1599<mark>{
</mark><br>1600<mark>#ifdef __OCPN__ANDROID__
</mark><br>1601<mark>    if(!event.IsButton())
</mark><br>1602<mark>        return;
</mark><br>1603<mark>#endif
</mark><br>1604<mark>
</mark><br>1605<mark>    wxCoord x, y;
</mark><br>1606<mark>    event.GetPosition( &x, &y );
</mark><br>1607<mark>    ocpnToolBarTool *tool = (ocpnToolBarTool *) FindToolForPosition( x, y );
</mark><br>1608<mark>
</mark><br>1609<mark>#ifndef __OCPN__ANDROID__
</mark><br>1610<mark>    if( event.LeftDown() ) {
</mark><br>1611<mark>        CaptureMouse();
</mark><br>1612<mark>        s_dragx = x;
</mark><br>1613<mark>        s_dragy = y;
</mark><br>1614<mark>    }
</mark><br>1615<mark>    if( event.LeftUp() ) {
</mark><br>1616<mark>        if( HasCapture() ) ReleaseMouse();
</mark><br>1617<mark>    }
</mark><br>1618<mark>#endif
</mark><br>1619<mark>
</mark><br>1620<mark>    if( tool && tool->IsButton() && IsShown() ) {
</mark><br>1621<mark>
</mark><br>1622<mark>        //    ToolTips
</mark><br>1623<mark>        if( NULL == m_pToolTipWin ) {
</mark><br>1624<mark>            m_pToolTipWin = new ToolTipWin( GetParent() );
</mark><br>1625<mark>            m_pToolTipWin->SetColorScheme( m_currentColorScheme );
</mark><br>1626<mark>            m_pToolTipWin->Hide();
</mark><br>1627<mark>        }
</mark><br>1628<mark>
</mark><br>1629<mark>        if( tool != m_last_ro_tool ) m_pToolTipWin->Hide();
</mark><br>1630<mark>
</mark><br>1631<mark>#ifndef __OCPN__ANDROID__
</mark><br>1632<mark>        if( !m_pToolTipWin->IsShown() ) {
</mark><br>1633<mark>            m_tooltip_timer.Start( m_one_shot, wxTIMER_ONE_SHOT );
</mark><br>1634<mark>        }
</mark><br>1635<mark>#endif
</mark><br>1636<mark>
</mark><br>1637<mark>        //    Tool Rollover highlighting
</mark><br>1638<mark>        if(!g_btouch){
</mark><br>1639<mark>            if( tool != m_last_ro_tool ) {
</mark><br>1640<mark>                if( tool->IsEnabled() ) {
</mark><br>1641<mark>                    tool->rollover = true;
</mark><br>1642<mark>                    tool->bitmapOK = false;
</mark><br>1643<mark>                }
</mark><br>1644<mark>                if( m_last_ro_tool ) {
</mark><br>1645<mark>                    if( m_last_ro_tool->IsEnabled() ) {
</mark><br>1646<mark>                        m_last_ro_tool->rollover = false;
</mark><br>1647<mark>                        m_last_ro_tool->bitmapOK = false;
</mark><br>1648<mark>                    }
</mark><br>1649<mark>                }
</mark><br>1650<mark>                m_last_ro_tool = tool;
</mark><br>1651<mark>                if(g_toolbar)
</mark><br>1652<mark>                    g_toolbar->Refresh( false );
</mark><br>1653<mark>            }
</mark><br>1654<mark>        }
</mark><br>1655<mark>    } else {
</mark><br>1656<mark>        //    Tooltips
</mark><br>1657<mark>        if( m_pToolTipWin && m_pToolTipWin->IsShown() ) m_pToolTipWin->Hide();
</mark><br>1658<mark>
</mark><br>1659<mark>        //    Remove Highlighting
</mark><br>1660<mark>        if( m_last_ro_tool ) {
</mark><br>1661<mark>            if( m_last_ro_tool->IsEnabled() ) {
</mark><br>1662<mark>                m_last_ro_tool->rollover = false;
</mark><br>1663<mark>                m_last_ro_tool->bitmapOK = false;
</mark><br>1664<mark>            }
</mark><br>1665<mark>            g_toolbar->Refresh( false );
</mark><br>1666<mark>        }
</mark><br>1667<mark>    }
</mark><br>1668<mark>
</mark><br>1669<mark>    m_last_ro_tool = tool;
</mark><br>1670<mark>
</mark><br>1671<mark>    // allow smooth zooming while toolbutton is held down
</mark><br>1672<mark>    if(g_bsmoothpanzoom && !g_btouch) {
</mark><br>1673<mark>        if(event.LeftUp() && m_btoolbar_is_zooming) {
</mark><br>1674<mark>            cc1->StopMovement();
</mark><br>1675<mark>            m_btoolbar_is_zooming = false;
</mark><br>1676<mark>            return;
</mark><br>1677<mark>        }
</mark><br>1678<mark>
</mark><br>1679<mark>        if( event.LeftDown() && tool &&
</mark><br>1680<mark>            (tool->GetId() == ID_ZOOMIN || tool->GetId() == ID_ZOOMOUT) ) {
</mark><br>1681<mark>            cc1->ZoomCanvas( tool->GetId() == ID_ZOOMIN ? 2.0 : .5, false, false );
</mark><br>1682<mark>            m_btoolbar_is_zooming = true;
</mark><br>1683<mark>            return;
</mark><br>1684<mark>        }
</mark><br>1685<mark>    }
</mark><br>1686<mark>
</mark><br>1687<mark>    if( !tool ) {
</mark><br>1688<mark>        if( m_currentTool > -1 ) {
</mark><br>1689<mark>            if( event.LeftIsDown() ) SpringUpButton( m_currentTool );
</mark><br>1690<mark>            m_currentTool = -1;
</mark><br>1691<mark>            OnMouseEnter( -1 );
</mark><br>1692<mark>        }
</mark><br>1693<mark>
</mark><br>1694<mark>        wxMouseEvent *pev = (wxMouseEvent *) event.Clone();
</mark><br>1695<mark>        GetParent()->GetEventHandler()->AddPendingEvent( *pev );
</mark><br>1696<mark>        wxDELETE( pev );
</mark><br>1697<mark>
</mark><br>1698<mark>        return;
</mark><br>1699<mark>    }
</mark><br>1700<mark>
</mark><br>1701<mark>    if( !event.IsButton() ) {
</mark><br>1702<mark>        if( tool->GetId() != m_currentTool ) {
</mark><br>1703<mark>            // If the left button is kept down and moved over buttons,
</mark><br>1704<mark>            // press those buttons.
</mark><br>1705<mark>            if( event.LeftIsDown() && tool->IsEnabled() ) {
</mark><br>1706<mark>                SpringUpButton( m_currentTool );
</mark><br>1707<mark>
</mark><br>1708<mark>                if( tool->CanBeToggled() ) {
</mark><br>1709<mark>                    tool->Toggle();
</mark><br>1710<mark>                }
</mark><br>1711<mark>
</mark><br>1712<mark>                DrawTool( tool );
</mark><br>1713<mark>            }
</mark><br>1714<mark>
</mark><br>1715<mark>            m_currentTool = tool->GetId();
</mark><br>1716<mark>            OnMouseEnter( m_currentTool );
</mark><br>1717<mark>        }
</mark><br>1718<mark>
</mark><br>1719<mark>        wxMouseEvent *pev = (wxMouseEvent *) event.Clone();
</mark><br>1720<mark>        GetParent()->GetEventHandler()->AddPendingEvent( *pev );
</mark><br>1721<mark>        wxDELETE( pev );
</mark><br>1722<mark>
</mark><br>1723<mark>        return;
</mark><br>1724<mark>    }
</mark><br>1725<mark>
</mark><br>1726<mark>    // Left button pressed.
</mark><br>1727<mark>    if( event.LeftDown() && tool->IsEnabled() ) {
</mark><br>1728<mark>        if( tool->CanBeToggled() ) {
</mark><br>1729<mark>            tool->Toggle();
</mark><br>1730<mark>            tool->bitmapOK = false;
</mark><br>1731<mark>            
</mark><br>1732<mark>        }
</mark><br>1733<mark>
</mark><br>1734<mark>        DrawTool( tool );
</mark><br>1735<mark>
</mark><br>1736<mark>        //        Look for PlugIn tools
</mark><br>1737<mark>        //        If found, make the callback.
</mark><br>1738<mark>        if( g_pi_manager ) {
</mark><br>1739<mark>            ArrayOfPlugInToolbarTools tool_array = g_pi_manager->GetPluginToolbarToolArray();
</mark><br>1740<mark>            for( unsigned int i = 0; i < tool_array.GetCount(); i++ ) {
</mark><br>1741<mark>                PlugInToolbarToolContainer *pttc = tool_array.Item( i );
</mark><br>1742<mark>                if( tool->GetId() == pttc->id ) {
</mark><br>1743<mark>                    opencpn_plugin_113 *ppi = dynamic_cast<opencpn_plugin_113 *>(pttc->m_pplugin);
</mark><br>1744<mark>                    if( ppi ) {
</mark><br>1745<mark>                        ppi->OnToolbarToolDownCallback( pttc->id );
</mark><br>1746<mark>                        m_last_plugin_down_id = pttc->id;
</mark><br>1747<mark>                    }
</mark><br>1748<mark>                }
</mark><br>1749<mark>            }
</mark><br>1750<mark>        }
</mark><br>1751<mark>    } else
</mark><br>1752<mark>        if( event.RightDown() ) {
</mark><br>1753<mark>            OnRightClick( tool->GetId(), x, y );
</mark><br>1754<mark>        }
</mark><br>1755<mark>
</mark><br>1756<mark>    // Left Button Released.  Only this action confirms selection.
</mark><br>1757<mark>    // If the button is enabled and it is not a toggle tool and it is
</mark><br>1758<mark>    // in the pressed state, then raise the button and call OnLeftClick.
</mark><br>1759<mark>    //
</mark><br>1760<mark>    if( event.LeftUp() && tool->IsEnabled() ) {
</mark><br>1761<mark>        // Pass the OnLeftClick event to tool
</mark><br>1762<mark>        if( !OnLeftClick( tool->GetId(), tool->IsToggled() ) && tool->CanBeToggled() ) {
</mark><br>1763<mark>            // If it was a toggle, and OnLeftClick says No Toggle allowed,
</mark><br>1764<mark>            // then change it back
</mark><br>1765<mark>            tool->Toggle();
</mark><br>1766<mark>            tool->bitmapOK = false;
</mark><br>1767<mark>        }
</mark><br>1768<mark>
</mark><br>1769<mark>        DoPluginToolUp();
</mark><br>1770<mark>    }
</mark><br>1771<mark>
</mark><br>1772<mark>    wxMouseEvent *pev = (wxMouseEvent *) event.Clone();
</mark><br>1773<mark>    GetParent()->GetEventHandler()->AddPendingEvent( *pev );
</mark><br>1774<mark>    wxDELETE( pev );
</mark><br>1775<mark>    event.Skip();
</mark><br>1776<mark>}
</mark><br>1777<mark>
</mark><br>1778<mark>// ----------------------------------------------------------------------------
</mark><br>1779<mark>// drawing
</mark><br>1780<mark>// ----------------------------------------------------------------------------
</mark><br>1781<mark>
</mark><br>1782<mark>void ocpnToolBarSimple::DrawTool( wxToolBarToolBase *tool )
</mark><br>1783<mark>{
</mark><br>1784<mark>    wxClientDC dc( this );
</mark><br>1785<mark>    DrawTool( dc, tool );
</mark><br>1786<mark>}
</mark><br>1787<mark>
</mark><br>1788<mark>// NB! The current DrawTool code assumes that plugin tools are never disabled
</mark><br>1789<mark>// when they are present on the toolbar, since disabled plugins are removed.
</mark><br>1790<mark>
</mark><br>1791<mark>void ocpnToolBarSimple::DrawTool( wxDC& dc, wxToolBarToolBase *toolBase )
</mark><br>1792<mark>{
</mark><br>1793<mark>    ocpnToolBarTool *tool = (ocpnToolBarTool *) toolBase;
</mark><br>1794<mark>    PrepareDC( dc );
</mark><br>1795<mark>
</mark><br>1796<mark>    wxPoint drawAt( tool->m_x, tool->m_y );
</mark><br>1797<mark>    wxBitmap bmp;
</mark><br>1798<mark>
</mark><br>1799<mark>    if( tool->bitmapOK ) {
</mark><br>1800<mark>        if( tool->IsEnabled() ) {
</mark><br>1801<mark>            bmp = tool->GetNormalBitmap();
</mark><br>1802<mark>            if( !bmp.IsOk() ){
</mark><br>1803<mark>                bmp = m_style->GetToolIcon( tool->GetToolname(), TOOLICON_NORMAL, tool->rollover );
</mark><br>1804<mark>                if(m_sizefactor > 1.0 ){
</mark><br>1805<mark>                    wxImage scaled_image = bmp.ConvertToImage();
</mark><br>1806<mark>                    bmp = wxBitmap(scaled_image.Scale(tool->m_width, tool->m_height, wxIMAGE_QUALITY_HIGH));
</mark><br>1807<mark>                }
</mark><br>1808<mark>                tool->SetNormalBitmap( bmp );
</mark><br>1809<mark>                tool->bitmapOK = true;
</mark><br>1810<mark>            }
</mark><br>1811<mark>        } else {
</mark><br>1812<mark>            bmp = tool->GetDisabledBitmap();
</mark><br>1813<mark>            if( !bmp.IsOk() ){
</mark><br>1814<mark>                bmp = m_style->GetToolIcon( tool->GetToolname(), TOOLICON_DISABLED );
</mark><br>1815<mark>                if(m_sizefactor > 1.0 ){
</mark><br>1816<mark>                    wxImage scaled_image = bmp.ConvertToImage();
</mark><br>1817<mark>                    bmp = wxBitmap(scaled_image.Scale(tool->m_width, tool->m_height, wxIMAGE_QUALITY_HIGH));
</mark><br>1818<mark>                }
</mark><br>1819<mark>                tool->SetDisabledBitmap( bmp );
</mark><br>1820<mark>                tool->bitmapOK = true;
</mark><br>1821<mark>            }
</mark><br>1822<mark>        }
</mark><br>1823<mark>    } else {
</mark><br>1824<mark>        if ( tool->isPluginTool ) {
</mark><br>1825<mark>
</mark><br>1826<mark>            // First try getting the icon from the Style.
</mark><br>1827<mark>            // If it is not in the style we build a new icon from the style BG and the plugin icon.
</mark><br>1828<mark>
</mark><br>1829<mark>            if( tool->IsToggled() ) {
</mark><br>1830<mark>                bmp = m_style->GetToolIcon( tool->GetToolname(), TOOLICON_TOGGLED, tool->rollover );
</mark><br>1831<mark>                if( bmp.GetDepth() == 1 ) {
</mark><br>1832<mark>                    if( tool->rollover ) {
</mark><br>1833<mark>                        bmp = m_style->BuildPluginIcon( tool->pluginRolloverIcon, TOOLICON_TOGGLED );
</mark><br>1834<mark>                        if( ! bmp.IsOk() )
</mark><br>1835<mark>                            bmp = m_style->BuildPluginIcon( tool->pluginNormalIcon, TOOLICON_TOGGLED );
</mark><br>1836<mark>                    }
</mark><br>1837<mark>                    else
</mark><br>1838<mark>                        bmp = m_style->BuildPluginIcon( tool->pluginNormalIcon, TOOLICON_TOGGLED );
</mark><br>1839<mark>                }
</mark><br>1840<mark>            } else {
</mark><br>1841<mark>                bmp = m_style->GetToolIcon( tool->GetToolname(), TOOLICON_NORMAL, tool->rollover );
</mark><br>1842<mark>                if( bmp.GetDepth() == 1 ) {
</mark><br>1843<mark>                    if( tool->rollover ) {
</mark><br>1844<mark>                        bmp = m_style->BuildPluginIcon( tool->pluginRolloverIcon, TOOLICON_NORMAL );
</mark><br>1845<mark>                        if( ! bmp.IsOk() )
</mark><br>1846<mark>                            bmp = m_style->BuildPluginIcon( tool->pluginNormalIcon, TOOLICON_NORMAL );
</mark><br>1847<mark>                    }
</mark><br>1848<mark>                    else
</mark><br>1849<mark>                        bmp = m_style->BuildPluginIcon( tool->pluginNormalIcon, TOOLICON_NORMAL );
</mark><br>1850<mark>                }
</mark><br>1851<mark>            }
</mark><br>1852<mark>            if(m_sizefactor > 1.0 ){
</mark><br>1853<mark>                wxImage scaled_image = bmp.ConvertToImage();
</mark><br>1854<mark>                bmp = wxBitmap(scaled_image.Scale(tool->m_width, tool->m_height, wxIMAGE_QUALITY_HIGH));
</mark><br>1855<mark>            }
</mark><br>1856<mark>            tool->SetNormalBitmap( bmp );
</mark><br>1857<mark>            tool->bitmapOK = true;
</mark><br>1858<mark>        } else {
</mark><br>1859<mark>            if( tool->IsEnabled() ) {
</mark><br>1860<mark>                if( tool->IsToggled() )
</mark><br>1861<mark>                    bmp = m_style->GetToolIcon( tool->GetToolname(), TOOLICON_TOGGLED, tool->rollover );
</mark><br>1862<mark>                else
</mark><br>1863<mark>                    bmp = m_style->GetToolIcon( tool->GetIconName(), TOOLICON_NORMAL, tool->rollover );
</mark><br>1864<mark>
</mark><br>1865<mark>                if(m_sizefactor > 1.0 ){
</mark><br>1866<mark>                    wxImage scaled_image = bmp.ConvertToImage();
</mark><br>1867<mark>                    bmp = wxBitmap(scaled_image.Scale(tool->m_width, tool->m_height, wxIMAGE_QUALITY_HIGH));
</mark><br>1868<mark>                }
</mark><br>1869<mark>                tool->SetNormalBitmap( bmp );
</mark><br>1870<mark>                tool->bitmapOK = true;
</mark><br>1871<mark>            } else {
</mark><br>1872<mark>                bmp = m_style->GetToolIcon( tool->GetToolname(), TOOLICON_DISABLED );
</mark><br>1873<mark>                if(m_sizefactor > 1.0 ){
</mark><br>1874<mark>                    wxImage scaled_image = bmp.ConvertToImage();
</mark><br>1875<mark>                    bmp = wxBitmap(scaled_image.Scale(tool->m_width, tool->m_height, wxIMAGE_QUALITY_HIGH));
</mark><br>1876<mark>                }
</mark><br>1877<mark>                tool->SetDisabledBitmap( bmp );
</mark><br>1878<mark>                tool->bitmapOK = true;
</mark><br>1879<mark>            }
</mark><br>1880<mark>        }
</mark><br>1881<mark>    }
</mark><br>1882<mark>
</mark><br>1883<mark>    if( tool->firstInLine ) {
</mark><br>1884<mark>        m_style->DrawToolbarLineStart( bmp );
</mark><br>1885<mark>    }
</mark><br>1886<mark>    if( tool->lastInLine ) {
</mark><br>1887<mark>        m_style->DrawToolbarLineEnd( bmp );
</mark><br>1888<mark>    }
</mark><br>1889<mark>
</mark><br>1890<mark>    if( bmp.GetWidth() != m_style->GetToolSize().x
</mark><br>1891<mark>            || bmp.GetHeight() != m_style->GetToolSize().y ) {
</mark><br>1892<mark>//        drawAt.x -= ( bmp.GetWidth() - m_style->GetToolSize().x ) / 2;
</mark><br>1893<mark>//        drawAt.y -= ( bmp.GetHeight() - m_style->GetToolSize().y ) / 2;
</mark><br>1894<mark>    }
</mark><br>1895<mark>
</mark><br>1896<mark>    //      Clear the last drawn tool if necessary
</mark><br>1897<mark>    if( tool->last_rect.width && ((tool->last_rect.x != drawAt.x) || (tool->last_rect.y != drawAt.y)) ){
</mark><br>1898<mark>        wxBrush bb(GetGlobalColor( _T("GREY2") ));
</mark><br>1899<mark>        dc.SetBrush(bb);
</mark><br>1900<mark>        dc.SetPen( *wxTRANSPARENT_PEN );
</mark><br>1901<mark>        dc.DrawRectangle(tool->last_rect.x, tool->last_rect.y, tool->last_rect.width, tool->last_rect.height);
</mark><br>1902<mark>    }
</mark><br>1903<mark>
</mark><br>1904<mark>    //  could cache this in the tool...
</mark><br>1905<mark>    //  A bit of a hack here.  We only scale tools if they are to be magnified globally
</mark><br>1906<mark>    if(0/*m_sizefactor > 1.0*/ )
</mark><br>1907<mark>    {
</mark><br>1908<mark>        wxImage scaled_image = bmp.ConvertToImage();
</mark><br>1909<mark>        wxBitmap sbmp = wxBitmap(scaled_image.Scale(tool->m_width, tool->m_height, wxIMAGE_QUALITY_HIGH));
</mark><br>1910<mark>        dc.DrawBitmap( sbmp, drawAt );
</mark><br>1911<mark>        tool->last_rect = wxRect(drawAt.x, drawAt.y, sbmp.GetWidth(), sbmp.GetHeight());
</mark><br>1912<mark>
</mark><br>1913<mark>    }
</mark><br>1914<mark>    else
</mark><br>1915<mark>    {
</mark><br>1916<mark>        dc.DrawBitmap( bmp, drawAt );
</mark><br>1917<mark>        tool->last_rect = wxRect(drawAt.x, drawAt.y, bmp.GetWidth(), bmp.GetHeight());
</mark><br>1918<mark>    }
</mark><br>1919<mark>
</mark><br>1920<mark>}
</mark><br>1921<mark>
</mark><br>1922<mark>// ----------------------------------------------------------------------------
</mark><br>1923<mark>// toolbar geometry
</mark><br>1924<mark>// ----------------------------------------------------------------------------
</mark><br>1925<mark>
</mark><br>1926<mark>wxToolBarToolBase *ocpnToolBarSimple::FindToolForPosition( wxCoord x, wxCoord y )
</mark><br>1927<mark>{
</mark><br>1928<mark>    wxToolBarToolsList::compatibility_iterator node = m_tools.GetFirst();
</mark><br>1929<mark>    while( node ) {
</mark><br>1930<mark>        ocpnToolBarTool *tool = (ocpnToolBarTool *) node->GetData();
</mark><br>1931<mark>        if( ( x >= tool->m_x ) && ( y >= tool->m_y ) && ( x < ( tool->m_x + tool->GetWidth() ) )
</mark><br>1932<mark>                && ( y < ( tool->m_y + tool->GetHeight() ) ) ) {
</mark><br>1933<mark>            return tool;
</mark><br>1934<mark>        }
</mark><br>1935<mark>
</mark><br>1936<mark>        node = node->GetNext();
</mark><br>1937<mark>    }
</mark><br>1938<mark>
</mark><br>1939<mark>    return (wxToolBarToolBase *) NULL;
</mark><br>1940<mark>}
</mark><br>1941<mark>
</mark><br>1942<mark>void ocpnToolBarSimple::InvalidateBitmaps()
</mark><br>1943<mark>{
</mark><br>1944<mark>    wxToolBarToolsList::compatibility_iterator node = m_tools.GetFirst();
</mark><br>1945<mark>    while( node ) {
</mark><br>1946<mark>        ocpnToolBarTool *tool = (ocpnToolBarTool *) node->GetData();
</mark><br>1947<mark>        tool->bitmapOK = false;
</mark><br>1948<mark>        node = node->GetNext();
</mark><br>1949<mark>    }
</mark><br>1950<mark>}
</mark><br>1951<mark>
</mark><br>1952<mark>wxRect ocpnToolBarSimple::GetToolRect( int tool_id )
</mark><br>1953<mark>{
</mark><br>1954<mark>    wxRect rect;
</mark><br>1955<mark>    wxToolBarToolBase *tool = FindById( tool_id );
</mark><br>1956<mark>    if( tool ) {
</mark><br>1957<mark>        ocpnToolBarTool *otool = (ocpnToolBarTool *) tool;
</mark><br>1958<mark>        if( otool ) rect = otool->trect;
</mark><br>1959<mark>    }
</mark><br>1960<mark>
</mark><br>1961<mark>    return rect;
</mark><br>1962<mark>}
</mark><br>1963<mark>
</mark><br>1964<mark>// ----------------------------------------------------------------------------
</mark><br>1965<mark>// tool state change handlers
</mark><br>1966<mark>// ----------------------------------------------------------------------------
</mark><br>1967<mark>
</mark><br>1968<mark>void ocpnToolBarSimple::DoEnableTool( wxToolBarToolBase *tool, bool WXUNUSED(enable) )
</mark><br>1969<mark>{
</mark><br>1970<mark>    DrawTool( tool );
</mark><br>1971<mark>}
</mark><br>1972<mark>
</mark><br>1973<mark>void ocpnToolBarSimple::DoToggleTool( wxToolBarToolBase *tool, bool WXUNUSED(toggle) )
</mark><br>1974<mark>{
</mark><br>1975<mark>    ocpnToolBarTool *t = (ocpnToolBarTool *) tool;
</mark><br>1976<mark>    t->bitmapOK = false;
</mark><br>1977<mark>    DrawTool( tool );
</mark><br>1978<mark>}
</mark><br>1979<mark>
</mark><br>1980<mark>// Okay, so we've left the tool we're in ... we must check if the tool we're
</mark><br>1981<mark>// leaving was a 'sprung push button' and if so, spring it back to the up
</mark><br>1982<mark>// state.
</mark><br>1983<mark>void ocpnToolBarSimple::SpringUpButton( int id )
</mark><br>1984<mark>{
</mark><br>1985<mark>    wxToolBarToolBase *tool = FindById( id );
</mark><br>1986<mark>
</mark><br>1987<mark>    if( tool && tool->CanBeToggled() ) {
</mark><br>1988<mark>        if( tool->IsToggled() ) tool->Toggle();
</mark><br>1989<mark>
</mark><br>1990<mark>        DrawTool( tool );
</mark><br>1991<mark>    }
</mark><br>1992<mark>}
</mark><br>1993<mark>
</mark><br>1994<mark>// ----------------------------------------------------------------------------
</mark><br>1995<mark>// scrolling implementation
</mark><br>1996<mark>// ----------------------------------------------------------------------------
</mark><br>1997<mark>
</mark><br>1998<mark>wxString ocpnToolBarSimple::GetToolShortHelp( int id ) const
</mark><br>1999<mark>{
</mark><br>2000<mark>    wxToolBarToolBase *tool = FindById( id );
</mark><br>2001<mark>    wxCHECK_MSG( tool, wxEmptyString, _T("no such tool") );
</mark><br>2002<mark>
</mark><br>2003<mark>    return tool->GetShortHelp();
</mark><br>2004<mark>}
</mark><br>2005<mark>
</mark><br>2006<mark>wxString ocpnToolBarSimple::GetToolLongHelp( int id ) const
</mark><br>2007<mark>{
</mark><br>2008<mark>    wxToolBarToolBase *tool = FindById( id );
</mark><br>2009<mark>    wxCHECK_MSG( tool, wxEmptyString, _T("no such tool") );
</mark><br>2010<mark>
</mark><br>2011<mark>    return tool->GetLongHelp();
</mark><br>2012<mark>}
</mark><br>2013<mark>
</mark><br>2014<mark>void ocpnToolBarSimple::SetToolShortHelp( int id, const wxString& help )
</mark><br>2015<mark>{
</mark><br>2016<mark>    wxToolBarToolBase *tool = FindById( id );
</mark><br>2017<mark>    if( tool ) {
</mark><br>2018<mark>        (void) tool->SetShortHelp( help );
</mark><br>2019<mark>    }
</mark><br>2020<mark>}
</mark><br>2021<mark>
</mark><br>2022<mark>void ocpnToolBarSimple::SetToolLongHelp( int id, const wxString& help )
</mark><br>2023<mark>{
</mark><br>2024<mark>    wxToolBarToolBase *tool = FindById( id );
</mark><br>2025<mark>    if( tool ) {
</mark><br>2026<mark>        (void) tool->SetLongHelp( help );
</mark><br>2027<mark>    }
</mark><br>2028<mark>}
</mark><br>2029<mark>
</mark><br>2030<mark>int ocpnToolBarSimple::GetToolPos( int id ) const
</mark><br>2031<mark>{
</mark><br>2032<mark>    size_t pos = 0;
</mark><br>2033<mark>    wxToolBarToolsList::compatibility_iterator node;
</mark><br>2034<mark>
</mark><br>2035<mark>    for( node = m_tools.GetFirst(); node; node = node->GetNext() ) {
</mark><br>2036<mark>        if( node->GetData()->GetId() == id ) return pos;
</mark><br>2037<mark>
</mark><br>2038<mark>        pos++;
</mark><br>2039<mark>    }
</mark><br>2040<mark>
</mark><br>2041<mark>    return wxNOT_FOUND;
</mark><br>2042<mark>}
</mark><br>2043<mark>bool ocpnToolBarSimple::GetToolState( int id ) const
</mark><br>2044<mark>{
</mark><br>2045<mark>    wxToolBarToolBase *tool = FindById( id );
</mark><br>2046<mark>    wxCHECK_MSG( tool, false, _T("no such tool") );
</mark><br>2047<mark>
</mark><br>2048<mark>    return tool->IsToggled();
</mark><br>2049<mark>}
</mark><br>2050<mark>
</mark><br>2051<mark>bool ocpnToolBarSimple::GetToolEnabled( int id ) const
</mark><br>2052<mark>{
</mark><br>2053<mark>    wxToolBarToolBase *tool = FindById( id );
</mark><br>2054<mark>    wxCHECK_MSG( tool, false, _T("no such tool") );
</mark><br>2055<mark>
</mark><br>2056<mark>    return tool->IsEnabled();
</mark><br>2057<mark>}
</mark><br>2058<mark>
</mark><br>2059<mark>void ocpnToolBarSimple::ToggleTool( int id, bool toggle )
</mark><br>2060<mark>{
</mark><br>2061<mark>    wxToolBarToolBase *tool = FindById( id );
</mark><br>2062<mark>        
</mark><br>2063<mark>    if( tool && tool->CanBeToggled() && tool->Toggle( toggle ) ) {
</mark><br>2064<mark>        DoToggleTool( tool, toggle );
</mark><br>2065<mark>        if( g_toolbar ) g_toolbar->Refresh();
</mark><br>2066<mark>    }
</mark><br>2067<mark>}
</mark><br>2068<mark>
</mark><br>2069<mark>wxObject *ocpnToolBarSimple::GetToolClientData( int id ) const
</mark><br>2070<mark>{
</mark><br>2071<mark>    wxToolBarToolBase *tool = FindById( id );
</mark><br>2072<mark>    return tool ? tool->GetClientData() : (wxObject *) NULL;
</mark><br>2073<mark>}
</mark><br>2074<mark>
</mark><br>2075<mark>void ocpnToolBarSimple::SetToolClientData( int id, wxObject *clientData )
</mark><br>2076<mark>{
</mark><br>2077<mark>    wxToolBarToolBase *tool = FindById( id );
</mark><br>2078<mark>
</mark><br>2079<mark>    wxCHECK_RET( tool, _T("no such tool in wxToolBar::SetToolClientData") );
</mark><br>2080<mark>
</mark><br>2081<mark>    tool->SetClientData( clientData );
</mark><br>2082<mark>}
</mark><br>2083<mark>
</mark><br>2084<mark>void ocpnToolBarSimple::EnableTool( int id, bool enable )
</mark><br>2085<mark>{
</mark><br>2086<mark>    wxToolBarToolBase *tool = FindById( id );
</mark><br>2087<mark>    if( tool ) {
</mark><br>2088<mark>        if( tool->Enable( enable ) ) {
</mark><br>2089<mark>            DoEnableTool( tool, enable );
</mark><br>2090<mark>        }
</mark><br>2091<mark>    }
</mark><br>2092<mark>    wxMenuItem* configItem = g_FloatingToolbarConfigMenu->FindItem( id );
</mark><br>2093<mark>    configItem->Check( true );
</mark><br>2094<mark>}
</mark><br>2095<mark>
</mark><br>2096<mark>void ocpnToolBarSimple::SetToolBitmaps( int id, wxBitmap *bmp, wxBitmap *bmpRollover )
</mark><br>2097<mark>{
</mark><br>2098<mark>    ocpnToolBarTool *tool = (ocpnToolBarTool*)FindById( id );
</mark><br>2099<mark>    if( tool ) {
</mark><br>2100<mark>        tool->pluginNormalIcon = bmp;
</mark><br>2101<mark>        tool->pluginRolloverIcon = bmpRollover;
</mark><br>2102<mark>        tool->bitmapOK = false;
</mark><br>2103<mark>    }
</mark><br>2104<mark>}
</mark><br>2105<mark>
</mark><br>2106<mark>void ocpnToolBarSimple::SetToolTooltipHiViz( int id, bool b_hiviz )
</mark><br>2107<mark>{
</mark><br>2108<mark>    ocpnToolBarTool *tool = (ocpnToolBarTool*)FindById( id );
</mark><br>2109<mark>    if( tool ) {
</mark><br>2110<mark>        tool->SetTooltipHiviz( b_hiviz );
</mark><br>2111<mark>    }
</mark><br>2112<mark>}
</mark><br>2113<mark>
</mark><br>2114<mark>
</mark><br>2115<mark>void ocpnToolBarSimple::ClearTools()
</mark><br>2116<mark>{
</mark><br>2117<mark>    while( GetToolsCount() ) {
</mark><br>2118<mark>        DeleteToolByPos( 0 );
</mark><br>2119<mark>    }
</mark><br>2120<mark>}
</mark><br>2121<mark>
</mark><br>2122<mark>int ocpnToolBarSimple::GetVisibleToolCount()
</mark><br>2123<mark>{
</mark><br>2124<mark>    int counter = 0;
</mark><br>2125<mark>    wxToolBarToolsList::compatibility_iterator node = m_tools.GetFirst();
</mark><br>2126<mark>    while( node ) {
</mark><br>2127<mark>        ocpnToolBarTool *tool = (ocpnToolBarTool *) node->GetData();
</mark><br>2128<mark>        counter++;
</mark><br>2129<mark>        node = node->GetNext();
</mark><br>2130<mark>    }
</mark><br>2131<mark>    return counter;
</mark><br>2132<mark>}
</mark><br>2133<mark>
</mark><br>2134<mark>bool ocpnToolBarSimple::DeleteToolByPos( size_t pos )
</mark><br>2135<mark>{
</mark><br>2136<mark>    wxCHECK_MSG( pos < GetToolsCount(), false,
</mark><br>2137<mark>            _T("invalid position in wxToolBar::DeleteToolByPos()") );
</mark><br>2138<mark>
</mark><br>2139<mark>    wxToolBarToolsList::compatibility_iterator node = m_tools.Item( pos );
</mark><br>2140<mark>
</mark><br>2141<mark>    if( !DoDeleteTool( pos, node->GetData() ) ) {
</mark><br>2142<mark>        return false;
</mark><br>2143<mark>    }
</mark><br>2144<mark>
</mark><br>2145<mark>    delete node->GetData();
</mark><br>2146<mark>    m_tools.Erase( node );
</mark><br>2147<mark>
</mark><br>2148<mark>    return true;
</mark><br>2149<mark>}
</mark><br>2150<mark>
</mark><br>2151<mark>bool ocpnToolBarSimple::DeleteTool( int id )
</mark><br>2152<mark>{
</mark><br>2153<mark>    size_t pos = 0;
</mark><br>2154<mark>    wxToolBarToolsList::compatibility_iterator node;
</mark><br>2155<mark>    for( node = m_tools.GetFirst(); node; node = node->GetNext() ) {
</mark><br>2156<mark>        if( node->GetData()->GetId() == id ) break;
</mark><br>2157<mark>
</mark><br>2158<mark>        pos++;
</mark><br>2159<mark>    }
</mark><br>2160<mark>
</mark><br>2161<mark>    if( !node || !DoDeleteTool( pos, node->GetData() ) ) {
</mark><br>2162<mark>        return false;
</mark><br>2163<mark>    }
</mark><br>2164<mark>
</mark><br>2165<mark>    delete node->GetData();
</mark><br>2166<mark>    m_tools.Erase( node );
</mark><br>2167<mark>
</mark><br>2168<mark>    return true;
</mark><br>2169<mark>}
</mark><br>2170<mark>
</mark><br>2171<mark>wxToolBarToolBase *ocpnToolBarSimple::AddSeparator()
</mark><br>2172<mark>{
</mark><br>2173<mark>    return InsertSeparator( GetToolsCount() );
</mark><br>2174<mark>}
</mark><br>2175<mark>
</mark><br>2176<mark>wxToolBarToolBase *ocpnToolBarSimple::InsertSeparator( size_t pos )
</mark><br>2177<mark>{
</mark><br>2178<mark>    wxCHECK_MSG( pos <= GetToolsCount(), (wxToolBarToolBase *)NULL,
</mark><br>2179<mark>            _T("invalid position in wxToolBar::InsertSeparator()") );
</mark><br>2180<mark>
</mark><br>2181<mark>    wxToolBarToolBase *tool = CreateTool( wxID_SEPARATOR, wxEmptyString, wxNullBitmap, wxNullBitmap,
</mark><br>2182<mark>            wxITEM_SEPARATOR, (wxObject *) NULL, wxEmptyString, wxEmptyString );
</mark><br>2183<mark>
</mark><br>2184<mark>    if( !tool || !DoInsertTool( pos, tool ) ) {
</mark><br>2185<mark>        delete tool;
</mark><br>2186<mark>
</mark><br>2187<mark>        return NULL;
</mark><br>2188<mark>    }
</mark><br>2189<mark>
</mark><br>2190<mark>    m_tools.Insert( pos, tool );
</mark><br>2191<mark>
</mark><br>2192<mark>    return tool;
</mark><br>2193<mark>}
</mark><br>2194<mark>
</mark><br>2195<mark>wxToolBarToolBase *ocpnToolBarSimple::RemoveTool( int id )
</mark><br>2196<mark>{
</mark><br>2197<mark>    size_t pos = 0;
</mark><br>2198<mark>    wxToolBarToolsList::compatibility_iterator node;
</mark><br>2199<mark>    for( node = m_tools.GetFirst(); node; node = node->GetNext() ) {
</mark><br>2200<mark>        if( node->GetData()->GetId() == id ) break;
</mark><br>2201<mark>
</mark><br>2202<mark>        pos++;
</mark><br>2203<mark>    }
</mark><br>2204<mark>
</mark><br>2205<mark>    if( !node ) {
</mark><br>2206<mark>        // don't give any error messages - sometimes we might call RemoveTool()
</mark><br>2207<mark>        // without knowing whether the tool is or not in the toolbar
</mark><br>2208<mark>        return (wxToolBarToolBase *) NULL;
</mark><br>2209<mark>    }
</mark><br>2210<mark>
</mark><br>2211<mark>    wxToolBarToolBase *tool = node->GetData();
</mark><br>2212<mark>    if( !DoDeleteTool( pos, tool ) ) {
</mark><br>2213<mark>        return (wxToolBarToolBase *) NULL;
</mark><br>2214<mark>    }
</mark><br>2215<mark>
</mark><br>2216<mark>    m_tools.Erase( node );
</mark><br>2217<mark>
</mark><br>2218<mark>    return tool;
</mark><br>2219<mark>}
</mark><br>2220<mark>
</mark><br>2221<mark>
</mark><br>2222<mark>wxControl *ocpnToolBarSimple::FindControl( int id )
</mark><br>2223<mark>{
</mark><br>2224<mark>    for( wxToolBarToolsList::compatibility_iterator node = m_tools.GetFirst(); node;
</mark><br>2225<mark>            node = node->GetNext() ) {
</mark><br>2226<mark>        const wxToolBarToolBase * const tool = node->GetData();
</mark><br>2227<mark>        if( tool->IsControl() ) {
</mark><br>2228<mark>            wxControl * const control = tool->GetControl();
</mark><br>2229<mark>
</mark><br>2230<mark>            if( !control ) {
</mark><br>2231<mark>                wxFAIL_MSG( _T("NULL control in toolbar?") );
</mark><br>2232<mark>            } else
</mark><br>2233<mark>                if( control->GetId() == id ) {
</mark><br>2234<mark>                    // found
</mark><br>2235<mark>                    return control;
</mark><br>2236<mark>                }
</mark><br>2237<mark>        }
</mark><br>2238<mark>    }
</mark><br>2239<mark>
</mark><br>2240<mark>    return NULL;
</mark><br>2241<mark>}
</mark><br>2242<mark>
</mark><br>2243<mark>wxToolBarToolBase *ocpnToolBarSimple::FindById( int id ) const
</mark><br>2244<mark>{
</mark><br>2245<mark>    wxToolBarToolBase *tool = (wxToolBarToolBase *) NULL;
</mark><br>2246<mark>
</mark><br>2247<mark>    for( wxToolBarToolsList::compatibility_iterator node = m_tools.GetFirst(); node;
</mark><br>2248<mark>            node = node->GetNext() ) {
</mark><br>2249<mark>        tool = node->GetData();
</mark><br>2250<mark>        if( tool->GetId() == id ) {
</mark><br>2251<mark>            // found
</mark><br>2252<mark>            break;
</mark><br>2253<mark>        }
</mark><br>2254<mark>
</mark><br>2255<mark>        tool = NULL;
</mark><br>2256<mark>    }
</mark><br>2257<mark>
</mark><br>2258<mark>    return tool;
</mark><br>2259<mark>}
</mark><br>2260<mark>
</mark><br>2261<mark>// ----------------------------------------------------------------------------
</mark><br>2262<mark>// event processing
</mark><br>2263<mark>// ----------------------------------------------------------------------------
</mark><br>2264<mark>
</mark><br>2265<mark>// Only allow toggle if returns true
</mark><br>2266<mark>bool ocpnToolBarSimple::OnLeftClick( int id, bool toggleDown )
</mark><br>2267<mark>{
</mark><br>2268<mark>    wxCommandEvent event( wxEVT_COMMAND_TOOL_CLICKED, id );
</mark><br>2269<mark>    event.SetEventObject( this );
</mark><br>2270<mark>
</mark><br>2271<mark>    // we use SetInt() to make wxCommandEvent::IsChecked() return toggleDown
</mark><br>2272<mark>    event.SetInt( (int) toggleDown );
</mark><br>2273<mark>
</mark><br>2274<mark>    // and SetExtraLong() for backwards compatibility
</mark><br>2275<mark>    event.SetExtraLong( (long) toggleDown );
</mark><br>2276<mark>
</mark><br>2277<mark>    // Send events to this toolbar instead (and thence up the window hierarchy)
</mark><br>2278<mark>    GetEventHandler()->ProcessEvent( event );
</mark><br>2279<mark>
</mark><br>2280<mark>    return true;
</mark><br>2281<mark>}
</mark><br>2282<mark>
</mark><br>2283<mark>// Call when right button down.
</mark><br>2284<mark>void ocpnToolBarSimple::OnRightClick( int id, long WXUNUSED(x), long WXUNUSED(y) )
</mark><br>2285<mark>{
</mark><br>2286<mark>    wxCommandEvent event( wxEVT_COMMAND_TOOL_RCLICKED, id );
</mark><br>2287<mark>    event.SetEventObject( this );
</mark><br>2288<mark>    event.SetInt( id );
</mark><br>2289<mark>
</mark><br>2290<mark>    HideTooltip();
</mark><br>2291<mark>    ((ocpnFloatingToolbarDialog*)GetParent())->toolbarConfigChanged = false;
</mark><br>2292<mark>    wxMenu* contextMenu = new wxMenu();
</mark><br>2293<mark>    wxMenuItem* submenu = contextMenu->AppendSubMenu( g_FloatingToolbarConfigMenu, _("Visible buttons") );
</mark><br>2294<mark>
</mark><br>2295<mark>    PopupMenu( contextMenu );
</mark><br>2296<mark>
</mark><br>2297<mark>    contextMenu->Remove( submenu );
</mark><br>2298<mark>    delete contextMenu;
</mark><br>2299<mark>
</mark><br>2300<mark>    if( ((ocpnFloatingToolbarDialog*)GetParent())->toolbarConfigChanged )
</mark><br>2301<mark>        gFrame->GetEventHandler()->AddPendingEvent( event );
</mark><br>2302<mark>}
</mark><br>2303<mark>
</mark><br>2304<mark>// Called when the mouse cursor enters a tool bitmap (no button pressed).
</mark><br>2305<mark>// Argument is wxID_ANY if mouse is exiting the toolbar.
</mark><br>2306<mark>// Note that for this event, the id of the window is used,
</mark><br>2307<mark>// and the integer parameter of wxCommandEvent is used to retrieve
</mark><br>2308<mark>// the tool id.
</mark><br>2309<mark>void ocpnToolBarSimple::OnMouseEnter( int id )
</mark><br>2310<mark>{
</mark><br>2311<mark>    wxCommandEvent event( wxEVT_COMMAND_TOOL_ENTER, GetId() );
</mark><br>2312<mark>    event.SetEventObject( this );
</mark><br>2313<mark>    event.SetInt( id );
</mark><br>2314<mark>
</mark><br>2315<mark>    wxFrame *frame = wxDynamicCast(GetParent(), wxFrame);
</mark><br>2316<mark>    if( frame ) {
</mark><br>2317<mark>        wxString help;
</mark><br>2318<mark>        wxToolBarToolBase* tool = id == wxID_ANY ? (wxToolBarToolBase*) NULL : FindById( id );
</mark><br>2319<mark>        if( tool ) help = tool->GetLongHelp();
</mark><br>2320<mark>        frame->DoGiveHelp( help, id != wxID_ANY );
</mark><br>2321<mark>    }
</mark><br>2322<mark>
</mark><br>2323<mark>    (void) GetEventHandler()->ProcessEvent( event );
</mark><br>2324<mark>
</mark><br>2325<mark>    DoPluginToolUp();
</mark><br>2326<mark>}
</mark><br>2327<mark>
</mark><br>2328<mark>void ocpnToolBarSimple::DoPluginToolUp()
</mark><br>2329<mark>{
</mark><br>2330<mark>    //        Look for PlugIn tools
</mark><br>2331<mark>    //        If found, make the callback.
</mark><br>2332<mark>    if( !g_pi_manager)
</mark><br>2333<mark>        return;
</mark><br>2334<mark>
</mark><br>2335<mark>    ArrayOfPlugInToolbarTools tool_array = g_pi_manager->GetPluginToolbarToolArray();
</mark><br>2336<mark>    for( unsigned int i = 0; i < tool_array.GetCount(); i++ ) {
</mark><br>2337<mark>        PlugInToolbarToolContainer *pttc = tool_array.Item( i );
</mark><br>2338<mark>        if( m_last_plugin_down_id == pttc->id ) {
</mark><br>2339<mark>            opencpn_plugin_113 *ppi = dynamic_cast<opencpn_plugin_113 *>(pttc->m_pplugin);
</mark><br>2340<mark>            if( ppi )
</mark><br>2341<mark>                ppi->OnToolbarToolUpCallback( pttc->id );
</mark><br>2342<mark>        }
</mark><br>2343<mark>    }
</mark><br>2344<mark>
</mark><br>2345<mark>    m_last_plugin_down_id = -1;
</mark><br>2346<mark>}
</mark><br>2347<mark>
</mark><br>2348<mark>void ocpnToolBarSimple::SetToolNormalBitmapEx( wxToolBarToolBase *tool, const wxString &iconName)
</mark><br>2349<mark>{
</mark><br>2350<mark>    if( tool ) {
</mark><br>2351<mark>        ocpnToolBarTool *otool = (ocpnToolBarTool *) tool;
</mark><br>2352<mark>        if(otool){
</mark><br>2353<mark>            ocpnStyle::Style *style = g_StyleManager->GetCurrentStyle();
</mark><br>2354<mark>
</mark><br>2355<mark>            wxBitmap bmp = style->GetToolIcon( iconName, TOOLICON_NORMAL );
</mark><br>2356<mark>            if(m_sizefactor > 1.0 ){
</mark><br>2357<mark>                wxImage scaled_image = bmp.ConvertToImage();
</mark><br>2358<mark>                bmp = wxBitmap(scaled_image.Scale(otool->m_width, otool->m_height, wxIMAGE_QUALITY_HIGH));
</mark><br>2359<mark>            }
</mark><br>2360<mark>        
</mark><br>2361<mark>            tool->SetNormalBitmap( bmp );
</mark><br>2362<mark>            otool->SetIconName( iconName );
</mark><br>2363<mark>        }
</mark><br>2364<mark>    }
</mark><br>2365<mark>}
</mark><br>2366<mark>
</mark><br>2367<mark>
</mark><br>2368<mark>//-------------------------------------------------------------------------------------
</mark><br>2369<mark>
</mark><br>2370<mark>ToolbarMOBDialog::ToolbarMOBDialog( wxWindow* parent )
</mark><br>2371<mark>       : wxDialog( parent, wxID_ANY, _("OpenCPN Alert"), wxDefaultPosition, wxSize(250, 230) )
</mark><br>2372<mark>{
</mark><br>2373<mark>    wxBoxSizer* topSizer = new wxBoxSizer( wxVERTICAL );
</mark><br>2374<mark>
</mark><br>2375<mark>    wxBoxSizer* sizer = new wxBoxSizer( wxVERTICAL );
</mark><br>2376<mark>    topSizer->Add( sizer, 0, wxALIGN_CENTER_HORIZONTAL | wxALL, 5 );
</mark><br>2377<mark>
</mark><br>2378<mark>    choices.push_back( new wxRadioButton( this, 0,  _("No, I don't want to hide it."),
</mark><br>2379<mark>            wxDefaultPosition, wxDefaultSize, wxRB_GROUP ) );
</mark><br>2380<mark>
</mark><br>2381<mark>    choices.push_back( new wxRadioButton( this, 1, _("No, and permanently remove the option to hide it."),
</mark><br>2382<mark>            wxDefaultPosition) );
</mark><br>2383<mark>
</mark><br>2384<mark>    choices.push_back( new wxRadioButton( this, 2, _("Yes, hide it."),
</mark><br>2385<mark>            wxDefaultPosition) );
</mark><br>2386<mark>
</mark><br>2387<mark>    wxStdDialogButtonSizer* buttonSizer = CreateStdDialogButtonSizer( wxOK | wxCANCEL );
</mark><br>2388<mark>
</mark><br>2389<mark>
</mark><br>2390<mark>    wxStaticText* textCtrl = new wxStaticText( this, wxID_ANY, _("The Man Over Board button could be an important safety feature.\nAre you sure you want to hide it?") );
</mark><br>2391<mark>
</mark><br>2392<mark>    sizer->Add( textCtrl, 0, wxEXPAND | wxALL, 5 );
</mark><br>2393<mark>    sizer->Add( choices[0], 0, wxEXPAND | wxALL, 5 );
</mark><br>2394<mark>    sizer->Add( choices[1], 0, wxEXPAND | wxALL, 5 );
</mark><br>2395<mark>    sizer->Add( choices[2], 0, wxEXPAND | wxALL, 5 );
</mark><br>2396<mark>    sizer->Add( buttonSizer, 0, wxEXPAND | wxTOP, 5 );
</mark><br>2397<mark>
</mark><br>2398<mark>    topSizer->SetSizeHints(this);
</mark><br>2399<mark>    SetSizer( topSizer );
</mark><br>2400<mark>}
</mark><br>2401<mark>
</mark><br>2402<mark>int ToolbarMOBDialog::GetSelection() {
</mark><br>2403<mark>    for( unsigned int i=0; i<choices.size(); i++ ) {
</mark><br>2404<mark>        if( choices[i]->GetValue() ) return choices[i]->GetId();
</mark><br>2405<mark>    }
</mark><br>2406<mark>    return 0;
</mark><br>2407<mark>}
</mark></p></body>
    </html>