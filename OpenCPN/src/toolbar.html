<html>
    <head></head>
    <body><p><br>1/***************************************************************************
<br>2 *
<br>3 * Project:  OpenCPN
<br>4 * Purpose:  OpenCPN Toolbar
<br>5 * Author:   David Register
<br>6 *
<br>7 ***************************************************************************
<br>8 *   Copyright (C) 2010 by David S. Register                               *
<br>9 *                                                                         *
<br>10 *   This program is free software; you can redistribute it and/or modify  *
<br>11 *   it under the terms of the GNU General Public License as published by  *
<br>12 *   the Free Software Foundation; either version 2 of the License, or     *
<br>13<mark> *   (at your option) any later version.                                   *
</mark><br>14 *                                                                         *
<br>15 *   This program is distributed in the hope that it will be useful,       *
<br>16 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
<br>17 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
<br>18 *   GNU General Public License for more details.                          *
<br>19 *                                                                         *
<br>20 *   You should have received a copy of the GNU General Public License     *
<br>21 *   along with this program; if not, write to the                         *
<br>22 *   Free Software Foundation, Inc.,                                       *
<br>23 *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,  USA.         *
<br>24 **************************************************************************/
<br>25
<br>26#include "wx/wxprec.h"
<br>27
<br>28#ifndef  WX_PRECOMP
<br>29#include "wx/wx.h"
<br>30#endif
<br>31
<br>32#include <vector>
<br>33
<br>34#include "ocpn_types.h"
<br>35#include "navutil.h"
<br>36#include "styles.h"
<br>37<mark>#include "toolbar.h"
</mark><br>38#include "chart1.h"
<br>39#include "pluginmanager.h"
<br>40#include "FontMgr.h"
<br>41
<br>42<mark>extern ocpnFloatingToolbarDialog* g_FloatingToolbarDialog;
</mark><br>43<mark>extern bool                       g_bTransparentToolbar;
</mark><br>44<mark>extern bool                       g_bTransparentToolbarInOpenGLOK;
</mark><br>45<mark>extern ChartCanvas*               cc1;
</mark><br>46extern bool                       g_bopengl;
<br>47<mark>extern ocpnToolBarSimple*         g_toolbar;
</mark><br>48extern ocpnStyle::StyleManager*   g_StyleManager;
<br>49<mark>extern MyFrame*                   gFrame;
</mark><br>50extern PlugInManager*             g_pi_manager;
<br>51<mark>extern wxMenu*                    g_FloatingToolbarConfigMenu;
</mark><br>52<mark>extern wxString                   g_toolbarConfig;
</mark><br>53extern bool                       g_bPermanentMOBIcon;
<br>54extern bool                       g_btouch;
<br>55extern bool                       g_bsmoothpanzoom;
<br>56
<br>57//----------------------------------------------------------------------------
<br>58<mark>// GrabberWindow Implementation
</mark><br>59//----------------------------------------------------------------------------
<br>60<mark>BEGIN_EVENT_TABLE(GrabberWin, wxPanel) EVT_MOUSE_EVENTS ( GrabberWin::MouseEvent )
</mark><br>61<mark>EVT_PAINT ( GrabberWin::OnPaint )
</mark><br>62END_EVENT_TABLE()
<br>63
<br>64<mark>GrabberWin::GrabberWin( wxWindow *parent, ocpnFloatingToolbarDialog *toolbar, float scale_factor, wxString icon_name, wxPoint position ):
</mark><br>65<mark>    wxPanel( parent, wxID_ANY, position, wxDefaultSize, wxNO_BORDER )
</mark><br>66{
<br>67    m_icon_name = icon_name;
<br>68    m_style = g_StyleManager->GetCurrentStyle();
<br>69<mark>    wxBitmap bitmap = m_style->GetIcon( icon_name );
</mark><br>70    if(scale_factor > 1.0f){
<br>71<mark>        int new_width = bitmap.GetWidth() * scale_factor;
</mark><br>72<mark>        int new_height = bitmap.GetHeight() * scale_factor;
</mark><br>73<mark>        wxImage scaled_image = bitmap.ConvertToImage();
</mark><br>74<mark>        m_bitmap = wxBitmap(scaled_image.Scale(new_width, new_height, wxIMAGE_QUALITY_HIGH));
</mark><br>75    }
<br>76    else
<br>77<mark>        m_bitmap = bitmap;
</mark><br>78
<br>79<mark>    SetSize( wxSize( m_bitmap.GetWidth(), m_bitmap.GetHeight() ) );
</mark><br>80<mark>    SetMinSize( wxSize( m_bitmap.GetWidth(), m_bitmap.GetHeight() ) );
</mark><br>81
<br>82    m_bLeftDown = false;
<br>83    m_bRightDown = false;
<br>84    m_scale_factor = scale_factor;
<br>85<mark>    m_ptoolbar = toolbar;
</mark><br>86    m_dragging = false;
<br>87    Hide();
<br>88    
<br>89}
<br>90
<br>91
<br>92<mark>void GrabberWin::OnPaint( wxPaintEvent& event )
</mark><br>93{
<br>94<mark>    wxPaintDC dc( this );
</mark><br>95    
<br>96<mark>    wxColour back_color = GetGlobalColor( _T("GREY2") );
</mark><br>97<mark>    SetBackgroundColour( back_color );
</mark><br>98    ClearBackground();
<br>99    
<br>100<mark>    dc.DrawBitmap( m_bitmap, 0, 0, true );
</mark><br>101}
<br>102
<br>103<mark>void GrabberWin::SetColorScheme( ColorScheme cs )
</mark><br>104{
<br>105<mark>    wxColour back_color = GetGlobalColor( _T("GREY2") );
</mark><br>106
<br>107<mark>    SetBackgroundColour( back_color );
</mark><br>108    ClearBackground();
<br>109
<br>110<mark>    wxBitmap bitmap = m_style->GetIcon( m_icon_name) ;
</mark><br>111    if(m_scale_factor > 1.0f){
<br>112<mark>        int new_width = bitmap.GetWidth() * m_scale_factor;
</mark><br>113<mark>        int new_height = bitmap.GetHeight() * m_scale_factor;
</mark><br>114<mark>        wxImage scaled_image = bitmap.ConvertToImage();
</mark><br>115<mark>        m_bitmap = wxBitmap(scaled_image.Scale(new_width, new_height, wxIMAGE_QUALITY_HIGH));
</mark><br>116    }
<br>117    else
<br>118<mark>        m_bitmap = bitmap;
</mark><br>119}
<br>120
<br>121<mark>void GrabberWin::MouseEvent( wxMouseEvent& event )
</mark><br>122{
<br>123<mark>    static wxPoint s_gspt;
</mark><br>124    int x, y;
<br>125
<br>126    event.GetPosition( &x, &y );
<br>127
<br>128<mark>    wxPoint spt = ClientToScreen( wxPoint( x, y ) );
</mark><br>129    if( event.LeftDown() ) {
<br>130<mark>        s_gspt = spt;
</mark><br>131    }
<br>132    
<br>133    
<br>134#ifndef __WXQT__
<br>135
<br>136    if( event.LeftDown() ) {
<br>137<mark>        CaptureMouse();
</mark><br>138    }
<br>139
<br>140    if( event.LeftUp() ) {
<br>141<mark>        if( HasCapture() ) ReleaseMouse();
</mark><br>142    }
<br>143
<br>144#endif
<br>145
<br>146
<br>147    if( event.RightDown() ){
<br>148<mark>        if(m_ptoolbar){
</mark><br>149<mark>            m_dragging = true;
</mark><br>150            
<br>151<mark>            if( !m_ptoolbar->m_bnavgrabber ){
</mark><br>152<mark>                m_ptoolbar->m_bnavgrabber = true;
</mark><br>153<mark>                m_ptoolbar->SetGrabber(_T("4WayMove") );
</mark><br>154            }
<br>155            else{
<br>156<mark>                m_ptoolbar->m_bnavgrabber = false;
</mark><br>157<mark>                m_ptoolbar->SetGrabber(_T("grabber_hi") );
</mark><br>158            }
<br>159                
<br>160        }
<br>161    }
<br>162    
<br>163
<br>164
<br>165    if( event.Dragging() ) {
<br>166<mark>        if(m_ptoolbar && m_ptoolbar->IsShown() /*&& m_ptoolbar->m_bnavgrabber*/){
</mark><br>167<mark>            wxPoint par_pos_old = m_ptoolbar->GetPosition();
</mark><br>168
<br>169<mark>            wxPoint par_pos = par_pos_old;
</mark><br>170<mark>            par_pos.x += spt.x - s_gspt.x;
</mark><br>171<mark>            par_pos.y += spt.y - s_gspt.y;
</mark><br>172
<br>173<mark>            m_ptoolbar->MoveDialogInScreenCoords( par_pos, par_pos_old );
</mark><br>174
<br>175<mark>            s_gspt = spt;
</mark><br>176<mark>            m_dragging = true;
</mark><br>177        }
<br>178
<br>179    }
<br>180
<br>181    if( event.LeftUp() ) {
<br>182<mark>        if(m_ptoolbar){
</mark><br>183<mark>            if(m_ptoolbar->m_bnavgrabber){
</mark><br>184                if(!m_dragging)
<br>185<mark>                    m_ptoolbar->ToggleOrientation();
</mark><br>186            }
<br>187            else if(!m_dragging){
<br>188<mark>                if(m_ptoolbar->m_bsubmerged){
</mark><br>189<mark>                    m_ptoolbar->SurfaceFromGrabber();
</mark><br>190                }
<br>191                else{
<br>192<mark>                    m_ptoolbar->SubmergeToGrabber();
</mark><br>193                 }
<br>194            }
<br>195        }
<br>196        m_dragging = false;
<br>197    }
<br>198    
<br>199    
<br>200#ifndef __OCPN__ANDROID__
<br>201<mark>    gFrame->Raise();
</mark><br>202#endif
<br>203    
<br>204}
<br>205
<br>206class ocpnToolBarTool: public wxToolBarToolBase {
<br>207public:
<br>208<mark>    ocpnToolBarTool( ocpnToolBarSimple *tbar, int id, const wxString& label,
</mark><br>209<mark>            const wxBitmap& bmpNormal, const wxBitmap& bmpRollover, wxItemKind kind,
</mark><br>210<mark>            wxObject *clientData, const wxString& shortHelp, const wxString& longHelp ) :
</mark><br>211<mark>            wxToolBarToolBase( (wxToolBarBase*) tbar, id, label, bmpNormal, bmpRollover, kind,
</mark><br>212<mark>                    clientData, shortHelp, longHelp )
</mark><br>213    {
<br>214<mark>        m_enabled = true;
</mark><br>215        m_toggled = false;
<br>216        rollover = false;
<br>217<mark>        bitmapOK = false;
</mark><br>218        m_btooltip_hiviz = false;
<br>219
<br>220        toolname = g_pi_manager->GetToolOwnerCommonName( id );
<br>221        if( toolname == _T("") ) {
<br>222            isPluginTool = false;
<br>223            toolname = label;
<br>224            iconName = label;
<br>225        } else {
<br>226<mark>            isPluginTool = true;
</mark><br>227<mark>            pluginNormalIcon = &bmpNormal;
</mark><br>228<mark>            pluginRolloverIcon = &bmpRollover;
</mark><br>229        }
<br>230    }
<br>231
<br>232    void SetSize( const wxSize& size )
<br>233    {
<br>234        m_width = size.x;
<br>235        m_height = size.y;
<br>236    }
<br>237
<br>238    wxCoord GetWidth() const
<br>239    {
<br>240        return m_width;
<br>241    }
<br>242
<br>243    wxCoord GetHeight() const
<br>244    {
<br>245        return m_height;
<br>246    }
<br>247
<br>248    wxString GetToolname()
<br>249    {
<br>250        return toolname;
<br>251    }
<br>252
<br>253    void SetIconName(wxString name)
<br>254    {
<br>255        iconName = name;
<br>256    }
<br>257    wxString GetIconName()
<br>258    {
<br>259        return iconName;
<br>260    }
<br>261
<br>262    void SetTooltipHiviz( bool enable){ m_btooltip_hiviz = enable; }
<br>263
<br>264    wxCoord m_x;
<br>265    wxCoord m_y;
<br>266    wxCoord m_width;
<br>267    wxCoord m_height;
<br>268    wxRect trect;
<br>269    wxString toolname;
<br>270    wxString iconName;
<br>271<mark>    const wxBitmap* pluginNormalIcon;
</mark><br>272<mark>    const wxBitmap* pluginRolloverIcon;
</mark><br>273    bool firstInLine;
<br>274    bool lastInLine;
<br>275    bool rollover;
<br>276<mark>    bool bitmapOK;
</mark><br>277    bool isPluginTool;
<br>278    bool b_hilite;
<br>279    bool m_btooltip_hiviz;
<br>280    wxRect last_rect;
<br>281};
<br>282
<br>283//---------------------------------------------------------------------------------------
<br>284<mark>//          ocpnFloatingToolbarDialog Implementation
</mark><br>285//---------------------------------------------------------------------------------------
<br>286<mark>BEGIN_EVENT_TABLE(ocpnFloatingToolbarDialog, wxDialog)
</mark><br>287<mark>    EVT_MOUSE_EVENTS ( ocpnFloatingToolbarDialog::MouseEvent )
</mark><br>288<mark>    EVT_MENU(wxID_ANY, ocpnFloatingToolbarDialog::OnToolLeftClick)
</mark><br>289<mark>    EVT_TIMER ( FADE_TIMER, ocpnFloatingToolbarDialog::FadeTimerEvent )
</mark><br>290<mark>    EVT_TIMER ( DESTROY_TIMER, ocpnFloatingToolbarDialog::DestroyTimerEvent )
</mark><br>291<mark>    EVT_WINDOW_CREATE(ocpnFloatingToolbarDialog::OnWindowCreate)
</mark><br>292END_EVENT_TABLE()
<br>293
<br>294<mark>ocpnFloatingToolbarDialog::ocpnFloatingToolbarDialog( wxWindow *parent, wxPoint position,
</mark><br>295                                                      long orient, float size_factor )
<br>296{
<br>297<mark>    m_pparent = parent;
</mark><br>298    long wstyle = wxNO_BORDER | wxFRAME_NO_TASKBAR;
<br>299#ifndef __WXMAC__
<br>300    wstyle |= wxFRAME_SHAPED;
<br>301#endif
<br>302
<br>303<mark>    m_ptoolbar = NULL;
</mark><br>304
<br>305#ifdef __WXOSX__
<br>306    wstyle |= wxSTAY_ON_TOP;
<br>307#endif
<br>308<mark>    wxDialog::Create( parent, -1, _T("ocpnToolbarDialog"), wxPoint( -1, -1 ), wxSize( -1, -1 ),
</mark><br>309            wstyle );
<br>310
<br>311    m_opacity = 255;
<br>312
<br>313<mark>    m_pGrabberwin = new GrabberWin( this, this, size_factor, _T("grabber_hi") );
</mark><br>314<mark>    m_pGrabberwin->Show();
</mark><br>315    
<br>316    m_pRecoverwin = NULL;
<br>317<mark>    m_position = position;
</mark><br>318    m_orient = orient;
<br>319    m_sizefactor = size_factor;
<br>320    
<br>321    m_bAutoHideToolbar = false;
<br>322    m_nAutoHideToolbar = 5;
<br>323    
<br>324
<br>325    m_style = g_StyleManager->GetCurrentStyle();
<br>326
<br>327<mark>// A top-level sizer
</mark><br>328<mark>    m_topSizer = new wxBoxSizer( wxHORIZONTAL );
</mark><br>329<mark>    SetSizer( m_topSizer );
</mark><br>330
<br>331    //    Set initial "Dock" parameters
<br>332    m_dock_x = 0;
<br>333    m_dock_y = 0;
<br>334    m_block = false;
<br>335
<br>336    m_marginsInvisible = m_style->marginsInvisible;
<br>337
<br>338//    if(m_sizefactor > 1.0 )
<br>339<mark> //       m_marginsInvisible = true;
</mark><br>340
<br>341<mark>    m_bnavgrabber = false;    
</mark><br>342    
<br>343    Hide();
<br>344
<br>345    m_bsubmerged = false;
<br>346    
<br>347    m_fade_timer.SetOwner( this, FADE_TIMER );
<br>348<mark>    if( g_bTransparentToolbar )
</mark><br>349        m_fade_timer.Start( 5000 );
<br>350    
<br>351    if( m_bAutoHideToolbar && (m_nAutoHideToolbar > 0))
<br>352        m_fade_timer.Start( m_nAutoHideToolbar * 1000 );
<br>353    
<br>354    m_destroyTimer.SetOwner( this, DESTROY_TIMER );
<br>355}
<br>356
<br>357<mark>ocpnFloatingToolbarDialog::~ocpnFloatingToolbarDialog()
</mark><br>358{
<br>359    DestroyToolBar();
<br>360}
<br>361
<br>362<mark>void ocpnFloatingToolbarDialog::OnWindowCreate( wxWindowCreateEvent& event )
</mark><br>363{
<br>364    Realize();
<br>365}
<br>366
<br>367<mark>void ocpnFloatingToolbarDialog::SetGrabber( wxString icon_name )
</mark><br>368{
<br>369<mark>//    m_pGrabberwin->Destroy();
</mark><br>370<mark>    m_pGrabberwin = new GrabberWin( this, this, m_sizefactor, icon_name );
</mark><br>371<mark>    m_pGrabberwin->Show();
</mark><br>372    
<br>373    Realize();
<br>374    
<br>375#ifdef __WXOSX__    
<br>376<mark>    m_pGrabberwin->Refresh();
</mark><br>377#endif    
<br>378    
<br>379}
<br>380
<br>381
<br>382    
<br>383<mark>void ocpnFloatingToolbarDialog::SetColorScheme( ColorScheme cs )
</mark><br>384{
<br>385    m_cs = cs;
<br>386
<br>387<mark>    wxColour back_color = GetGlobalColor( _T("GREY2") );
</mark><br>388
<br>389    //  Set background
<br>390<mark>    SetBackgroundColour( back_color );
</mark><br>391    ClearBackground();
<br>392
<br>393<mark>    if( m_ptoolbar ) {
</mark><br>394<mark>        wxColour back_color = GetGlobalColor( _T("GREY2") );
</mark><br>395
<br>396        //  Set background
<br>397<mark>        m_ptoolbar->SetBackgroundColour( back_color );
</mark><br>398<mark>        m_ptoolbar->ClearBackground();
</mark><br>399
<br>400<mark>        m_ptoolbar->SetToggledBackgroundColour( GetGlobalColor( _T("GREY1") ) );
</mark><br>401
<br>402<mark>        m_ptoolbar->SetColorScheme( cs );
</mark><br>403<mark>        m_ptoolbar->Refresh( true );
</mark><br>404    }
<br>405
<br>406<mark>    if( m_pGrabberwin ) m_pGrabberwin->SetColorScheme( cs );
</mark><br>407
<br>408}
<br>409
<br>410<mark>void ocpnFloatingToolbarDialog::SetGeometry(bool bAvoid, wxRect rectAvoid)
</mark><br>411{
<br>412
<br>413<mark>    if( m_ptoolbar ) {
</mark><br>414        wxSize style_tool_size = m_style->GetToolSize();
<br>415
<br>416        style_tool_size.x *= m_sizefactor;
<br>417        style_tool_size.y *= m_sizefactor;
<br>418
<br>419<mark>        m_ptoolbar->SetToolBitmapSize( style_tool_size );
</mark><br>420
<br>421<mark>        wxSize tool_size = m_ptoolbar->GetToolBitmapSize();
</mark><br>422<mark>        int grabber_width =  m_style->GetIcon( _T("grabber") ).GetWidth();
</mark><br>423        
<br>424        int max_rows = 10;
<br>425        int max_cols = 100;
<br>426<mark>        if(cc1){
</mark><br>427
<br>428<mark>            int avoid_start = cc1->GetClientSize().x - (tool_size.x + m_style->GetToolSeparation()) * 2;  // default
</mark><br>429<mark>            if(bAvoid && !rectAvoid.IsEmpty()){
</mark><br>430<mark>                avoid_start = cc1->GetClientSize().x - rectAvoid.width - 10;  // this is compass window, if shown
</mark><br>431            }
<br>432            
<br>433            
<br>434<mark>            max_rows = (cc1->GetClientSize().y / ( tool_size.y + m_style->GetToolSeparation())) - 1;
</mark><br>435            
<br>436<mark>            max_cols = (avoid_start - grabber_width) / ( tool_size.x + m_style->GetToolSeparation());
</mark><br>437            max_cols -= 1;
<br>438            
<br>439            if(m_orient == wxTB_VERTICAL)
<br>440                max_rows = wxMax( max_rows, 2);             // at least two rows
<br>441            else
<br>442                max_cols = wxMax( max_cols, 2);             // at least two columns
<br>443        }
<br>444
<br>445        if( m_orient == wxTB_VERTICAL )
<br>446<mark>            m_ptoolbar->SetMaxRowsCols(max_rows, 100);
</mark><br>447        else
<br>448<mark>            m_ptoolbar->SetMaxRowsCols( 100, max_cols);
</mark><br>449<mark>        m_ptoolbar->SetSizeFactor(m_sizefactor);
</mark><br>450        
<br>451    }
<br>452 }
<br>453
<br>454<mark>void ocpnFloatingToolbarDialog::RePosition()
</mark><br>455{
<br>456    if(m_block) return;
<br>457
<br>458<mark>    if( m_pparent && m_ptoolbar ) {
</mark><br>459<mark>        wxSize cs = m_pparent->GetClientSize();
</mark><br>460<mark>        if( -1 == m_dock_x ) m_position.x = 0;
</mark><br>461        else
<br>462<mark>            if( 1 == m_dock_x ) m_position.x = cs.x - GetSize().x;
</mark><br>463
<br>464<mark>        if( -1 == m_dock_y ) m_position.y = 0;
</mark><br>465        else
<br>466<mark>            if( 1 == m_dock_y ) m_position.y = cs.y - GetSize().y;
</mark><br>467
<br>468<mark>        m_position.x = wxMin(cs.x - GetSize().x, m_position.x);
</mark><br>469<mark>        m_position.y = wxMin(cs.y - GetSize().y, m_position.y);
</mark><br>470
<br>471<mark>        m_position.x = wxMax(0, m_position.x);
</mark><br>472<mark>        m_position.y = wxMax(0, m_position.y);
</mark><br>473
<br>474<mark>        wxPoint screen_pos = m_pparent->ClientToScreen( m_position );
</mark><br>475
<br>476<mark>        Move( screen_pos );
</mark><br>477
<br>478#ifdef __WXQT__
<br>479        Raise();
<br>480#endif
<br>481
<br>482    }
<br>483}
<br>484
<br>485<mark>void ocpnFloatingToolbarDialog::Submerge()
</mark><br>486{
<br>487<mark>    m_bsubmerged = true;
</mark><br>488    Hide();
<br>489<mark>    if( m_ptoolbar ) m_ptoolbar->KillTooltip();
</mark><br>490}
<br>491
<br>492<mark>void ocpnFloatingToolbarDialog::SubmergeToGrabber()
</mark><br>493{
<br>494//Submerge();
<br>495<mark>    m_bsubmerged = true;
</mark><br>496    Hide();
<br>497<mark>    if( m_ptoolbar ) m_ptoolbar->KillTooltip();
</mark><br>498
<br>499<mark>    m_pRecoverwin = new GrabberWin( m_pparent, this, m_sizefactor, _T("grabber_ext" ), wxPoint(10,10) );
</mark><br>500   
<br>501    m_pRecoverwin->Show();
<br>502    m_pRecoverwin->Raise();
<br>503#ifdef __WXQT__
<br>504<mark>    wxSize s = gFrame->GetSize();
</mark><br>505    m_recoversize = s;
<br>506    s.y--;
<br>507<mark>    gFrame->TriggerResize(s);
</mark><br>508    Raise();
<br>509#endif    
<br>510
<br>511<mark>    gFrame->Refresh();          // Needed for MSW OpenGL
</mark><br>512}
<br>513
<br>514<mark>void ocpnFloatingToolbarDialog::Surface()
</mark><br>515{
<br>516    
<br>517    if(m_pRecoverwin){
<br>518        m_pRecoverwin->Show();
<br>519        m_pRecoverwin->Raise();
<br>520    }
<br>521    else {
<br>522        m_bsubmerged = false;
<br>523        #ifndef __WXOSX__
<br>524        Hide();
<br>525        Move( 0, 0 );
<br>526        #endif
<br>527
<br>528        RePosition();
<br>529        Show();
<br>530<mark>        if( m_ptoolbar )
</mark><br>531<mark>            m_ptoolbar->EnableTooltips();
</mark><br>532
<br>533        #ifdef __WXQT__
<br>534        Raise();
<br>535        #endif
<br>536    }
<br>537    
<br>538    if( m_bAutoHideToolbar && (m_nAutoHideToolbar > 0) ){
<br>539        m_fade_timer.Start( m_nAutoHideToolbar * 1000 );
<br>540    }
<br>541}
<br>542
<br>543<mark>bool ocpnFloatingToolbarDialog::CheckSurfaceRequest( wxMouseEvent &event )
</mark><br>544{
<br>545    if( m_bsubmerged ){
<br>546        if( event.LeftUp() ){
<br>547            int x,y;
<br>548            event.GetPosition( &x, &y );
<br>549            if( m_pRecoverwin ){
<br>550                wxRect winRect = m_pRecoverwin->GetRect();
<br>551                if( winRect.Contains( x, y ) ){
<br>552<mark>                    SurfaceFromGrabber();
</mark><br>553<mark>                    return true;
</mark><br>554                }
<br>555            }
<br>556        }
<br>557    }
<br>558    
<br>559    return false;
<br>560}
<br>561        
<br>562<mark>void ocpnFloatingToolbarDialog::SurfaceFromGrabber()
</mark><br>563{
<br>564    m_bsubmerged = false;
<br>565    
<br>566#ifndef __WXOSX__
<br>567    Hide();
<br>568    Move( 0, 0 );
<br>569#endif
<br>570
<br>571<mark>    if( m_ptoolbar )
</mark><br>572<mark>        m_ptoolbar->InvalidateBitmaps();
</mark><br>573    
<br>574    RePosition();
<br>575    Show();
<br>576<mark>    if( m_ptoolbar )
</mark><br>577<mark>        m_ptoolbar->EnableTooltips();
</mark><br>578    
<br>579    if( m_bAutoHideToolbar && (m_nAutoHideToolbar > 0) ){
<br>580        m_fade_timer.Start( m_nAutoHideToolbar * 1000 );
<br>581    }
<br>582    
<br>583#ifdef __WXQT__
<br>584<mark>    wxSize s = gFrame->GetSize();               // check for rotation
</mark><br>585    if(m_recoversize.x == s.x)
<br>586<mark>        gFrame->TriggerResize(m_recoversize);
</mark><br>587    Raise();
<br>588#endif
<br>589    
<br>590<mark>    m_destroyGrabber = m_pRecoverwin;
</mark><br>591<mark>    m_destroyTimer.Start( 5, wxTIMER_ONE_SHOT );           //  Destor the unneeded recovery grabber
</mark><br>592    
<br>593}
<br>594
<br>595<mark>void ocpnFloatingToolbarDialog::DestroyTimerEvent( wxTimerEvent& event )
</mark><br>596{
<br>597<mark>    delete m_destroyGrabber;
</mark><br>598<mark>    m_destroyGrabber = NULL;
</mark><br>599    m_pRecoverwin = NULL;
<br>600}
<br>601
<br>602<mark>void ocpnFloatingToolbarDialog::HideTooltip()
</mark><br>603{
<br>604<mark>    if( m_ptoolbar ) m_ptoolbar->HideTooltip();
</mark><br>605}
<br>606
<br>607<mark>void ocpnFloatingToolbarDialog::ShowTooltips()
</mark><br>608{
<br>609<mark>    if( m_ptoolbar ) m_ptoolbar->EnableTooltips();
</mark><br>610}
<br>611
<br>612<mark>void ocpnFloatingToolbarDialog::ToggleOrientation()
</mark><br>613{
<br>614    if( m_orient == wxTB_HORIZONTAL )
<br>615        m_orient = wxTB_VERTICAL;
<br>616    else
<br>617        m_orient = wxTB_HORIZONTAL;
<br>618
<br>619    m_style->SetOrientation( m_orient );
<br>620
<br>621<mark>    wxPoint old_screen_pos = m_pparent->ClientToScreen( m_position );
</mark><br>622<mark>    wxPoint grabber_point_abs = ClientToScreen( m_pGrabberwin->GetPosition() );
</mark><br>623
<br>624<mark>    gFrame->RequestNewToolbar();
</mark><br>625<mark>    wxPoint pos_abs = grabber_point_abs;
</mark><br>626<mark>    pos_abs.x -= m_pGrabberwin->GetPosition().x;
</mark><br>627<mark>    MoveDialogInScreenCoords( pos_abs, old_screen_pos );
</mark><br>628
<br>629
<br>630<mark>    Show();   // this seems to be necessary on GTK to kick the sizer into gear...(FS#553)
</mark><br>631<mark>    Refresh(true);
</mark><br>632    Raise();
<br>633}
<br>634
<br>635<mark>void ocpnFloatingToolbarDialog::MouseEvent( wxMouseEvent& event )
</mark><br>636{
<br>637<mark>    if( g_bTransparentToolbar ) {
</mark><br>638        if( event.Entering() && ( m_opacity < 255 ) ) {
<br>639<mark>            SetTransparent( 255 );
</mark><br>640            m_opacity = 255;
<br>641        }
<br>642
<br>643        m_fade_timer.Start( 5000 );           // retrigger the continuous timer
<br>644    }
<br>645    
<br>646    if(m_bAutoHideToolbar && (m_nAutoHideToolbar > 0) ){
<br>647        m_fade_timer.Start( m_nAutoHideToolbar * 1000 );
<br>648    }
<br>649}
<br>650
<br>651<mark>void ocpnFloatingToolbarDialog::FadeTimerEvent( wxTimerEvent& event )
</mark><br>652{
<br>653<mark>    if(m_bnavgrabber){
</mark><br>654<mark>        m_fade_timer.Start( 5000 );           // do nothing if nav grabber is shown
</mark><br>655    }
<br>656    else{
<br>657<mark>        if( g_bTransparentToolbar && (!g_bopengl || g_bTransparentToolbarInOpenGLOK) ){
</mark><br>658            DoFade( 128 );
<br>659            m_fade_timer.Start( 5000 );           // retrigger the continuous timer
<br>660        }
<br>661        
<br>662        if(m_bAutoHideToolbar && (m_nAutoHideToolbar > 0) && !m_bsubmerged){
<br>663<mark>            SubmergeToGrabber();
</mark><br>664//            m_fade_timer.Stop();
<br>665        }
<br>666    }
<br>667}
<br>668
<br>669<mark>void ocpnFloatingToolbarDialog::SetAutoHideTimer(int time)
</mark><br>670{
<br>671    m_nAutoHideToolbar = time;
<br>672    if(m_bAutoHideToolbar){
<br>673        m_fade_timer.Stop();
<br>674        m_fade_timer.Start( m_nAutoHideToolbar * 1000 );
<br>675    }
<br>676}
<br>677        
<br>678<mark>void ocpnFloatingToolbarDialog::DoFade( int value )
</mark><br>679{
<br>680<mark>    if( value != m_opacity ) SetTransparent( value );
</mark><br>681    m_opacity = value;
<br>682}
<br>683
<br>684<mark>void ocpnFloatingToolbarDialog::RefreshFadeTimer()
</mark><br>685{
<br>686<mark>    SetTransparent( 255 );
</mark><br>687    m_opacity = 255;
<br>688    m_fade_timer.Start( 500 );           // retrigger the continuous timer
<br>689    
<br>690    if(m_bAutoHideToolbar && (m_nAutoHideToolbar > 0) ){
<br>691        m_fade_timer.Start( m_nAutoHideToolbar * 1000 );
<br>692    }
<br>693    
<br>694}
<br>695
<br>696<mark>void ocpnFloatingToolbarDialog::MoveDialogInScreenCoords( wxPoint posn, wxPoint posn_old )
</mark><br>697{
<br>698<mark>    wxPoint pos_in_parent = m_pparent->ScreenToClient( posn );
</mark><br>699<mark>    wxPoint pos_in_parent_old = m_pparent->ScreenToClient( posn_old );
</mark><br>700
<br>701    //    "Docking" support
<br>702#define DOCK_MARGIN 40
<br>703
<br>704    // X
<br>705    m_dock_x = 0;
<br>706<mark>    if( pos_in_parent.x < pos_in_parent_old.x )            // moving left
</mark><br>707            {
<br>708<mark>        if( pos_in_parent.x < DOCK_MARGIN ) {
</mark><br>709<mark>            pos_in_parent.x = 0;
</mark><br>710            m_dock_x = -1;
<br>711        }
<br>712    } else
<br>713<mark>        if( pos_in_parent.x > pos_in_parent_old.x )            // moving right
</mark><br>714                {
<br>715<mark>            int max_right = m_pparent->GetClientSize().x - GetSize().x;
</mark><br>716<mark>            if( pos_in_parent.x > ( max_right - DOCK_MARGIN ) ) {
</mark><br>717<mark>                pos_in_parent.x = max_right;
</mark><br>718                m_dock_x = 1;
<br>719            }
<br>720        }
<br>721
<br>722    // Y
<br>723    m_dock_y = 0;
<br>724<mark>    if( pos_in_parent.y < pos_in_parent_old.y )            // moving up
</mark><br>725            {
<br>726<mark>        if( pos_in_parent.y < DOCK_MARGIN ) {
</mark><br>727<mark>            pos_in_parent.y = 0;
</mark><br>728            m_dock_y = -1;
<br>729        }
<br>730    } else
<br>731<mark>        if( pos_in_parent.y > pos_in_parent_old.y )            // moving down
</mark><br>732                {
<br>733<mark>            int max_down = m_pparent->GetClientSize().y - GetSize().y;
</mark><br>734<mark>            if( pos_in_parent.y > ( max_down - DOCK_MARGIN ) ) {
</mark><br>735<mark>                pos_in_parent.y = max_down;
</mark><br>736                m_dock_y = 1;
<br>737            }
<br>738        }
<br>739
<br>740<mark>    m_position = pos_in_parent;
</mark><br>741
<br>742<mark>    wxPoint final_pos = m_pparent->ClientToScreen( pos_in_parent );
</mark><br>743
<br>744<mark>    Move( final_pos );
</mark><br>745}
<br>746
<br>747<mark>void ocpnFloatingToolbarDialog::Realize()
</mark><br>748{
<br>749<mark>    if( m_ptoolbar ) {
</mark><br>750<mark>        m_ptoolbar->Realize();
</mark><br>751
<br>752<mark>        m_topSizer->Clear();
</mark><br>753<mark>        m_topSizer->Add( m_ptoolbar );
</mark><br>754<mark>        m_topSizer->Add( m_pGrabberwin, 0, wxTOP, m_style->GetTopMargin() );
</mark><br>755
<br>756<mark>        m_topSizer->Layout();
</mark><br>757        Fit();
<br>758
<br>759        //    Update "Dock" parameters
<br>760<mark>        if( m_position.x == 0 ) m_dock_x = -1;
</mark><br>761        else
<br>762<mark>            if( m_position.x == m_pparent->GetClientSize().x - GetSize().x ) m_dock_x = 1;
</mark><br>763
<br>764<mark>        if( m_position.y == 0 ) m_dock_y = -1;
</mark><br>765        else
<br>766<mark>            if( m_position.y == m_pparent->GetClientSize().y - GetSize().y ) m_dock_y = 1;
</mark><br>767
<br>768<mark>        // Now create a bitmap mask forthe frame shape.
</mark><br>769
<br>770        if( m_marginsInvisible ) {
<br>771
<br>772<mark>            wxSize tool_size = m_ptoolbar->GetToolBitmapSize();
</mark><br>773
<br>774            //  Determine whether the tool icons are meant (by style) to join without speces between
<br>775            //  This will determine what type of region to draw.
<br>776            bool b_overlap = false;
<br>777
<br>778<mark>            wxToolBarToolsList::compatibility_iterator node1 = m_ptoolbar->m_tools.GetFirst();
</mark><br>779            wxToolBarToolsList::compatibility_iterator node2 = node1->GetNext() ;
<br>780
<br>781            wxToolBarToolBase *tool1 = node1->GetData();
<br>782            ocpnToolBarTool *tools1 = (ocpnToolBarTool *) tool1;
<br>783
<br>784            wxToolBarToolBase *tool2 = node2->GetData();
<br>785            ocpnToolBarTool *tools2 = (ocpnToolBarTool *) tool2;
<br>786
<br>787            if( (tools1->m_x + tools1->m_width) >= tools2->m_x)
<br>788<mark>                b_overlap = true;
</mark><br>789
<br>790
<br>791
<br>792
<br>793<mark>            int toolCount = m_ptoolbar->GetVisibleToolCount();
</mark><br>794
<br>795<mark>            wxPoint upperLeft( m_style->GetLeftMargin(), m_style->GetTopMargin() );
</mark><br>796            wxSize visibleSize;
<br>797<mark>            if( m_ptoolbar->IsVertical() ) {
</mark><br>798<mark>                int noTools = m_ptoolbar->GetMaxRows();
</mark><br>799                if( noTools > toolCount )
<br>800                    noTools = toolCount;
<br>801<mark>                visibleSize.x = m_ptoolbar->GetLineCount() * ( tool_size.x + m_style->GetTopMargin() );
</mark><br>802                visibleSize.y = noTools * ( tool_size.y + m_style->GetToolSeparation() );
<br>803                visibleSize.x -= m_style->GetTopMargin();
<br>804                visibleSize.y -= m_style->GetToolSeparation();
<br>805            } else {
<br>806<mark>                    int noTools = m_ptoolbar->GetMaxCols();
</mark><br>807                    if( noTools > toolCount )
<br>808                        noTools = toolCount;
<br>809                visibleSize.x = noTools * ( tool_size.x + m_style->GetToolSeparation() );
<br>810<mark>                visibleSize.y = m_ptoolbar->GetLineCount() * ( tool_size.y + m_style->GetTopMargin() );
</mark><br>811                visibleSize.x -= m_style->GetToolSeparation();
<br>812                visibleSize.y -= m_style->GetTopMargin();
<br>813            }
<br>814
<br>815<mark>            wxBitmap shape( visibleSize.x + tool_size.x, visibleSize.y + tool_size.y);          // + fluff
</mark><br>816<mark>            wxMemoryDC sdc( shape );
</mark><br>817<mark>            sdc.SetBackground( *wxWHITE_BRUSH );
</mark><br>818<mark>            sdc.SetBrush( *wxBLACK_BRUSH );
</mark><br>819<mark>            sdc.SetPen( *wxBLACK_PEN );
</mark><br>820<mark>            sdc.Clear();
</mark><br>821
<br>822            if(b_overlap) {
<br>823<mark>                int lines = m_ptoolbar->GetLineCount();
</mark><br>824                for( int i = 1; i <= lines; i++ ) {
<br>825<mark>                    if( m_ptoolbar->IsVertical() ) {
</mark><br>826                        wxSize barsize( tool_size.x, visibleSize.y );
<br>827                        if( i == lines && i > 1 ) {
<br>828<mark>                            int toolsInLastLine = toolCount % m_ptoolbar->GetMaxRows();
</mark><br>829<mark>                            if( toolsInLastLine == 0 ) toolsInLastLine = m_ptoolbar->GetMaxRows();
</mark><br>830<mark>                            int emptySpace = ( m_ptoolbar->GetMaxRows() - toolsInLastLine );
</mark><br>831<mark>                            barsize.y -= emptySpace
</mark><br>832                            * ( tool_size.y + m_style->GetToolSeparation() );
<br>833                        }
<br>834                        if( i == lines ) {
<br>835<mark>                            // Also do grabber here, since it is to the right of the last line.
</mark><br>836<mark>                            wxRect grabMask( upperLeft, barsize );
</mark><br>837<mark>                            grabMask.width += m_style->GetIcon( _T("grabber") ).GetWidth();
</mark><br>838<mark>                            grabMask.height = m_style->GetIcon( _T("grabber") ).GetHeight();
</mark><br>839<mark>                            sdc.DrawRoundedRectangle( grabMask, m_style->GetToolbarCornerRadius() );
</mark><br>840                        }
<br>841<mark>                        sdc.DrawRoundedRectangle( upperLeft, barsize,
</mark><br>842                                m_style->GetToolbarCornerRadius() );
<br>843<mark>                        upperLeft.x += m_style->GetTopMargin() + tool_size.x;
</mark><br>844                    } else {
<br>845                        wxSize barsize( visibleSize.x, tool_size.y );
<br>846
<br>847                        if( i == 1 ) {
<br>848<mark>                            barsize.x += m_style->GetIcon( _T("grabber") ).GetWidth();
</mark><br>849                        }
<br>850                        if( i == lines && i > 1 ) {
<br>851<mark>                            int toolsInLastLine = toolCount % m_ptoolbar->GetMaxCols();
</mark><br>852<mark>                            if( toolsInLastLine == 0 ) toolsInLastLine = m_ptoolbar->GetMaxCols();
</mark><br>853<mark>                            int emptySpace = ( m_ptoolbar->GetMaxCols() - toolsInLastLine );
</mark><br>854<mark>                            barsize.x -= emptySpace * ( tool_size.x + m_style->GetToolSeparation() );
</mark><br>855                        }
<br>856
<br>857<mark>                        sdc.DrawRoundedRectangle( upperLeft, barsize,
</mark><br>858                                m_style->GetToolbarCornerRadius() );
<br>859<mark>                        upperLeft.y += m_style->GetTopMargin() + tool_size.y;
</mark><br>860                    }
<br>861                }
<br>862            } //b_overlap
<br>863            else {
<br>864<mark>                for( wxToolBarToolsList::compatibility_iterator node = m_ptoolbar->m_tools.GetFirst(); node; node = node->GetNext() ) {
</mark><br>865                    wxToolBarToolBase *tool = node->GetData();
<br>866                    ocpnToolBarTool *tools = (ocpnToolBarTool *) tool;
<br>867                    wxRect toolRect = tools->trect;
<br>868
<br>869<mark>                    sdc.DrawRoundedRectangle( tools->m_x, tools->m_y, tool_size.x, tool_size.y,
</mark><br>870                                              m_style->GetToolbarCornerRadius() );
<br>871                }
<br>872            }
<br>873
<br>874#ifndef __OCPN__ANDROID__
<br>875<mark>            if(shape.GetWidth() && shape.GetHeight())
</mark><br>876<mark>                SetShape( wxRegion( shape, *wxWHITE, 10 ) );
</mark><br>877#endif
<br>878        }
<br>879    }
<br>880}
<br>881
<br>882<mark>void ocpnFloatingToolbarDialog::OnToolLeftClick( wxCommandEvent& event )
</mark><br>883{
<br>884    // First see if it was actually the context menu that was clicked.
<br>885
<br>886    if( event.GetId() >= ID_PLUGIN_BASE + 100 ) {
<br>887
<br>888<mark>        int itemId = event.GetId() - ID_PLUGIN_BASE - 100;
</mark><br>889<mark>        wxMenuItem *item = g_FloatingToolbarConfigMenu->FindItem( event.GetId() );
</mark><br>890
<br>891<mark>        if(item){
</mark><br>892<mark>            bool toolIsChecked = item->IsChecked();
</mark><br>893
<br>894            if( toolIsChecked ) {
<br>895<mark>                g_toolbarConfig.SetChar( itemId, _T('X') );
</mark><br>896            } else {
<br>897
<br>898<mark>                if( itemId + ID_ZOOMIN == ID_MOB ) {
</mark><br>899                    ToolbarMOBDialog mdlg( this );
<br>900                    int dialog_ret = mdlg.ShowModal();
<br>901                    int answer = mdlg.GetSelection();
<br>902
<br>903                    if( answer == 0 || answer == 1 || dialog_ret == wxID_CANCEL ) {
<br>904<mark>                        g_FloatingToolbarConfigMenu->FindItem( event.GetId() )->Check( true );
</mark><br>905                        if( answer == 1 && dialog_ret == wxID_OK ) {
<br>906<mark>                            g_bPermanentMOBIcon = true;
</mark><br>907<mark>                            delete g_FloatingToolbarConfigMenu;
</mark><br>908<mark>                            g_FloatingToolbarConfigMenu = new wxMenu();
</mark><br>909<mark>                            toolbarConfigChanged = true;
</mark><br>910                        }
<br>911                        return;
<br>912                    }
<br>913                }
<br>914
<br>915<mark>                if( m_ptoolbar->GetVisibleToolCount() == 1 ) {
</mark><br>916                    OCPNMessageBox( this,
<br>917<mark>                            _("You can't hide the last tool from the toolbar\nas this would make it inaccessible."),
</mark><br>918                            _("OpenCPN Alert"), wxOK );
<br>919<mark>                    g_FloatingToolbarConfigMenu->FindItem( event.GetId() )->Check( true );
</mark><br>920                    return;
<br>921                }
<br>922
<br>923<mark>                g_toolbarConfig.SetChar( itemId, _T('.') );
</mark><br>924            }
<br>925        }
<br>926
<br>927<mark>        toolbarConfigChanged = true;
</mark><br>928        return;
<br>929    }
<br>930
<br>931    // No it was a button that was clicked.
<br>932    // Since Dialog events don't propagate automatically, we send it explicitly
<br>933    // (instead of relying on event.Skip()). Send events up the window hierarchy
<br>934
<br>935<mark>    m_pparent->GetEventHandler()->AddPendingEvent( event );
</mark><br>936#ifndef __WXQT__
<br>937<mark>    gFrame->Raise();
</mark><br>938#endif    
<br>939}
<br>940
<br>941<mark>ocpnToolBarSimple *ocpnFloatingToolbarDialog::GetToolbar()
</mark><br>942{
<br>943<mark>    if( !m_ptoolbar ) {
</mark><br>944        long winstyle = wxNO_BORDER | wxTB_FLAT;
<br>945        winstyle |= m_orient;
<br>946
<br>947<mark>        m_ptoolbar = new ocpnToolBarSimple( this, -1, wxPoint( -1, -1 ), wxSize( -1, -1 ),
</mark><br>948                winstyle );
<br>949
<br>950<mark>        m_ptoolbar->SetBackgroundColour( GetGlobalColor( _T("GREY2") ) );
</mark><br>951<mark>        m_ptoolbar->ClearBackground();
</mark><br>952<mark>        m_ptoolbar->SetToggledBackgroundColour( GetGlobalColor( _T("GREY1") ) );
</mark><br>953<mark>        m_ptoolbar->SetColorScheme( m_cs );
</mark><br>954
<br>955        SetGeometry(false, wxRect());
<br>956    }
<br>957
<br>958<mark>    return m_ptoolbar;
</mark><br>959}
<br>960
<br>961<mark>void ocpnFloatingToolbarDialog::DestroyToolBar()
</mark><br>962{
<br>963<mark>    if( m_ptoolbar ) {
</mark><br>964<mark>        m_ptoolbar->ClearTools();
</mark><br>965<mark>        delete m_ptoolbar;                  //->Destroy();
</mark><br>966<mark>        m_ptoolbar = NULL;
</mark><br>967    }
<br>968 
<br>969<mark>    m_destroyGrabber = m_pRecoverwin;
</mark><br>970<mark>    m_destroyTimer.Start( 5, wxTIMER_ONE_SHOT );           //  Destor the unneeded recovery grabber
</mark><br>971    
<br>972}
<br>973
<br>974//----------------------------------------------------------------------------
<br>975// Toolbar Tooltip Popup Window Definition
<br>976//----------------------------------------------------------------------------
<br>977class ToolTipWin: public wxDialog {
<br>978public:
<br>979<mark>    ToolTipWin( wxWindow *parent );
</mark><br>980    ~ToolTipWin();
<br>981
<br>982    void OnPaint( wxPaintEvent& event );
<br>983
<br>984    void SetColorScheme( ColorScheme cs );
<br>985    void SetString( wxString &s )
<br>986    {
<br>987        m_string = s;
<br>988    }
<br>989<mark>    void SetPosition( wxPoint pt )
</mark><br>990    {
<br>991<mark>        m_position = pt;
</mark><br>992    }
<br>993    void SetBitmap( void );
<br>994
<br>995    void SetHiviz( bool hiviz){ m_hiviz = hiviz; }
<br>996    
<br>997    wxSize GetRenderedSize( void );
<br>998    
<br>999private:
<br>1000
<br>1001    wxString m_string;
<br>1002    wxSize m_size;
<br>1003<mark>    wxPoint m_position;
</mark><br>1004<mark>    wxBitmap *m_pbm;
</mark><br>1005<mark>    wxColour m_back_color;
</mark><br>1006<mark>    wxColour m_text_color;
</mark><br>1007    ColorScheme m_cs ;
<br>1008    bool m_hiviz;
<br>1009
<br>1010DECLARE_EVENT_TABLE()
<br>1011};
<br>1012//-----------------------------------------------------------------------
<br>1013//
<br>1014//    Toolbar Tooltip window implementation
<br>1015//
<br>1016//-----------------------------------------------------------------------
<br>1017BEGIN_EVENT_TABLE(ToolTipWin, wxDialog) EVT_PAINT(ToolTipWin::OnPaint)
<br>1018
<br>1019END_EVENT_TABLE()
<br>1020
<br>1021<mark>// Define a constructor
</mark><br>1022<mark>ToolTipWin::ToolTipWin( wxWindow *parent ) :
</mark><br>1023<mark>        wxDialog( parent, wxID_ANY, _T(""), wxPoint( 0, 0 ), wxSize( 1, 1 ),
</mark><br>1024                wxNO_BORDER | wxSTAY_ON_TOP )
<br>1025{
<br>1026<mark>    m_pbm = NULL;
</mark><br>1027
<br>1028<mark>    m_back_color = GetGlobalColor( _T ( "UIBCK" ) );
</mark><br>1029<mark>    m_text_color = GetGlobalColor( _T ( "UITX1" ) );
</mark><br>1030
<br>1031    SetBackgroundStyle( wxBG_STYLE_CUSTOM );
<br>1032<mark>    SetBackgroundColour( m_back_color );
</mark><br>1033    m_cs = GLOBAL_COLOR_SCHEME_RGB;
<br>1034
<br>1035    Hide();
<br>1036}
<br>1037
<br>1038ToolTipWin::~ToolTipWin()
<br>1039{
<br>1040<mark>    delete m_pbm;
</mark><br>1041}
<br>1042
<br>1043void ToolTipWin::SetColorScheme( ColorScheme cs )
<br>1044{
<br>1045<mark>    m_back_color = GetGlobalColor( _T ( "UIBCK" ) );
</mark><br>1046<mark>    m_text_color = FontMgr::Get().GetFontColor( _("ToolTips") );
</mark><br>1047
<br>1048    m_cs = cs;
<br>1049}
<br>1050
<br>1051wxSize ToolTipWin::GetRenderedSize( void )
<br>1052{
<br>1053    int h, w;
<br>1054    wxSize sz;
<br>1055
<br>1056<mark>    wxClientDC cdc( GetParent() );
</mark><br>1057
<br>1058<mark>    wxFont *plabelFont = FontMgr::Get().GetFont( _("ToolTips") );
</mark><br>1059<mark>    cdc.GetTextExtent( m_string, &w, &h, NULL, NULL, plabelFont );
</mark><br>1060
<br>1061    sz.x = w + 8;
<br>1062    sz.y = h + 4;
<br>1063    
<br>1064    return sz;
<br>1065
<br>1066}
<br>1067
<br>1068void ToolTipWin::SetBitmap()
<br>1069{
<br>1070    int h, w;
<br>1071
<br>1072<mark>    wxClientDC cdc( GetParent() );
</mark><br>1073
<br>1074<mark>    wxFont *plabelFont = FontMgr::Get().GetFont( _("ToolTips") );
</mark><br>1075<mark>    cdc.GetTextExtent( m_string, &w, &h, NULL, NULL, plabelFont );
</mark><br>1076
<br>1077    m_size.x = w + 8;
<br>1078    m_size.y = h + 4;
<br>1079
<br>1080<mark>    wxMemoryDC mdc;
</mark><br>1081
<br>1082<mark>    delete m_pbm;
</mark><br>1083<mark>    m_pbm = new wxBitmap( m_size.x, m_size.y, -1 );
</mark><br>1084<mark>    mdc.SelectObject( *m_pbm );
</mark><br>1085
<br>1086<mark>    wxPen pborder( m_text_color );
</mark><br>1087<mark>    wxBrush bback( m_back_color );
</mark><br>1088<mark>    mdc.SetPen( pborder );
</mark><br>1089<mark>    mdc.SetBrush( bback );
</mark><br>1090
<br>1091    if(m_hiviz){
<br>1092        if((m_cs == GLOBAL_COLOR_SCHEME_DUSK) || (m_cs == GLOBAL_COLOR_SCHEME_NIGHT)){
<br>1093<mark>            wxBrush hv_back( wxColour(200,200,200));
</mark><br>1094<mark>            mdc.SetBrush( hv_back );
</mark><br>1095        }
<br>1096    }
<br>1097<mark>    mdc.DrawRectangle( 0, 0, m_size.x, m_size.y );
</mark><br>1098
<br>1099    //    Draw the text
<br>1100<mark>    mdc.SetFont( *plabelFont );
</mark><br>1101<mark>    mdc.SetTextForeground( m_text_color );
</mark><br>1102<mark>    mdc.SetTextBackground( m_back_color );
</mark><br>1103
<br>1104<mark>    mdc.DrawText( m_string, 4, 2 );
</mark><br>1105
<br>1106<mark>    SetSize( m_position.x, m_position.y, m_size.x, m_size.y );
</mark><br>1107
<br>1108}
<br>1109
<br>1110void ToolTipWin::OnPaint( wxPaintEvent& event )
<br>1111{
<br>1112    int width, height;
<br>1113    GetClientSize( &width, &height );
<br>1114<mark>    wxPaintDC dc( this );
</mark><br>1115
<br>1116    if( m_string.Len() ) {
<br>1117<mark>        wxMemoryDC mdc;
</mark><br>1118<mark>        mdc.SelectObject( *m_pbm );
</mark><br>1119<mark>        dc.Blit( 0, 0, width, height, &mdc, 0, 0 );
</mark><br>1120    }
<br>1121}
<br>1122
<br>1123
<br>1124// ----------------------------------------------------------------------------
<br>1125<mark>BEGIN_EVENT_TABLE(ocpnToolBarSimple, wxControl) EVT_SIZE(ocpnToolBarSimple::OnSize)
</mark><br>1126<mark>EVT_PAINT(ocpnToolBarSimple::OnPaint)
</mark><br>1127<mark>EVT_KILL_FOCUS(ocpnToolBarSimple::OnKillFocus)
</mark><br>1128<mark>EVT_MOUSE_EVENTS(ocpnToolBarSimple::OnMouseEvent)
</mark><br>1129<mark>EVT_TIMER(TOOLTIPON_TIMER, ocpnToolBarSimple::OnToolTipTimerEvent)
</mark><br>1130<mark>EVT_TIMER(TOOLTIPOFF_TIMER, ocpnToolBarSimple::OnToolTipOffTimerEvent)
</mark><br>1131
<br>1132END_EVENT_TABLE()
<br>1133
<br>1134// ============================================================================
<br>1135// implementation
<br>1136// ============================================================================
<br>1137
<br>1138// ----------------------------------------------------------------------------
<br>1139<mark>// tool bar tools creation
</mark><br>1140// ----------------------------------------------------------------------------
<br>1141
<br>1142<mark>wxToolBarToolBase *ocpnToolBarSimple::CreateTool( int id, const wxString& label,
</mark><br>1143<mark>        const wxBitmap& bmpNormal, const wxBitmap& bmpDisabled, wxItemKind kind,
</mark><br>1144<mark>        wxObject *clientData, const wxString& shortHelp, const wxString& longHelp )
</mark><br>1145{
<br>1146<mark>    return new ocpnToolBarTool( this, id, label, bmpNormal, bmpDisabled, kind, clientData,
</mark><br>1147            shortHelp, longHelp );
<br>1148}
<br>1149
<br>1150// ----------------------------------------------------------------------------
<br>1151<mark>// ocpnToolBarSimple creation
</mark><br>1152// ----------------------------------------------------------------------------
<br>1153
<br>1154<mark>void ocpnToolBarSimple::Init()
</mark><br>1155{
<br>1156    m_currentRowsOrColumns = 0;
<br>1157
<br>1158    m_lastX = m_lastY = 0;
<br>1159
<br>1160    m_maxWidth = m_maxHeight = 0;
<br>1161
<br>1162    m_pressedTool = m_currentTool = -1;
<br>1163
<br>1164    m_xPos = m_yPos = wxDefaultCoord;
<br>1165
<br>1166    m_style = g_StyleManager->GetCurrentStyle();
<br>1167
<br>1168    m_defaultWidth = 16;
<br>1169    m_defaultHeight = 15;
<br>1170
<br>1171    m_toggle_bg_color = wxSystemSettings::GetColour( wxSYS_COLOUR_3DFACE );
<br>1172    m_toolOutlineColour.Set( _T("BLACK") );
<br>1173    m_pToolTipWin = NULL;
<br>1174    m_last_ro_tool = NULL;
<br>1175
<br>1176<mark>    m_btoolbar_is_zooming = false;
</mark><br>1177    m_sizefactor = 1.0f;
<br>1178
<br>1179    m_last_plugin_down_id = -1;
<br>1180    
<br>1181    EnableTooltips();
<br>1182}
<br>1183
<br>1184<mark>wxToolBarToolBase *ocpnToolBarSimple::DoAddTool( int id, const wxString& label,
</mark><br>1185<mark>        const wxBitmap& bitmap, const wxBitmap& bmpDisabled, wxItemKind kind,
</mark><br>1186<mark>        const wxString& shortHelp, const wxString& longHelp, wxObject *clientData, wxCoord xPos,
</mark><br>1187        wxCoord yPos )
<br>1188{
<br>1189<mark>    // rememeber the position for DoInsertTool()
</mark><br>1190    m_xPos = xPos;
<br>1191    m_yPos = yPos;
<br>1192
<br>1193    InvalidateBestSize();
<br>1194<mark>    return InsertTool( GetToolsCount(), id, label, bitmap, bmpDisabled, kind, shortHelp, longHelp,
</mark><br>1195<mark>            clientData );
</mark><br>1196
<br>1197}
<br>1198
<br>1199///
<br>1200
<br>1201<mark>wxToolBarToolBase *ocpnToolBarSimple::AddTool( int toolid, const wxString& label,
</mark><br>1202<mark>        const wxBitmap& bitmap, const wxBitmap& bmpDisabled, wxItemKind kind,
</mark><br>1203<mark>        const wxString& shortHelp, const wxString& longHelp, wxObject *data )
</mark><br>1204{
<br>1205    InvalidateBestSize();
<br>1206<mark>    ocpnToolBarTool* tool = (ocpnToolBarTool*)InsertTool( GetToolsCount(), toolid, label, bitmap, bmpDisabled, kind,
</mark><br>1207<mark>            shortHelp, longHelp, data );
</mark><br>1208    return tool;
<br>1209}
<br>1210
<br>1211<mark>wxToolBarToolBase *ocpnToolBarSimple::InsertTool( size_t pos, int id, const wxString& label,
</mark><br>1212<mark>        const wxBitmap& bitmap, const wxBitmap& bmpDisabled, wxItemKind kind,
</mark><br>1213<mark>        const wxString& shortHelp, const wxString& longHelp, wxObject *clientData )
</mark><br>1214{
<br>1215    wxCHECK_MSG( pos <= GetToolsCount(), (wxToolBarToolBase *)NULL,
<br>1216<mark>            _T("invalid position in wxToolBar::InsertTool()") );
</mark><br>1217
<br>1218<mark>    wxToolBarToolBase *tool = CreateTool( id, label, bitmap, bmpDisabled, kind, clientData,
</mark><br>1219            shortHelp, longHelp );
<br>1220
<br>1221    if( !InsertTool( pos, tool ) ) {
<br>1222        delete tool;
<br>1223
<br>1224        return NULL;
<br>1225    }
<br>1226
<br>1227    return tool;
<br>1228}
<br>1229
<br>1230<mark>wxToolBarToolBase *ocpnToolBarSimple::InsertTool( size_t pos, wxToolBarToolBase *tool )
</mark><br>1231{
<br>1232    wxCHECK_MSG( pos <= GetToolsCount(), (wxToolBarToolBase *)NULL,
<br>1233<mark>            _T("invalid position in wxToolBar::InsertTool()") );
</mark><br>1234
<br>1235    if( !tool || !DoInsertTool( pos, tool ) ) {
<br>1236        return NULL;
<br>1237    }
<br>1238
<br>1239    m_tools.Insert( pos, tool );
<br>1240
<br>1241    return tool;
<br>1242}
<br>1243
<br>1244<mark>bool ocpnToolBarSimple::DoInsertTool( size_t WXUNUSED(pos), wxToolBarToolBase *toolBase )
</mark><br>1245{
<br>1246    ocpnToolBarTool *tool = (ocpnToolBarTool *) toolBase;
<br>1247
<br>1248    // Check if the plugin is inserting same-named tools. Make sure they have different names,
<br>1249    // otherwise the style manager cannot differentiate between them.
<br>1250    if( tool->isPluginTool ) {
<br>1251        for( unsigned int i=0; i<GetToolsCount(); i++ ) {
<br>1252            if( tool->GetToolname() == ((ocpnToolBarTool *)m_tools.Item(i)->GetData())->GetToolname()) {
<br>1253                tool->toolname << _T("1");
<br>1254            }
<br>1255        }
<br>1256    }
<br>1257
<br>1258    tool->m_x = m_xPos;
<br>1259    if( tool->m_x == wxDefaultCoord ) tool->m_x = m_style->GetLeftMargin();
<br>1260
<br>1261    tool->m_y = m_yPos;
<br>1262    if( tool->m_y == wxDefaultCoord ) tool->m_y = m_style->GetTopMargin();
<br>1263
<br>1264    if( tool->IsButton() ) {
<br>1265        tool->SetSize( GetToolSize() );
<br>1266
<br>1267        // Calculate reasonable max size in case Layout() not called
<br>1268        if( ( tool->m_x + tool->GetNormalBitmap().GetWidth() + m_style->GetLeftMargin() )
<br>1269                > m_maxWidth ) m_maxWidth = (wxCoord) ( ( tool->m_x + tool->GetWidth()
<br>1270                + m_style->GetLeftMargin() ) );
<br>1271
<br>1272        if( ( tool->m_y + tool->GetNormalBitmap().GetHeight() + m_style->GetTopMargin() )
<br>1273                > m_maxHeight ) m_maxHeight = (wxCoord) ( ( tool->m_y + tool->GetHeight()
<br>1274                + m_style->GetTopMargin() ) );
<br>1275    }
<br>1276
<br>1277    else
<br>1278        if( tool->IsControl() ) {
<br>1279            tool->SetSize( tool->GetControl()->GetSize() );
<br>1280        }
<br>1281
<br>1282    tool->b_hilite = false;
<br>1283
<br>1284<mark>    return true;
</mark><br>1285}
<br>1286
<br>1287<mark>bool ocpnToolBarSimple::DoDeleteTool( size_t WXUNUSED(pos), wxToolBarToolBase *tool )
</mark><br>1288{
<br>1289    // VZ: didn't test whether it works, but why not...
<br>1290    tool->Detach();
<br>1291
<br>1292    if( m_last_ro_tool == tool ) m_last_ro_tool = NULL;
<br>1293
<br>1294    Refresh( false );
<br>1295
<br>1296<mark>    return true;
</mark><br>1297}
<br>1298
<br>1299<mark>bool ocpnToolBarSimple::Create( wxWindow *parent, wxWindowID id, const wxPoint& pos,
</mark><br>1300        const wxSize& size, long style, const wxString& name )
<br>1301{
<br>1302<mark>    if( !wxWindow::Create( parent, id, pos, size, style, name ) ) return false;
</mark><br>1303
<br>1304    // Set it to grey (or other 3D face colour)
<br>1305    SetBackgroundColour( wxSystemSettings::GetColour( wxSYS_COLOUR_3DFACE ) );
<br>1306
<br>1307    if( GetWindowStyleFlag() & wxTB_VERTICAL ) {
<br>1308        m_lastX = 7;
<br>1309        m_lastY = 3;
<br>1310
<br>1311        m_maxRows = 32000;      // a lot
<br>1312        m_maxCols = 1;
<br>1313    } else {
<br>1314        m_lastX = 3;
<br>1315        m_lastY = 7;
<br>1316
<br>1317        m_maxRows = 1;
<br>1318        m_maxCols = 32000;      // a lot
<br>1319    }
<br>1320
<br>1321    SetCursor( *wxSTANDARD_CURSOR );
<br>1322
<br>1323    m_tooltip_timer.SetOwner( this, TOOLTIPON_TIMER );
<br>1324    m_tooltipoff_timer.SetOwner( this, TOOLTIPOFF_TIMER );
<br>1325    m_tooltip_off = 3000;
<br>1326
<br>1327<mark>    return true;
</mark><br>1328}
<br>1329
<br>1330<mark>ocpnToolBarSimple::~ocpnToolBarSimple()
</mark><br>1331{
<br>1332    if( m_pToolTipWin ) {
<br>1333        m_pToolTipWin->Destroy();
<br>1334        m_pToolTipWin = NULL;
<br>1335    }
<br>1336
<br>1337}
<br>1338
<br>1339<mark>void ocpnToolBarSimple::KillTooltip()
</mark><br>1340{
<br>1341    m_btooltip_show = false;
<br>1342
<br>1343    if( m_pToolTipWin ) {
<br>1344        m_pToolTipWin->Hide();
<br>1345        m_pToolTipWin->Destroy();
<br>1346        m_pToolTipWin = NULL;
<br>1347    }
<br>1348    m_tooltip_timer.Stop();
<br>1349
<br>1350    if( m_last_ro_tool ) {
<br>1351        if( m_last_ro_tool->IsEnabled() ) {
<br>1352            if( m_last_ro_tool->IsToggled() ) {
<br>1353                m_last_ro_tool->SetNormalBitmap( m_style->GetToolIcon( m_last_ro_tool->GetToolname(), TOOLICON_TOGGLED ) );
<br>1354            }
<br>1355            else {
<br>1356                m_last_ro_tool->SetNormalBitmap( m_style->GetToolIcon( m_last_ro_tool->GetToolname(), TOOLICON_NORMAL ) );
<br>1357            }
<br>1358        }
<br>1359    }
<br>1360}
<br>1361
<br>1362<mark>void ocpnToolBarSimple::HideTooltip()
</mark><br>1363{
<br>1364    if( m_pToolTipWin ) {
<br>1365        m_pToolTipWin->Hide();
<br>1366    }
<br>1367}
<br>1368
<br>1369<mark>void ocpnToolBarSimple::SetColorScheme( ColorScheme cs )
</mark><br>1370{
<br>1371    if( m_pToolTipWin ) {
<br>1372        m_pToolTipWin->Destroy();
<br>1373        m_pToolTipWin = NULL;
<br>1374    }
<br>1375
<br>1376    m_toolOutlineColour = GetGlobalColor( _T("UIBDR") );
<br>1377
<br>1378    m_currentColorScheme = cs;
<br>1379}
<br>1380
<br>1381<mark>bool ocpnToolBarSimple::Realize()
</mark><br>1382{
<br>1383    m_currentRowsOrColumns = 0;
<br>1384    m_LineCount = 1;
<br>1385    m_lastX = m_style->GetLeftMargin();
<br>1386    m_lastY = m_style->GetTopMargin();
<br>1387    m_maxWidth = 0;
<br>1388    m_maxHeight = 0;
<br>1389
<br>1390    if( IsVertical() ) m_style->SetOrientation( wxTB_VERTICAL );
<br>1391    else
<br>1392        m_style->SetOrientation( wxTB_HORIZONTAL );
<br>1393
<br>1394    wxSize toolSize = wxSize(-1, -1);
<br>1395    int separatorSize = m_style->GetToolSeparation();
<br>1396
<br>1397    ocpnToolBarTool *lastTool = NULL;
<br>1398<mark>    bool firstNode = true;
</mark><br>1399    wxToolBarToolsList::compatibility_iterator node = m_tools.GetFirst();
<br>1400
<br>1401    while( node ) {
<br>1402        ocpnToolBarTool *tool = (ocpnToolBarTool *) node->GetData();
<br>1403
<br>1404        // Set the tool size to be the size of the first non-separator tool, usually the first one
<br>1405        if(toolSize.x == -1){
<br>1406            if( !tool->IsSeparator() ){
<br>1407                toolSize.x = tool->m_width;
<br>1408                toolSize.y = tool->m_height;
<br>1409            }
<br>1410        }
<br>1411
<br>1412        tool->firstInLine = firstNode;
<br>1413        tool->lastInLine = false;
<br>1414        firstNode = false;
<br>1415
<br>1416        tool->last_rect.width = 0;              // mark it invalid
<br>1417        
<br>1418        if( tool->IsSeparator() ) {
<br>1419            if( GetWindowStyleFlag() & wxTB_HORIZONTAL ) {
<br>1420                if( m_currentRowsOrColumns >= m_maxCols ) m_lastY += separatorSize;
<br>1421                else
<br>1422                    m_lastX += separatorSize;
<br>1423            } else {
<br>1424                if( m_currentRowsOrColumns >= m_maxRows ) m_lastX += separatorSize;
<br>1425                else
<br>1426                    m_lastY += separatorSize;
<br>1427            }
<br>1428        } else
<br>1429            if( tool->IsButton() ) {
<br>1430                if( !IsVertical() ) {
<br>1431                    if( m_currentRowsOrColumns >= m_maxCols ) {
<br>1432<mark>                        tool->firstInLine = true;
</mark><br>1433<mark>                        if( lastTool && m_LineCount > 1 ) lastTool->lastInLine = true;
</mark><br>1434                        m_LineCount++;
<br>1435                        m_currentRowsOrColumns = 0;
<br>1436                        m_lastX = m_style->GetLeftMargin();
<br>1437                        m_lastY += toolSize.y + m_style->GetTopMargin();
<br>1438                    }
<br>1439                    tool->m_x = (wxCoord) m_lastX;
<br>1440                    tool->m_y = (wxCoord) m_lastY;
<br>1441
<br>1442                    tool->trect = wxRect( tool->m_x, tool->m_y, toolSize.x, toolSize.y );
<br>1443                    tool->trect.Inflate( m_style->GetToolSeparation() / 2,
<br>1444                            m_style->GetTopMargin() );
<br>1445
<br>1446                    m_lastX += toolSize.x + m_style->GetToolSeparation();
<br>1447                } else {
<br>1448                    if( m_currentRowsOrColumns >= m_maxRows ) {
<br>1449<mark>                        tool->firstInLine = true;
</mark><br>1450<mark>                        if( lastTool ) lastTool->lastInLine = true;
</mark><br>1451                        m_LineCount++;
<br>1452                        m_currentRowsOrColumns = 0;
<br>1453                        m_lastX += toolSize.x + m_style->GetTopMargin();
<br>1454                        m_lastY = m_style->GetTopMargin();
<br>1455                    }
<br>1456                    tool->m_x = (wxCoord) m_lastX;
<br>1457                    tool->m_y = (wxCoord) m_lastY;
<br>1458
<br>1459                    tool->trect = wxRect( tool->m_x, tool->m_y, toolSize.x, toolSize.y );
<br>1460                    tool->trect.Inflate( m_style->GetToolSeparation() / 2,
<br>1461                            m_style->GetTopMargin() );
<br>1462
<br>1463                    m_lastY += toolSize.y + m_style->GetToolSeparation();
<br>1464                }
<br>1465                m_currentRowsOrColumns++;
<br>1466            } else
<br>1467                if( tool->IsControl() ) {
<br>1468                    tool->m_x = (wxCoord) ( m_lastX );
<br>1469                    tool->m_y = (wxCoord) ( m_lastY - ( m_style->GetTopMargin() / 2 ) );
<br>1470
<br>1471                    tool->trect = wxRect( tool->m_x, tool->m_y, tool->GetWidth(),
<br>1472                            tool->GetHeight() );
<br>1473                    tool->trect.Inflate( m_style->GetToolSeparation() / 2,
<br>1474                            m_style->GetTopMargin() );
<br>1475                    ;
<br>1476
<br>1477                    wxSize s = tool->GetControl()->GetSize();
<br>1478                    m_lastX += s.x + m_style->GetToolSeparation();
<br>1479
<br>1480                }
<br>1481
<br>1482        if( m_lastX > m_maxWidth ) m_maxWidth = m_lastX;
<br>1483        if( m_lastY > m_maxHeight ) m_maxHeight = m_lastY;
<br>1484
<br>1485        lastTool = tool;
<br>1486        node = node->GetNext();
<br>1487    }
<br>1488    if( lastTool && (m_LineCount > 1 || IsVertical()) )
<br>1489<mark>        lastTool->lastInLine = true;
</mark><br>1490
<br>1491    if( GetWindowStyleFlag() & wxTB_HORIZONTAL ) m_maxHeight += toolSize.y;
<br>1492    else
<br>1493        m_maxWidth += toolSize.x;
<br>1494
<br>1495    m_maxWidth += m_style->GetRightMargin();
<br>1496    m_maxHeight += m_style->GetBottomMargin();
<br>1497
<br>1498    SetSize( m_maxWidth, m_maxHeight );
<br>1499    SetMinSize( wxSize( m_maxWidth, m_maxHeight ) );
<br>1500
<br>1501<mark>    return true;
</mark><br>1502}
<br>1503
<br>1504// ----------------------------------------------------------------------------
<br>1505// event handlers
<br>1506// ----------------------------------------------------------------------------
<br>1507
<br>1508<mark>void ocpnToolBarSimple::OnPaint( wxPaintEvent& WXUNUSED(event) )
</mark><br>1509{
<br>1510<mark>    wxPaintDC dc( this );
</mark><br>1511<mark>    PrepareDC( dc );
</mark><br>1512
<br>1513<mark>    wxRegion ru = GetUpdateRegion();
</mark><br>1514<mark>    wxRect upRect = ru.GetBox();
</mark><br>1515
<br>1516    static int count = 0;
<br>1517<mark>    // Prevent reentry of OnPaint which would cause wxMemoryDC errors.
</mark><br>1518    if( count > 0 ) return;
<br>1519    count++;
<br>1520
<br>1521    for( wxToolBarToolsList::compatibility_iterator node = m_tools.GetFirst(); node;
<br>1522            node = node->GetNext() ) {
<br>1523        wxToolBarToolBase *tool = node->GetData();
<br>1524        ocpnToolBarTool *tools = (ocpnToolBarTool *) tool;
<br>1525        wxRect toolRect = tools->trect;
<br>1526
<br>1527        if( toolRect.Intersects( upRect ) ) {
<br>1528
<br>1529            if( tool->IsButton() ) {
<br>1530<mark>                DrawTool( dc, tool );
</mark><br>1531            } else
<br>1532                if( tool->IsControl() ) {
<br>1533                    if( tool->GetControl()->IsKindOf( CLASSINFO(wxStaticBitmap) ) ) {
<br>1534                        wxStaticBitmap *psbm = (wxStaticBitmap *) tool->GetControl();
<br>1535                        ocpnToolBarTool *toolsimp = (ocpnToolBarTool *) tool;
<br>1536<mark>                        dc.DrawBitmap( psbm->GetBitmap(), toolsimp->m_x, toolsimp->m_y, false );
</mark><br>1537                    }
<br>1538                }
<br>1539        }
<br>1540    }
<br>1541
<br>1542    count--;
<br>1543}
<br>1544
<br>1545<mark>void ocpnToolBarSimple::OnSize( wxSizeEvent& WXUNUSED(event) )
</mark><br>1546{
<br>1547    if( GetAutoLayout() ) Layout();
<br>1548}
<br>1549
<br>1550<mark>void ocpnToolBarSimple::OnKillFocus( wxFocusEvent& WXUNUSED(event) )
</mark><br>1551{
<br>1552    OnMouseEnter( m_pressedTool = m_currentTool = -1 );
<br>1553}
<br>1554
<br>1555<mark>void ocpnToolBarSimple::OnToolTipTimerEvent( wxTimerEvent& event )
</mark><br>1556{
<br>1557<mark>    if( !gFrame->IsActive() ) return;
</mark><br>1558
<br>1559    if( m_btooltip_show && IsShown() && m_pToolTipWin && ( !m_pToolTipWin->IsShown() ) ) {
<br>1560        if( m_last_ro_tool ) {
<br>1561            wxString s = m_last_ro_tool->GetShortHelp();
<br>1562
<br>1563            if( s.Len() ) {
<br>1564                m_pToolTipWin->SetString( s );
<br>1565                m_pToolTipWin->SetHiviz(m_last_ro_tool->m_btooltip_hiviz);
<br>1566
<br>1567<mark>                wxPoint pos_in_toolbar( m_last_ro_tool->m_x, m_last_ro_tool->m_y );
</mark><br>1568<mark>                pos_in_toolbar.x += m_last_ro_tool->m_width + 2;
</mark><br>1569
<br>1570                m_pToolTipWin->Move(0,0);       // workaround for gtk autocentre dialog behavior
<br>1571
<br>1572<mark>                wxPoint screenPosition = ClientToScreen( pos_in_toolbar );
</mark><br>1573<mark>                wxPoint framePosition = gFrame->ScreenToClient(screenPosition);
</mark><br>1574                wxSize tipSize = m_pToolTipWin->GetRenderedSize();
<br>1575                
<br>1576<mark>                if( (framePosition.x + tipSize.x) > gFrame->GetSize().x)
</mark><br>1577<mark>                    screenPosition.x -= (tipSize.x + m_last_ro_tool->m_width + 4);
</mark><br>1578                
<br>1579<mark>                m_pToolTipWin->SetPosition( screenPosition );
</mark><br>1580                m_pToolTipWin->SetBitmap();
<br>1581                m_pToolTipWin->Show();
<br>1582<mark>                gFrame->Raise();
</mark><br>1583                if( g_btouch )
<br>1584                    m_tooltipoff_timer.Start(m_tooltip_off, wxTIMER_ONE_SHOT);
<br>1585            }
<br>1586        }
<br>1587    }
<br>1588}
<br>1589
<br>1590<mark>void ocpnToolBarSimple::OnToolTipOffTimerEvent( wxTimerEvent& event )
</mark><br>1591{
<br>1592    HideTooltip();
<br>1593}
<br>1594
<br>1595
<br>1596int s_dragx, s_dragy;
<br>1597
<br>1598<mark>void ocpnToolBarSimple::OnMouseEvent( wxMouseEvent & event )
</mark><br>1599{
<br>1600#ifdef __OCPN__ANDROID__
<br>1601    if(!event.IsButton())
<br>1602        return;
<br>1603#endif
<br>1604
<br>1605    wxCoord x, y;
<br>1606    event.GetPosition( &x, &y );
<br>1607    ocpnToolBarTool *tool = (ocpnToolBarTool *) FindToolForPosition( x, y );
<br>1608
<br>1609#ifndef __OCPN__ANDROID__
<br>1610    if( event.LeftDown() ) {
<br>1611<mark>        CaptureMouse();
</mark><br>1612        s_dragx = x;
<br>1613        s_dragy = y;
<br>1614    }
<br>1615    if( event.LeftUp() ) {
<br>1616<mark>        if( HasCapture() ) ReleaseMouse();
</mark><br>1617    }
<br>1618#endif
<br>1619
<br>1620    if( tool && tool->IsButton() && IsShown() ) {
<br>1621
<br>1622        //    ToolTips
<br>1623        if( NULL == m_pToolTipWin ) {
<br>1624            m_pToolTipWin = new ToolTipWin( GetParent() );
<br>1625            m_pToolTipWin->SetColorScheme( m_currentColorScheme );
<br>1626            m_pToolTipWin->Hide();
<br>1627        }
<br>1628
<br>1629        if( tool != m_last_ro_tool ) m_pToolTipWin->Hide();
<br>1630
<br>1631#ifndef __OCPN__ANDROID__
<br>1632        if( !m_pToolTipWin->IsShown() ) {
<br>1633            m_tooltip_timer.Start( m_one_shot, wxTIMER_ONE_SHOT );
<br>1634        }
<br>1635#endif
<br>1636
<br>1637        //    Tool Rollover highlighting
<br>1638        if(!g_btouch){
<br>1639            if( tool != m_last_ro_tool ) {
<br>1640                if( tool->IsEnabled() ) {
<br>1641<mark>                    tool->rollover = true;
</mark><br>1642<mark>                    tool->bitmapOK = false;
</mark><br>1643                }
<br>1644                if( m_last_ro_tool ) {
<br>1645                    if( m_last_ro_tool->IsEnabled() ) {
<br>1646                        m_last_ro_tool->rollover = false;
<br>1647<mark>                        m_last_ro_tool->bitmapOK = false;
</mark><br>1648                    }
<br>1649                }
<br>1650                m_last_ro_tool = tool;
<br>1651<mark>                if(g_toolbar)
</mark><br>1652<mark>                    g_toolbar->Refresh( false );
</mark><br>1653            }
<br>1654        }
<br>1655    } else {
<br>1656        //    Tooltips
<br>1657        if( m_pToolTipWin && m_pToolTipWin->IsShown() ) m_pToolTipWin->Hide();
<br>1658
<br>1659        //    Remove Highlighting
<br>1660        if( m_last_ro_tool ) {
<br>1661            if( m_last_ro_tool->IsEnabled() ) {
<br>1662                m_last_ro_tool->rollover = false;
<br>1663<mark>                m_last_ro_tool->bitmapOK = false;
</mark><br>1664            }
<br>1665<mark>            g_toolbar->Refresh( false );
</mark><br>1666        }
<br>1667    }
<br>1668
<br>1669    m_last_ro_tool = tool;
<br>1670
<br>1671    // allow smooth zooming while toolbutton is held down
<br>1672    if(g_bsmoothpanzoom && !g_btouch) {
<br>1673<mark>        if(event.LeftUp() && m_btoolbar_is_zooming) {
</mark><br>1674<mark>            cc1->StopMovement();
</mark><br>1675<mark>            m_btoolbar_is_zooming = false;
</mark><br>1676            return;
<br>1677        }
<br>1678
<br>1679        if( event.LeftDown() && tool &&
<br>1680            (tool->GetId() == ID_ZOOMIN || tool->GetId() == ID_ZOOMOUT) ) {
<br>1681<mark>            cc1->ZoomCanvas( tool->GetId() == ID_ZOOMIN ? 2.0 : .5, false, false );
</mark><br>1682<mark>            m_btoolbar_is_zooming = true;
</mark><br>1683            return;
<br>1684        }
<br>1685    }
<br>1686
<br>1687    if( !tool ) {
<br>1688        if( m_currentTool > -1 ) {
<br>1689            if( event.LeftIsDown() ) SpringUpButton( m_currentTool );
<br>1690            m_currentTool = -1;
<br>1691            OnMouseEnter( -1 );
<br>1692        }
<br>1693
<br>1694        wxMouseEvent *pev = (wxMouseEvent *) event.Clone();
<br>1695        GetParent()->GetEventHandler()->AddPendingEvent( *pev );
<br>1696        wxDELETE( pev );
<br>1697
<br>1698        return;
<br>1699    }
<br>1700
<br>1701    if( !event.IsButton() ) {
<br>1702        if( tool->GetId() != m_currentTool ) {
<br>1703<mark>            // If the left button is kept down and moved over buttons,
</mark><br>1704            // press those buttons.
<br>1705            if( event.LeftIsDown() && tool->IsEnabled() ) {
<br>1706                SpringUpButton( m_currentTool );
<br>1707
<br>1708                if( tool->CanBeToggled() ) {
<br>1709                    tool->Toggle();
<br>1710                }
<br>1711
<br>1712                DrawTool( tool );
<br>1713            }
<br>1714
<br>1715            m_currentTool = tool->GetId();
<br>1716            OnMouseEnter( m_currentTool );
<br>1717        }
<br>1718
<br>1719        wxMouseEvent *pev = (wxMouseEvent *) event.Clone();
<br>1720        GetParent()->GetEventHandler()->AddPendingEvent( *pev );
<br>1721        wxDELETE( pev );
<br>1722
<br>1723        return;
<br>1724    }
<br>1725
<br>1726    // Left button pressed.
<br>1727    if( event.LeftDown() && tool->IsEnabled() ) {
<br>1728        if( tool->CanBeToggled() ) {
<br>1729            tool->Toggle();
<br>1730<mark>            tool->bitmapOK = false;
</mark><br>1731            
<br>1732        }
<br>1733
<br>1734        DrawTool( tool );
<br>1735
<br>1736        //        Look for PlugIn tools
<br>1737        //        If found, make the callback.
<br>1738        if( g_pi_manager ) {
<br>1739            ArrayOfPlugInToolbarTools tool_array = g_pi_manager->GetPluginToolbarToolArray();
<br>1740            for( unsigned int i = 0; i < tool_array.GetCount(); i++ ) {
<br>1741<mark>                PlugInToolbarToolContainer *pttc = tool_array.Item( i );
</mark><br>1742<mark>                if( tool->GetId() == pttc->id ) {
</mark><br>1743<mark>                    opencpn_plugin_113 *ppi = dynamic_cast<opencpn_plugin_113 *>(pttc->m_pplugin);
</mark><br>1744                    if( ppi ) {
<br>1745<mark>                        ppi->OnToolbarToolDownCallback( pttc->id );
</mark><br>1746<mark>                        m_last_plugin_down_id = pttc->id;
</mark><br>1747                    }
<br>1748                }
<br>1749            }
<br>1750        }
<br>1751    } else
<br>1752        if( event.RightDown() ) {
<br>1753            OnRightClick( tool->GetId(), x, y );
<br>1754        }
<br>1755
<br>1756    // Left Button Released.  Only this action confirms selection.
<br>1757    // If the button is enabled and it is not a toggle tool and it is
<br>1758    // in the pressed state, then raise the button and call OnLeftClick.
<br>1759    //
<br>1760    if( event.LeftUp() && tool->IsEnabled() ) {
<br>1761        // Pass the OnLeftClick event to tool
<br>1762        if( !OnLeftClick( tool->GetId(), tool->IsToggled() ) && tool->CanBeToggled() ) {
<br>1763            // If it was a toggle, and OnLeftClick says No Toggle allowed,
<br>1764            // then change it back
<br>1765            tool->Toggle();
<br>1766<mark>            tool->bitmapOK = false;
</mark><br>1767        }
<br>1768
<br>1769        DoPluginToolUp();
<br>1770    }
<br>1771
<br>1772    wxMouseEvent *pev = (wxMouseEvent *) event.Clone();
<br>1773    GetParent()->GetEventHandler()->AddPendingEvent( *pev );
<br>1774    wxDELETE( pev );
<br>1775    event.Skip();
<br>1776}
<br>1777
<br>1778// ----------------------------------------------------------------------------
<br>1779// drawing
<br>1780// ----------------------------------------------------------------------------
<br>1781
<br>1782<mark>void ocpnToolBarSimple::DrawTool( wxToolBarToolBase *tool )
</mark><br>1783{
<br>1784<mark>    wxClientDC dc( this );
</mark><br>1785<mark>    DrawTool( dc, tool );
</mark><br>1786}
<br>1787
<br>1788// NB! The current DrawTool code assumes that plugin tools are never disabled
<br>1789<mark>// when they are present on the toolbar, since disabled plugins are removed.
</mark><br>1790
<br>1791<mark>void ocpnToolBarSimple::DrawTool( wxDC& dc, wxToolBarToolBase *toolBase )
</mark><br>1792{
<br>1793    ocpnToolBarTool *tool = (ocpnToolBarTool *) toolBase;
<br>1794<mark>    PrepareDC( dc );
</mark><br>1795
<br>1796<mark>    wxPoint drawAt( tool->m_x, tool->m_y );
</mark><br>1797<mark>    wxBitmap bmp;
</mark><br>1798
<br>1799<mark>    if( tool->bitmapOK ) {
</mark><br>1800        if( tool->IsEnabled() ) {
<br>1801<mark>            bmp = tool->GetNormalBitmap();
</mark><br>1802<mark>            if( !bmp.IsOk() ){
</mark><br>1803<mark>                bmp = m_style->GetToolIcon( tool->GetToolname(), TOOLICON_NORMAL, tool->rollover );
</mark><br>1804                if(m_sizefactor > 1.0 ){
<br>1805<mark>                    wxImage scaled_image = bmp.ConvertToImage();
</mark><br>1806<mark>                    bmp = wxBitmap(scaled_image.Scale(tool->m_width, tool->m_height, wxIMAGE_QUALITY_HIGH));
</mark><br>1807                }
<br>1808<mark>                tool->SetNormalBitmap( bmp );
</mark><br>1809<mark>                tool->bitmapOK = true;
</mark><br>1810            }
<br>1811        } else {
<br>1812<mark>            bmp = tool->GetDisabledBitmap();
</mark><br>1813<mark>            if( !bmp.IsOk() ){
</mark><br>1814<mark>                bmp = m_style->GetToolIcon( tool->GetToolname(), TOOLICON_DISABLED );
</mark><br>1815                if(m_sizefactor > 1.0 ){
<br>1816<mark>                    wxImage scaled_image = bmp.ConvertToImage();
</mark><br>1817<mark>                    bmp = wxBitmap(scaled_image.Scale(tool->m_width, tool->m_height, wxIMAGE_QUALITY_HIGH));
</mark><br>1818                }
<br>1819<mark>                tool->SetDisabledBitmap( bmp );
</mark><br>1820<mark>                tool->bitmapOK = true;
</mark><br>1821            }
<br>1822        }
<br>1823    } else {
<br>1824        if ( tool->isPluginTool ) {
<br>1825
<br>1826            // First try getting the icon from the Style.
<br>1827            // If it is not in the style we build a new icon from the style BG and the plugin icon.
<br>1828
<br>1829            if( tool->IsToggled() ) {
<br>1830<mark>                bmp = m_style->GetToolIcon( tool->GetToolname(), TOOLICON_TOGGLED, tool->rollover );
</mark><br>1831<mark>                if( bmp.GetDepth() == 1 ) {
</mark><br>1832                    if( tool->rollover ) {
<br>1833<mark>                        bmp = m_style->BuildPluginIcon( tool->pluginRolloverIcon, TOOLICON_TOGGLED );
</mark><br>1834<mark>                        if( ! bmp.IsOk() )
</mark><br>1835<mark>                            bmp = m_style->BuildPluginIcon( tool->pluginNormalIcon, TOOLICON_TOGGLED );
</mark><br>1836                    }
<br>1837                    else
<br>1838<mark>                        bmp = m_style->BuildPluginIcon( tool->pluginNormalIcon, TOOLICON_TOGGLED );
</mark><br>1839                }
<br>1840            } else {
<br>1841<mark>                bmp = m_style->GetToolIcon( tool->GetToolname(), TOOLICON_NORMAL, tool->rollover );
</mark><br>1842<mark>                if( bmp.GetDepth() == 1 ) {
</mark><br>1843                    if( tool->rollover ) {
<br>1844<mark>                        bmp = m_style->BuildPluginIcon( tool->pluginRolloverIcon, TOOLICON_NORMAL );
</mark><br>1845<mark>                        if( ! bmp.IsOk() )
</mark><br>1846<mark>                            bmp = m_style->BuildPluginIcon( tool->pluginNormalIcon, TOOLICON_NORMAL );
</mark><br>1847                    }
<br>1848                    else
<br>1849<mark>                        bmp = m_style->BuildPluginIcon( tool->pluginNormalIcon, TOOLICON_NORMAL );
</mark><br>1850                }
<br>1851            }
<br>1852            if(m_sizefactor > 1.0 ){
<br>1853<mark>                wxImage scaled_image = bmp.ConvertToImage();
</mark><br>1854<mark>                bmp = wxBitmap(scaled_image.Scale(tool->m_width, tool->m_height, wxIMAGE_QUALITY_HIGH));
</mark><br>1855            }
<br>1856<mark>            tool->SetNormalBitmap( bmp );
</mark><br>1857<mark>            tool->bitmapOK = true;
</mark><br>1858        } else {
<br>1859            if( tool->IsEnabled() ) {
<br>1860                if( tool->IsToggled() )
<br>1861<mark>                    bmp = m_style->GetToolIcon( tool->GetToolname(), TOOLICON_TOGGLED, tool->rollover );
</mark><br>1862                else
<br>1863<mark>                    bmp = m_style->GetToolIcon( tool->GetIconName(), TOOLICON_NORMAL, tool->rollover );
</mark><br>1864
<br>1865                if(m_sizefactor > 1.0 ){
<br>1866<mark>                    wxImage scaled_image = bmp.ConvertToImage();
</mark><br>1867<mark>                    bmp = wxBitmap(scaled_image.Scale(tool->m_width, tool->m_height, wxIMAGE_QUALITY_HIGH));
</mark><br>1868                }
<br>1869<mark>                tool->SetNormalBitmap( bmp );
</mark><br>1870<mark>                tool->bitmapOK = true;
</mark><br>1871            } else {
<br>1872<mark>                bmp = m_style->GetToolIcon( tool->GetToolname(), TOOLICON_DISABLED );
</mark><br>1873                if(m_sizefactor > 1.0 ){
<br>1874<mark>                    wxImage scaled_image = bmp.ConvertToImage();
</mark><br>1875<mark>                    bmp = wxBitmap(scaled_image.Scale(tool->m_width, tool->m_height, wxIMAGE_QUALITY_HIGH));
</mark><br>1876                }
<br>1877<mark>                tool->SetDisabledBitmap( bmp );
</mark><br>1878<mark>                tool->bitmapOK = true;
</mark><br>1879            }
<br>1880        }
<br>1881    }
<br>1882
<br>1883    if( tool->firstInLine ) {
<br>1884<mark>        m_style->DrawToolbarLineStart( bmp );
</mark><br>1885    }
<br>1886    if( tool->lastInLine ) {
<br>1887<mark>        m_style->DrawToolbarLineEnd( bmp );
</mark><br>1888    }
<br>1889
<br>1890<mark>    if( bmp.GetWidth() != m_style->GetToolSize().x
</mark><br>1891<mark>            || bmp.GetHeight() != m_style->GetToolSize().y ) {
</mark><br>1892<mark>//        drawAt.x -= ( bmp.GetWidth() - m_style->GetToolSize().x ) / 2;
</mark><br>1893<mark>//        drawAt.y -= ( bmp.GetHeight() - m_style->GetToolSize().y ) / 2;
</mark><br>1894    }
<br>1895
<br>1896    //      Clear the last drawn tool if necessary
<br>1897<mark>    if( tool->last_rect.width && ((tool->last_rect.x != drawAt.x) || (tool->last_rect.y != drawAt.y)) ){
</mark><br>1898<mark>        wxBrush bb(GetGlobalColor( _T("GREY2") ));
</mark><br>1899<mark>        dc.SetBrush(bb);
</mark><br>1900<mark>        dc.SetPen( *wxTRANSPARENT_PEN );
</mark><br>1901<mark>        dc.DrawRectangle(tool->last_rect.x, tool->last_rect.y, tool->last_rect.width, tool->last_rect.height);
</mark><br>1902    }
<br>1903
<br>1904    //  could cache this in the tool...
<br>1905    //  A bit of a hack here.  We only scale tools if they are to be magnified globally
<br>1906    if(0/*m_sizefactor > 1.0*/ )
<br>1907    {
<br>1908<mark>        wxImage scaled_image = bmp.ConvertToImage();
</mark><br>1909<mark>        wxBitmap sbmp = wxBitmap(scaled_image.Scale(tool->m_width, tool->m_height, wxIMAGE_QUALITY_HIGH));
</mark><br>1910<mark>        dc.DrawBitmap( sbmp, drawAt );
</mark><br>1911<mark>        tool->last_rect = wxRect(drawAt.x, drawAt.y, sbmp.GetWidth(), sbmp.GetHeight());
</mark><br>1912
<br>1913    }
<br>1914    else
<br>1915    {
<br>1916<mark>        dc.DrawBitmap( bmp, drawAt );
</mark><br>1917<mark>        tool->last_rect = wxRect(drawAt.x, drawAt.y, bmp.GetWidth(), bmp.GetHeight());
</mark><br>1918    }
<br>1919
<br>1920}
<br>1921
<br>1922// ----------------------------------------------------------------------------
<br>1923<mark>// toolbar geometry
</mark><br>1924// ----------------------------------------------------------------------------
<br>1925
<br>1926<mark>wxToolBarToolBase *ocpnToolBarSimple::FindToolForPosition( wxCoord x, wxCoord y )
</mark><br>1927{
<br>1928    wxToolBarToolsList::compatibility_iterator node = m_tools.GetFirst();
<br>1929    while( node ) {
<br>1930        ocpnToolBarTool *tool = (ocpnToolBarTool *) node->GetData();
<br>1931        if( ( x >= tool->m_x ) && ( y >= tool->m_y ) && ( x < ( tool->m_x + tool->GetWidth() ) )
<br>1932                && ( y < ( tool->m_y + tool->GetHeight() ) ) ) {
<br>1933            return tool;
<br>1934        }
<br>1935
<br>1936        node = node->GetNext();
<br>1937    }
<br>1938
<br>1939    return (wxToolBarToolBase *) NULL;
<br>1940}
<br>1941
<br>1942<mark>void ocpnToolBarSimple::InvalidateBitmaps()
</mark><br>1943{
<br>1944    wxToolBarToolsList::compatibility_iterator node = m_tools.GetFirst();
<br>1945    while( node ) {
<br>1946        ocpnToolBarTool *tool = (ocpnToolBarTool *) node->GetData();
<br>1947<mark>        tool->bitmapOK = false;
</mark><br>1948        node = node->GetNext();
<br>1949    }
<br>1950}
<br>1951
<br>1952<mark>wxRect ocpnToolBarSimple::GetToolRect( int tool_id )
</mark><br>1953{
<br>1954    wxRect rect;
<br>1955    wxToolBarToolBase *tool = FindById( tool_id );
<br>1956    if( tool ) {
<br>1957        ocpnToolBarTool *otool = (ocpnToolBarTool *) tool;
<br>1958        if( otool ) rect = otool->trect;
<br>1959    }
<br>1960
<br>1961    return rect;
<br>1962}
<br>1963
<br>1964// ----------------------------------------------------------------------------
<br>1965// tool state change handlers
<br>1966// ----------------------------------------------------------------------------
<br>1967
<br>1968<mark>void ocpnToolBarSimple::DoEnableTool( wxToolBarToolBase *tool, bool WXUNUSED(enable) )
</mark><br>1969{
<br>1970    DrawTool( tool );
<br>1971}
<br>1972
<br>1973<mark>void ocpnToolBarSimple::DoToggleTool( wxToolBarToolBase *tool, bool WXUNUSED(toggle) )
</mark><br>1974{
<br>1975    ocpnToolBarTool *t = (ocpnToolBarTool *) tool;
<br>1976<mark>    t->bitmapOK = false;
</mark><br>1977    DrawTool( tool );
<br>1978}
<br>1979
<br>1980// Okay, so we've left the tool we're in ... we must check if the tool we're
<br>1981<mark>// leaving was a 'sprung push button' and if so, spring it back to the up
</mark><br>1982// state.
<br>1983<mark>void ocpnToolBarSimple::SpringUpButton( int id )
</mark><br>1984{
<br>1985    wxToolBarToolBase *tool = FindById( id );
<br>1986
<br>1987    if( tool && tool->CanBeToggled() ) {
<br>1988        if( tool->IsToggled() ) tool->Toggle();
<br>1989
<br>1990        DrawTool( tool );
<br>1991    }
<br>1992}
<br>1993
<br>1994// ----------------------------------------------------------------------------
<br>1995// scrolling implementation
<br>1996// ----------------------------------------------------------------------------
<br>1997
<br>1998<mark>wxString ocpnToolBarSimple::GetToolShortHelp( int id ) const
</mark><br>1999{
<br>2000    wxToolBarToolBase *tool = FindById( id );
<br>2001<mark>    wxCHECK_MSG( tool, wxEmptyString, _T("no such tool") );
</mark><br>2002
<br>2003    return tool->GetShortHelp();
<br>2004}
<br>2005
<br>2006<mark>wxString ocpnToolBarSimple::GetToolLongHelp( int id ) const
</mark><br>2007{
<br>2008    wxToolBarToolBase *tool = FindById( id );
<br>2009<mark>    wxCHECK_MSG( tool, wxEmptyString, _T("no such tool") );
</mark><br>2010
<br>2011    return tool->GetLongHelp();
<br>2012}
<br>2013
<br>2014<mark>void ocpnToolBarSimple::SetToolShortHelp( int id, const wxString& help )
</mark><br>2015{
<br>2016    wxToolBarToolBase *tool = FindById( id );
<br>2017    if( tool ) {
<br>2018        (void) tool->SetShortHelp( help );
<br>2019    }
<br>2020}
<br>2021
<br>2022<mark>void ocpnToolBarSimple::SetToolLongHelp( int id, const wxString& help )
</mark><br>2023{
<br>2024    wxToolBarToolBase *tool = FindById( id );
<br>2025    if( tool ) {
<br>2026        (void) tool->SetLongHelp( help );
<br>2027    }
<br>2028}
<br>2029
<br>2030<mark>int ocpnToolBarSimple::GetToolPos( int id ) const
</mark><br>2031{
<br>2032    size_t pos = 0;
<br>2033    wxToolBarToolsList::compatibility_iterator node;
<br>2034
<br>2035    for( node = m_tools.GetFirst(); node; node = node->GetNext() ) {
<br>2036        if( node->GetData()->GetId() == id ) return pos;
<br>2037
<br>2038        pos++;
<br>2039    }
<br>2040
<br>2041    return wxNOT_FOUND;
<br>2042}
<br>2043<mark>bool ocpnToolBarSimple::GetToolState( int id ) const
</mark><br>2044{
<br>2045    wxToolBarToolBase *tool = FindById( id );
<br>2046    wxCHECK_MSG( tool, false, _T("no such tool") );
<br>2047
<br>2048    return tool->IsToggled();
<br>2049}
<br>2050
<br>2051<mark>bool ocpnToolBarSimple::GetToolEnabled( int id ) const
</mark><br>2052{
<br>2053    wxToolBarToolBase *tool = FindById( id );
<br>2054    wxCHECK_MSG( tool, false, _T("no such tool") );
<br>2055
<br>2056    return tool->IsEnabled();
<br>2057}
<br>2058
<br>2059<mark>void ocpnToolBarSimple::ToggleTool( int id, bool toggle )
</mark><br>2060{
<br>2061    wxToolBarToolBase *tool = FindById( id );
<br>2062        
<br>2063    if( tool && tool->CanBeToggled() && tool->Toggle( toggle ) ) {
<br>2064        DoToggleTool( tool, toggle );
<br>2065<mark>        if( g_toolbar ) g_toolbar->Refresh();
</mark><br>2066    }
<br>2067}
<br>2068
<br>2069<mark>wxObject *ocpnToolBarSimple::GetToolClientData( int id ) const
</mark><br>2070{
<br>2071    wxToolBarToolBase *tool = FindById( id );
<br>2072    return tool ? tool->GetClientData() : (wxObject *) NULL;
<br>2073}
<br>2074
<br>2075<mark>void ocpnToolBarSimple::SetToolClientData( int id, wxObject *clientData )
</mark><br>2076{
<br>2077    wxToolBarToolBase *tool = FindById( id );
<br>2078
<br>2079    wxCHECK_RET( tool, _T("no such tool in wxToolBar::SetToolClientData") );
<br>2080
<br>2081<mark>    tool->SetClientData( clientData );
</mark><br>2082}
<br>2083
<br>2084<mark>void ocpnToolBarSimple::EnableTool( int id, bool enable )
</mark><br>2085{
<br>2086    wxToolBarToolBase *tool = FindById( id );
<br>2087    if( tool ) {
<br>2088        if( tool->Enable( enable ) ) {
<br>2089            DoEnableTool( tool, enable );
<br>2090        }
<br>2091    }
<br>2092<mark>    wxMenuItem* configItem = g_FloatingToolbarConfigMenu->FindItem( id );
</mark><br>2093<mark>    configItem->Check( true );
</mark><br>2094}
<br>2095
<br>2096<mark>void ocpnToolBarSimple::SetToolBitmaps( int id, wxBitmap *bmp, wxBitmap *bmpRollover )
</mark><br>2097{
<br>2098    ocpnToolBarTool *tool = (ocpnToolBarTool*)FindById( id );
<br>2099    if( tool ) {
<br>2100<mark>        tool->pluginNormalIcon = bmp;
</mark><br>2101<mark>        tool->pluginRolloverIcon = bmpRollover;
</mark><br>2102<mark>        tool->bitmapOK = false;
</mark><br>2103    }
<br>2104}
<br>2105
<br>2106<mark>void ocpnToolBarSimple::SetToolTooltipHiViz( int id, bool b_hiviz )
</mark><br>2107{
<br>2108    ocpnToolBarTool *tool = (ocpnToolBarTool*)FindById( id );
<br>2109    if( tool ) {
<br>2110        tool->SetTooltipHiviz( b_hiviz );
<br>2111    }
<br>2112}
<br>2113
<br>2114
<br>2115<mark>void ocpnToolBarSimple::ClearTools()
</mark><br>2116{
<br>2117    while( GetToolsCount() ) {
<br>2118        DeleteToolByPos( 0 );
<br>2119    }
<br>2120}
<br>2121
<br>2122<mark>int ocpnToolBarSimple::GetVisibleToolCount()
</mark><br>2123{
<br>2124    int counter = 0;
<br>2125    wxToolBarToolsList::compatibility_iterator node = m_tools.GetFirst();
<br>2126    while( node ) {
<br>2127        ocpnToolBarTool *tool = (ocpnToolBarTool *) node->GetData();
<br>2128        counter++;
<br>2129        node = node->GetNext();
<br>2130    }
<br>2131    return counter;
<br>2132}
<br>2133
<br>2134<mark>bool ocpnToolBarSimple::DeleteToolByPos( size_t pos )
</mark><br>2135{
<br>2136    wxCHECK_MSG( pos < GetToolsCount(), false,
<br>2137<mark>            _T("invalid position in wxToolBar::DeleteToolByPos()") );
</mark><br>2138
<br>2139    wxToolBarToolsList::compatibility_iterator node = m_tools.Item( pos );
<br>2140
<br>2141    if( !DoDeleteTool( pos, node->GetData() ) ) {
<br>2142        return false;
<br>2143    }
<br>2144
<br>2145    delete node->GetData();
<br>2146    m_tools.Erase( node );
<br>2147
<br>2148<mark>    return true;
</mark><br>2149}
<br>2150
<br>2151<mark>bool ocpnToolBarSimple::DeleteTool( int id )
</mark><br>2152{
<br>2153    size_t pos = 0;
<br>2154    wxToolBarToolsList::compatibility_iterator node;
<br>2155    for( node = m_tools.GetFirst(); node; node = node->GetNext() ) {
<br>2156        if( node->GetData()->GetId() == id ) break;
<br>2157
<br>2158        pos++;
<br>2159    }
<br>2160
<br>2161    if( !node || !DoDeleteTool( pos, node->GetData() ) ) {
<br>2162        return false;
<br>2163    }
<br>2164
<br>2165    delete node->GetData();
<br>2166    m_tools.Erase( node );
<br>2167
<br>2168<mark>    return true;
</mark><br>2169}
<br>2170
<br>2171<mark>wxToolBarToolBase *ocpnToolBarSimple::AddSeparator()
</mark><br>2172{
<br>2173    return InsertSeparator( GetToolsCount() );
<br>2174}
<br>2175
<br>2176<mark>wxToolBarToolBase *ocpnToolBarSimple::InsertSeparator( size_t pos )
</mark><br>2177{
<br>2178    wxCHECK_MSG( pos <= GetToolsCount(), (wxToolBarToolBase *)NULL,
<br>2179<mark>            _T("invalid position in wxToolBar::InsertSeparator()") );
</mark><br>2180
<br>2181<mark>    wxToolBarToolBase *tool = CreateTool( wxID_SEPARATOR, wxEmptyString, wxNullBitmap, wxNullBitmap,
</mark><br>2182<mark>            wxITEM_SEPARATOR, (wxObject *) NULL, wxEmptyString, wxEmptyString );
</mark><br>2183
<br>2184    if( !tool || !DoInsertTool( pos, tool ) ) {
<br>2185        delete tool;
<br>2186
<br>2187        return NULL;
<br>2188    }
<br>2189
<br>2190    m_tools.Insert( pos, tool );
<br>2191
<br>2192    return tool;
<br>2193}
<br>2194
<br>2195<mark>wxToolBarToolBase *ocpnToolBarSimple::RemoveTool( int id )
</mark><br>2196{
<br>2197    size_t pos = 0;
<br>2198    wxToolBarToolsList::compatibility_iterator node;
<br>2199    for( node = m_tools.GetFirst(); node; node = node->GetNext() ) {
<br>2200        if( node->GetData()->GetId() == id ) break;
<br>2201
<br>2202        pos++;
<br>2203    }
<br>2204
<br>2205    if( !node ) {
<br>2206        // don't give any error messages - sometimes we might call RemoveTool()
<br>2207<mark>        // without knowing whether the tool is or not in the toolbar
</mark><br>2208        return (wxToolBarToolBase *) NULL;
<br>2209    }
<br>2210
<br>2211    wxToolBarToolBase *tool = node->GetData();
<br>2212    if( !DoDeleteTool( pos, tool ) ) {
<br>2213        return (wxToolBarToolBase *) NULL;
<br>2214    }
<br>2215
<br>2216    m_tools.Erase( node );
<br>2217
<br>2218    return tool;
<br>2219}
<br>2220
<br>2221
<br>2222<mark>wxControl *ocpnToolBarSimple::FindControl( int id )
</mark><br>2223{
<br>2224    for( wxToolBarToolsList::compatibility_iterator node = m_tools.GetFirst(); node;
<br>2225            node = node->GetNext() ) {
<br>2226        const wxToolBarToolBase * const tool = node->GetData();
<br>2227        if( tool->IsControl() ) {
<br>2228            wxControl * const control = tool->GetControl();
<br>2229
<br>2230            if( !control ) {
<br>2231<mark>                wxFAIL_MSG( _T("NULL control in toolbar?") );
</mark><br>2232            } else
<br>2233                if( control->GetId() == id ) {
<br>2234                    // found
<br>2235                    return control;
<br>2236                }
<br>2237        }
<br>2238    }
<br>2239
<br>2240    return NULL;
<br>2241}
<br>2242
<br>2243<mark>wxToolBarToolBase *ocpnToolBarSimple::FindById( int id ) const
</mark><br>2244{
<br>2245    wxToolBarToolBase *tool = (wxToolBarToolBase *) NULL;
<br>2246
<br>2247    for( wxToolBarToolsList::compatibility_iterator node = m_tools.GetFirst(); node;
<br>2248            node = node->GetNext() ) {
<br>2249        tool = node->GetData();
<br>2250        if( tool->GetId() == id ) {
<br>2251            // found
<br>2252            break;
<br>2253        }
<br>2254
<br>2255        tool = NULL;
<br>2256    }
<br>2257
<br>2258    return tool;
<br>2259}
<br>2260
<br>2261// ----------------------------------------------------------------------------
<br>2262// event processing
<br>2263// ----------------------------------------------------------------------------
<br>2264
<br>2265<mark>// Only allow toggle if returns true
</mark><br>2266<mark>bool ocpnToolBarSimple::OnLeftClick( int id, bool toggleDown )
</mark><br>2267{
<br>2268    wxCommandEvent event( wxEVT_COMMAND_TOOL_CLICKED, id );
<br>2269    event.SetEventObject( this );
<br>2270
<br>2271    // we use SetInt() to make wxCommandEvent::IsChecked() return toggleDown
<br>2272    event.SetInt( (int) toggleDown );
<br>2273
<br>2274    // and SetExtraLong() for backwards compatibility
<br>2275    event.SetExtraLong( (long) toggleDown );
<br>2276
<br>2277<mark>    // Send events to this toolbar instead (and thence up the window hierarchy)
</mark><br>2278    GetEventHandler()->ProcessEvent( event );
<br>2279
<br>2280<mark>    return true;
</mark><br>2281}
<br>2282
<br>2283// Call when right button down.
<br>2284<mark>void ocpnToolBarSimple::OnRightClick( int id, long WXUNUSED(x), long WXUNUSED(y) )
</mark><br>2285{
<br>2286    wxCommandEvent event( wxEVT_COMMAND_TOOL_RCLICKED, id );
<br>2287    event.SetEventObject( this );
<br>2288    event.SetInt( id );
<br>2289
<br>2290    HideTooltip();
<br>2291<mark>    ((ocpnFloatingToolbarDialog*)GetParent())->toolbarConfigChanged = false;
</mark><br>2292<mark>    wxMenu* contextMenu = new wxMenu();
</mark><br>2293<mark>    wxMenuItem* submenu = contextMenu->AppendSubMenu( g_FloatingToolbarConfigMenu, _("Visible buttons") );
</mark><br>2294
<br>2295<mark>    PopupMenu( contextMenu );
</mark><br>2296
<br>2297<mark>    contextMenu->Remove( submenu );
</mark><br>2298<mark>    delete contextMenu;
</mark><br>2299
<br>2300<mark>    if( ((ocpnFloatingToolbarDialog*)GetParent())->toolbarConfigChanged )
</mark><br>2301<mark>        gFrame->GetEventHandler()->AddPendingEvent( event );
</mark><br>2302}
<br>2303
<br>2304<mark>// Called when the mouse cursor enters a tool bitmap (no button pressed).
</mark><br>2305<mark>// Argument is wxID_ANY if mouse is exiting the toolbar.
</mark><br>2306// Note that for this event, the id of the window is used,
<br>2307// and the integer parameter of wxCommandEvent is used to retrieve
<br>2308// the tool id.
<br>2309<mark>void ocpnToolBarSimple::OnMouseEnter( int id )
</mark><br>2310{
<br>2311    wxCommandEvent event( wxEVT_COMMAND_TOOL_ENTER, GetId() );
<br>2312    event.SetEventObject( this );
<br>2313    event.SetInt( id );
<br>2314
<br>2315<mark>    wxFrame *frame = wxDynamicCast(GetParent(), wxFrame);
</mark><br>2316<mark>    if( frame ) {
</mark><br>2317        wxString help;
<br>2318        wxToolBarToolBase* tool = id == wxID_ANY ? (wxToolBarToolBase*) NULL : FindById( id );
<br>2319        if( tool ) help = tool->GetLongHelp();
<br>2320<mark>        frame->DoGiveHelp( help, id != wxID_ANY );
</mark><br>2321    }
<br>2322
<br>2323    (void) GetEventHandler()->ProcessEvent( event );
<br>2324
<br>2325    DoPluginToolUp();
<br>2326}
<br>2327
<br>2328<mark>void ocpnToolBarSimple::DoPluginToolUp()
</mark><br>2329{
<br>2330    //        Look for PlugIn tools
<br>2331    //        If found, make the callback.
<br>2332    if( !g_pi_manager)
<br>2333        return;
<br>2334
<br>2335    ArrayOfPlugInToolbarTools tool_array = g_pi_manager->GetPluginToolbarToolArray();
<br>2336    for( unsigned int i = 0; i < tool_array.GetCount(); i++ ) {
<br>2337<mark>        PlugInToolbarToolContainer *pttc = tool_array.Item( i );
</mark><br>2338<mark>        if( m_last_plugin_down_id == pttc->id ) {
</mark><br>2339<mark>            opencpn_plugin_113 *ppi = dynamic_cast<opencpn_plugin_113 *>(pttc->m_pplugin);
</mark><br>2340            if( ppi )
<br>2341<mark>                ppi->OnToolbarToolUpCallback( pttc->id );
</mark><br>2342        }
<br>2343    }
<br>2344
<br>2345    m_last_plugin_down_id = -1;
<br>2346}
<br>2347
<br>2348<mark>void ocpnToolBarSimple::SetToolNormalBitmapEx( wxToolBarToolBase *tool, const wxString &iconName)
</mark><br>2349{
<br>2350    if( tool ) {
<br>2351        ocpnToolBarTool *otool = (ocpnToolBarTool *) tool;
<br>2352        if(otool){
<br>2353            ocpnStyle::Style *style = g_StyleManager->GetCurrentStyle();
<br>2354
<br>2355<mark>            wxBitmap bmp = style->GetToolIcon( iconName, TOOLICON_NORMAL );
</mark><br>2356            if(m_sizefactor > 1.0 ){
<br>2357<mark>                wxImage scaled_image = bmp.ConvertToImage();
</mark><br>2358<mark>                bmp = wxBitmap(scaled_image.Scale(otool->m_width, otool->m_height, wxIMAGE_QUALITY_HIGH));
</mark><br>2359            }
<br>2360        
<br>2361<mark>            tool->SetNormalBitmap( bmp );
</mark><br>2362            otool->SetIconName( iconName );
<br>2363        }
<br>2364    }
<br>2365}
<br>2366
<br>2367
<br>2368//-------------------------------------------------------------------------------------
<br>2369
<br>2370<mark>ToolbarMOBDialog::ToolbarMOBDialog( wxWindow* parent )
</mark><br>2371<mark>       : wxDialog( parent, wxID_ANY, _("OpenCPN Alert"), wxDefaultPosition, wxSize(250, 230) )
</mark><br>2372{
<br>2373<mark>    wxBoxSizer* topSizer = new wxBoxSizer( wxVERTICAL );
</mark><br>2374
<br>2375<mark>    wxBoxSizer* sizer = new wxBoxSizer( wxVERTICAL );
</mark><br>2376<mark>    topSizer->Add( sizer, 0, wxALIGN_CENTER_HORIZONTAL | wxALL, 5 );
</mark><br>2377
<br>2378    choices.push_back( new wxRadioButton( this, 0,  _("No, I don't want to hide it."),
<br>2379            wxDefaultPosition, wxDefaultSize, wxRB_GROUP ) );
<br>2380
<br>2381<mark>    choices.push_back( new wxRadioButton( this, 1, _("No, and permanently remove the option to hide it."),
</mark><br>2382            wxDefaultPosition) );
<br>2383
<br>2384    choices.push_back( new wxRadioButton( this, 2, _("Yes, hide it."),
<br>2385            wxDefaultPosition) );
<br>2386
<br>2387<mark>    wxStdDialogButtonSizer* buttonSizer = CreateStdDialogButtonSizer( wxOK | wxCANCEL );
</mark><br>2388
<br>2389
<br>2390    wxStaticText* textCtrl = new wxStaticText( this, wxID_ANY, _("The Man Over Board button could be an important safety feature.\nAre you sure you want to hide it?") );
<br>2391
<br>2392<mark>    sizer->Add( textCtrl, 0, wxEXPAND | wxALL, 5 );
</mark><br>2393<mark>    sizer->Add( choices[0], 0, wxEXPAND | wxALL, 5 );
</mark><br>2394<mark>    sizer->Add( choices[1], 0, wxEXPAND | wxALL, 5 );
</mark><br>2395<mark>    sizer->Add( choices[2], 0, wxEXPAND | wxALL, 5 );
</mark><br>2396<mark>    sizer->Add( buttonSizer, 0, wxEXPAND | wxTOP, 5 );
</mark><br>2397
<br>2398<mark>    topSizer->SetSizeHints(this);
</mark><br>2399<mark>    SetSizer( topSizer );
</mark><br>2400}
<br>2401
<br>2402int ToolbarMOBDialog::GetSelection() {
<br>2403    for( unsigned int i=0; i<choices.size(); i++ ) {
<br>2404        if( choices[i]->GetValue() ) return choices[i]->GetId();
<br>2405    }
<br>2406    return 0;
<br>2407}
</p></body>
    </html>